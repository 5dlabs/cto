//! Callback handlers for workflow completion events.
//!
//! These endpoints are called by Argo workflows when they complete,
//! allowing the service to update Linear with results.

use axum::{extract::State, http::StatusCode, response::Json};
use serde::Deserialize;
use serde_json::{json, Value};
use std::sync::Arc;
use tracing::{error, info, warn};

use super::intake::{
    create_task_issues, generate_completion_summary, IntakeRequest, IntakeTask, TasksJson,
};
use crate::LinearClient;

/// Callback payload for intake workflow completion.
#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct IntakeCompleteCallback {
    /// Linear session ID for activity updates.
    pub session_id: String,
    /// Linear issue ID (PRD issue).
    pub issue_id: String,
    /// Linear issue identifier (e.g., "TSK-1").
    pub issue_identifier: String,
    /// Team ID for creating task issues.
    pub team_id: String,
    /// Tasks generated by intake workflow.
    pub tasks: Vec<IntakeTask>,
    /// Workflow name that completed.
    #[serde(default)]
    pub workflow_name: Option<String>,
    /// Success status.
    #[serde(default = "default_true")]
    pub success: bool,
    /// Error message if failed.
    #[serde(default)]
    pub error: Option<String>,
}

fn default_true() -> bool {
    true
}

/// State for callback handlers.
#[derive(Clone)]
pub struct CallbackState {
    /// Linear client for API calls.
    pub linear_client: Option<LinearClient>,
}

/// Handle intake workflow completion callback.
///
/// This is called by the Argo intake workflow when it completes.
/// It creates Linear sub-issues for each generated task.
pub async fn handle_intake_complete(
    State(state): State<Arc<CallbackState>>,
    Json(payload): Json<IntakeCompleteCallback>,
) -> Result<Json<Value>, StatusCode> {
    info!(
        session_id = %payload.session_id,
        issue_identifier = %payload.issue_identifier,
        task_count = payload.tasks.len(),
        success = payload.success,
        "Received intake completion callback"
    );

    // Check for failure
    if !payload.success {
        let error_msg = payload.error.unwrap_or_else(|| "Unknown error".to_string());
        error!(
            session_id = %payload.session_id,
            error = %error_msg,
            "Intake workflow failed"
        );

        // Emit error activity to Linear
        if let Some(client) = &state.linear_client {
            let _ = client
                .emit_error(&payload.session_id, format!("Intake failed: {error_msg}"))
                .await;
        }

        return Ok(Json(json!({
            "status": "error",
            "error": error_msg,
            "session_id": payload.session_id
        })));
    }

    // Get Linear client
    let Some(client) = &state.linear_client else {
        error!("Linear client not configured");
        return Ok(Json(json!({
            "status": "error",
            "error": "Linear client not configured",
            "session_id": payload.session_id
        })));
    };

    // Emit progress activity
    if let Err(e) = client
        .emit_thought(
            &payload.session_id,
            format!("Creating {} task issues in Linear...", payload.tasks.len()),
        )
        .await
    {
        warn!(error = %e, "Failed to emit thought activity");
    }

    // Create intake request from callback
    let request = IntakeRequest {
        session_id: payload.session_id.clone(),
        prd_issue_id: payload.issue_id.clone(),
        prd_identifier: payload.issue_identifier.clone(),
        team_id: payload.team_id.clone(),
        title: String::new(),       // Not needed for issue creation
        prd_content: String::new(), // Not needed for issue creation
        architecture_content: None,
        repository_url: None,
        source_branch: None,
    };

    // Create task issues
    match create_task_issues(client, &request, &payload.tasks).await {
        Ok(task_issue_map) => {
            let created_count = task_issue_map.len();
            info!(
                session_id = %payload.session_id,
                created_count = created_count,
                "Created task issues"
            );

            // Generate and emit completion summary
            let summary = generate_completion_summary(&request, &payload.tasks, &task_issue_map);

            if let Err(e) = client.emit_response(&payload.session_id, &summary).await {
                warn!(error = %e, "Failed to emit completion response");
            }

            Ok(Json(json!({
                "status": "success",
                "session_id": payload.session_id,
                "tasks_received": payload.tasks.len(),
                "issues_created": created_count,
                "task_issue_map": task_issue_map,
                "workflow_name": payload.workflow_name
            })))
        }
        Err(e) => {
            error!(
                session_id = %payload.session_id,
                error = %e,
                "Failed to create task issues"
            );

            if let Err(emit_err) = client
                .emit_error(
                    &payload.session_id,
                    format!("Failed to create task issues: {e}"),
                )
                .await
            {
                warn!(error = %emit_err, "Failed to emit error activity");
            }

            Ok(Json(json!({
                "status": "error",
                "error": format!("Failed to create task issues: {}", e),
                "session_id": payload.session_id
            })))
        }
    }
}

/// Simplified callback for just parsing tasks.json content.
#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TasksJsonCallback {
    /// Linear session ID.
    pub session_id: String,
    /// Linear issue ID.
    pub issue_id: String,
    /// Linear issue identifier.
    pub issue_identifier: String,
    /// Team ID.
    pub team_id: String,
    /// Raw tasks.json content as a string.
    pub tasks_json: String,
    /// Workflow name.
    #[serde(default)]
    pub workflow_name: Option<String>,
}

/// Handle callback with raw tasks.json content.
///
/// Parses the tasks.json and delegates to the main handler.
pub async fn handle_tasks_json_callback(
    state: State<Arc<CallbackState>>,
    Json(payload): Json<TasksJsonCallback>,
) -> Result<Json<Value>, StatusCode> {
    // Parse tasks.json
    let tasks_json: TasksJson = serde_json::from_str(&payload.tasks_json).map_err(|e| {
        error!(
            session_id = %payload.session_id,
            error = %e,
            "Failed to parse tasks.json"
        );
        StatusCode::BAD_REQUEST
    })?;

    // Convert to full callback and delegate
    let full_callback = IntakeCompleteCallback {
        session_id: payload.session_id,
        issue_id: payload.issue_id,
        issue_identifier: payload.issue_identifier,
        team_id: payload.team_id,
        tasks: tasks_json.tasks,
        workflow_name: payload.workflow_name,
        success: true,
        error: None,
    };

    handle_intake_complete(state, Json(full_callback)).await
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_deserialize_intake_callback() {
        let json = r#"{
            "sessionId": "session-123",
            "issueId": "issue-456",
            "issueIdentifier": "TSK-1",
            "teamId": "team-789",
            "tasks": [
                {
                    "id": 1,
                    "title": "Test Task",
                    "description": "Test description",
                    "priority": 2,
                    "dependencies": []
                }
            ],
            "workflowName": "intake-12345",
            "success": true
        }"#;

        let callback: IntakeCompleteCallback = serde_json::from_str(json).unwrap();
        assert_eq!(callback.session_id, "session-123");
        assert_eq!(callback.tasks.len(), 1);
        assert!(callback.success);
    }

    #[test]
    fn test_deserialize_failed_callback() {
        let json = r#"{
            "sessionId": "session-123",
            "issueId": "issue-456",
            "issueIdentifier": "TSK-1",
            "teamId": "team-789",
            "tasks": [],
            "success": false,
            "error": "Workflow timeout"
        }"#;

        let callback: IntakeCompleteCallback = serde_json::from_str(json).unwrap();
        assert!(!callback.success);
        assert_eq!(callback.error, Some("Workflow timeout".to_string()));
    }
}

