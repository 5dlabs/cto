//! Callback handlers for workflow completion events.
//!
//! These endpoints are called by Argo workflows when they complete,
//! allowing the service to update Linear with results.

use axum::{extract::State, http::StatusCode, response::Json};
use serde::Deserialize;
use serde_json::{json, Value};
use std::sync::Arc;
use tracing::{error, info, warn};

use super::intake::{
    create_intake_project, create_task_issues_with_project, generate_completion_summary,
    IntakeRequest, IntakeTask, TasksJson, TechStack,
};
use crate::config::CtoConfig;
use crate::models::AgentStatus;
use crate::LinearClient;

/// Callback payload for intake workflow completion.
#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct IntakeCompleteCallback {
    /// Linear session ID for activity updates.
    pub session_id: String,
    /// Linear issue ID (PRD issue).
    pub issue_id: String,
    /// Linear issue identifier (e.g., "TSK-1").
    pub issue_identifier: String,
    /// Team ID for creating task issues.
    pub team_id: String,
    /// Tasks generated by intake workflow.
    pub tasks: Vec<IntakeTask>,
    /// Workflow name that completed.
    #[serde(default)]
    pub workflow_name: Option<String>,
    /// Success status.
    #[serde(default = "default_true")]
    pub success: bool,
    /// Error message if failed.
    #[serde(default)]
    pub error: Option<String>,
}

fn default_true() -> bool {
    true
}

/// State for callback handlers.
#[derive(Clone)]
pub struct CallbackState {
    /// Linear client for API calls.
    pub linear_client: Option<LinearClient>,
    /// HTTP client for external API calls (GitHub, etc.).
    pub http_client: reqwest::Client,
    /// GitHub token for API authentication (optional).
    pub github_token: Option<String>,
    /// Kubernetes namespace for workflows.
    pub namespace: String,
    /// Play workflow configuration.
    pub play_config: crate::config::PlayConfig,
}

/// Handle intake workflow completion callback.
///
/// This is called by the Argo intake workflow when it completes.
/// It creates Linear sub-issues for each generated task.
#[allow(clippy::too_many_lines)]
pub async fn handle_intake_complete(
    State(state): State<Arc<CallbackState>>,
    Json(payload): Json<IntakeCompleteCallback>,
) -> Result<Json<Value>, StatusCode> {
    info!(
        session_id = %payload.session_id,
        issue_identifier = %payload.issue_identifier,
        task_count = payload.tasks.len(),
        success = payload.success,
        "Received intake completion callback"
    );

    // Check for failure
    if !payload.success {
        let error_msg = payload.error.unwrap_or_else(|| "Unknown error".to_string());
        error!(
            session_id = %payload.session_id,
            error = %error_msg,
            "Intake workflow failed"
        );

        // Emit error activity to Linear
        if let Some(client) = &state.linear_client {
            let _ = client
                .emit_error(&payload.session_id, format!("Intake failed: {error_msg}"))
                .await;
        }

        return Ok(Json(json!({
            "status": "error",
            "error": error_msg,
            "session_id": payload.session_id
        })));
    }

    // Get Linear client
    let Some(client) = &state.linear_client else {
        error!("Linear client not configured");
        return Ok(Json(json!({
            "status": "error",
            "error": "Linear client not configured",
            "session_id": payload.session_id
        })));
    };

    // Create intake request from callback
    let request = IntakeRequest {
        session_id: payload.session_id.clone(),
        prd_issue_id: payload.issue_id.clone(),
        prd_identifier: payload.issue_identifier.clone(),
        team_id: payload.team_id.clone(),
        title: payload
            .workflow_name
            .clone()
            .unwrap_or_else(|| "Intake Project".to_string()),
        project_name: None,
        prd_content: String::new(), // Not needed for issue creation
        architecture_content: None,
        repository_url: None,
        github_visibility: "private".to_string(),
        source_branch: None,
        tech_stack: TechStack::default(), // Not needed for issue creation
        cto_config: CtoConfig::default(), // Not needed for issue creation
    };

    // Create project first
    if let Err(e) = client
        .emit_thought(
            &payload.session_id,
            "Creating Linear project for this intake...",
        )
        .await
    {
        warn!(error = %e, "Failed to emit thought activity");
    }

    let project = match create_intake_project(client, &request, payload.tasks.len()).await {
        Ok(p) => {
            info!(
                session_id = %payload.session_id,
                project_id = %p.id,
                project_name = %p.name,
                "Created project for intake"
            );
            Some(p)
        }
        Err(e) => {
            warn!(
                session_id = %payload.session_id,
                error = %e,
                "Failed to create project, continuing without project"
            );
            None
        }
    };

    // Emit progress activity
    if let Err(e) = client
        .emit_thought(
            &payload.session_id,
            format!("Creating {} task issues in Linear...", payload.tasks.len()),
        )
        .await
    {
        warn!(error = %e, "Failed to emit thought activity");
    }

    // Create task issues (with project if created)
    let project_id = project.as_ref().map(|p| p.id.as_str());
    match create_task_issues_with_project(client, &request, &payload.tasks, project_id).await {
        Ok(task_issue_map) => {
            let created_count = task_issue_map.len();
            info!(
                session_id = %payload.session_id,
                created_count = created_count,
                project_id = ?project_id,
                "Created task issues"
            );

            // Generate and emit completion summary
            let summary = generate_completion_summary(&request, &payload.tasks, &task_issue_map);

            if let Err(e) = client.emit_response(&payload.session_id, &summary).await {
                warn!(error = %e, "Failed to emit completion response");
            }

            Ok(Json(json!({
                "status": "success",
                "session_id": payload.session_id,
                "tasks_received": payload.tasks.len(),
                "issues_created": created_count,
                "task_issue_map": task_issue_map,
                "workflow_name": payload.workflow_name,
                "project_id": project.as_ref().map(|p| &p.id),
                "project_name": project.as_ref().map(|p| &p.name)
            })))
        }
        Err(e) => {
            error!(
                session_id = %payload.session_id,
                error = %e,
                "Failed to create task issues"
            );

            if let Err(emit_err) = client
                .emit_error(
                    &payload.session_id,
                    format!("Failed to create task issues: {e}"),
                )
                .await
            {
                warn!(error = %emit_err, "Failed to emit error activity");
            }

            Ok(Json(json!({
                "status": "error",
                "error": format!("Failed to create task issues: {}", e),
                "session_id": payload.session_id
            })))
        }
    }
}

/// Simplified callback for just parsing tasks.json content.
#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TasksJsonCallback {
    /// Linear session ID.
    pub session_id: String,
    /// Linear issue ID.
    pub issue_id: String,
    /// Linear issue identifier.
    pub issue_identifier: String,
    /// Team ID.
    pub team_id: String,
    /// Raw tasks.json content as a string.
    pub tasks_json: String,
    /// Workflow name.
    #[serde(default)]
    pub workflow_name: Option<String>,
}

/// Handle callback with raw tasks.json content.
///
/// Parses the tasks.json and delegates to the main handler.
pub async fn handle_tasks_json_callback(
    state: State<Arc<CallbackState>>,
    Json(payload): Json<TasksJsonCallback>,
) -> Result<Json<Value>, StatusCode> {
    // Parse tasks.json
    let tasks_json: TasksJson = serde_json::from_str(&payload.tasks_json).map_err(|e| {
        error!(
            session_id = %payload.session_id,
            error = %e,
            "Failed to parse tasks.json"
        );
        StatusCode::BAD_REQUEST
    })?;

    // Convert to full callback and delegate
    let full_callback = IntakeCompleteCallback {
        session_id: payload.session_id,
        issue_id: payload.issue_id,
        issue_identifier: payload.issue_identifier,
        team_id: payload.team_id,
        tasks: tasks_json.tasks,
        workflow_name: payload.workflow_name,
        success: true,
        error: None,
    };

    handle_intake_complete(state, Json(full_callback)).await
}

/// Callback payload for play workflow completion.
#[derive(Debug, Clone, Deserialize)]
pub struct PlayCompleteCallback {
    /// Workflow name that completed.
    pub workflow_name: String,
    /// Workflow status (Succeeded, Failed, etc.).
    pub workflow_status: String,
    /// Linear session ID for activity updates.
    pub linear_session_id: String,
    /// Linear issue ID (task issue).
    pub linear_issue_id: String,
    /// Linear team ID.
    pub linear_team_id: String,
    /// Task ID.
    #[serde(default)]
    pub task_id: Option<String>,
    /// Repository.
    #[serde(default)]
    pub repository: Option<String>,
}

/// Handle play workflow completion callback.
///
/// This is called by the Argo play workflow when it completes.
/// It updates the Linear issue state, agent status label, and emits completion activity.
pub async fn handle_play_complete(
    State(state): State<Arc<CallbackState>>,
    Json(payload): Json<PlayCompleteCallback>,
) -> Result<Json<Value>, StatusCode> {
    info!(
        session_id = %payload.linear_session_id,
        workflow_name = %payload.workflow_name,
        workflow_status = %payload.workflow_status,
        "Received play completion callback"
    );

    // Get Linear client
    let Some(client) = &state.linear_client else {
        error!("Linear client not configured");
        return Ok(Json(json!({
            "status": "error",
            "error": "Linear client not configured",
            "session_id": payload.linear_session_id
        })));
    };

    let success = payload.workflow_status == "Succeeded";

    // Determine the final agent status
    let agent_status = if success {
        AgentStatus::PrCreated // PR created, awaiting review
    } else {
        AgentStatus::Error
    };

    // Update agent status label
    if let Err(e) = client
        .update_agent_status_label(
            &payload.linear_issue_id,
            &payload.linear_team_id,
            agent_status,
        )
        .await
    {
        warn!(error = %e, "Failed to update agent status label");
    } else {
        info!(
            issue_id = %payload.linear_issue_id,
            label = %agent_status.to_label_name(),
            "Updated agent status label on workflow completion"
        );
    }

    if success {
        // Emit success response
        let summary = format!(
            "## Task Implementation Complete\n\n\
             **Workflow:** `{}`\n\
             **Status:** ✅ Succeeded\n\n\
             The implementation has been completed and a PR has been created. \
             Please review the changes and merge when ready.",
            payload.workflow_name
        );

        if let Err(e) = client
            .emit_response(&payload.linear_session_id, &summary)
            .await
        {
            warn!(error = %e, "Failed to emit completion response");
        }

        // Update issue state to "In Review"
        if let Ok(states) = client
            .get_team_workflow_states(&payload.linear_team_id)
            .await
        {
            // Look for "In Review" state first
            let target_state = states
                .iter()
                .find(|s| s.name == "In Review")
                .or_else(|| states.iter().find(|s| s.state_type == "started"));

            if let Some(state) = target_state {
                if let Err(e) = client
                    .update_issue(
                        &payload.linear_issue_id,
                        crate::models::IssueUpdateInput {
                            state_id: Some(state.id.clone()),
                            ..Default::default()
                        },
                    )
                    .await
                {
                    warn!(error = %e, "Failed to update issue state");
                }
            }
        }
    } else {
        // Emit failure response
        let error_msg = format!(
            "## Task Implementation Failed\n\n\
             **Workflow:** `{}`\n\
             **Status:** ❌ {}\n\n\
             The implementation workflow failed. Please check the logs and retry.",
            payload.workflow_name, payload.workflow_status
        );

        if let Err(e) = client
            .emit_error(&payload.linear_session_id, error_msg)
            .await
        {
            warn!(error = %e, "Failed to emit error activity");
        }
    }

    Ok(Json(json!({
        "status": if success { "success" } else { "error" },
        "session_id": payload.linear_session_id,
        "workflow_name": payload.workflow_name,
        "workflow_status": payload.workflow_status,
        "agent_label": agent_status.to_label_name()
    })))
}

/// Task status from sidecar.
#[derive(Debug, Clone, Deserialize)]
pub struct SidecarTaskStatus {
    /// Current status (e.g., `in_progress`, `testing`, `review`, `complete`, `failed`)
    pub status: String,
    /// Current stage (e.g., "implementation", "quality", "testing")
    #[serde(default)]
    pub stage: Option<String>,
    /// Progress percentage (0-100)
    #[serde(default)]
    pub progress: Option<u8>,
    /// Current activity description
    #[serde(default)]
    pub activity: Option<String>,
    /// Error message if failed
    #[serde(default)]
    pub error: Option<String>,
    /// PR URL if created
    #[serde(default)]
    pub pr_url: Option<String>,
}

/// Status update payload from sidecar.
#[derive(Debug, Clone, Deserialize)]
pub struct StatusSyncPayload {
    /// Linear session ID
    pub linear_session_id: String,
    /// Linear issue ID
    pub linear_issue_id: String,
    /// Linear team ID
    pub linear_team_id: String,
    /// Task status
    pub status: SidecarTaskStatus,
    /// Workflow name
    pub workflow_name: String,
}

/// Handle status sync from sidecar.
///
/// This endpoint receives status updates from the sidecar container
/// and syncs them to Linear (issue state + agent status labels + activities).
#[allow(clippy::too_many_lines)]
pub async fn handle_status_sync(
    State(state): State<Arc<CallbackState>>,
    Json(payload): Json<StatusSyncPayload>,
) -> Result<Json<Value>, StatusCode> {
    info!(
        session_id = %payload.linear_session_id,
        status = %payload.status.status,
        stage = ?payload.status.stage,
        "Received status sync from sidecar"
    );

    // Get Linear client
    let Some(client) = &state.linear_client else {
        return Ok(Json(json!({
            "status": "skipped",
            "reason": "Linear client not configured"
        })));
    };

    // Map status to Linear workflow state
    let linear_state_type = match payload.status.status.as_str() {
        "complete" | "done" => "completed",
        // All other states (in_progress, testing, quality, review, failed, error, etc.)
        // stay in "started" - use activity for errors
        _ => "started",
    };

    // Update issue state if we can map it
    if let Ok(states) = client
        .get_team_workflow_states(&payload.linear_team_id)
        .await
    {
        // Find appropriate state based on status
        let target_state = match payload.status.status.as_str() {
            "review" => states.iter().find(|s| s.name == "In Review"),
            "complete" | "done" => states.iter().find(|s| s.state_type == "completed"),
            _ => states.iter().find(|s| s.state_type == linear_state_type),
        };

        if let Some(state) = target_state {
            if let Err(e) = client
                .update_issue(
                    &payload.linear_issue_id,
                    crate::models::IssueUpdateInput {
                        state_id: Some(state.id.clone()),
                        ..Default::default()
                    },
                )
                .await
            {
                warn!(error = %e, "Failed to update issue state");
            }
        }
    }

    // Update agent status label
    let agent_status = AgentStatus::from_sidecar_status(&payload.status.status);
    if let Err(e) = client
        .update_agent_status_label(
            &payload.linear_issue_id,
            &payload.linear_team_id,
            agent_status,
        )
        .await
    {
        warn!(error = %e, "Failed to update agent status label");
    } else {
        info!(
            issue_id = %payload.linear_issue_id,
            label = %agent_status.to_label_name(),
            "Updated agent status label"
        );
    }

    // Emit activity based on status
    let activity_message = if let Some(activity) = &payload.status.activity {
        activity.clone()
    } else {
        match payload.status.status.as_str() {
            "in_progress" => format!(
                "Working on task... {}",
                payload.status.stage.as_deref().unwrap_or("implementation")
            ),
            "testing" => "Running tests...".to_string(),
            "quality" => "Running quality checks...".to_string(),
            "review" => "Ready for review".to_string(),
            "complete" => "Task completed".to_string(),
            "failed" => format!(
                "Task failed: {}",
                payload.status.error.as_deref().unwrap_or("Unknown error")
            ),
            other => format!("Status: {other}"),
        }
    };

    // Emit appropriate activity type
    let emit_result = if payload.status.status == "failed" {
        client
            .emit_error(&payload.linear_session_id, activity_message)
            .await
    } else if payload.status.status == "complete" {
        let response = if let Some(pr_url) = &payload.status.pr_url {
            format!(
                "## Task Implementation Complete\n\n\
                 **Status:** ✅ Complete\n\
                 **PR:** {pr_url}\n\n\
                 The implementation is ready for review."
            )
        } else {
            "## Task Implementation Complete\n\n**Status:** ✅ Complete".to_string()
        };
        client
            .emit_response(&payload.linear_session_id, &response)
            .await
    } else {
        client
            .emit_thought(&payload.linear_session_id, activity_message)
            .await
    };

    if let Err(e) = emit_result {
        warn!(error = %e, "Failed to emit activity");
    }

    Ok(Json(json!({
        "status": "success",
        "session_id": payload.linear_session_id,
        "task_status": payload.status.status,
        "agent_label": agent_status.to_label_name()
    })))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_deserialize_intake_callback() {
        let json = r#"{
            "sessionId": "session-123",
            "issueId": "issue-456",
            "issueIdentifier": "TSK-1",
            "teamId": "team-789",
            "tasks": [
                {
                    "id": 1,
                    "title": "Test Task",
                    "description": "Test description",
                    "priority": 2,
                    "dependencies": []
                }
            ],
            "workflowName": "intake-12345",
            "success": true
        }"#;

        let callback: IntakeCompleteCallback = serde_json::from_str(json).unwrap();
        assert_eq!(callback.session_id, "session-123");
        assert_eq!(callback.tasks.len(), 1);
        assert!(callback.success);
    }

    #[test]
    fn test_deserialize_failed_callback() {
        let json = r#"{
            "sessionId": "session-123",
            "issueId": "issue-456",
            "issueIdentifier": "TSK-1",
            "teamId": "team-789",
            "tasks": [],
            "success": false,
            "error": "Workflow timeout"
        }"#;

        let callback: IntakeCompleteCallback = serde_json::from_str(json).unwrap();
        assert!(!callback.success);
        assert_eq!(callback.error, Some("Workflow timeout".to_string()));
    }
}
