# Task ID: 5
# Title: Real-time Communication with Socket.io
# Status: pending
# Dependencies: 3, 4
# Priority: high
# Description: Implement Socket.io for real-time messaging, typing indicators, user presence, and read receipts.
# Details:
1. Set up Socket.io server in the backend

2. Implement socket authentication using JWT

3. Create socket event handlers for:
   - Joining/leaving rooms
   - Sending/receiving messages
   - Typing indicators
   - User presence status
   - Read receipts

4. Integrate Redis adapter for Socket.io to support horizontal scaling

5. Implement error handling and reconnection logic

Example Socket.io server setup:
```typescript
import { Server } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';

const io = new Server(httpServer, {
  cors: {
    origin: process.env.FRONTEND_URL,
    credentials: true
  }
});

// Redis adapter setup
const pubClient = createClient({ url: process.env.REDIS_URL });
const subClient = pubClient.duplicate();
io.adapter(createAdapter(pubClient, subClient));

// Socket authentication middleware
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  if (!token) return next(new Error('Authentication error'));
  
  jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {
    if (err) return next(new Error('Authentication error'));
    socket.user = decoded;
    next();
  });
});

// Socket event handlers
io.on('connection', (socket) => {
  console.log(`User connected: ${socket.user.id}`);
  
  // Update user presence
  userService.setUserOnline(socket.user.id);
  
  socket.on('join-room', (roomId) => {
    socket.join(roomId);
  });
  
  socket.on('send-message', async (data) => {
    const { roomId, content } = data;
    const message = await messageService.createMessage({
      roomId,
      userId: socket.user.id,
      content
    });
    
    io.to(roomId).emit('new-message', message);
  });
  
  socket.on('typing', (roomId) => {
    socket.to(roomId).emit('user-typing', {
      userId: socket.user.id,
      username: socket.user.username
    });
  });
  
  socket.on('read-message', async (messageId) => {
    await messageService.markAsRead(messageId, socket.user.id);
    const message = await messageService.getMessage(messageId);
    io.to(message.roomId).emit('message-read', {
      messageId,
      userId: socket.user.id
    });
  });
  
  socket.on('disconnect', () => {
    userService.setUserOffline(socket.user.id);
  });
});
```

# Test Strategy:
Write unit tests for Socket.io event handlers. Test real-time communication between multiple clients. Measure message delivery latency to ensure it meets the sub-100ms requirement. Test reconnection scenarios and error handling.
