# Task ID: 2
# Title: Implement CLI-Aware Model Validation Framework
# Status: pending
# Dependencies: 1
# Priority: high
# Description: Refactor the hard-coded validate_model_name() function to support all CLI providers with extensible validation patterns and comprehensive model catalog
# Details:
Create controller/src/cli/validation.rs with a trait-based validation system. Implement ModelValidator trait with validate_model(&self, model: &str, cli_type: CLIType) -> Result<ValidatedModel>. Create provider-specific validators: ClaudeModelValidator (claude-3-opus, claude-3.5-sonnet, claude-3-haiku patterns), OpenAIModelValidator (gpt-4o, gpt-4-turbo, o1-preview, o3-mini patterns), GoogleModelValidator (gemini-1.5-pro, gemini-2.0-flash patterns), and extensible validators for Grok, Qwen, etc. Build a ModelCatalog struct that maintains a registry of valid models per CLI with version support. Implement fuzzy matching for common typos and provide helpful suggestions. Add comprehensive regex patterns for each provider's naming conventions. Create a validation cache with TTL to avoid repeated validations. Include model capability metadata (context window, multimodal support, streaming capability).

# Test Strategy:
Unit test each validator with valid and invalid model names. Test edge cases like version numbers, special characters, and case sensitivity. Verify fuzzy matching suggests correct models for typos. Test model catalog updates and cache invalidation. Performance test validation with 1000+ concurrent requests. Integration test with mock CLI responses to verify model availability.

# Subtasks:
## 1. Create trait-based validation architecture [pending]
### Dependencies: None
### Description: Design and implement the core ModelValidator trait and supporting types in controller/src/cli/validation.rs
### Details:
Define ModelValidator trait with validate_model(&self, model: &str, cli_type: CLIType) -> Result<ValidatedModel> signature. Create ValidatedModel struct containing model name, version, provider, and validation metadata. Define ValidationError enum with specific error types (InvalidFormat, UnsupportedModel, DeprecatedModel). Implement CLIType enum for all supported providers. Create ValidationContext struct for passing additional validation parameters. Define ModelPattern trait for regex-based validation patterns.

## 2. Implement ClaudeModelValidator [pending]
### Dependencies: 2.1
### Description: Build the Claude-specific model validator with comprehensive pattern matching for all Claude model variants
### Details:
Implement ModelValidator trait for ClaudeModelValidator struct. Define regex patterns for claude-3-opus-*, claude-3.5-sonnet-*, claude-3-haiku-* models with version support. Handle special cases like claude-instant, claude-2, and legacy models. Implement validation for date-based versions (e.g., claude-3.5-sonnet-20241022). Add support for Claude's feature flags and model capabilities. Create comprehensive unit tests covering all Claude model patterns and edge cases.

## 3. Create OpenAIModelValidator [pending]
### Dependencies: 2.1
### Description: Implement validation for OpenAI models including GPT-4, O1, and O3 series with version handling
### Details:
Implement ModelValidator for OpenAIModelValidator struct. Define patterns for gpt-4o*, gpt-4-turbo*, gpt-3.5-turbo*, o1-preview, o1-mini, o3-mini models. Handle versioned models with date suffixes (e.g., gpt-4-0125-preview). Support legacy models and deprecated naming conventions. Implement validation for fine-tuned model identifiers (ft:gpt-*). Add capability detection for vision, function calling, and JSON mode support. Write unit tests for all OpenAI model patterns.

## 4. Build GoogleModelValidator [pending]
### Dependencies: 2.1
### Description: Create validator for Google's Gemini models with version and variant support
### Details:
Implement ModelValidator for GoogleModelValidator struct. Define patterns for gemini-1.5-pro*, gemini-1.5-flash*, gemini-2.0-flash*, gemini-exp-* models. Handle version suffixes and experimental model variants. Support multimodal model indicators and context window specifications. Implement validation for Bard-legacy model names if applicable. Add detection for model capabilities like grounding and code execution. Create comprehensive test suite for Gemini model validation.

## 5. Implement validators for additional providers [pending]
### Dependencies: 2.1
### Description: Create validators for Grok, Qwen, Mistral, and other emerging CLI providers
### Details:
Implement GrokModelValidator for xAI's Grok models (grok-beta, grok-2-*). Create QwenModelValidator for Alibaba's Qwen models with version patterns. Build MistralModelValidator for Mistral AI models (mistral-large, mistral-medium, codestral). Implement GenericModelValidator as fallback for unknown providers using configurable patterns. Add support for local/self-hosted models (ollama, llama.cpp patterns). Create extensible provider registry for easy addition of new validators.

## 6. Create ModelCatalog registry system [pending]
### Dependencies: 2.2, 2.3, 2.4, 2.5
### Description: Build a comprehensive model catalog that maintains valid models per CLI with version support and metadata
### Details:
Create ModelCatalog struct with HashMaps for provider->models mapping. Implement catalog loading from JSON/YAML configuration files. Add version range support using semver crate for model versioning. Create ModelMetadata struct with context_window, max_output_tokens, supports_vision, supports_tools fields. Implement catalog update mechanism with remote fetching capability. Add deprecation tracking with sunset dates and migration suggestions. Build catalog query API with filtering by capability.

## 7. Implement fuzzy matching and suggestion system [pending]
### Dependencies: 2.6
### Description: Build intelligent typo correction and model suggestion system for improved user experience
### Details:
Implement Levenshtein distance algorithm for fuzzy string matching. Create SuggestionEngine that finds closest valid models for invalid inputs. Build context-aware suggestions based on CLI type and user history. Implement common typo patterns detection (gpt4 -> gpt-4, claude3 -> claude-3). Add smart suggestions for deprecated models to their replacements. Create confidence scoring for suggestions with threshold configuration. Implement caching of suggestion results for performance.

## 8. Build validation caching mechanism [pending]
### Dependencies: 2.6, 2.7
### Description: Implement an efficient caching layer with TTL support to optimize repeated validations
### Details:
Create ValidationCache using LRU cache with configurable size limits. Implement TTL-based expiration using tokio time wheels. Build cache key generation from model name + CLI type + version. Add cache statistics tracking (hits, misses, evictions). Implement cache warming on startup with common models. Create cache invalidation API for catalog updates. Add distributed cache support using Redis for multi-instance deployments. Implement cache persistence for faster cold starts.

## 9. Add model capability metadata system [pending]
### Dependencies: 2.6
### Description: Implement comprehensive capability tracking for validated models including context windows and feature support
### Details:
Create ModelCapabilities struct with detailed capability fields: context_window_size, max_output_tokens, supports_streaming, supports_vision, supports_audio, supports_tools, supports_json_mode, supports_search. Implement capability inheritance for model families. Add dynamic capability updates from provider APIs. Create capability comparison utilities for model selection. Implement cost estimation based on token limits. Add performance characteristics (latency, throughput estimates). Build capability-based model recommendation engine.

## 10. Create comprehensive test suite [pending]
### Dependencies: 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9
### Description: Develop extensive unit and integration tests for the validation framework ensuring reliability and correctness
### Details:
Write unit tests for each validator covering valid/invalid patterns, edge cases, version formats. Create integration tests validating end-to-end validation flow. Implement property-based tests using proptest for fuzzy matching. Add performance benchmarks for validation operations. Create mock provider responses for capability testing. Implement regression tests for known validation issues. Add concurrent validation stress tests. Create test fixtures with real-world model names. Build validation accuracy metrics and reporting.

