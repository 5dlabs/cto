{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Project Structure and Dependencies",
        "description": "Analyze current multi-agent orchestration platform implementation status and document existing capabilities vs. gaps in the CLI-agnostic infrastructure",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "The project currently exists as a TaskMaster-generated task structure with comprehensive documentation but minimal implementation. Conduct analysis of: 1) Current state of the Rust-based multi-agent orchestration platform (controller, MCP servers, event-driven workflows), 2) Existing CLI container images and their readiness levels, 3) Multi-agent workflow capabilities (Rex→Cleo→Tess pipeline), 4) Event-driven infrastructure status (Argo Events, GitHub webhooks, workflow orchestration), 5) Infrastructure gaps preventing full multi-agent coordination. Focus on understanding the sophisticated production-ready architecture described in CLAUDE.md versus current implementation state, particularly around the workflow suspension issues and sensor configuration problems identified in the cluster analysis.",
        "testStrategy": "Verify TaskMaster project structure exists with generated tasks.json. Analyze .mcp.json configuration for current MCP server setup. Review .taskmaster/docs/ for architecture specifications and task documentation. Examine .taskmaster/tasks/tasks.json for complete task breakdown. Document gaps between documented architecture (29 comprehensive tasks, Rex→Cleo→Tess workflows, event-driven coordination) and current implementation state (TaskMaster setup only).",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze TaskMaster project structure and generated tasks",
            "description": "Review the complete TaskMaster-generated project structure to understand the scope and complexity of the multi-agent platform",
            "status": "pending",
            "dependencies": [],
            "details": "Examine .taskmaster/tasks/tasks.json for all 29 generated tasks covering foundation through system maturity phases. Review .taskmaster/docs/ directory for architecture documentation, PRD, and task-specific documentation. Analyze the task hierarchy and dependencies to understand the full implementation roadmap from basic workflow orchestration through ML optimization.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Document current MCP and multi-agent infrastructure status",
            "description": "Assess the existing MCP configuration and multi-agent orchestration capabilities",
            "status": "pending",
            "dependencies": [],
            "details": "Analyze .mcp.json configuration showing task-master-ai MCP server setup with multiple API key environment variables. Review project root for evidence of controller/, mcp/, or infra/ directories mentioned in architecture. Document the gap between TaskMaster setup (project planning/task generation) and actual multi-agent orchestration platform implementation (Rex, Cleo, Tess agents).",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Evaluate CLI container image readiness and capabilities",
            "description": "Assess the current state of CLI container images and multi-CLI support infrastructure",
            "status": "pending",
            "dependencies": [],
            "details": "Review architecture documentation references to infra/images/ directory structure for 8 CLI types (claude, codex, opencode, gemini, grok, qwen, cursor, openhands). Document the gap between documented container infrastructure and current project state. Analyze the CLI-specific configuration patterns (Node.js, Rust, Python runtimes) and MCP integration approaches described in the architecture.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Assess event-driven workflow orchestration capabilities",
            "description": "Evaluate the current state of GitHub webhook processing and Argo Events integration",
            "status": "pending",
            "dependencies": [
              3
            ],
            "details": "Review CLAUDE.md references to workflow suspension problems and sensor configuration errors preventing Rex→Cleo→Tess coordination. Analyze the gap between documented event-driven architecture (GitHub webhooks, Argo Events sensors, workflow resume operations) and current implementation. Document critical issues like 'template resume-after-implementation is invalid' preventing multi-agent workflows from progressing past implementation stage.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Document architecture vision vs implementation gaps",
            "description": "Create comprehensive gap analysis between documented capabilities and current state",
            "status": "pending",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Synthesize findings from architecture analysis into actionable gap assessment. Document that this is a sophisticated multi-agent orchestration platform design (not a simple CLI-agnostic tool) with production-grade architecture including event-driven coordination, quality gates, and multi-week workflows. Identify that current state is TaskMaster project planning phase, not implementation phase. Provide clear roadmap for moving from task planning to actual implementation.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Review existing development environment and tooling setup",
            "description": "Analyze current development configuration and tooling for the TaskMaster workflow",
            "status": "pending",
            "dependencies": [],
            "details": "Examine .env.example, various CLI-specific configuration files (.gemini/, .roo/, .kilo/, etc.), and development tooling setup. Document how the current TaskMaster-based development environment supports the multi-agent platform development workflow. Assess integration with Claude Code MCP server configuration and task-master-ai tooling.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Analyze task dependencies and implementation sequence",
            "description": "Review the generated task dependency graph and implementation roadmap",
            "status": "pending",
            "dependencies": [
              1,
              5
            ],
            "details": "Examine task dependencies in tasks.json to understand the proper implementation sequence from foundational infrastructure through advanced multi-agent coordination features. Document how tasks build from basic Rust workspace setup through sophisticated event-driven workflows, quality gates, and production-grade operations. Identify critical path tasks and potential parallelization opportunities.",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Create implementation readiness assessment report",
            "description": "Compile comprehensive analysis into actionable assessment document",
            "status": "pending",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Create detailed report documenting: 1) Current project state (TaskMaster planning phase with comprehensive architecture documentation), 2) Target architecture capabilities (multi-agent orchestration with Rex→Cleo→Tess workflows, event-driven coordination, production-grade quality gates), 3) Implementation gaps and priorities, 4) Recommended next steps for beginning actual implementation. Focus on the transition from planning to building the sophisticated multi-agent software development orchestration platform.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement CLI-Aware Model Validation Framework",
        "description": "Refactor the hard-coded validate_model_name() function to support all CLI providers with extensible validation patterns and comprehensive model catalog",
        "details": "Create controller/src/cli/validation.rs with a trait-based validation system. Implement ModelValidator trait with validate_model(&self, model: &str, cli_type: CLIType) -> Result<ValidatedModel>. Create provider-specific validators: ClaudeModelValidator (claude-3-opus, claude-3.5-sonnet, claude-3-haiku patterns), OpenAIModelValidator (gpt-4o, gpt-4-turbo, o1-preview, o3-mini patterns), GoogleModelValidator (gemini-1.5-pro, gemini-2.0-flash patterns), and extensible validators for Grok, Qwen, etc. Build a ModelCatalog struct that maintains a registry of valid models per CLI with version support. Implement fuzzy matching for common typos and provide helpful suggestions. Add comprehensive regex patterns for each provider's naming conventions. Create a validation cache with TTL to avoid repeated validations. Include model capability metadata (context window, multimodal support, streaming capability).",
        "testStrategy": "Unit test each validator with valid and invalid model names. Test edge cases like version numbers, special characters, and case sensitivity. Verify fuzzy matching suggests correct models for typos. Test model catalog updates and cache invalidation. Performance test validation with 1000+ concurrent requests. Integration test with mock CLI responses to verify model availability.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create trait-based validation architecture",
            "description": "Design and implement the core ModelValidator trait and supporting types in controller/src/cli/validation.rs",
            "dependencies": [],
            "details": "Define ModelValidator trait with validate_model(&self, model: &str, cli_type: CLIType) -> Result<ValidatedModel> signature. Create ValidatedModel struct containing model name, version, provider, and validation metadata. Define ValidationError enum with specific error types (InvalidFormat, UnsupportedModel, DeprecatedModel). Implement CLIType enum for all supported providers. Create ValidationContext struct for passing additional validation parameters. Define ModelPattern trait for regex-based validation patterns.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement ClaudeModelValidator",
            "description": "Build the Claude-specific model validator with comprehensive pattern matching for all Claude model variants",
            "dependencies": [
              "2.1"
            ],
            "details": "Implement ModelValidator trait for ClaudeModelValidator struct. Define regex patterns for claude-3-opus-*, claude-3.5-sonnet-*, claude-3-haiku-* models with version support. Handle special cases like claude-instant, claude-2, and legacy models. Implement validation for date-based versions (e.g., claude-3.5-sonnet-20241022). Add support for Claude's feature flags and model capabilities. Create comprehensive unit tests covering all Claude model patterns and edge cases.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create OpenAIModelValidator",
            "description": "Implement validation for OpenAI models including GPT-4, O1, and O3 series with version handling",
            "dependencies": [
              "2.1"
            ],
            "details": "Implement ModelValidator for OpenAIModelValidator struct. Define patterns for gpt-4o*, gpt-4-turbo*, gpt-3.5-turbo*, o1-preview, o1-mini, o3-mini models. Handle versioned models with date suffixes (e.g., gpt-4-0125-preview). Support legacy models and deprecated naming conventions. Implement validation for fine-tuned model identifiers (ft:gpt-*). Add capability detection for vision, function calling, and JSON mode support. Write unit tests for all OpenAI model patterns.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Build GoogleModelValidator",
            "description": "Create validator for Google's Gemini models with version and variant support",
            "dependencies": [
              "2.1"
            ],
            "details": "Implement ModelValidator for GoogleModelValidator struct. Define patterns for gemini-1.5-pro*, gemini-1.5-flash*, gemini-2.0-flash*, gemini-exp-* models. Handle version suffixes and experimental model variants. Support multimodal model indicators and context window specifications. Implement validation for Bard-legacy model names if applicable. Add detection for model capabilities like grounding and code execution. Create comprehensive test suite for Gemini model validation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement validators for additional providers",
            "description": "Create validators for Grok, Qwen, Mistral, and other emerging CLI providers",
            "dependencies": [
              "2.1"
            ],
            "details": "Implement GrokModelValidator for xAI's Grok models (grok-beta, grok-2-*). Create QwenModelValidator for Alibaba's Qwen models with version patterns. Build MistralModelValidator for Mistral AI models (mistral-large, mistral-medium, codestral). Implement GenericModelValidator as fallback for unknown providers using configurable patterns. Add support for local/self-hosted models (ollama, llama.cpp patterns). Create extensible provider registry for easy addition of new validators.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create ModelCatalog registry system",
            "description": "Build a comprehensive model catalog that maintains valid models per CLI with version support and metadata",
            "dependencies": [
              "2.2",
              "2.3",
              "2.4",
              "2.5"
            ],
            "details": "Create ModelCatalog struct with HashMaps for provider->models mapping. Implement catalog loading from JSON/YAML configuration files. Add version range support using semver crate for model versioning. Create ModelMetadata struct with context_window, max_output_tokens, supports_vision, supports_tools fields. Implement catalog update mechanism with remote fetching capability. Add deprecation tracking with sunset dates and migration suggestions. Build catalog query API with filtering by capability.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement fuzzy matching and suggestion system",
            "description": "Build intelligent typo correction and model suggestion system for improved user experience",
            "dependencies": [
              "2.6"
            ],
            "details": "Implement Levenshtein distance algorithm for fuzzy string matching. Create SuggestionEngine that finds closest valid models for invalid inputs. Build context-aware suggestions based on CLI type and user history. Implement common typo patterns detection (gpt4 -> gpt-4, claude3 -> claude-3). Add smart suggestions for deprecated models to their replacements. Create confidence scoring for suggestions with threshold configuration. Implement caching of suggestion results for performance.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Build validation caching mechanism",
            "description": "Implement an efficient caching layer with TTL support to optimize repeated validations",
            "dependencies": [
              "2.6",
              "2.7"
            ],
            "details": "Create ValidationCache using LRU cache with configurable size limits. Implement TTL-based expiration using tokio time wheels. Build cache key generation from model name + CLI type + version. Add cache statistics tracking (hits, misses, evictions). Implement cache warming on startup with common models. Create cache invalidation API for catalog updates. Add distributed cache support using Redis for multi-instance deployments. Implement cache persistence for faster cold starts.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Add model capability metadata system",
            "description": "Implement comprehensive capability tracking for validated models including context windows and feature support",
            "dependencies": [
              "2.6"
            ],
            "details": "Create ModelCapabilities struct with detailed capability fields: context_window_size, max_output_tokens, supports_streaming, supports_vision, supports_audio, supports_tools, supports_json_mode, supports_search. Implement capability inheritance for model families. Add dynamic capability updates from provider APIs. Create capability comparison utilities for model selection. Implement cost estimation based on token limits. Add performance characteristics (latency, throughput estimates). Build capability-based model recommendation engine.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Create comprehensive test suite",
            "description": "Develop extensive unit and integration tests for the validation framework ensuring reliability and correctness",
            "dependencies": [
              "2.2",
              "2.3",
              "2.4",
              "2.5",
              "2.6",
              "2.7",
              "2.8",
              "2.9"
            ],
            "details": "Write unit tests for each validator covering valid/invalid patterns, edge cases, version formats. Create integration tests validating end-to-end validation flow. Implement property-based tests using proptest for fuzzy matching. Add performance benchmarks for validation operations. Create mock provider responses for capability testing. Implement regression tests for known validation issues. Add concurrent validation stress tests. Create test fixtures with real-world model names. Build validation accuracy metrics and reporting.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Design and Implement CLI Adapter Trait System",
        "description": "Create the core abstraction layer with CliAdapter trait and base implementations for unified CLI interaction patterns",
        "details": "Create controller/src/cli/adapter.rs with the CliAdapter trait defining core methods: async fn validate_model(&self, model: &str) -> Result<bool>, async fn generate_config(&self, agent_config: &AgentConfig) -> Result<String>, fn format_prompt(&self, prompt: &str) -> String, async fn parse_response(&self, response: &str) -> Result<ParsedResponse>, fn get_memory_filename(&self) -> &str, fn get_executable_name(&self) -> &str, async fn initialize(&self, container: &Container) -> Result<()>. Implement BaseAdapter with shared functionality for logging, metrics, and error handling. Create AdapterFactory with fn create(cli_type: CLIType) -> Box<dyn CliAdapter> using pattern matching. Add lifecycle hooks for pre/post execution, cleanup, and health checks. Implement adapter configuration with per-CLI defaults and overrides. Add telemetry with OpenTelemetry integration for distributed tracing.",
        "testStrategy": "Unit test trait implementations with mock adapters. Test factory pattern creates correct adapter types. Verify shared functionality in BaseAdapter works across all implementations. Test lifecycle hooks are called in correct order. Mock container interactions to test initialization. Verify telemetry data is properly exported.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Core CliAdapter Trait Interface",
            "description": "Design and implement the main CliAdapter trait with all required async methods and associated types",
            "dependencies": [],
            "details": "Create controller/src/cli/adapter.rs and define the CliAdapter trait with methods: async fn validate_model(&self, model: &str) -> Result<bool>, async fn generate_config(&self, agent_config: &AgentConfig) -> Result<String>, fn format_prompt(&self, prompt: &str) -> String, async fn parse_response(&self, response: &str) -> Result<ParsedResponse>. Define associated types for Result<T> and error handling. Include lifetime parameters and Send + Sync bounds for async compatibility.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Lifecycle Management Methods",
            "description": "Add lifecycle hooks and container initialization methods to the CliAdapter trait",
            "dependencies": [
              "3.1"
            ],
            "details": "Extend CliAdapter trait with lifecycle methods: async fn initialize(&self, container: &Container) -> Result<()>, async fn pre_execution(&self) -> Result<()>, async fn post_execution(&self) -> Result<()>, async fn cleanup(&self) -> Result<()>, async fn health_check(&self) -> Result<HealthStatus>. Define HealthStatus enum with Ready, NotReady, and Degraded states. Add readiness probe support for Kubernetes integration.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create BaseAdapter Implementation",
            "description": "Build the BaseAdapter struct with shared functionality for all CLI adapters",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "Implement BaseAdapter struct in controller/src/cli/base.rs with common fields: logger: Arc<Logger>, metrics: Arc<MetricsCollector>, error_handler: ErrorHandler, config: AdapterConfig. Implement default methods for logging with structured context, error handling with retry logic, and metrics collection. Add circuit breaker pattern for fault tolerance. Include connection pooling for HTTP clients.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Design AdapterFactory with Pattern Matching",
            "description": "Create the factory pattern for instantiating appropriate CLI adapters based on CLI type",
            "dependencies": [
              "3.3"
            ],
            "details": "Create controller/src/cli/factory.rs with AdapterFactory struct. Implement create method: fn create(cli_type: CLIType, config: AdapterConfig) -> Result<Box<dyn CliAdapter>>. Use pattern matching on CLIType enum to instantiate correct adapter. Implement lazy loading with Arc<RwLock<HashMap<CLIType, Box<dyn CliAdapter>>>>. Add adapter caching and reuse logic for performance optimization.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Build Configuration System with Defaults",
            "description": "Implement per-CLI configuration with defaults and override mechanisms",
            "dependencies": [
              "3.3"
            ],
            "details": "Create controller/src/cli/config.rs with AdapterConfig struct containing: timeout_ms: u64, retry_count: u32, batch_size: usize, rate_limit: RateLimit, custom_headers: HashMap<String, String>. Implement ConfigBuilder with fluent API for configuration. Create default configurations for each CLI type using const values. Add configuration validation with serde_valid. Support environment variable overrides with prefix CLI_ADAPTER_.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Integrate OpenTelemetry for Distributed Tracing",
            "description": "Add comprehensive telemetry with OpenTelemetry for observability across the adapter system",
            "dependencies": [
              "3.3"
            ],
            "details": "Add opentelemetry v0.24.0 and opentelemetry-otlp v0.17.0 dependencies. Implement tracing in BaseAdapter with span creation for each method call. Add trace context propagation across async boundaries. Configure OTLP exporter for Jaeger/Zipkin integration. Implement custom span attributes for CLI type, model, and operation. Add metrics for latency, throughput, and error rates per adapter.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement Async File Operations Methods",
            "description": "Create async methods for file reading, writing, and manipulation required by CLI adapters",
            "dependencies": [
              "3.1"
            ],
            "details": "Add file operation methods to CliAdapter trait: async fn read_file(&self, path: &Path) -> Result<Vec<u8>>, async fn write_file(&self, path: &Path, content: &[u8]) -> Result<()>, async fn list_directory(&self, path: &Path) -> Result<Vec<PathBuf>>. Implement using tokio::fs for async I/O. Add file locking mechanisms for concurrent access. Include checksum validation for file integrity.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Build Prompt Formatting and Response Parsing",
            "description": "Implement flexible prompt formatting and response parsing logic for different CLI output formats",
            "dependencies": [
              "3.1"
            ],
            "details": "Create ParsedResponse enum with variants: Text(String), Json(serde_json::Value), Structured(StructuredOutput), Stream(AsyncStream). Implement format_prompt with template support using handlebars-rs. Add response parsers for JSON, YAML, and plain text formats. Include streaming response support with tokio::sync::mpsc. Implement error recovery for malformed responses.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Create Container Initialization Logic",
            "description": "Implement container setup and initialization for Kubernetes pod management",
            "dependencies": [
              "3.2"
            ],
            "details": "Build container initialization in initialize method with volume mounts, environment variable injection, and resource limits. Implement init container support for pre-flight checks. Add sidecar container management for logging and monitoring. Create PodSpec modifications for security contexts and service accounts. Include liveness and readiness probe configuration.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Implement Adapter Registry and Discovery",
            "description": "Build a dynamic registry system for adapter registration and discovery at runtime",
            "dependencies": [
              "3.4"
            ],
            "details": "Create controller/src/cli/registry.rs with AdapterRegistry struct using Arc<RwLock<HashMap<String, AdapterMetadata>>>. Implement register_adapter and discover_adapters methods. Add plugin system support for external adapters using dynamic library loading. Create AdapterMetadata with version, capabilities, and requirements. Implement capability negotiation for feature detection.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Add Health Check and Readiness Probes",
            "description": "Implement comprehensive health checking system for adapter availability and performance",
            "dependencies": [
              "3.2",
              "3.6"
            ],
            "details": "Create HealthChecker with periodic health checks using tokio::time::interval. Implement health endpoints for Kubernetes probes at /health/live and /health/ready. Add performance metrics collection for response times and error rates. Create circuit breaker integration to mark unhealthy adapters. Include dependency health checks for external services. Add graceful degradation for partial failures.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "Write Comprehensive Test Suite with Mocks",
            "description": "Create extensive unit and integration tests for the entire adapter system",
            "dependencies": [
              "3.1",
              "3.2",
              "3.3",
              "3.4",
              "3.5",
              "3.6",
              "3.7",
              "3.8",
              "3.9",
              "3.10",
              "3.11"
            ],
            "details": "Create mock implementations using mockall v0.13.0 for CliAdapter trait. Write unit tests for each adapter method with success and failure scenarios. Test factory pattern with all CLI types. Verify configuration merging and validation. Test async execution with tokio::test. Mock container and Kubernetes interactions. Test health checks and circuit breaker behavior. Add property-based tests using proptest. Include benchmarks for performance regression detection.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Configuration Resolution Engine",
        "description": "Build the multi-source configuration merger that handles Helm defaults, cto-config.json overrides, and runtime parameters with field-level granularity",
        "details": "Create controller/src/agents/resolver.rs with AgentResolver struct. Implement configuration loading from multiple sources: Helm values via ConfigMap (agent.agentCliConfigs), repository cto-config.json via Git clone, environment variables, and runtime parameters. Build MergeStrategy enum with Replace, Merge, Append, and DeepMerge options per field. Implement field-level merge rules using serde_json::Value manipulation. Add JSONSchema validation using jsonschema-rs v0.20.0 for configuration validation. Create precedence rules: Runtime > Environment > CtoConfig > Helm. Implement configuration caching with Redis using redis-rs v0.27.0 with 5-minute TTL. Add configuration preview API that shows resolved config without applying. Build audit trail logging all configuration changes with who/what/when/why. Handle backwards compatibility for agents without CLI specifications.",
        "testStrategy": "Test merge strategies with conflicting configurations. Verify precedence rules with multiple override sources. Test deep merge with nested JSON structures. Validate schema enforcement rejects invalid configs. Test cache invalidation on configuration changes. Verify audit trail captures all modifications. Load test with 100+ agents with different configurations.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AgentResolver struct and core interfaces",
            "description": "Design and implement the main AgentResolver struct with configuration source interfaces",
            "dependencies": [],
            "details": "Create controller/src/agents/resolver.rs with AgentResolver struct containing fields for configuration sources, merge strategies, and caching. Define ConfigSource trait with load_config() method. Create ConfigurationValue wrapper enum for handling different value types (String, Number, Bool, Object, Array). Implement basic constructor and initialization methods. Define error types for configuration resolution failures.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Helm ConfigMap configuration loader",
            "description": "Build the Helm values loader that reads from Kubernetes ConfigMaps",
            "dependencies": [
              "4.1"
            ],
            "details": "Create HelmConfigLoader implementing ConfigSource trait. Use k8s-openapi to read ConfigMap named 'agent-cli-configs' from namespace. Parse agent.agentCliConfigs YAML structure into serde_json::Value. Handle ConfigMap watch events for live updates. Implement retry logic for transient Kubernetes API failures. Add metrics for ConfigMap load times and failures.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build Git integration for cto-config.json retrieval",
            "description": "Implement Git clone and checkout functionality to fetch repository-specific configurations",
            "dependencies": [
              "4.1"
            ],
            "details": "Create GitConfigLoader using git2-rs v0.19.0 for repository operations. Implement shallow clone with depth=1 for performance. Support authentication via SSH keys and tokens from secret manager. Parse cto-config.json from repository root. Handle branch/tag/commit specification. Implement file watching for local development mode. Add caching of cloned repositories with TTL.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create field-level merge strategy engine",
            "description": "Implement the MergeStrategy enum and field-level merge rules",
            "dependencies": [
              "4.1"
            ],
            "details": "Define MergeStrategy enum with Replace, Merge, Append, and DeepMerge variants. Create MergeRules struct mapping field paths to strategies using JSONPath expressions. Implement merge_values() function handling each strategy type. Build deep merge logic for nested objects preserving array order. Handle type conflicts with configurable resolution. Support wildcard patterns in merge rules (e.g., '*.credentials' uses Replace).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement JSONSchema validation system",
            "description": "Add schema validation using jsonschema-rs for configuration verification",
            "dependencies": [
              "4.4"
            ],
            "details": "Integrate jsonschema-rs v0.20.0 for validation. Create schema registry loading schemas from embedded resources and external files. Implement validate_config() method checking merged configuration against schema. Build custom validators for CLI-specific constraints (model names, tool availability). Generate helpful error messages with field paths and expected values. Support schema versioning and migration between versions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Build precedence rules engine",
            "description": "Implement the configuration precedence system (Runtime > Environment > CtoConfig > Helm)",
            "dependencies": [
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Create PrecedenceEngine struct managing source priority. Implement resolve_config() method applying sources in correct order. Build environment variable parser supporting nested paths (AGENT_CONFIG_MODEL=gpt-4). Handle runtime parameter injection from API requests. Create precedence override mechanism for specific fields. Log precedence decisions for debugging. Support precedence customization per agent type.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement Redis caching with TTL management",
            "description": "Add configuration caching layer using Redis with automatic invalidation",
            "dependencies": [
              "4.6"
            ],
            "details": "Integrate redis-rs v0.27.0 for caching layer. Implement cache key generation from agent ID and configuration sources. Set 5-minute default TTL with configurable overrides. Build cache invalidation on source changes (ConfigMap updates, Git commits). Implement cache warming on startup. Add cache hit/miss metrics. Support cache bypass for debugging. Handle Redis connection failures with fallback to direct resolution.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Create configuration preview API",
            "description": "Build REST endpoint showing resolved configuration without applying changes",
            "dependencies": [
              "4.6"
            ],
            "details": "Create POST /agents/{id}/config/preview endpoint. Accept override parameters in request body. Return resolved configuration with source attribution per field. Show merge strategy applied for each field. Include validation results and warnings. Support diff view against current configuration. Add dry-run mode for testing changes. Implement response caching for repeated previews.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Build audit trail logging system",
            "description": "Implement comprehensive audit logging for all configuration changes",
            "dependencies": [
              "4.6",
              "4.7"
            ],
            "details": "Create AuditLogger with structured event format. Log configuration changes with before/after values. Capture change metadata: user/service identity, timestamp, change reason, source system. Implement log shipping to centralized storage (S3/GCS). Add query API for audit history retrieval. Support compliance export formats (CSV, JSON). Implement log retention policies. Add tamper detection using cryptographic signatures.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Implement backwards compatibility handling",
            "description": "Add support for legacy agents without CLI specifications",
            "dependencies": [
              "4.6"
            ],
            "details": "Create LegacyAgentAdapter detecting agents without CLI configs. Implement default configuration generation based on agent type. Map legacy environment variables to new configuration structure. Support gradual migration with deprecation warnings. Build compatibility shims for old configuration formats. Add feature flags for enabling new configuration system per agent. Implement configuration migration tool for bulk updates.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Create comprehensive test suite for merge scenarios",
            "description": "Build extensive tests covering all merge strategies and edge cases",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4",
              "4.5",
              "4.6",
              "4.7",
              "4.8",
              "4.9",
              "4.10"
            ],
            "details": "Write unit tests for each merge strategy with complex nested structures. Test precedence rules with all source combinations. Create property-based tests for merge commutativity and associativity. Test schema validation with valid and invalid configurations. Verify cache invalidation triggers correctly. Test audit trail captures all changes accurately. Build integration tests with real Kubernetes and Redis. Add performance benchmarks for 1000+ field configurations.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Create Template Management System",
        "description": "Implement dynamic template selection and rendering system for CLI-specific prompts, configurations, and scripts with fallback mechanisms",
        "details": "Create controller/src/templates/manager.rs with TemplateManager struct. Implement template registry with HashMap<(CLIType, TemplateType), Template>. Use Handlebars-rust v6.2.0 for template rendering with custom helpers. Create template types: SystemPrompt, ConfigFile, EntrypointScript, MemoryFile. Implement template discovery from filesystem (templates/{cli_type}/{template_type}.hbs). Add fallback chain: CLI-specific -> Generic -> Default. Create template variables context with agent metadata, configuration, and runtime info. Implement template validation with syntax checking and variable verification. Add template hot-reloading for development with notify-rs v7.0.0. Create template versioning system for gradual rollout. Build template performance cache with compiled templates.",
        "testStrategy": "Test template selection falls back correctly when CLI-specific missing. Verify Handlebars rendering with complex variable contexts. Test custom helpers produce correct output. Validate hot-reloading updates templates without restart. Test versioning system serves correct template versions. Performance test rendering 1000 templates/second.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TemplateManager struct with registry architecture",
            "description": "Implement the core TemplateManager struct in controller/src/templates/manager.rs with HashMap-based template registry for storing and retrieving templates by CLI type and template type",
            "dependencies": [],
            "details": "Define TemplateManager struct with HashMap<(CLIType, TemplateType), Template> registry. Create Template struct containing raw content, compiled version, and metadata. Implement new() constructor and basic CRUD operations (register, get, remove, list). Define CLIType enum (Claude, Codex, OpenCode, Gemini, etc.) and TemplateType enum (SystemPrompt, ConfigFile, EntrypointScript, MemoryFile). Set up error handling with custom TemplateError types.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Integrate Handlebars-rust with custom helpers",
            "description": "Set up Handlebars-rust v6.2.0 integration with custom helper functions for template rendering and variable substitution specific to CLI agent contexts",
            "dependencies": [
              "5.1"
            ],
            "details": "Add handlebars = \"6.2.0\" to Cargo.toml dependencies. Create HandlebarsEngine wrapper in templates/engine.rs. Implement custom helpers: if_cli_type, format_env_var, base64_encode, json_escape, default_value. Register standard helpers for string manipulation and conditional logic. Create RenderContext struct for passing data to templates. Implement compile() and render() methods with proper error handling.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement template discovery from filesystem",
            "description": "Build filesystem-based template discovery system that automatically loads templates from structured directory hierarchy",
            "dependencies": [
              "5.1"
            ],
            "details": "Create templates/ directory structure: templates/{cli_type}/{template_type}.hbs. Implement discover_templates() function using walkdir crate to traverse filesystem. Parse template filenames to extract CLI type and template type. Load template contents and metadata from accompanying .meta.toml files. Support template inheritance with @extends directive. Handle missing directories and malformed templates gracefully. Add file watcher setup preparation for hot-reloading.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Build fallback chain logic",
            "description": "Implement multi-level fallback system that resolves templates through CLI-specific, generic, and default fallback chain",
            "dependencies": [
              "5.1",
              "5.3"
            ],
            "details": "Create FallbackChain struct with resolve() method. Implement three-tier lookup: 1) CLI-specific template (e.g., templates/claude/system_prompt.hbs), 2) Generic template (templates/generic/system_prompt.hbs), 3) Default hardcoded template. Add configuration for custom fallback ordering. Implement lazy loading to avoid loading unused templates. Create fallback resolution logging for debugging. Add metrics for fallback usage patterns.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create template context builder with agent metadata",
            "description": "Build comprehensive context builder that aggregates agent metadata, configuration, and runtime information for template rendering",
            "dependencies": [
              "5.2"
            ],
            "details": "Create ContextBuilder struct in templates/context.rs. Implement methods to add agent metadata (name, namespace, labels, annotations). Add configuration context (CLI settings, environment variables, secrets). Include runtime context (timestamp, hostname, pod info). Build hierarchical context merging with precedence rules. Implement context validation to ensure required variables exist. Add context serialization for debugging and caching.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement template validation and syntax checking",
            "description": "Create comprehensive validation system for template syntax, variable usage, and output correctness",
            "dependencies": [
              "5.2",
              "5.5"
            ],
            "details": "Create TemplateValidator struct with validate() method. Implement Handlebars syntax validation using parser. Check for undefined variables and helpers in templates. Validate template output against expected schema (JSON/YAML validation). Create validation rules for each template type. Implement dry-run rendering with sample contexts. Add validation caching to avoid re-validating unchanged templates. Create detailed validation error messages with line numbers.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Add hot-reloading with notify-rs for development",
            "description": "Implement file system monitoring and automatic template reloading during development using notify-rs v7.0.0",
            "dependencies": [
              "5.3",
              "5.6"
            ],
            "details": "Add notify = \"7.0.0\" to Cargo.toml dependencies. Create FileWatcher component using notify::RecommendedWatcher. Monitor templates/ directory for create, modify, delete events. Implement debouncing to batch rapid changes (500ms window). Trigger template re-compilation on changes. Validate templates before applying updates. Add reload callbacks for downstream consumers. Create development/production mode toggle. Implement graceful error handling for invalid template updates.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Build template versioning system",
            "description": "Create versioning infrastructure for templates enabling gradual rollout, A/B testing, and rollback capabilities",
            "dependencies": [
              "5.1",
              "5.4"
            ],
            "details": "Design version schema (semver-based: major.minor.patch). Create VersionedTemplate wrapper with version history. Implement version resolution strategy (latest, pinned, range). Add version compatibility checking with CLI versions. Build rollout configuration (percentage-based, label-based). Create version migration system for template upgrades. Implement rollback mechanism with previous version retention. Add version metrics and usage tracking. Store version metadata in templates/{cli_type}/{template_type}/versions/.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Create performance cache for compiled templates",
            "description": "Implement high-performance caching layer for compiled templates to optimize rendering performance and reduce CPU usage",
            "dependencies": [
              "5.2",
              "5.6",
              "5.8"
            ],
            "details": "Create TemplateCache struct using LRU cache with 100 template limit. Implement cache key generation from (CLI type, template type, version). Store compiled Handlebars templates in memory. Add cache warming on startup with frequently used templates. Implement cache invalidation on template updates. Create cache metrics (hit rate, miss rate, eviction count). Add persistent cache option using RocksDB for faster restarts. Implement cache serialization for debugging. Add memory usage monitoring with configurable limits.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Build MCP Transport Abstraction Layer",
        "description": "Create unified MCP communication layer supporting streaming, buffered relay, and STDIO patterns across different CLI implementations",
        "details": "Create mcp/src/transport/mod.ts with abstract Transport class. Implement DirectStreamingTransport using native fetch with ReadableStream for CLIs with HTTP streaming. Build BufferedRelayTransport with configurable buffer sizes (default 64KB) for STDIO-based CLIs. Create StdioTransport using Node.js child_process for local MCP servers. Implement transport auto-detection based on CLI capabilities. Add retry logic with exponential backoff (initial: 100ms, max: 30s, jitter: 0.1). Build request/response correlation with UUID tracking. Implement timeout handling (default: 30s, configurable per tool). Add compression support using zstd for large payloads. Create metrics collection for latency, throughput, and error rates. Build connection pooling for HTTP transports with keep-alive.",
        "testStrategy": "Test streaming transport with mock SSE server. Verify buffered relay handles partial messages correctly. Test STDIO transport with mock child process. Verify auto-detection selects correct transport. Test retry logic with simulated failures. Verify timeout handling cancels requests properly. Load test with 100 concurrent MCP calls.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Abstract Transport Interface",
            "description": "Create the abstract Transport class with TypeScript interfaces defining the contract for all transport implementations",
            "dependencies": [],
            "details": "Design mcp/src/transport/mod.ts with abstract Transport class. Define interfaces for send(), receive(), connect(), disconnect(), and isConnected() methods. Create type definitions for TransportMessage, TransportOptions, and TransportMetrics. Define error types and response types. Establish the base configuration structure that all transports will inherit.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement DirectStreamingTransport",
            "description": "Build the HTTP streaming transport using native fetch API with ReadableStream support for real-time data flow",
            "dependencies": [
              "6.1"
            ],
            "details": "Create DirectStreamingTransport class extending Transport in mcp/src/transport/streaming.ts. Implement fetch with ReadableStream for Server-Sent Events (SSE) or chunked responses. Handle stream parsing with proper error boundaries. Implement backpressure handling. Add support for HTTP/2 multiplexing when available. Handle connection drops and automatic reconnection.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build BufferedRelayTransport",
            "description": "Create buffered transport implementation with configurable buffer sizes for STDIO-based CLI communication",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement BufferedRelayTransport in mcp/src/transport/buffered.ts with default 64KB buffer size. Create circular buffer implementation for efficient memory usage. Handle partial message assembly and fragmentation. Implement flow control to prevent buffer overflow. Add buffer flush mechanisms on timeout or size threshold. Build message boundary detection for proper packet reassembly.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create StdioTransport Implementation",
            "description": "Develop STDIO transport using Node.js child_process for local MCP server communication",
            "dependencies": [
              "6.1"
            ],
            "details": "Build StdioTransport in mcp/src/transport/stdio.ts using Node.js child_process.spawn(). Implement bidirectional communication through stdin/stdout pipes. Handle process lifecycle management including spawn, kill, and restart. Parse JSON-RPC messages from stdout stream. Implement stderr capture for debugging. Add process health monitoring with periodic heartbeats.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Transport Auto-Detection",
            "description": "Build intelligent transport selection based on CLI capabilities and environment detection",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Create TransportFactory in mcp/src/transport/factory.ts with capability detection logic. Probe for HTTP streaming support by checking fetch ReadableStream availability. Detect STDIO availability through process.stdin/stdout checks. Implement fallback chain: DirectStreaming -> BufferedRelay -> Stdio. Add CLI-specific overrides through configuration. Cache detection results for performance.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Build Retry Mechanism with Exponential Backoff",
            "description": "Implement robust retry logic with configurable exponential backoff for handling transient failures",
            "dependencies": [
              "6.1"
            ],
            "details": "Create RetryPolicy class with exponential backoff algorithm starting at 100ms, max 30s. Add jitter factor of 0.1 to prevent thundering herd. Implement retry budget to limit total retry attempts. Create retry predicates for determining retryable errors. Add circuit breaker pattern to prevent retry storms. Implement retry telemetry for monitoring retry patterns.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create Request/Response Correlation System",
            "description": "Implement UUID-based correlation for matching requests with responses in async communication",
            "dependencies": [
              "6.1"
            ],
            "details": "Generate UUIDs for each request using crypto.randomUUID(). Create CorrelationManager to track pending requests with Map<UUID, PendingRequest>. Implement timeout cleanup for orphaned requests. Add request queuing with priority support. Build response routing to correct request handlers. Implement correlation ID propagation through transport layers.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement Timeout and Cancellation Handling",
            "description": "Build comprehensive timeout management with request cancellation support",
            "dependencies": [
              "6.7"
            ],
            "details": "Implement configurable timeout per request type with 30s default. Create AbortController integration for request cancellation. Build timeout scheduler using setTimeout with cleanup on completion. Implement graceful shutdown handling for pending requests. Add timeout escalation for critical requests. Create timeout metrics collection for monitoring.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Add Compression Support with Zstd",
            "description": "Integrate zstd compression for efficient large payload transmission",
            "dependencies": [
              "6.1"
            ],
            "details": "Integrate zstd-wasm or node-zstd for compression support. Implement adaptive compression based on payload size threshold (>10KB). Add compression level configuration (default: 3, range: 1-19). Create streaming compression for large messages. Implement compression negotiation in transport handshake. Add compression metrics for ratio and performance tracking.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Build Metrics Collection System",
            "description": "Create comprehensive metrics tracking for latency, throughput, and error rates",
            "dependencies": [
              "6.1",
              "6.6",
              "6.7",
              "6.8"
            ],
            "details": "Implement MetricsCollector with latency histograms for p50, p95, p99. Track throughput in messages/sec and bytes/sec. Count errors by type and transport. Monitor active connections and connection pool usage. Add retry metrics including attempt counts and success rates. Create exporters for Prometheus and custom formats.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Implement Connection Pooling",
            "description": "Create HTTP connection pool with keep-alive support for improved performance",
            "dependencies": [
              "6.2",
              "6.10"
            ],
            "details": "Build ConnectionPool class with configurable pool size (default: 10). Implement keep-alive with periodic ping messages. Add connection health checking before reuse. Create connection lifecycle management (acquire, release, destroy). Implement fair scheduling for connection allocation. Add pool metrics for utilization and wait times.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Claude and Codex CLI Adapters",
        "description": "Create production-ready adapters for Claude (reference implementation) and Codex (TOML configuration) to validate multi-CLI architecture",
        "details": "Create controller/src/cli/adapters/claude.rs implementing CliAdapter for Claude. Maintain backward compatibility with existing CLAUDE.md memory files. Implement claude-specific model validation and configuration generation. Create controller/src/cli/adapters/codex.rs with TOML configuration support using toml-rs v0.8.0. Implement Codex-specific features: sandbox_preset (read-only, workspace-write, danger-full-access), model_reasoning_effort configuration, AGENTS.md memory file support, experimental_resume session handling. Add OAuth token exchange for Codex authentication. Implement configuration mapping between universal format and CLI-specific formats. Create response parsing for both CLIs handling different output formats. Add CLI-specific error handling and recovery mechanisms. Build health check implementations for both adapters.",
        "testStrategy": "Integration test both adapters with real CLI binaries in containers. Test configuration generation produces valid TOML/JSON. Verify memory file operations (read/write/update). Test authentication flows with mock OAuth server. Verify response parsing handles all output formats. Test error recovery with simulated failures. Benchmark adapter performance vs direct CLI usage.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and implement Claude adapter base structure",
            "description": "Create the foundational Claude adapter implementing the CliAdapter trait with core functionality",
            "dependencies": [],
            "details": "Create controller/src/cli/adapters/claude.rs file. Define ClaudeAdapter struct implementing CliAdapter trait. Set up basic configuration structures for Claude-specific settings. Implement constructor and initialization methods. Define Claude-specific error types and result types. Create adapter state management for maintaining Claude session context.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Claude model validation and configuration generation",
            "description": "Build Claude-specific model validation logic and JSON configuration generation",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement validate_model() method checking against Claude model catalog (claude-3-opus, claude-3.5-sonnet, claude-3-haiku). Create configuration generator producing valid Claude CLI JSON format. Map universal configuration fields to Claude-specific parameters. Handle model-specific parameters like max_tokens, temperature, and top_p. Validate API key format and presence. Generate .claude/settings.json compatible configuration.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build Claude memory file operations for CLAUDE.md",
            "description": "Implement reading, writing, and updating CLAUDE.md memory files maintaining backward compatibility",
            "dependencies": [
              "7.1"
            ],
            "details": "Create CLAUDE.md parser extracting instructions and context. Implement memory file writer preserving existing format. Build incremental update mechanism for adding new instructions. Handle file locking for concurrent access safety. Implement backup and restore functionality for rollback scenarios. Parse and validate markdown structure and frontmatter if present.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Codex adapter base structure with TOML support",
            "description": "Implement the foundational Codex adapter with TOML configuration parsing using toml-rs",
            "dependencies": [],
            "details": "Create controller/src/cli/adapters/codex.rs file. Define CodexAdapter struct implementing CliAdapter trait. Add toml-rs v0.8.0 dependency and implement TOML parsing. Set up Codex-specific configuration structures. Implement adapter initialization with TOML config loading. Define Codex-specific error handling and result types.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Codex-specific features and configurations",
            "description": "Build sandbox presets, model reasoning effort, and experimental features for Codex",
            "dependencies": [
              "7.4"
            ],
            "details": "Implement sandbox_preset enum with read-only, workspace-write, and danger-full-access modes. Create model_reasoning_effort configuration mapping (low, medium, high). Build experimental_resume session handling with state persistence. Implement AGENTS.md memory file support similar to CLAUDE.md. Map sandbox presets to appropriate filesystem permissions. Handle experimental feature flags and versioning.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Build OAuth token exchange for Codex authentication",
            "description": "Implement OAuth 2.0 PKCE flow for Codex authentication with token management",
            "dependencies": [
              "7.4"
            ],
            "details": "Implement OAuth 2.0 authorization code flow with PKCE. Build token exchange endpoint interaction. Create secure token storage with encryption. Implement automatic token refresh before expiry. Handle OAuth error responses and retry logic. Build fallback to device code flow for headless environments. Integrate with system keychain for credential storage.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create universal to CLI-specific configuration mapping",
            "description": "Build bidirectional configuration mappers between universal format and CLI-specific formats",
            "dependencies": [
              "7.2",
              "7.5"
            ],
            "details": "Create configuration mapper traits for extensibility. Implement UniversalToClaudeMapper producing JSON configurations. Build UniversalToCodexMapper generating TOML configurations. Handle field name transformations and type conversions. Map tool permissions to CLI-specific formats. Create validation for mapped configurations. Build reverse mappers for configuration import.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement response parsing for both CLI output formats",
            "description": "Build parsers handling different output formats from Claude and Codex CLIs",
            "dependencies": [
              "7.1",
              "7.4"
            ],
            "details": "Create response parser trait with CLI-specific implementations. Build Claude JSON response parser extracting content and metadata. Implement Codex structured output parser handling TOML responses. Parse streaming responses with incremental updates. Extract tool use calls and their results. Handle multi-turn conversation context. Parse error responses and extract actionable information.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Build error handling and recovery mechanisms",
            "description": "Implement CLI-specific error handling with recovery strategies and retry logic",
            "dependencies": [
              "7.8"
            ],
            "details": "Create error classification system for transient vs permanent failures. Implement exponential backoff retry logic for rate limits. Build circuit breaker pattern for repeated failures. Handle authentication errors with credential refresh. Implement graceful degradation for partial failures. Create error context enrichment with CLI-specific details. Build recovery strategies for connection timeouts and network issues.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Create health checks and integration tests",
            "description": "Implement health check endpoints and comprehensive integration tests with mock CLIs",
            "dependencies": [
              "7.1",
              "7.2",
              "7.3",
              "7.4",
              "7.5",
              "7.6",
              "7.7",
              "7.8",
              "7.9"
            ],
            "details": "Implement health check endpoints verifying CLI binary availability. Create readiness checks validating authentication and configuration. Build mock CLI binaries for integration testing. Write tests for configuration generation and validation. Test memory file operations with concurrent access. Verify OAuth flow with mock authorization server. Test response parsing with various output formats. Validate error recovery mechanisms with failure injection.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Create Multi-CLI Container Images",
        "description": "Build optimized Docker images for each CLI with proper runtime environments, dependencies, and health checks",
        "details": "Create base Dockerfiles in infra/images/{cli}/Dockerfile. For Node.js CLIs (Claude, Opencode, Gemini): Use node:22-slim base, install CLI via npm/curl, set up workspace directories. For Rust-based Codex: Use rust:1.83-slim, install with cargo install @openai/codex, cache cargo registry. For Python CLIs (Cursor, OpenHands): Use python:3.12-slim, create virtualenv, install with pip. Implement multi-stage builds to minimize image size. Add health check scripts checking CLI availability and MCP connectivity. Configure entrypoint scripts for initialization and environment setup. Add security scanning with Trivy in CI pipeline. Implement SBOM generation with syft. Sign images with cosign for supply chain security. Create matrix build for linux/amd64 and linux/arm64. Optimize layer caching with proper COPY ordering.",
        "testStrategy": "Build all images and verify size < 500MB (Node), < 700MB (Rust), < 800MB (Python). Test health checks return proper status codes. Verify CLI commands execute successfully in containers. Test multi-arch images on both amd64 and arm64. Scan images for vulnerabilities with severity threshold. Verify signed images with cosign verify.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Node.js Dockerfiles for Claude, Opencode, and Gemini CLIs",
            "description": "Build optimized Dockerfiles for Node.js-based CLIs using node:22-slim base image with proper dependency installation",
            "dependencies": [],
            "details": "Create Dockerfiles in infra/images/{claude,opencode,gemini}/Dockerfile. Use node:22-slim as base image. Install each CLI via npm or curl based on availability. Set up workspace directories at /workspace. Configure NODE_ENV=production. Add non-root user for security. Install essential system packages (ca-certificates, curl). Set up proper PATH and environment variables. Ensure proper file permissions and ownership.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Build Rust-based Dockerfile for Codex with Cargo Caching",
            "description": "Create optimized Dockerfile for Codex using rust:1.83-slim with cargo registry caching for faster rebuilds",
            "dependencies": [],
            "details": "Create infra/images/codex/Dockerfile using rust:1.83-slim base. Implement cargo caching layer with CARGO_HOME=/usr/local/cargo. Install Codex with 'cargo install @openai/codex'. Use cargo-chef for dependency caching optimization. Configure RUST_LOG environment variable. Set up cargo registry caching with --mount=type=cache. Add sccache for compilation caching. Create minimal runtime image with only necessary libraries.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Python Dockerfiles for Cursor and OpenHands CLIs",
            "description": "Build Python-based Docker images using python:3.12-slim with virtual environments and pip installations",
            "dependencies": [],
            "details": "Create Dockerfiles in infra/images/{cursor,openhands}/Dockerfile. Use python:3.12-slim as base. Create virtual environment at /opt/venv. Install CLIs with pip in isolated environments. Set PYTHONUNBUFFERED=1 for proper logging. Add requirements.txt for dependency management. Configure proper PYTHONPATH. Install build-essential for native dependencies. Set up pip caching with --mount=type=cache,target=/root/.cache/pip.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Multi-stage Builds for Size Optimization",
            "description": "Refactor all Dockerfiles to use multi-stage builds reducing final image sizes below target thresholds",
            "dependencies": [
              "8.1",
              "8.2",
              "8.3"
            ],
            "details": "Convert all Dockerfiles to multi-stage builds. Create builder stage for compilation/installation. Create minimal runtime stage with only necessary files. Copy only required binaries and dependencies. Remove build tools and temporary files. Optimize layer ordering for better caching. Use .dockerignore to exclude unnecessary files. Target sizes: Node.js < 500MB, Rust < 700MB, Python < 800MB. Use 'docker history' to analyze layer sizes.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add Health Check Scripts for CLI and MCP Connectivity",
            "description": "Implement health check scripts that verify CLI availability and MCP server connectivity for each container",
            "dependencies": [
              "8.1",
              "8.2",
              "8.3"
            ],
            "details": "Create health-check.sh scripts in each image directory. Implement CLI availability check with 'command -v {cli}' or version check. Add MCP connectivity test using curl/wget to MCP endpoint. Configure HEALTHCHECK instruction in Dockerfiles with proper intervals (30s) and timeouts (10s). Return proper exit codes (0 for healthy, 1 for unhealthy). Log health check results to stdout. Add retry logic for transient failures. Include memory and disk space checks.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Configure Entrypoint Scripts with Initialization Logic",
            "description": "Create entrypoint scripts that handle environment setup, configuration injection, and graceful startup for each CLI",
            "dependencies": [
              "8.5"
            ],
            "details": "Create entrypoint.sh scripts for each CLI. Handle environment variable expansion and validation. Create necessary directories and set permissions. Wait for dependent services (MCP server) to be ready. Configure signal handling for graceful shutdown. Support both interactive and daemon modes. Load configuration from mounted ConfigMaps. Initialize CLI-specific settings and preferences. Log startup sequence to help debugging.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Integrate Security Scanning with Trivy in CI Pipeline",
            "description": "Add Trivy vulnerability scanning to GitHub Actions workflow with configurable severity thresholds and reporting",
            "dependencies": [
              "8.4"
            ],
            "details": "Add Trivy action to .github/workflows/docker-build.yml. Configure severity threshold (HIGH, CRITICAL). Scan images before pushing to registry. Generate SARIF reports for GitHub Security tab. Set up ignore file for known false positives (.trivyignore). Configure exit codes for CI failure on vulnerabilities. Add daily scheduled scans for existing images. Create vulnerability database update job. Generate HTML reports as artifacts.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement SBOM Generation and Image Signing with Cosign",
            "description": "Set up Software Bill of Materials generation using Syft and implement image signing with Cosign for supply chain security",
            "dependencies": [
              "8.7"
            ],
            "details": "Install syft in CI pipeline for SBOM generation. Generate SBOM in SPDX and CycloneDX formats. Store SBOMs as OCI artifacts alongside images. Set up Cosign with GitHub OIDC for keyless signing. Sign all images after successful builds and scans. Attach SBOMs as attestations to signed images. Create verification policy for deployment. Document signature verification process. Store public keys in repository.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Set Up Matrix Builds for Multi-architecture Support",
            "description": "Configure Docker buildx matrix builds to support both linux/amd64 and linux/arm64 architectures",
            "dependencies": [
              "8.4",
              "8.6"
            ],
            "details": "Configure Docker buildx in GitHub Actions. Set up QEMU for cross-platform builds. Create build matrix for amd64 and arm64. Use buildx cache for faster builds. Push multi-arch manifests to registry. Test images on both architectures. Optimize architecture-specific dependencies. Configure platform-specific build args. Verify manifest lists with 'docker manifest inspect'. Document platform compatibility.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Authentication and Secret Management",
        "description": "Build secure credential handling for API keys, OAuth tokens, and session management across different CLI authentication patterns",
        "details": "Create controller/src/auth/manager.rs with AuthManager struct. Implement credential providers: KubernetesSecretProvider using k8s-openapi v0.23.0, VaultProvider for HashiCorp Vault integration, EnvironmentProvider for development. Build authentication strategies: ApiKeyAuth for usage-based billing (OpenAI, Anthropic), OAuthTokenAuth with PKCE flow for session-based auth, HeadlessAuth for CLI login flows. Implement secure storage using AES-256-GCM encryption at rest. Add automatic token refresh with 15-minute buffer before expiry. Create credential rotation scheduler with zero-downtime updates. Implement audit logging to separate security log with structured events. Build rate limiting per API key to prevent abuse. Add authentication cache to reduce provider API calls. Create fallback authentication chain for high availability.",
        "testStrategy": "Test each provider retrieves credentials correctly. Verify encryption/decryption with known test vectors. Test OAuth flow with mock authorization server. Verify token refresh happens before expiry. Test credential rotation doesn't cause downtime. Audit log contains all authentication events. Rate limiting prevents excessive API usage.",
        "priority": "high",
        "dependencies": [
          3,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AuthManager Core Structure",
            "description": "Build the foundational AuthManager struct with provider pattern architecture in controller/src/auth/manager.rs",
            "dependencies": [],
            "details": "Define AuthManager struct with provider registry, authentication strategy selector, and configuration loader. Create AuthProvider trait with methods: authenticate(), refresh_token(), validate_credentials(), get_credential_metadata(). Implement provider registration system with dynamic loading. Set up dependency injection for providers. Create AuthConfig struct for runtime configuration. Build provider factory pattern for instantiation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement KubernetesSecretProvider",
            "description": "Build Kubernetes secret provider using k8s-openapi v0.23.0 for native K8s secret management",
            "dependencies": [
              "9.1"
            ],
            "details": "Create KubernetesSecretProvider implementing AuthProvider trait. Use k8s-openapi to interface with Kubernetes API. Implement secret retrieval from specified namespaces. Add RBAC permission checks before accessing secrets. Build secret watching mechanism for real-time updates. Implement secret versioning support. Add connection pooling for K8s API client. Create retry logic with exponential backoff.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build VaultProvider for HashiCorp Vault",
            "description": "Create VaultProvider for HashiCorp Vault integration with AppRole authentication",
            "dependencies": [
              "9.1"
            ],
            "details": "Implement VaultProvider using vault-rs client library. Build AppRole authentication flow. Implement secret retrieval from KV v2 engine. Add dynamic secret generation support. Create lease renewal mechanism for Vault tokens. Implement secret versioning and rollback. Add Vault namespace support for multi-tenancy. Build connection health checks and failover.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create EnvironmentProvider for Development",
            "description": "Implement EnvironmentProvider for development and local testing scenarios",
            "dependencies": [
              "9.1"
            ],
            "details": "Build EnvironmentProvider reading from environment variables and .env files. Implement dotenv file parsing with override hierarchy. Add environment variable prefix support (e.g., CTO_AUTH_). Create secure variable masking in logs. Build validation for required environment variables. Implement hot-reload for development mode. Add support for encrypted .env files.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement ApiKeyAuth Strategy",
            "description": "Build API key authentication for usage-based billing providers like OpenAI and Anthropic",
            "dependencies": [
              "9.1"
            ],
            "details": "Create ApiKeyAuth struct implementing AuthStrategy trait. Build API key validation with provider-specific formats. Implement rate limiting per API key with sliding window. Add usage tracking for billing integration. Create API key rotation mechanism. Build header injection for HTTP requests. Implement API key masking in logs and errors. Add support for multiple API keys per provider.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Build OAuthTokenAuth with PKCE Flow",
            "description": "Implement OAuth 2.0 authentication with PKCE flow for session-based authentication",
            "dependencies": [
              "9.1"
            ],
            "details": "Implement OAuth 2.0 with PKCE (RFC 7636) using oauth2-rs library. Build authorization code flow with code verifier/challenge. Create secure state parameter generation. Implement redirect URI handling for CLI context. Build token exchange mechanism. Add refresh token support with secure storage. Implement scope management and validation. Create headless authentication fallback.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement AES-256-GCM Encryption Storage",
            "description": "Build secure storage system using AES-256-GCM encryption for credentials at rest",
            "dependencies": [
              "9.2",
              "9.3",
              "9.4"
            ],
            "details": "Implement AES-256-GCM encryption using ring or RustCrypto. Create key derivation using Argon2id for master keys. Build secure key storage with OS keychain integration. Implement nonce generation and management. Create encryption/decryption wrapper functions. Add integrity verification with HMAC. Build key rotation mechanism. Implement secure memory wiping for sensitive data.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Create Automatic Token Refresh Logic",
            "description": "Build token refresh system with 15-minute buffer before expiry",
            "dependencies": [
              "9.5",
              "9.6"
            ],
            "details": "Implement token expiry monitoring with background task. Create refresh scheduler using tokio::time intervals. Build 15-minute pre-expiry buffer calculation. Implement refresh token flow for OAuth. Add retry logic for failed refreshes. Create token cache with TTL management. Build refresh coordination for concurrent requests. Implement fallback to re-authentication on refresh failure.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Build Credential Rotation Scheduler",
            "description": "Implement zero-downtime credential rotation system with scheduled updates",
            "dependencies": [
              "9.7",
              "9.8"
            ],
            "details": "Create rotation scheduler using cron expressions. Implement dual-credential support for zero-downtime rotation. Build rotation orchestration across all providers. Add rotation event notifications. Create rollback mechanism for failed rotations. Implement gradual rotation with canary validation. Build rotation audit trail. Add emergency rotation triggers.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Implement Security Audit Logging",
            "description": "Create comprehensive audit logging system for all authentication events",
            "dependencies": [
              "9.5",
              "9.6",
              "9.9"
            ],
            "details": "Build structured audit logger with separate security log file. Implement audit event types: login, logout, token_refresh, credential_rotation, access_denied. Create tamper-proof log format with checksums. Add log shipping to SIEM systems. Implement PII redaction in logs. Build log retention policies. Create audit trail querying API. Add compliance reporting features.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Add Rate Limiting and Authentication Caching",
            "description": "Implement rate limiting per API key and authentication result caching",
            "dependencies": [
              "9.10"
            ],
            "details": "Build sliding window rate limiter using Redis or in-memory store. Implement per-key rate limits with configurable thresholds. Create authentication result cache with TTL. Build cache invalidation on credential changes. Implement distributed rate limiting for multi-instance deployments. Add rate limit headers to responses. Create bypass mechanism for admin operations. Build monitoring and alerting for rate limit violations.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Create Controller API and Monitoring Infrastructure",
        "description": "Implement REST API endpoints for CLI operations, migration tools, and comprehensive observability with Prometheus metrics and Grafana dashboards",
        "details": "Create controller/src/api/mod.rs with Axum v0.7.0 web framework. Implement REST endpoints: GET /agents/{name}/cli-options (available CLIs), POST /agents/{name}/migrate (initiate migration), GET /agents/{name}/cli-config (resolved configuration), POST /agents/{name}/validate (test configuration), GET /health (liveness probe), GET /ready (readiness probe). Add OpenAPI documentation with utoipa v5.2.0. Implement Prometheus metrics: cli_requests_total{cli_type,agent}, cli_response_time_seconds{cli_type,operation}, cli_errors_total{cli_type,error_type}, cli_tokens_used{cli_type,model}, cli_active_sessions{cli_type}. Create Grafana dashboards for CLI comparison, cost analysis, and performance monitoring. Add distributed tracing with OpenTelemetry and Jaeger. Implement structured logging with tracing-subscriber v0.3.0. Build alerting rules for SLO violations. Create runbooks linked to alerts.",
        "testStrategy": "API endpoints return correct status codes and responses. OpenAPI spec validates against implementation. Prometheus metrics increment correctly for operations. Grafana dashboards render without errors. Traces connect across service boundaries. Alerts fire for simulated failures. Load test API handles 1000 req/s.",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Axum web framework and basic server structure",
            "description": "Initialize Axum v0.7.0 server with tokio runtime, configure basic middleware, and create modular routing structure",
            "dependencies": [],
            "details": "Create controller/src/api/mod.rs with Axum application setup. Configure tower middleware stack including cors, compression, and request tracing. Set up Router with modular route registration. Configure server to listen on port 8080 with graceful shutdown handling. Add basic error handling middleware with custom error types. Set up shared application state with Arc<AppState> for dependency injection.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement core REST endpoints for agent operations",
            "description": "Create REST endpoints for CLI options, configuration retrieval, and validation",
            "dependencies": [
              "10.1"
            ],
            "details": "Implement GET /agents/{name}/cli-options endpoint returning available CLI types and capabilities. Create GET /agents/{name}/cli-config endpoint for resolved configuration with template variables expanded. Build POST /agents/{name}/validate endpoint to test configuration against schema. Add proper request/response serialization with serde. Implement path parameter extraction and validation. Add authorization middleware with Bearer token support.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build migration endpoint with state management",
            "description": "Implement POST /agents/{name}/migrate endpoint with proper state tracking and rollback capabilities",
            "dependencies": [
              "10.1",
              "10.2"
            ],
            "details": "Create POST /agents/{name}/migrate endpoint accepting migration request payload. Implement migration state machine with states: pending, in-progress, completed, failed. Add rollback mechanism storing previous configuration. Build async migration job processor using tokio tasks. Implement progress tracking with SSE or WebSocket updates. Create migration history storage with timestamp and status tracking.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add health and readiness probe endpoints",
            "description": "Implement Kubernetes-compatible health check endpoints with dependency verification",
            "dependencies": [
              "10.1"
            ],
            "details": "Create GET /health endpoint for liveness probe returning 200 OK when service is running. Implement GET /ready endpoint checking database connectivity, MCP server availability, and cache status. Add configurable health check thresholds and timeouts. Implement circuit breaker pattern for dependency checks. Return detailed health status in JSON format with component breakdown. Add startup probe endpoint for initial readiness.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Integrate OpenAPI documentation with utoipa",
            "description": "Generate comprehensive OpenAPI/Swagger documentation for all API endpoints",
            "dependencies": [
              "10.2",
              "10.3",
              "10.4"
            ],
            "details": "Add utoipa v5.2.0 and utoipa-swagger-ui dependencies. Annotate all endpoints with #[utoipa::path] macros including request/response schemas. Generate OpenAPI spec with proper tags, descriptions, and examples. Serve Swagger UI at /swagger-ui endpoint. Add response schema validation with examples. Include authentication requirements in OpenAPI spec. Generate TypeScript client from OpenAPI spec.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Prometheus metrics collection",
            "description": "Set up comprehensive metrics for CLI operations, performance, and error tracking",
            "dependencies": [
              "10.2",
              "10.3"
            ],
            "details": "Add prometheus and prometheus-hyper crates. Create metrics registry with cli_requests_total counter labeled by cli_type and agent. Implement cli_response_time_seconds histogram for latency tracking. Add cli_errors_total counter with error_type labels. Track cli_tokens_used gauge for cost monitoring. Create cli_active_sessions gauge for concurrent usage. Expose metrics at /metrics endpoint with proper formatting.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create Grafana dashboards and visualization",
            "description": "Build comprehensive Grafana dashboards for CLI comparison, cost analysis, and performance monitoring",
            "dependencies": [
              "10.6"
            ],
            "details": "Create CLI comparison dashboard showing request rates, latency percentiles, and error rates across CLI types. Build cost analysis dashboard with token usage, estimated costs, and budget tracking. Implement performance dashboard with p50/p95/p99 latencies and throughput metrics. Add agent-level dashboard showing individual agent health and resource usage. Create dashboard templates as JSON for version control. Configure variable dropdowns for filtering by CLI type and time range.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Set up distributed tracing with OpenTelemetry",
            "description": "Implement request tracing across service boundaries with Jaeger integration",
            "dependencies": [
              "10.1",
              "10.2"
            ],
            "details": "Add opentelemetry, opentelemetry-jaeger, and tracing-opentelemetry crates. Configure OTLP exporter to send traces to Jaeger collector. Instrument all HTTP endpoints with span creation and context propagation. Add custom span attributes for CLI type, operation, and agent name. Implement trace sampling with configurable rate (default 10%). Create parent-child span relationships for async operations. Add baggage propagation for cross-service metadata.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Configure structured logging and alerting",
            "description": "Implement structured logging with tracing-subscriber and create alerting rules with runbooks",
            "dependencies": [
              "10.8"
            ],
            "details": "Configure tracing-subscriber v0.3.0 with JSON formatting for production. Set up log levels per module with RUST_LOG environment variable. Add contextual fields to logs including trace_id, span_id, and request metadata. Create Prometheus alerting rules for SLO violations (error rate > 1%, p99 latency > 2s). Write runbooks in Markdown format linked to each alert. Configure PagerDuty or Slack webhook integration for alert notifications. Implement log aggregation with Vector or Fluentd.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Build load testing harness and performance validation",
            "description": "Create comprehensive load testing suite to validate API performance and identify bottlenecks",
            "dependencies": [
              "10.2",
              "10.3",
              "10.6",
              "10.7"
            ],
            "details": "Create load testing scenarios using k6 or Gatling targeting all API endpoints. Implement ramp-up pattern testing from 10 to 1000 concurrent users. Add spike testing to validate behavior under sudden load. Create soak testing for memory leak detection over 24 hours. Generate performance reports with latency distributions and error rates. Validate metrics accuracy by comparing load test results with Prometheus. Set up CI pipeline integration for automated performance regression testing.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement Migration Tools and Rollout Strategy",
        "description": "Build automated migration utilities for transitioning agents between CLIs with validation, rollback capabilities, and gradual rollout controls",
        "details": "Create controller/src/migration/mod.rs with migration orchestrator. Build configuration converters: CLAUDE.md to AGENTS.md translator, JSON to TOML converter for Codex, prompt adaptation for model differences. Implement migration validator checking configuration compatibility, tool availability, and model support. Create rollout controller with percentage-based traffic splitting using Istio/Envoy. Build A/B testing framework comparing response quality, latency, and cost. Implement automatic rollback triggers on error rate > 5%, latency > 2x baseline, or cost > 1.5x threshold. Create shadow mode running new CLI in parallel without user impact. Build migration state machine with stages: Planning, Testing, Canary (10%), Rollout (25%, 50%), Complete. Add migration metrics dashboard showing progress and issues. Create dry-run mode for risk-free testing.",
        "testStrategy": "Configuration converters produce valid output formats. Migration validator catches incompatibilities. Traffic splitting routes correct percentage. A/B tests measure differences accurately. Rollback triggers activate on threshold breach. Shadow mode doesn't affect production. State machine transitions correctly. Dry-run doesn't modify any state.",
        "priority": "medium",
        "dependencies": [
          7,
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Migration Orchestrator Core Module",
            "description": "Build the foundation migration orchestrator in controller/src/migration/mod.rs with state machine implementation",
            "dependencies": [],
            "details": "Create MigrationOrchestrator struct with state management using enum MigrationState (Planning, Testing, Canary, Rollout25, Rollout50, Complete, RolledBack). Implement state transition logic with validation rules. Add configuration for migration parameters including thresholds, timeouts, and retry policies. Create migration context to track source/target CLI, configuration mappings, and progress metrics. Implement async execution with tokio for non-blocking operations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement CLAUDE.md to AGENTS.md Translator",
            "description": "Build configuration converter to translate Claude's CLAUDE.md format to Codex's AGENTS.md format with syntax adaptation",
            "dependencies": [
              "11.1"
            ],
            "details": "Create MarkdownTranslator trait with convert_memory_file() method. Parse CLAUDE.md using markdown parser to extract directives, tools, and instructions. Map Claude-specific syntax (@./.taskmaster/CLAUDE.md imports) to Codex equivalents. Handle tool permission formats (allowedTools vs sandbox_preset mappings). Convert instruction blocks preserving semantic meaning. Generate valid AGENTS.md with proper TOML frontmatter. Add validation to ensure no information loss during translation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build JSON to TOML Configuration Converter",
            "description": "Create converter for transforming JSON configurations to TOML format required by Codex and other CLIs",
            "dependencies": [
              "11.1"
            ],
            "details": "Implement ConfigConverter with to_toml() and from_json() methods using serde_json and toml crates. Handle nested structures with proper TOML table syntax. Map JSON arrays to TOML arrays preserving order. Convert camelCase to snake_case following TOML conventions. Handle special types like dates, booleans, and null values. Add pretty-printing for readable TOML output. Implement reverse conversion for bidirectional support.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Prompt Adaptation Layer",
            "description": "Implement prompt transformer to adapt prompts between different model providers and their specific requirements",
            "dependencies": [
              "11.1"
            ],
            "details": "Build PromptAdapter with adapt_prompt() method for each CLI type. Handle Claude's constitutional AI prompt structure vs OpenAI's system/user format. Adapt token limits (Claude 200k vs GPT-4 128k vs Gemini 2M). Transform special tokens and formatting (@-mentions, markdown blocks). Handle model-specific features (Claude's artifacts, GPT's functions, Gemini's grounding). Add context window management with smart truncation. Preserve semantic intent across transformations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Migration Validator",
            "description": "Build comprehensive validator to check compatibility between source and target CLI configurations before migration",
            "dependencies": [
              "11.2",
              "11.3",
              "11.4"
            ],
            "details": "Create MigrationValidator with validate_compatibility() returning ValidationResult. Check tool availability mapping between CLIs (Edit, Bash, WebSearch equivalents). Verify model support and fallback options. Validate authentication methods compatibility (API keys vs OAuth). Check configuration schema compliance using JSONSchema. Verify file path conventions and workspace access. Test memory file format compatibility. Generate detailed validation report with warnings and errors.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Build Traffic Splitting with Istio Integration",
            "description": "Implement percentage-based traffic routing using Istio VirtualService and DestinationRule for gradual rollout",
            "dependencies": [
              "11.1"
            ],
            "details": "Create TrafficController interfacing with Istio via k8s-openapi. Generate VirtualService with weighted routing (10%, 25%, 50%, 100%). Configure DestinationRule with subsets for old/new CLI versions. Implement dynamic weight updates without downtime. Add circuit breaker configuration for fault tolerance. Configure retry policies and timeouts per subset. Monitor traffic distribution metrics via Envoy stats. Create rollback mechanism updating weights to 100% old version.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create A/B Testing Framework",
            "description": "Build framework to compare response quality, latency, and cost between old and new CLI implementations",
            "dependencies": [
              "11.6"
            ],
            "details": "Implement ABTestRunner with parallel execution capability. Create ResponseComparator using similarity scoring (cosine similarity for embeddings). Measure latency percentiles (p50, p95, p99) for both versions. Track token usage and calculate cost differences. Implement quality metrics: task completion rate, error frequency, user satisfaction proxy. Store results in time-series database (Prometheus). Generate statistical significance tests (t-test, chi-square). Create comparison dashboard with Grafana.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement Automatic Rollback Triggers",
            "description": "Build monitoring and automatic rollback system triggered by error rates, latency, or cost thresholds",
            "dependencies": [
              "11.6",
              "11.7"
            ],
            "details": "Create RollbackController with threshold monitoring. Implement error rate trigger (>5% 5xx errors in 5-minute window). Add latency trigger (p95 > 2x baseline for 3 minutes). Build cost trigger (rolling hour cost > 1.5x threshold). Create composite health score combining all metrics. Implement graceful rollback updating traffic weights gradually. Add manual override capability with reason logging. Send alerts via webhook/email on trigger activation. Store rollback events in audit log.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Build Shadow Mode Execution",
            "description": "Implement parallel execution mode where new CLI runs alongside production without affecting users",
            "dependencies": [
              "11.7"
            ],
            "details": "Create ShadowExecutor running requests in parallel threads. Implement request duplication preserving headers and context. Route shadow responses to metrics collection only. Add sampling configuration (1%, 10%, 100% of traffic). Implement timeout handling preventing shadow delays affecting production. Store shadow results in separate database for analysis. Compare shadow vs production responses offline. Generate shadow mode performance reports. Add feature flag for instant enable/disable.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Create Migration State Machine",
            "description": "Implement state machine managing staged rollout with Planning, Testing, Canary, and Complete phases",
            "dependencies": [
              "11.5",
              "11.8"
            ],
            "details": "Build StateMachine with state transitions and guards. Implement Planning state running validation and generating migration plan. Create Testing state executing integration tests and shadow mode. Build Canary state (10% traffic) with duration and success criteria. Implement progressive Rollout states (25%, 50%, 100%). Add automatic progression based on health metrics. Create manual approval gates for critical transitions. Implement state persistence for crash recovery. Add state history with timestamp and trigger tracking.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Build Migration Metrics Dashboard",
            "description": "Create comprehensive dashboard showing migration progress, health metrics, and issue tracking",
            "dependencies": [
              "11.7",
              "11.9",
              "11.10"
            ],
            "details": "Implement MetricsDashboard using Grafana with Prometheus datasource. Create migration progress panel showing current state and completion percentage. Add traffic distribution chart with real-time weight updates. Build error rate comparison between old/new versions. Display latency percentile graphs with baseline overlay. Show cost tracking with projection and alerts. Add A/B test results with confidence intervals. Create rollback history timeline. Implement issue tracker integration showing related problems.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "Implement Dry-Run Mode",
            "description": "Create risk-free testing mode simulating migration without making actual changes",
            "dependencies": [
              "11.10",
              "11.11"
            ],
            "details": "Build DryRunExecutor with simulation capabilities. Mock traffic splitting without Istio changes. Simulate state transitions logging planned actions. Generate migration preview report with expected outcomes. Test configuration converters without writing files. Validate all prerequisites and dependencies. Simulate rollback scenarios with injected failures. Calculate estimated migration duration and resource usage. Generate dry-run summary with risk assessment and recommendations.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 12,
        "title": "Production Hardening and Performance Optimization",
        "description": "Implement reliability patterns, performance optimizations, security hardening, and operational excellence features for production deployment",
        "details": "Implement circuit breakers using tower-rs v0.5.0 with failure threshold 50% over 10 requests. Add request hedging for critical operations with 95th percentile trigger. Build connection pooling with bb8 v0.8.0 for database connections. Implement lazy loading for CLI components reducing startup time by 60%. Add request coalescing for duplicate requests within 100ms window. Create adaptive timeout adjustment based on historical latency. Implement graceful degradation falling back to simpler models on overload. Add cost optimization selecting cheapest capable model for task. Build security scanning with OWASP dependency check, Snyk for vulnerabilities, and Semgrep for code patterns. Implement zero-trust networking with mTLS between services. Add compliance logging for SOC2 and GDPR requirements. Create chaos engineering tests with Litmus framework. Build SLO monitoring with 99.9% availability target.",
        "testStrategy": "Circuit breakers open after threshold failures. Request hedging reduces p99 latency by 30%. Connection pools handle connection failures gracefully. Lazy loading reduces startup time below 5 seconds. Security scans find no critical vulnerabilities. Chaos tests don't cause data loss. SLOs maintained under load testing with 10x normal traffic.",
        "priority": "high",
        "dependencies": [
          10,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Circuit Breaker Pattern with Tower-rs",
            "description": "Create circuit breaker implementation using tower-rs v0.5.0 with configurable failure thresholds and recovery mechanisms",
            "dependencies": [],
            "details": "Build CircuitBreakerService in controller/src/reliability/circuit_breaker.rs using tower-rs middleware. Configure failure threshold at 50% over 10 requests with exponential backoff. Implement half-open state logic for recovery testing. Add metrics collection for breaker state transitions. Create per-endpoint configuration support. Implement manual reset and force-open capabilities for testing.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Build Request Hedging for Critical Operations",
            "description": "Implement request hedging mechanism that triggers backup requests at 95th percentile latency for critical API calls",
            "dependencies": [],
            "details": "Create HedgingService in controller/src/reliability/hedging.rs. Track request latency percentiles using HDRHistogram. Implement backup request triggering at p95 threshold. Add configurable hedging strategies per operation type. Build request deduplication to handle multiple responses. Create metrics for hedged request success rates.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Connection Pool Management with bb8",
            "description": "Implement database connection pooling using bb8 v0.8.0 with automatic health checks and connection recycling",
            "dependencies": [],
            "details": "Build ConnectionPoolManager in controller/src/database/pool.rs using bb8. Configure pool sizes based on workload patterns. Implement connection health checks and automatic recycling. Add connection timeout and retry logic. Create metrics for pool utilization and wait times. Build dynamic pool sizing based on load.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Lazy Loading for CLI Components",
            "description": "Build lazy loading system for CLI components to reduce startup time by 60% through deferred initialization",
            "dependencies": [],
            "details": "Create LazyLoader trait in controller/src/performance/lazy.rs. Implement component registry with on-demand loading. Build dependency graph for component initialization order. Add preloading hints for frequently used components. Create startup profiling to identify bottlenecks. Implement parallel initialization where possible.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Build Request Coalescing Mechanism",
            "description": "Create request coalescing system that deduplicates identical requests within 100ms time window",
            "dependencies": [],
            "details": "Implement RequestCoalescer in controller/src/performance/coalescing.rs. Build request signature generation for deduplication. Create time-windowed request cache with 100ms TTL. Implement response broadcasting to waiting requests. Add metrics for coalescing effectiveness. Build bypass mechanism for non-idempotent operations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create Adaptive Timeout Adjustment System",
            "description": "Implement dynamic timeout adjustment based on historical latency patterns and service health indicators",
            "dependencies": [
              "12.2"
            ],
            "details": "Build AdaptiveTimeout in controller/src/reliability/timeout.rs. Track historical latency using exponential moving average. Implement timeout calculation based on percentile targets. Add service health awareness for timeout adjustment. Create override mechanisms for critical operations. Build timeout budget management for chained calls.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement Graceful Degradation Patterns",
            "description": "Build graceful degradation system that falls back to simpler models and reduced functionality during overload",
            "dependencies": [
              "12.1"
            ],
            "details": "Create DegradationController in controller/src/reliability/degradation.rs. Implement load detection using system metrics. Build fallback chain from complex to simple models. Create feature flags for degradable functionality. Add user notification for degraded service. Implement automatic recovery when load normalizes.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Build Cost Optimization with Model Selection",
            "description": "Create intelligent model selection system that chooses the cheapest capable model for each task",
            "dependencies": [],
            "details": "Implement CostOptimizer in controller/src/optimization/cost.rs. Build model capability matrix for task requirements. Create cost calculator with pricing data for all providers. Implement model selection algorithm balancing cost and quality. Add budget tracking and alerting. Build historical analysis for optimization recommendations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Integrate Security Scanning Tools",
            "description": "Set up comprehensive security scanning with OWASP dependency check, Snyk vulnerability scanning, and Semgrep code analysis",
            "dependencies": [],
            "details": "Configure OWASP dependency check in CI pipeline. Integrate Snyk for container and dependency scanning. Set up Semgrep with custom rules for code patterns. Create vulnerability reporting dashboard. Implement automatic PR creation for fixes. Build security scorecard tracking.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Implement mTLS for Zero-Trust Networking",
            "description": "Build mutual TLS authentication between all services for zero-trust security model",
            "dependencies": [],
            "details": "Create CertificateManager in controller/src/security/mtls.rs. Implement certificate generation and rotation using cert-manager. Build service mesh integration with Istio for mTLS enforcement. Create certificate validation and revocation checking. Add audit logging for all TLS connections. Implement certificate pinning for critical services.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Add Compliance Logging for SOC2/GDPR",
            "description": "Implement comprehensive audit logging system meeting SOC2 and GDPR compliance requirements",
            "dependencies": [],
            "details": "Build ComplianceLogger in controller/src/compliance/audit.rs. Implement structured logging with required fields for SOC2. Add PII detection and masking for GDPR compliance. Create log retention policies with automatic archival. Build audit trail reconstruction capabilities. Implement log integrity verification with checksums.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "Create Chaos Engineering Tests with Litmus",
            "description": "Build chaos engineering test suite using Litmus framework for resilience validation",
            "dependencies": [
              "12.1",
              "12.2",
              "12.3",
              "12.7"
            ],
            "details": "Set up Litmus ChaosCenter in testing environment. Create chaos experiments for network latency, pod failures, and CPU stress. Build automated chaos test execution in staging. Implement steady-state hypothesis validation. Create chaos test reporting and analysis. Build automatic rollback on critical failures.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 13,
            "title": "Build SLO Monitoring and Reporting",
            "description": "Implement Service Level Objective monitoring with 99.9% availability target and automated reporting",
            "dependencies": [
              "12.1",
              "12.2",
              "12.6"
            ],
            "details": "Create SLOMonitor in controller/src/observability/slo.rs. Define SLIs for availability, latency, and error rates. Implement error budget tracking and alerting. Build SLO dashboards with burn rate visualization. Create automated SLO reports for stakeholders. Implement SLO-based alerting with PagerDuty integration.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-24T19:27:08.605Z",
      "updated": "2025-09-24T19:27:08.605Z",
      "description": "Tasks for master context"
    }
  }
}