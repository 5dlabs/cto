# Task ID: 10
# Title: Create Controller API and Monitoring Infrastructure
# Status: pending
# Dependencies: 7, 9
# Priority: medium
# Description: Implement REST API endpoints for CLI operations, migration tools, and comprehensive observability with Prometheus metrics and Grafana dashboards
# Details:
Create controller/src/api/mod.rs with Axum v0.7.0 web framework. Implement REST endpoints: GET /agents/{name}/cli-options (available CLIs), POST /agents/{name}/migrate (initiate migration), GET /agents/{name}/cli-config (resolved configuration), POST /agents/{name}/validate (test configuration), GET /health (liveness probe), GET /ready (readiness probe). Add OpenAPI documentation with utoipa v5.2.0. Implement Prometheus metrics: cli_requests_total{cli_type,agent}, cli_response_time_seconds{cli_type,operation}, cli_errors_total{cli_type,error_type}, cli_tokens_used{cli_type,model}, cli_active_sessions{cli_type}. Create Grafana dashboards for CLI comparison, cost analysis, and performance monitoring. Add distributed tracing with OpenTelemetry and Jaeger. Implement structured logging with tracing-subscriber v0.3.0. Build alerting rules for SLO violations. Create runbooks linked to alerts.

# Test Strategy:
API endpoints return correct status codes and responses. OpenAPI spec validates against implementation. Prometheus metrics increment correctly for operations. Grafana dashboards render without errors. Traces connect across service boundaries. Alerts fire for simulated failures. Load test API handles 1000 req/s.

# Subtasks:
## 1. Set up Axum web framework and basic server structure [pending]
### Dependencies: None
### Description: Initialize Axum v0.7.0 server with tokio runtime, configure basic middleware, and create modular routing structure
### Details:
Create controller/src/api/mod.rs with Axum application setup. Configure tower middleware stack including cors, compression, and request tracing. Set up Router with modular route registration. Configure server to listen on port 8080 with graceful shutdown handling. Add basic error handling middleware with custom error types. Set up shared application state with Arc<AppState> for dependency injection.

## 2. Implement core REST endpoints for agent operations [pending]
### Dependencies: 10.1
### Description: Create REST endpoints for CLI options, configuration retrieval, and validation
### Details:
Implement GET /agents/{name}/cli-options endpoint returning available CLI types and capabilities. Create GET /agents/{name}/cli-config endpoint for resolved configuration with template variables expanded. Build POST /agents/{name}/validate endpoint to test configuration against schema. Add proper request/response serialization with serde. Implement path parameter extraction and validation. Add authorization middleware with Bearer token support.

## 3. Build migration endpoint with state management [pending]
### Dependencies: 10.1, 10.2
### Description: Implement POST /agents/{name}/migrate endpoint with proper state tracking and rollback capabilities
### Details:
Create POST /agents/{name}/migrate endpoint accepting migration request payload. Implement migration state machine with states: pending, in-progress, completed, failed. Add rollback mechanism storing previous configuration. Build async migration job processor using tokio tasks. Implement progress tracking with SSE or WebSocket updates. Create migration history storage with timestamp and status tracking.

## 4. Add health and readiness probe endpoints [pending]
### Dependencies: 10.1
### Description: Implement Kubernetes-compatible health check endpoints with dependency verification
### Details:
Create GET /health endpoint for liveness probe returning 200 OK when service is running. Implement GET /ready endpoint checking database connectivity, MCP server availability, and cache status. Add configurable health check thresholds and timeouts. Implement circuit breaker pattern for dependency checks. Return detailed health status in JSON format with component breakdown. Add startup probe endpoint for initial readiness.

## 5. Integrate OpenAPI documentation with utoipa [pending]
### Dependencies: 10.2, 10.3, 10.4
### Description: Generate comprehensive OpenAPI/Swagger documentation for all API endpoints
### Details:
Add utoipa v5.2.0 and utoipa-swagger-ui dependencies. Annotate all endpoints with #[utoipa::path] macros including request/response schemas. Generate OpenAPI spec with proper tags, descriptions, and examples. Serve Swagger UI at /swagger-ui endpoint. Add response schema validation with examples. Include authentication requirements in OpenAPI spec. Generate TypeScript client from OpenAPI spec.

## 6. Implement Prometheus metrics collection [pending]
### Dependencies: 10.2, 10.3
### Description: Set up comprehensive metrics for CLI operations, performance, and error tracking
### Details:
Add prometheus and prometheus-hyper crates. Create metrics registry with cli_requests_total counter labeled by cli_type and agent. Implement cli_response_time_seconds histogram for latency tracking. Add cli_errors_total counter with error_type labels. Track cli_tokens_used gauge for cost monitoring. Create cli_active_sessions gauge for concurrent usage. Expose metrics at /metrics endpoint with proper formatting.

## 7. Create Grafana dashboards and visualization [pending]
### Dependencies: 10.6
### Description: Build comprehensive Grafana dashboards for CLI comparison, cost analysis, and performance monitoring
### Details:
Create CLI comparison dashboard showing request rates, latency percentiles, and error rates across CLI types. Build cost analysis dashboard with token usage, estimated costs, and budget tracking. Implement performance dashboard with p50/p95/p99 latencies and throughput metrics. Add agent-level dashboard showing individual agent health and resource usage. Create dashboard templates as JSON for version control. Configure variable dropdowns for filtering by CLI type and time range.

## 8. Set up distributed tracing with OpenTelemetry [pending]
### Dependencies: 10.1, 10.2
### Description: Implement request tracing across service boundaries with Jaeger integration
### Details:
Add opentelemetry, opentelemetry-jaeger, and tracing-opentelemetry crates. Configure OTLP exporter to send traces to Jaeger collector. Instrument all HTTP endpoints with span creation and context propagation. Add custom span attributes for CLI type, operation, and agent name. Implement trace sampling with configurable rate (default 10%). Create parent-child span relationships for async operations. Add baggage propagation for cross-service metadata.

## 9. Configure structured logging and alerting [pending]
### Dependencies: 10.8
### Description: Implement structured logging with tracing-subscriber and create alerting rules with runbooks
### Details:
Configure tracing-subscriber v0.3.0 with JSON formatting for production. Set up log levels per module with RUST_LOG environment variable. Add contextual fields to logs including trace_id, span_id, and request metadata. Create Prometheus alerting rules for SLO violations (error rate > 1%, p99 latency > 2s). Write runbooks in Markdown format linked to each alert. Configure PagerDuty or Slack webhook integration for alert notifications. Implement log aggregation with Vector or Fluentd.

## 10. Build load testing harness and performance validation [pending]
### Dependencies: 10.2, 10.3, 10.6, 10.7
### Description: Create comprehensive load testing suite to validate API performance and identify bottlenecks
### Details:
Create load testing scenarios using k6 or Gatling targeting all API endpoints. Implement ramp-up pattern testing from 10 to 1000 concurrent users. Add spike testing to validate behavior under sudden load. Create soak testing for memory leak detection over 24 hours. Generate performance reports with latency distributions and error rates. Validate metrics accuracy by comparing load test results with Prometheus. Set up CI pipeline integration for automated performance regression testing.

