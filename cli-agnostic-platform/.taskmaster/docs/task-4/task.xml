<prompt>
    <role>You are a senior configuration management engineer with expertise in multi-source configuration merging, distributed caching systems, JSON Schema validation, and enterprise software configuration patterns with experience in Kubernetes, Redis, and audit compliance.</role>
    <task>
        <id>4</id>
        <title>Implement Configuration Resolution Engine</title>
        <description>Build the multi-source configuration merger that handles Helm defaults, cto-config.json overrides, and runtime parameters with field-level granularity. This system provides intelligent configuration resolution enabling agents to have cluster-wide defaults while supporting repository-specific customizations. The system must handle complex merge scenarios with clear precedence rules, comprehensive validation, high-performance caching, and complete audit trails for compliance.</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies>1,3</dependencies>
    </task>
    <technical_specifications>
        <spec>Create controller/src/agents/resolver.rs with AgentResolver managing multi-source configuration loading</spec>
        <spec>Implement configuration loaders: HelmConfigLoader (Kubernetes ConfigMaps), CtoConfigLoader (repository cto-config.json), EnvironmentLoader, RuntimeLoader</spec>
        <spec>Build MergeEngine with strategies: Replace, Merge, Append, DeepMerge with configurable field-level merge rules</spec>
        <spec>Implement precedence hierarchy: Runtime > Environment > CtoConfig > Helm > Built-in Defaults</spec>
        <spec>Add JSON Schema validation using jsonschema-rs v0.20.0 with detailed error messages and suggestions</spec>
        <spec>Create Redis-based configuration cache using redis-rs v0.27.0 with 5-minute TTL and compression</spec>
        <spec>Build configuration preview API showing changes and impact assessment before application</spec>
        <spec>Implement comprehensive audit logging with correlation IDs tracking all configuration decisions</spec>
        <spec>Add field-level merge control with conflict detection and resolution strategies</spec>
        <spec>Support backward compatibility for agents without CLI specifications</spec>
    </technical_specifications>
    <implementation_details>
        Create controller/src/agents/resolver.rs with AgentResolver struct. Implement configuration loading from multiple sources: Helm values via ConfigMap (agent.agentCliConfigs), repository cto-config.json via Git clone, environment variables, and runtime parameters. Build MergeStrategy enum with Replace, Merge, Append, and DeepMerge options per field. Implement field-level merge rules using serde_json::Value manipulation. Add JSONSchema validation using jsonschema-rs v0.20.0 for configuration validation. Create precedence rules: Runtime > Environment > CtoConfig > Helm. Implement configuration caching with Redis using redis-rs v0.27.0 with 5-minute TTL. Add configuration preview API that shows resolved config without applying. Build audit trail logging all configuration changes with who/what/when/why. Handle backwards compatibility for agents without CLI specifications.
    </implementation_details>
    <acceptance_criteria>
        <criterion>Multi-source configuration loading from Helm ConfigMaps, repository cto-config.json, environment variables, and runtime parameters</criterion>
        <criterion>Intelligent merge strategies with field-level control: Replace, Merge, Append, DeepMerge with conflict resolution</criterion>
        <criterion>Clear precedence rules applied correctly: Runtime > Environment > CtoConfig > Helm > Defaults</criterion>
        <criterion>JSON Schema validation with detailed error messages and helpful suggestions for common mistakes</criterion>
        <criterion>Redis caching with compression achieving >85% hit ratio and <200ms configuration resolution time</criterion>
        <criterion>Configuration preview API shows changes, diffs, and impact assessment before application</criterion>
        <criterion>Comprehensive audit trail logs all configuration decisions with correlation IDs and actor tracking</criterion>
        <criterion>Performance requirements met: <200ms resolution time, support 100+ concurrent operations</criterion>
        <criterion>Backward compatibility maintained for existing agents without CLI specifications</criterion>
        <criterion>Error handling provides actionable messages with suggestions for configuration fixes</criterion>
    </acceptance_criteria>
    <test_strategy>
        Test merge strategies with conflicting configurations. Verify precedence rules with multiple override sources. Test deep merge with nested JSON structures. Validate schema enforcement rejects invalid configs. Test cache invalidation on configuration changes. Verify audit trail captures all modifications. Load test with 100+ agents with different configurations. Test preview API shows accurate change diffs. Test error scenarios with missing or malformed configurations. Validate backward compatibility with existing agent configurations.
    </test_strategy>
    <instructions>
        Think step-by-step about the implementation approach. This is a critical system that must handle complex configuration scenarios reliably and efficiently.
        Start by designing the AgentResolver architecture with clear separation of concerns for each configuration source. Consider the challenges of merging JSON objects from different sources with conflicting values.
        Focus on the merge engine implementation - this must handle nested objects, arrays, and primitive values with configurable strategies. The deep merge algorithm should be recursive and handle edge cases like null values and type mismatches.
        The caching layer is critical for performance - use Redis with compression and implement proper TTL management. Consider cache warming strategies for frequently accessed configurations.
        Audit logging is essential for compliance - ensure every configuration decision is tracked with sufficient context for debugging and audit trails.
        Provide complete, production-ready code with comprehensive error handling, performance optimization, and security considerations. Include proper async/await patterns, connection pooling, and resource cleanup.
        Where appropriate, use MCP tools (filesystem, git, web search) to research configuration management patterns, Redis optimization strategies, and JSON Schema validation best practices to ensure optimal implementation.
    </instructions>
</prompt>