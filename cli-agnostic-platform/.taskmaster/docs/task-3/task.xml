<prompt>
    <role>You are a senior Rust architect specializing in trait-based system design, async programming, multi-provider abstraction layers, and high-performance concurrent systems with expertise in OpenTelemetry observability.</role>
    <task>
        <id>3</id>
        <title>Design and Implement CLI Adapter Trait System</title>
        <description>Create the core abstraction layer with CliAdapter trait and base implementations for unified CLI interaction patterns. This establishes the foundational interface that all CLI providers will implement, enabling consistent behavior across 8 different CLI tools (Claude, Codex, Opencode, Gemini, Grok, Qwen, Cursor, OpenHands) while handling their unique requirements like different configuration formats (JSON, TOML, JSONC), memory strategies (CLAUDE.md, AGENTS.md, GEMINI.md, subdirectory patterns), and authentication methods.</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies>1,2</dependencies>
    </task>
    <technical_specifications>
        <spec>Design CliAdapter trait with async methods: validate_model, generate_config, format_prompt, parse_response, initialize, cleanup, health_check</spec>
        <spec>Create comprehensive type system: CLIType enum (8 types), ParsedResponse, CliCapabilities, MemoryStrategy, ConfigFormat</spec>
        <spec>Implement BaseAdapter with shared functionality: logging, metrics, template rendering, configuration validation</spec>
        <spec>Build AdapterFactory with registration system, health monitoring, and thread-safe adapter creation</spec>
        <spec>Create ClaudeAdapter reference implementation maintaining exact backward compatibility</spec>
        <spec>Integrate OpenTelemetry for distributed tracing, metrics collection, and structured logging</spec>
        <spec>Support diverse CLI characteristics: TOML config (Codex), JSON config (Claude/Gemini), TypeScript (Opencode), Python (Cursor/OpenHands)</spec>
        <spec>Implement lifecycle hooks for pre/post execution, error handling, and resource cleanup</spec>
        <spec>Add template rendering system using Handlebars for configuration generation</spec>
        <spec>Ensure thread safety with Send + Sync traits and Arc/RwLock for shared state</spec>
    </technical_specifications>
    <implementation_details>
        Create controller/src/cli/adapter.rs with the CliAdapter trait defining core methods: async fn validate_model(&self, model: &str) -> Result<bool>, async fn generate_config(&self, agent_config: &AgentConfig) -> Result<String>, fn format_prompt(&self, prompt: &str) -> String, async fn parse_response(&self, response: &str) -> Result<ParsedResponse>, fn get_memory_filename(&self) -> &str, fn get_executable_name(&self) -> &str, async fn initialize(&self, container: &Container) -> Result<()>. Implement BaseAdapter with shared functionality for logging, metrics, and error handling. Create AdapterFactory with fn create(cli_type: CLIType) -> Box<dyn CliAdapter> using pattern matching. Add lifecycle hooks for pre/post execution, cleanup, and health checks. Implement adapter configuration with per-CLI defaults and overrides. Add telemetry with OpenTelemetry integration for distributed tracing.
    </implementation_details>
    <acceptance_criteria>
        <criterion>CliAdapter trait defines all required methods with proper async/await patterns and Send + Sync bounds</criterion>
        <criterion>BaseAdapter provides shared functionality: structured logging, OpenTelemetry metrics, template rendering, config validation</criterion>
        <criterion>AdapterFactory manages adapter lifecycle with registration, health checks, and thread-safe creation</criterion>
        <criterion>ClaudeAdapter reference implementation maintains 100% backward compatibility with existing behavior</criterion>
        <criterion>Performance requirements met: <50ms adapter creation, <100ms config generation, <10MB memory per adapter</criterion>
        <criterion>Thread safety verified with 1000+ concurrent operations without data races or deadlocks</criterion>
        <criterion>Comprehensive error handling with actionable error messages and proper context propagation</criterion>
        <criterion>Template system generates valid configurations for different CLI formats (JSON, TOML)</criterion>
        <criterion>Telemetry integration provides metrics, tracing, and structured logging with correlation IDs</criterion>
        <criterion>Extensible architecture allows easy addition of new CLI adapters with minimal boilerplate</criterion>
    </acceptance_criteria>
    <test_strategy>
        Unit test trait implementations with mock adapters. Test factory pattern creates correct adapter types. Verify shared functionality in BaseAdapter works across all implementations. Test lifecycle hooks are called in correct order. Mock container interactions to test initialization. Verify telemetry data is properly exported. Test concurrent adapter creation and usage with 1000+ simultaneous operations. Validate backward compatibility with existing Claude behavior. Test error handling and recovery scenarios. Performance benchmark all operations to ensure SLA compliance.
    </test_strategy>
    <instructions>
        Think step-by-step about the implementation approach. This is the architectural foundation that all subsequent CLI integrations will build upon, so design must be elegant, performant, and extensible.
        Start by designing the CliAdapter trait to abstract the diverse requirements of 8 different CLI tools. Consider that Codex uses TOML config and STDIO MCP, Claude uses JSON and streaming, Python CLIs use different patterns entirely.
        Focus on the BaseAdapter shared functionality - this should provide significant value to all adapter implementations. Include comprehensive logging, metrics, template rendering, and error handling patterns.
        The ClaudeAdapter is critical - it must maintain exact backward compatibility while demonstrating the patterns other adapters will follow. Use this as the reference implementation.
        Provide complete, production-ready code that follows Rust best practices. Include proper error handling, async/await patterns, thread safety, and comprehensive testing. Consider memory usage and performance implications of trait objects and dynamic dispatch.
        Where appropriate, use MCP tools (filesystem, git, rustdocs_query_rust_docs) to research Rust trait design patterns, async trait implementations, and OpenTelemetry integration to ensure optimal architecture and performance.
    </instructions>
</prompt>