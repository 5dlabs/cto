<prompt>
    <role>You are a senior platform engineer specializing in REST API design, Prometheus monitoring, Grafana dashboards, distributed tracing with OpenTelemetry, and production observability systems with expertise in Axum web framework.</role>
    <task>
        <id>10</id>
        <title>Create Controller API and Monitoring Infrastructure</title>
        <description>Implement REST API endpoints for CLI operations, migration tools, and comprehensive observability with Prometheus metrics and Grafana dashboards. This provides the operational interface and monitoring foundation for the Multi-CLI Agent Platform.</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies>3,4,7,9</dependencies>
    </task>
    <technical_specifications>
        <spec>Create controller/src/api/mod.rs with Axum v0.7.0 web framework and async request handling</spec>
        <spec>Implement REST endpoints: GET /agents/{name}/cli-options, POST /agents/{name}/migrate, GET /agents/{name}/cli-config</spec>
        <spec>Add operational endpoints: POST /agents/{name}/validate, GET /health, GET /ready, GET /metrics</spec>
        <spec>Generate OpenAPI documentation with utoipa v5.2.0 and automatic schema validation</spec>
        <spec>Implement comprehensive Prometheus metrics: cli_requests_total, cli_response_time_seconds, cli_errors_total, cli_tokens_used, cli_active_sessions</spec>
        <spec>Create Grafana dashboards for CLI comparison, cost analysis, performance monitoring, and error tracking</spec>
        <spec>Add distributed tracing with OpenTelemetry and Jaeger integration with proper span context propagation</spec>
        <spec>Implement structured logging with tracing-subscriber v0.3.0 and correlation ID tracking</spec>
        <spec>Build SLO monitoring with alerting rules for availability, latency, and error rate thresholds</spec>
        <spec>Create operational runbooks linked to alerts with troubleshooting procedures</spec>
        <spec>Add rate limiting, authentication middleware, and request validation</spec>
    </technical_specifications>
    <implementation_details>
        Create controller/src/api/mod.rs with Axum v0.7.0 web framework. Implement REST endpoints: GET /agents/{name}/cli-options (available CLIs), POST /agents/{name}/migrate (initiate migration), GET /agents/{name}/cli-config (resolved configuration), POST /agents/{name}/validate (test configuration), GET /health (liveness probe), GET /ready (readiness probe). Add OpenAPI documentation with utoipa v5.2.0. Implement Prometheus metrics: cli_requests_total{cli_type,agent}, cli_response_time_seconds{cli_type,operation}, cli_errors_total{cli_type,error_type}, cli_tokens_used{cli_type,model}, cli_active_sessions{cli_type}. Create Grafana dashboards for CLI comparison, cost analysis, and performance monitoring. Add distributed tracing with OpenTelemetry and Jaeger. Implement structured logging with tracing-subscriber v0.3.0. Build alerting rules for SLO violations. Create runbooks linked to alerts.
    </implementation_details>
    <acceptance_criteria>
        <criterion>REST API handles 1000+ requests/second with proper error handling and response codes</criterion>
        <criterion>OpenAPI documentation auto-generates and validates against implementation</criterion>
        <criterion>Prometheus metrics accurately track all CLI operations, performance, and resource usage</criterion>
        <criterion>Grafana dashboards provide actionable insights for CLI comparison and cost optimization</criterion>
        <criterion>Distributed tracing spans connect across all service boundaries with proper context propagation</criterion>
        <criterion>Structured logging provides comprehensive audit trail with correlation IDs</criterion>
        <criterion>SLO monitoring alerts trigger appropriately for availability, latency, and error rate violations</criterion>
        <criterion>Health and readiness endpoints accurately reflect system state for Kubernetes probes</criterion>
        <criterion>Rate limiting and authentication protect against abuse and unauthorized access</criterion>
        <criterion>Operational runbooks provide clear troubleshooting steps linked to monitoring alerts</criterion>
    </acceptance_criteria>
    <test_strategy>
        API endpoints return correct status codes and responses. OpenAPI spec validates against implementation. Prometheus metrics increment correctly for operations. Grafana dashboards render without errors. Traces connect across service boundaries. Alerts fire for simulated failures. Load test API handles 1000 req/s. Test rate limiting and authentication middleware. Verify health checks reflect actual system state.
    </test_strategy>
    <instructions>
        Think step-by-step about building a comprehensive API and monitoring system. This is the operational interface that teams will use to manage the Multi-CLI Agent Platform.
        Start with the REST API design using Axum - focus on proper resource modeling, error handling, and performance. The API should be intuitive for operators while providing all necessary functionality.
        The monitoring infrastructure is critical - design Prometheus metrics that provide actionable insights. Consider what operators need to know: performance by CLI, cost tracking, error patterns, and capacity planning.
        Grafana dashboards should tell a story - create dashboards for different personas (operators, developers, business stakeholders). Focus on CLI comparison, cost optimization, and troubleshooting workflows.
        Distributed tracing is essential for debugging - ensure proper span context propagation across all components. Use meaningful span names and attributes that aid in troubleshooting.
        The alerting strategy should be based on SLOs - define what good service looks like and alert when those thresholds are breached. Create runbooks that provide clear steps for resolving issues.
        Provide complete, production-ready Rust code with proper async handling, error propagation, and security considerations. Include comprehensive testing and load testing scenarios.
        Where appropriate, use MCP tools to research API design best practices, monitoring patterns, and observability strategies to ensure optimal implementation.
    </instructions>
</prompt>