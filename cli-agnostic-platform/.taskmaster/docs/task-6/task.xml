<prompt>
    <role>You are a senior transport layer engineer with expertise in TypeScript, streaming protocols, MCP (Model Context Protocol), STDIO communication, and distributed systems performance optimization.</role>
    <task>
        <id>6</id>
        <title>Build MCP Transport Abstraction Layer</title>
        <description>Create unified MCP communication layer supporting streaming, buffered relay, and STDIO patterns across different CLI implementations. This abstraction enables consistent tool communication regardless of CLI transport mechanisms, handling the diverse communication patterns required by 8 different CLI tools.</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies>3,5</dependencies>
    </task>
    <technical_specifications>
        <spec>Create mcp/src/transport/mod.ts with abstract Transport class and concrete implementations</spec>
        <spec>Implement DirectStreamingTransport using native fetch with ReadableStream for HTTP streaming CLIs</spec>
        <spec>Build BufferedRelayTransport with configurable buffer sizes (64KB default) for STDIO-based CLIs</spec>
        <spec>Create StdioTransport using Node.js child_process for local MCP servers</spec>
        <spec>Implement transport auto-detection based on CLI capabilities and endpoint probing</spec>
        <spec>Add retry logic with exponential backoff: initial 100ms, max 30s, jitter 0.1</spec>
        <spec>Build request/response correlation with UUID tracking and timeout handling (30s default)</spec>
        <spec>Add compression support using zstd for large payloads with automatic threshold detection</spec>
        <spec>Create comprehensive metrics: latency, throughput, error rates, connection pool stats</spec>
        <spec>Build connection pooling for HTTP transports with keep-alive and health checks</spec>
    </technical_specifications>
    <implementation_details>
        Create mcp/src/transport/mod.ts with abstract Transport class. Implement DirectStreamingTransport using native fetch with ReadableStream for CLIs with HTTP streaming. Build BufferedRelayTransport with configurable buffer sizes (default 64KB) for STDIO-based CLIs. Create StdioTransport using Node.js child_process for local MCP servers. Implement transport auto-detection based on CLI capabilities. Add retry logic with exponential backoff (initial: 100ms, max: 30s, jitter: 0.1). Build request/response correlation with UUID tracking. Implement timeout handling (default: 30s, configurable per tool). Add compression support using zstd for large payloads. Create metrics collection for latency, throughput, and error rates. Build connection pooling for HTTP transports with keep-alive.
    </implementation_details>
    <acceptance_criteria>
        <criterion>Abstract Transport class provides unified interface for all MCP communication patterns</criterion>
        <criterion>Auto-detection system selects optimal transport (streaming, buffered, or STDIO) based on CLI capabilities</criterion>
        <criterion>DirectStreamingTransport handles HTTP streaming with proper error recovery and backpressure</criterion>
        <criterion>BufferedRelayTransport manages STDIO communication with configurable buffering and message framing</criterion>
        <criterion>Retry logic with exponential backoff handles transient failures gracefully</criterion>
        <criterion>Request correlation and timeout management prevents hanging operations</criterion>
        <criterion>Compression reduces bandwidth usage by >50% for large tool responses</criterion>
        <criterion>Connection pooling optimizes HTTP transport performance with reuse and health checks</criterion>
        <criterion>Comprehensive metrics track performance and reliability across all transport types</criterion>
        <criterion>Performance target: <500ms p99 latency for tool calls under normal load</criterion>
    </acceptance_criteria>
    <test_strategy>
        Test streaming transport with mock SSE server. Verify buffered relay handles partial messages correctly. Test STDIO transport with mock child process. Verify auto-detection selects correct transport. Test retry logic with simulated failures. Verify timeout handling cancels requests properly. Load test with 100 concurrent MCP calls. Test compression effectiveness with large payloads. Verify connection pooling reuses connections properly.
    </test_strategy>
    <instructions>
        Think step-by-step about the transport layer design. This is a critical abstraction that must handle the diverse communication patterns of 8 different CLI tools seamlessly.
        Start by designing the abstract Transport interface that can accommodate streaming (Claude, Gemini), buffered STDIO (Codex), and direct STDIO patterns. Consider the unique requirements of each CLI type.
        Focus on the auto-detection system - it should intelligently probe CLI capabilities and select the optimal transport without manual configuration. Handle edge cases like network failures during detection.
        The buffering strategy for STDIO-based CLIs is crucial - implement proper message framing, backpressure handling, and memory management to prevent issues with large responses.
        Performance is critical - implement connection pooling, compression, and request coalescing where appropriate. The retry and timeout logic should be sophisticated enough to handle various failure modes.
        Provide complete, production-ready TypeScript code with proper error handling, async/await patterns, and comprehensive testing. Include proper resource cleanup and memory management.
        Where appropriate, use MCP tools to research streaming protocols, STDIO communication patterns, and Node.js performance optimization techniques.
    </instructions>
</prompt>