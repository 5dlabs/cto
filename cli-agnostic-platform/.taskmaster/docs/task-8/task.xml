<prompt>
    <role>You are a senior DevOps engineer specializing in Docker containerization, multi-architecture builds, security hardening, and supply chain security with expertise in optimizing container images for production workloads.</role>
    <task>
        <id>8</id>
        <title>Create Multi-CLI Container Images</title>
        <description>Build optimized Docker images for each CLI with proper runtime environments, dependencies, and health checks. This provides the containerized execution environment for all 8 CLI tools with security hardening, multi-architecture support, and comprehensive health monitoring.</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies>1,7</dependencies>
    </task>
    <technical_specifications>
        <spec>Create base Dockerfiles in infra/images/{cli}/Dockerfile for each CLI type with appropriate base images</spec>
        <spec>Node.js CLIs (Claude, Opencode, Gemini, Grok, Qwen): Use node:22-slim, install via npm/curl, optimize layer caching</spec>
        <spec>Rust-based Codex: Use rust:1.83-slim, install with cargo, cache cargo registry for build performance</spec>
        <spec>Python CLIs (Cursor, OpenHands): Use python:3.12-slim, create virtualenv, optimize pip caching</spec>
        <spec>Implement multi-stage builds to minimize final image size with build/runtime separation</spec>
        <spec>Add comprehensive health check scripts testing CLI availability and MCP connectivity</spec>
        <spec>Configure entrypoint scripts for proper initialization, environment setup, and signal handling</spec>
        <spec>Integrate security scanning with Trivy in CI pipeline with vulnerability thresholds</spec>
        <spec>Implement SBOM generation with syft for supply chain transparency and compliance</spec>
        <spec>Set up cosign image signing for supply chain security and verification</spec>
        <spec>Create matrix builds for linux/amd64 and linux/arm64 architectures with buildx</spec>
        <spec>Optimize layer caching with proper COPY ordering and .dockerignore configuration</spec>
    </technical_specifications>
    <implementation_details>
        Create base Dockerfiles in infra/images/{cli}/Dockerfile. For Node.js CLIs (Claude, Opencode, Gemini): Use node:22-slim base, install CLI via npm/curl, set up workspace directories. For Rust-based Codex: Use rust:1.83-slim, install with cargo install @openai/codex, cache cargo registry. For Python CLIs (Cursor, OpenHands): Use python:3.12-slim, create virtualenv, install with pip. Implement multi-stage builds to minimize image size. Add health check scripts checking CLI availability and MCP connectivity. Configure entrypoint scripts for initialization and environment setup. Add security scanning with Trivy in CI pipeline. Implement SBOM generation with syft. Sign images with cosign for supply chain security. Create matrix build for linux/amd64 and linux/arm64. Optimize layer caching with proper COPY ordering.
    </implementation_details>
    <acceptance_criteria>
        <criterion>Image sizes meet targets: <500MB (Node.js), <700MB (Rust), <800MB (Python)</criterion>
        <criterion>Health checks return proper status codes and detect CLI/MCP connectivity issues</criterion>
        <criterion>CLI commands execute successfully in containers with proper error handling</criterion>
        <criterion>Multi-architecture images work correctly on both amd64 and arm64 platforms</criterion>
        <criterion>Security scans show zero high/critical vulnerabilities with proper remediation</criterion>
        <criterion>Signed images verify successfully with cosign and proper keyless signatures</criterion>
        <criterion>SBOM generation provides complete supply chain visibility</criterion>
        <criterion>Build performance optimized with effective layer caching and parallel builds</criterion>
        <criterion>Entrypoint scripts handle signals properly and support graceful shutdown</criterion>
        <criterion>Non-root user execution for security with proper file permissions</criterion>
    </acceptance_criteria>
    <test_strategy>
        Build all images and verify size constraints. Test health checks return proper status codes. Verify CLI commands execute successfully in containers. Test multi-arch images on both amd64 and arm64. Scan images for vulnerabilities with severity thresholds. Verify signed images with cosign verify. Test SBOM completeness and accuracy. Benchmark build times and cache effectiveness. Test entrypoint signal handling and graceful shutdown.
    </test_strategy>
    <instructions>
        Think step-by-step about containerizing 8 different CLI tools with their unique requirements. Each CLI has different installation methods, dependencies, and runtime needs.
        Start with the Node.js-based CLIs (Claude, Opencode, Gemini, Grok, Qwen) - these share similar patterns but may have different installation procedures. Focus on layer optimization and caching strategies.
        The Rust-based Codex requires careful handling of the cargo ecosystem, build caching, and potentially large build artifacts. Consider using cargo-chef or similar tools for optimal caching.
        Python CLIs (Cursor, OpenHands) need proper virtualenv setup, pip caching, and dependency management. Consider using pip-tools or similar for reproducible builds.
        Security is paramount - implement comprehensive scanning, SBOM generation, and image signing. Follow container security best practices including non-root users, minimal attack surface, and proper secret handling.
        Multi-architecture support is critical for modern deployment scenarios. Ensure all images work correctly on both Intel and ARM platforms.
        Provide complete, production-ready Dockerfiles with proper optimization, security hardening, and comprehensive health checks. Include CI/CD pipeline configurations for automated building and testing.
        Where appropriate, use MCP tools to research container optimization techniques, security scanning best practices, and multi-architecture build strategies.
    </instructions>
</prompt>