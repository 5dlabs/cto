<context>
# Overview  
The 5D Labs Agent Platform currently operates exclusively with Claude Code CLI, limiting our ability to support diverse development workflows and leverage different AI models' strengths. This Multi-CLI Agent Platform project extends our platform to support 8 different CLI tools (Claude, Codex, Opencode, Gemini, Grok, Qwen, Cursor, OpenHands), enabling agents to work with the most appropriate AI model for their specific tasks while maintaining consistent behavior and collaboration capabilities.

The platform will provide a CLI-agnostic abstraction layer that handles the unique requirements of each CLI - from configuration formats (JSON, TOML, JSONC) to authentication methods (API keys, OAuth, session tokens) to memory mechanisms (CLAUDE.md, AGENTS.md, GEMINI.md) - while preserving backward compatibility with our existing Claude-only workflows.

This enhancement directly addresses critical business needs: expanding our customer base to organizations using different AI providers, reducing vendor lock-in risks, optimizing costs by selecting appropriate models for different task types, and enabling best-of-breed AI selection where certain models excel at specific domains (e.g., Codex for code generation, Gemini for multimodal tasks).

# Core Features  

## CLI Abstraction Layer
The foundation of the multi-CLI platform is a standardized interface that abstracts CLI-specific behaviors. This layer provides unified methods for model validation, configuration generation, prompt formatting, response parsing, and memory management. Each CLI adapter implements these interfaces while handling their unique requirements - Codex uses TOML configuration, Opencode uses JSON/JSONC, Claude uses markdown memory files, and each has different model naming conventions and authentication patterns.

## Dynamic Configuration Management
A sophisticated configuration system that merges Helm chart defaults with repository-level overrides in cto-config.json. The system supports field-level configuration merging, CLI-specific validation rules, runtime configuration resolution, and graceful fallback to defaults. Agents can specify their CLI preference and configuration without modifying cluster-wide settings, enabling experimentation and gradual migration.

## Template Abstraction System
CLI-specific template variants for system prompts, configuration files, and container scripts. The template manager dynamically selects appropriate templates based on the CLI type, falling back to generic templates when CLI-specific ones aren't available. This enables optimal prompt engineering for each AI model while maintaining a consistent agent experience.

## MCP (Model Context Protocol) Integration
Unified MCP tool access across all CLIs through the existing Toolman infrastructure. The system handles different MCP client implementations - Claude's native support, Codex's STDIO-only clients, Opencode's local/remote server support - while providing consistent tool interfaces to agents. Includes streaming compatibility layers and buffered relay fallbacks for CLIs without native streaming support.

## Authentication Orchestration
Support for diverse authentication methods across CLIs: API key injection from Kubernetes secrets, OAuth token exchange for session-based auth, headless login flows for CLI tools, and environment variable configuration. The system securely manages credentials while supporting both usage-based billing and session-based access models.

## Container Environment Management
CLI-specific container images with appropriate runtime dependencies. Node.js environments for TypeScript CLIs (Claude, Opencode, Gemini), Rust toolchain for Codex, Python virtualenvs for Cursor and OpenHands. Each container includes the necessary configuration files, memory persistence mechanisms, and tool bindings specific to its CLI.

## Model Validation Framework
CLI-aware model validation that understands each provider's naming conventions: Claude models (claude-*, opus, sonnet, haiku), OpenAI/Codex models (gpt-*, o1, o3), Google models (gemini-*), and provider-specific variants. The framework prevents invalid CLI/model combinations while providing helpful error messages.

## Migration Tools
Automated tools for migrating existing Claude-only agents to other CLIs, including configuration converters, prompt adapters, memory file translators, and validation scripts. These tools ensure smooth transitions without data loss or workflow disruption.

# User Experience  

## Agent Developers
Software engineers configuring and deploying AI agents need a seamless experience regardless of their chosen CLI. They can specify their preferred CLI in the agent configuration, provide CLI-specific settings (models, temperatures, token limits), and migrate existing agents to new CLIs without code changes. The platform provides clear error messages for configuration issues, comprehensive documentation for each CLI's capabilities, and migration guides with step-by-step instructions.

## Platform Operators
DevOps teams managing the agent platform need visibility and control over multi-CLI deployments. They can set cluster-wide CLI defaults in Helm charts, monitor CLI usage and performance metrics, enforce security policies per CLI, manage API keys and credentials centrally, and roll out new CLI support gradually with feature flags. The platform provides health checks, resource utilization metrics, and cost tracking per CLI type.

## Agent End Users
Developers interacting with deployed agents experience consistent behavior regardless of underlying CLI. They submit tasks through the same interfaces, receive responses in familiar formats, and access the same tool capabilities. The platform abstracts CLI differences, ensuring that workflow changes are transparent to end users while potentially benefiting from improved model capabilities or reduced latency.

## Migration Experience
Teams migrating from Claude to other CLIs follow a structured process: assess current agent configurations and identify CLI-specific dependencies, select target CLI based on requirements and capabilities, run migration tools to convert configurations, test agents in isolated environments with new CLI, gradually roll out changes using feature flags, and monitor performance and accuracy metrics. The platform provides rollback capabilities at each step, ensuring safe transitions.
</context>
<PRD>
# Technical Architecture  

## System Components

### CLI Adapter Layer (controller/src/cli/adapter.rs)
The adapter layer provides a trait-based abstraction for CLI interactions. Each CLI implementation (ClaudeAdapter, CodexAdapter, OpencodeAdapter, GeminiAdapter) implements the CliAdapter trait with methods for validate_model(), generate_config(), format_prompt(), parse_response(), get_memory_filename(), and get_executable_name(). The adapters handle CLI-specific configuration formats (TOML for Codex, JSON for Opencode, markdown for Claude) and model validation rules unique to each provider.

### Configuration Resolver (controller/src/agents/resolver.rs)
The AgentResolver merges configurations from multiple sources with clear precedence rules. It loads Helm defaults from the per-agent CLI declarations (`agents.<agent>.cli`, `model`, token limits), reads repository overrides from cto-config.json, validates merged configurations against CLI requirements, and generates final runtime configurations. The resolver handles field-level merging for granular control while maintaining backward compatibility for agents without CLI specifications.

### Template Management System (controller/src/templates/manager.rs)
TemplateManager provides dynamic template selection based on CLI type. It maintains a registry of CLI-specific templates (system prompts, config files, container scripts), implements fallback logic for missing templates, and handles template variable injection. The system uses Handlebars for template rendering with CLI-aware helper functions and custom formatters.

### MCP Transport Layer (mcp/src/transport/)
The transport layer abstracts MCP communication patterns across CLIs. It provides DirectStreaming for CLIs with native HTTP streaming support, BufferedRelay for STDIO-based CLIs requiring buffering, and automatic detection of CLI streaming capabilities. The layer includes retry logic, timeout handling, and performance monitoring for each transport type.

### Authentication Manager (controller/src/auth/)
Handles diverse authentication requirements across CLIs. Supports API key injection from Kubernetes secrets (for usage-based billing), OAuth token exchange for session-based authentication, headless CLI login flows, and credential refresh for long-running jobs. The manager implements secure credential storage, automatic token rotation, and audit logging for all authentication events.

### Container Orchestration (infra/images/)
CLI-specific Docker images with optimized runtime environments. Base images include language runtimes (Node.js, Python, Rust), CLI tools installed via package managers (npm, pip, cargo), configuration file templates, and MCP client libraries. Each image is versioned and tagged for precise control, with health checks and readiness probes configured.

## Data Models

### Enhanced Agent Configuration
```rust
pub struct AgentConfig {
    pub github_app: String,
    pub cli: CLIType,
    pub cli_config: Option<CLIConfig>,
    pub tools: ToolConfiguration,
    pub memory_strategy: MemoryStrategy,
}

pub struct CLIConfig {
    pub model: String,
    pub max_tokens: Option<u32>,
    pub temperature: Option<f32>,
    pub container_image: Option<String>,
    pub auth: AuthenticationConfig,
    pub sandbox_preset: Option<String>,
    pub custom_env: HashMap<String, String>,
}

pub enum CLIType {
    Claude,
    Codex,
    Opencode,
    Gemini,
    Grok,
    Qwen,
    Cursor,
    OpenHands,
}

pub enum MemoryStrategy {
    MarkdownFile(String),  // CLAUDE.md, AGENTS.md, GEMINI.md
    Subdirectory(String),  // .grok/GROK.md
    SessionBased,          // Cursor, OpenHands
}
```

### Configuration Merge Rules
```rust
pub struct MergeStrategy {
    pub source_precedence: Vec<ConfigSource>,
    pub field_level_merge: bool,
    pub validation_mode: ValidationMode,
    pub conflict_resolution: ConflictResolution,
}

pub enum ConfigSource {
    HelmDefaults,
    CtoConfig,
    EnvironmentOverrides,
    RuntimeParameters,
}
```

## APIs and Integrations

### MCP Server Extensions
The MCP server gains CLI-aware endpoints for model validation (/validate/{cli_type}/model), configuration preview (/config/{agent_name}/preview), capability queries (/cli/{cli_type}/capabilities), and health checks (/cli/{cli_type}/health). These endpoints enable pre-flight validation and debugging of CLI configurations.

### Controller API Enhancements
New controller endpoints support CLI operations: GET /agents/{name}/cli-options returns available CLIs for an agent, POST /agents/{name}/migrate initiates CLI migration, GET /agents/{name}/cli-config shows resolved configuration, and POST /agents/{name}/validate tests configuration validity.

### GitHub Integration Updates
Enhanced GitHub App integration supports CLI-specific PR comments, workflow dispatch with CLI parameters, status checks per CLI type, and deployment environment tags. The integration ensures consistent GitHub interactions regardless of underlying CLI.

### Monitoring and Metrics APIs
Prometheus metrics for CLI-specific monitoring: cli_requests_total{cli_type, agent_name}, cli_response_time_seconds{cli_type, operation}, cli_errors_total{cli_type, error_type}, and cli_model_tokens_used{cli_type, model}. Grafana dashboards provide visualization of multi-CLI performance.

## Infrastructure Requirements

### Kubernetes Resources
- Additional ConfigMaps for CLI-specific templates (one per CLI type)
- Secrets for API keys and authentication tokens (referenced by cliConfig.auth.apiKeySecretRef)
- PersistentVolumeClaims for CLI-specific workspace data
- ServiceAccounts with appropriate RBAC for multi-CLI operations
- NetworkPolicies allowing CLI-specific egress to AI provider endpoints

### Container Registry
- Automated builds for 8 CLI container images
- Multi-architecture support (amd64, arm64) for each image
- Vulnerability scanning and SBOM generation
- Image signing with cosign for supply chain security
- Retention policies for version management

### Resource Scaling
- Increased CPU/memory limits for Python-based CLIs (Cursor, OpenHands)
- GPU node support for future model-local deployments
- Horizontal pod autoscaling based on CLI request patterns
- Cluster autoscaling for burst workloads
- Resource quotas per CLI type to prevent resource exhaustion

# Development Roadmap  

## Phase 0: Foundation and Prerequisites (Critical Path)
### Infrastructure Setup
- Set up multi-CLI container build pipelines with automated testing and security scanning
- Create Kubernetes namespace and RBAC configurations for multi-CLI testing environment
- Deploy monitoring stack with CLI-specific dashboards and alerting rules
- Configure secret management for API keys and authentication tokens
- Implement feature flag system for gradual CLI rollout

### Model Validation Framework
- Refactor validate_model_name() to support CLI-aware validation with extensible provider patterns
- Implement model cataloging system with supported models per CLI
- Create model compatibility matrix documenting CLI/model combinations
- Add comprehensive unit tests for all model validation scenarios
- Deploy model validation service as standalone microservice for reusability

### Configuration Schema Design
- Define comprehensive cto-config.json schema with JSON Schema validation
- Document configuration precedence rules with visual diagrams
- Create configuration migration tools for existing deployments
- Implement configuration validation hooks in controller startup
- Build configuration preview API for testing merged configurations

## Phase 1: CLI Abstraction Layer Implementation
### Core Adapter System
- Implement CliAdapter trait with all required methods
- Create ClaudeAdapter as reference implementation with existing behavior
- Build adapter factory pattern for dynamic CLI selection
- Implement adapter lifecycle management (initialization, cleanup)
- Add comprehensive logging and telemetry to adapter operations

### Configuration Resolution Engine
- Build AgentResolver with multi-source configuration merging
- Implement field-level merge strategies with conflict detection
- Create validation framework for CLI-specific requirements
- Add configuration caching with TTL and invalidation
- Build configuration audit trail for debugging

### Template Management Infrastructure
- Design template registry with versioning support
- Implement dynamic template selection algorithm
- Create template validation and testing framework
- Build template inheritance for shared components
- Add template performance profiling and optimization

## Phase 2: Codex CLI Integration
### Codex Adapter Implementation
- Implement CodexAdapter with TOML configuration generation
- Add Codex-specific model validation for OpenAI models
- Create Codex memory management with AGENTS.md support
- Implement Codex-specific error handling and retry logic
- Add comprehensive integration tests with mock Codex responses

### Codex Container Environment
- Create Codex Docker image with Rust toolchain and dependencies
- Implement codex-entrypoint.sh with proper initialization sequence
- Configure Codex-specific health checks and readiness probes
- Add Codex binary caching for faster container starts
- Implement Codex workspace isolation and cleanup

### Codex MCP Integration
- Test Codex with existing Toolman STDIO wrapper
- Implement buffered relay if streaming limitations discovered
- Create Codex-specific tool configuration mappings
- Add performance monitoring for Codex MCP operations
- Build fallback mechanisms for MCP communication failures

### Authentication Implementation
- Implement ChatGPT session token exchange for Codex
- Add API key injection for usage-based billing
- Create credential rotation for long-running jobs
- Implement authentication failure recovery mechanisms
- Add audit logging for all authentication events

## Phase 3: Opencode CLI Integration
### Opencode Adapter Development
- Implement OpencodeAdapter with JSON/JSONC configuration
- Add Opencode-specific model validation
- Create Opencode memory management with AGENTS.md
- Implement TypeScript-specific error handling
- Build Opencode response parsing with streaming support

### Opencode Container Setup
- Create Opencode Docker image with Node.js and TypeScript
- Implement opencode-entrypoint.sh with multi-package setup
- Configure Opencode-specific environment variables
- Add Opencode package caching strategies
- Implement Opencode workspace management

### Opencode MCP Configuration
- Integrate Opencode's native MCP client libraries
- Configure local and remote MCP server support
- Implement Opencode-specific tool discovery
- Add Opencode MCP performance optimizations
- Create Opencode tool compatibility layer

## Phase 4: Gemini CLI Integration
### Gemini Adapter Creation
- Implement GeminiAdapter with GEMINI.md memory support
- Add Gemini-specific model validation for Google models
- Create Gemini prompt formatting with multimodal support
- Implement Gemini-specific rate limiting
- Add Gemini response parsing with structured outputs

### Gemini Container Configuration
- Create Gemini Docker image from upstream base
- Implement gemini-entrypoint.sh with Google Cloud setup
- Configure Gemini authentication with service accounts
- Add Gemini-specific monitoring and logging
- Implement Gemini workspace persistence

### Gemini Integration Features
- Integrate Gemini's native MCP support
- Add multimodal input handling for Gemini
- Implement Gemini-specific tool configurations
- Create Gemini performance optimizations
- Add Gemini-specific error recovery

## Phase 5: Extended CLI Support
### Grok and Qwen Integration
- Implement GrokAdapter and QwenAdapter
- Create container images for both CLIs
- Add authentication mechanisms for each
- Configure MCP integration patterns
- Test with existing agent workflows

### Python CLI Support (Cursor, OpenHands)
- Design Python-specific adapter patterns
- Create Python-based container environments
- Implement virtualenv management
- Add Python-specific dependency handling
- Create session-based state management

## Phase 6: Production Hardening
### Performance Optimization
- Profile and optimize adapter performance across all CLIs
- Implement request batching and connection pooling
- Add caching layers for frequently used configurations
- Optimize container startup times with layer caching
- Implement lazy loading for CLI components

### Reliability Engineering
- Add circuit breakers for each CLI integration
- Implement exponential backoff with jitter
- Create health check endpoints for all CLIs
- Add automatic failover between CLIs
- Implement request hedging for critical operations

### Security Hardening
- Implement credential encryption at rest
- Add secret rotation automation
- Create security scanning for CLI containers
- Implement network policies for CLI isolation
- Add compliance logging and audit trails

## Phase 7: Migration and Rollout
### Migration Tooling
- Create automated migration scripts for each CLI
- Build configuration converters with validation
- Implement prompt adaptation tools
- Add memory file translators
- Create rollback mechanisms

### Gradual Rollout Strategy
- Implement percentage-based rollout controls
- Create A/B testing framework for CLI comparison
- Add shadow mode for risk-free testing
- Build automated rollback triggers
- Create performance comparison dashboards

### Documentation and Training
- Write comprehensive CLI integration guides
- Create video tutorials for each CLI
- Build interactive CLI selection wizard
- Document troubleshooting procedures
- Create runbooks for common issues

# Logical Dependency Chain

## Foundation Dependencies (Must Complete First)
1. **Model Validation Refactoring** - Blocks all CLI integration work as current validation prevents non-Claude models
2. **Configuration Schema Design** - Required before implementing any adapter as it defines the contract
3. **Container Build Infrastructure** - Needed before creating CLI-specific images
4. **Feature Flag System** - Enables safe rollout and testing without affecting production

## Core Platform Dependencies (Parallel Development Possible)
5. **CLI Adapter Trait** - Defines interface all adapters must implement
6. **Template Management System** - Can be developed in parallel with adapters
7. **Configuration Resolver** - Can be built alongside adapter development
8. **MCP Transport Abstraction** - Can be developed independently and integrated later

## CLI-Specific Implementation Chain (Sequential per CLI)
9. **Claude Adapter** (Reference) - Implement first as reference, ensuring backward compatibility
10. **Codex Integration** - Second implementation to prove multi-CLI concept with different config format (TOML)
11. **Opencode Integration** - Third to validate TypeScript CLI patterns
12. **Gemini Integration** - Fourth to test Google-specific authentication and multimodal support

## Progressive Enhancement Chain
13. **Basic MCP Integration** - Get tools working with simple request/response
14. **Streaming Support** - Add streaming once basic integration works
15. **Buffered Relay** - Implement only if streaming issues discovered
16. **Performance Optimizations** - After functional implementation is stable

## Testing and Validation Chain
17. **Unit Tests** - For each component as it's built
18. **Integration Tests** - After each CLI adapter is complete
19. **End-to-End Tests** - Once full workflow works for a CLI
20. **Performance Tests** - After functional testing passes
21. **Security Tests** - Before production deployment

## Migration and Rollout Chain
22. **Migration Tools** - After at least two CLIs are working
23. **Documentation** - Parallel with implementation but must be complete before rollout
24. **Pilot Testing** - With small group before general availability
25. **Gradual Rollout** - Percentage-based increase in usage
26. **Full Production** - After metrics show stability

## Optimization and Scaling Chain
27. **Performance Profiling** - After initial production deployment
28. **Resource Optimization** - Based on actual usage patterns
29. **Cost Optimization** - After understanding token usage per CLI
30. **Scaling Automation** - Once resource patterns are understood

# Risks and Mitigations  

## Technical Risks

### Model Validation Breaking Changes
The current validate_model_name() function is hard-coded for Claude models only, completely blocking any non-Claude CLI integration. This is our highest priority risk that must be fixed immediately. Mitigation involves creating a CLI-aware validation system in Phase 0 that can be extended without breaking existing agents, implementing comprehensive test coverage for all model patterns, and adding a temporary bypass with warning logs if needed for development.

### MCP Streaming Incompatibility
Several CLIs (particularly Codex with STDIO-only support) may not handle streaming responses efficiently, leading to timeouts or high memory usage. We'll implement a transport abstraction layer that can switch between streaming and buffered modes, create configurable buffer thresholds based on response size patterns, monitor latency and memory metrics per CLI, and plan to retire buffered relay once native streaming is available upstream.

### Configuration Complexity Explosion
With 8 different CLIs, each with unique configuration formats and requirements, the system could become unmaintainable. We'll implement a unified configuration schema that abstracts CLI differences, use code generation for repetitive configuration handling, create comprehensive validation at multiple stages, provide clear error messages with suggested fixes, and maintain extensive documentation with examples for each CLI.

### Authentication Security Vulnerabilities
Multiple authentication methods across CLIs create increased attack surface and potential for credential leakage. Mitigation includes implementing defense-in-depth with multiple security layers, using Kubernetes secrets with encryption at rest, adding automatic credential rotation with zero downtime, implementing comprehensive audit logging, and following the principle of least privilege for all service accounts.

### Container Image Sprawl
Eight different container images with various dependencies could lead to maintenance burden and security vulnerabilities. We'll implement automated vulnerability scanning for all images, use multi-stage builds to minimize image size, share base layers where possible, implement automated dependency updates, and maintain strict version pinning with regular updates.

## Operational Risks

### Backward Compatibility Breakage
Existing Claude-only agents might stop working during migration, causing production outages. Our mitigation strategy includes comprehensive regression testing at each phase, feature flags for gradual rollout, maintaining Claude as the default CLI when not specified, creating automated compatibility tests, and implementing instant rollback capabilities.

### Performance Degradation
New abstraction layers might introduce latency or resource overhead. We'll benchmark performance before and after each phase, implement caching at multiple levels, optimize critical paths identified through profiling, set up performance alerts with automatic scaling, and maintain performance SLOs for each CLI type.

### Increased Operational Complexity
Supporting 8 CLIs increases monitoring, debugging, and maintenance burden. Mitigation includes creating unified observability with CLI-specific dashboards, implementing standardized logging formats across CLIs, building automated troubleshooting tools, providing comprehensive runbooks for common issues, and implementing self-healing mechanisms where possible.

## Resource Risks

### Development Time Underestimation
The complexity of supporting 8 different CLIs might exceed initial estimates. We'll use a phased approach focusing on high-value CLIs first, implement the most different CLIs early to uncover issues, maintain a prioritized backlog with clear dependencies, use timeboxed spikes for unknown areas, and have contingency plans for scope reduction if needed.

### Skill Gap in Team
Team might lack expertise in all CLI technologies (Rust for Codex, TypeScript for others, Python for Cursor/OpenHands). Mitigation involves bringing in consultants for specific CLI expertise, implementing pair programming for knowledge transfer, creating comprehensive internal documentation, setting up dedicated learning time for new technologies, and building relationships with CLI vendor support teams.

### Testing Resource Constraints
Testing 8 different CLI combinations requires significant resources. We'll implement automated testing at all levels, use property-based testing for configuration combinations, create synthetic monitoring for production, implement chaos engineering for reliability testing, and use shadow testing to validate changes safely.

## Strategic Risks

### Vendor Lock-in to New Providers
While reducing Claude lock-in, we might create dependencies on other providers. Mitigation includes maintaining abstraction layers for all external dependencies, ensuring at least two CLI options for critical workflows, implementing vendor-agnostic interfaces where possible, maintaining migration tools between CLIs, and regularly testing failover capabilities.

### Rapid CLI Evolution
CLI tools might change faster than we can adapt our integration. We'll implement version pinning with controlled updates, maintain compatibility matrices for CLI versions, implement adapter versioning for backward compatibility, maintain close relationships with CLI vendors, and implement gradual deprecation strategies.

### Cost Optimization Complexity
Different pricing models across providers make cost optimization difficult. Mitigation involves implementing detailed token usage tracking per CLI, creating cost allocation dashboards, implementing automatic model selection based on cost/performance, setting up budget alerts and automatic throttling, and providing cost optimization recommendations.

# Appendix  

## Configuration Examples

### Complete Codex Agent Configuration
```json
{
  "agents": {
    "codex_rex": {
      "githubApp": "5DLabs-Rex",
      "cli": "codex",
      "cliConfig": {
        "model": "gpt-5-codex",
        "maxTokens": 8192,
        "temperature": 0.7,
        "containerImage": "ghcr.io/5dlabs/codex:v0.7.2",
        "auth": {
          "mode": "api_key",
          "apiKeySecretRef": "openai-api-key"
        },
        "sandboxPreset": "workspace-write",
        "customEnv": {
          "CODEX_LOG_LEVEL": "debug",
          "CODEX_CACHE_DIR": "/tmp/codex-cache"
        }
      },
      "tools": {
        "remote": ["memory_create_entities", "rustdocs_query_rust_docs"],
        "localServers": {
          "filesystem": {
            "enabled": true,
            "tools": ["read_file", "write_file", "list_directory", "create_directory"]
          },
          "git": {
            "enabled": true,
            "tools": ["git_status", "git_diff", "git_commit", "git_push"]
          }
        }
      }
    }
  }
}
```

### Gemini Multimodal Configuration
```json
{
  "agents": {
    "gemini_vision": {
      "githubApp": "5DLabs-Vision",
      "cli": "gemini",
      "cliConfig": {
        "model": "gemini-pro-vision",
        "maxTokens": 32768,
        "temperature": 0.5,
        "containerImage": "ghcr.io/5dlabs/gemini:v0.7.0-nightly.20250918",
        "auth": {
          "mode": "service_account",
          "serviceAccountKeyRef": "gemini-sa-key"
        },
        "multimodal": {
          "enabled": true,
          "supportedFormats": ["image/png", "image/jpeg", "image/webp"]
        }
      }
    }
  }
}
```

### Migration Configuration Example
```json
{
  "migration": {
    "source": {
      "cli": "claude",
      "model": "claude-sonnet-4-20250514"
    },
    "target": {
      "cli": "codex",
      "model": "gpt-5-codex"
    },
    "strategy": "gradual",
    "stages": [
      {"percentage": 10, "duration": "24h"},
      {"percentage": 25, "duration": "48h"},
      {"percentage": 50, "duration": "72h"},
      {"percentage": 100, "duration": "permanent"}
    ],
    "rollbackTriggers": {
      "errorRateThreshold": 0.05,
      "latencyThreshold": "2s",
      "costIncreaseThreshold": 1.5
    }
  }
}
```

## Technical Specifications

### CLI Capability Matrix
| CLI | Config Format | Memory Type | MCP Support | Streaming | Auth Methods | Container Base |
|-----|--------------|-------------|-------------|-----------|--------------|----------------|
| Claude | JSON | CLAUDE.md | Native | Yes | Session | Node.js |
| Codex | TOML | AGENTS.md | STDIO | No | API Key/ChatGPT | Rust |
| Opencode | JSON/JSONC | AGENTS.md | Native | Yes | API Key | TypeScript |
| Gemini | JSON | GEMINI.md | Native | Yes | Service Account | TypeScript |
| Grok | JSON | .grok/GROK.md | Unknown | Unknown | API Key | TypeScript |
| Qwen | JSON | GEMINI.md variant | Unknown | Unknown | API Key | TypeScript |
| Cursor | Python Config | Session-based | No | No | OAuth | Python |
| OpenHands | YAML/TOML | Session-based | No | No | OAuth | Python |

### Model Support by CLI
- **Claude**: claude-3-opus, claude-3-sonnet, claude-3-haiku, claude-2.1
- **Codex**: gpt-4, gpt-4-turbo, gpt-3.5-turbo, o1, o1-mini, o3
- **Opencode**: Multiple provider support via adapters
- **Gemini**: gemini-pro, gemini-pro-vision, gemini-ultra
- **Grok**: grok-1, grok-2 (pending confirmation)
- **Qwen**: qwen-7b, qwen-14b, qwen-72b
- **Cursor**: Proxies to various providers
- **OpenHands**: Multiple model support via configuration

### Performance Benchmarks (Target)
- Model validation: < 10ms per validation
- Configuration merge: < 50ms per agent
- Template rendering: < 100ms per template
- Container startup: < 30s cold start, < 5s warm start
- MCP tool invocation: < 500ms p99 latency
- Authentication: < 1s for API key, < 3s for OAuth flows

### Resource Requirements per CLI
- **Claude**: 2 CPU, 4Gi memory, 10Gi storage
- **Codex**: 1 CPU, 2Gi memory, 5Gi storage
- **Opencode**: 2 CPU, 4Gi memory, 10Gi storage
- **Gemini**: 2 CPU, 4Gi memory, 10Gi storage
- **Python CLIs**: 4 CPU, 8Gi memory, 20Gi storage (includes virtualenv)

### Security Compliance Requirements
- SOC 2 Type II compliance for credential handling
- GDPR compliance for data processing
- Zero-trust networking between CLI containers
- End-to-end encryption for sensitive data
- Comprehensive audit logging with 90-day retention
- Regular penetration testing of CLI integrations
- Supply chain security for all container images
</PRD>
