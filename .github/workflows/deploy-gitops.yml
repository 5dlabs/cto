name: GitOps Deployment

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy'
        required: false
        default: 'main'
      tag:
        description: 'Tag to deploy (e.g., v1.0.0, latest)'
        required: true
        default: 'latest'
      sync-timeout:
        description: 'Argo CD sync timeout'
        required: false
        default: '600s'
  
  push:
    branches: [main]
    paths:
      - 'orchestrator/**'
      - 'infra/charts/orchestrator/**'
      - 'infra/gitops/**'
      - '.github/workflows/deploy-gitops.yml'

env:
  REGISTRY: ghcr.io
  IMAGE_BASE: 5dlabs

jobs:
  # Build and push container image
  build:
    name: Build Container
    runs-on: [self-hosted, k8s-runner]
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      version: ${{ steps.version.outputs.version }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.branch || github.ref }}

      - name: Generate version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ inputs.tag }}"
          else
            VERSION="$(date +%Y%m%d)-$(echo ${{ github.sha }} | cut -c1-7)"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è Version: ${VERSION}"

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/orchestrator
          tags: |
            type=ref,event=branch
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ steps.version.outputs.version }}

      - name: Build and push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./orchestrator
          file: ./orchestrator/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Update image tag in GitOps repository
  update-gitops:
    name: Update GitOps Config
    runs-on: [self-hosted, k8s-runner]
    needs: build
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update orchestrator image tag
        run: |
          echo "üìù Updating orchestrator image tag to ${{ needs.build.outputs.version }}"
          
          # Update the Argo CD Application with new image tag
          sed -i "s|value: latest|value: ${{ needs.build.outputs.version }}|g" \
            infra/gitops/applications/orchestrator.yaml
          
          # Alternative: Update values.yaml if using that approach
          if [ -f "infra/charts/orchestrator/values.yaml" ]; then
            sed -i "s|tag: .*|tag: ${{ needs.build.outputs.version }}|g" \
              infra/charts/orchestrator/values.yaml
          fi

      - name: Commit and push GitOps changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if git diff --exit-code infra/gitops/ infra/charts/; then
            echo "üìÑ No GitOps changes to commit"
          else
            git add infra/gitops/ infra/charts/
            git commit -m "chore: update orchestrator image to ${{ needs.build.outputs.version }}"
            git push
            echo "‚úÖ GitOps configuration updated"
          fi

  # Trigger Argo CD sync
  deploy-via-argocd:
    name: Deploy via Argo CD
    runs-on: [self-hosted, k8s-runner]
    needs: [build, update-gitops]
    
    steps:
      - uses: actions/checkout@v4

      - name: Setup tools
        run: |
          mkdir -p $HOME/bin
          
          # Copy kubectl from shared location
          if [ -f /shared/kubectl ]; then
            cp /shared/kubectl $HOME/bin/
            chmod +x $HOME/bin/kubectl
          fi
          
          # Install Argo CD CLI if not available
          if [ ! -f /shared/argocd ]; then
            echo "üì¶ Installing Argo CD CLI..."
            curl -sSL -o $HOME/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
            chmod +x $HOME/bin/argocd
          else
            cp /shared/argocd $HOME/bin/
            chmod +x $HOME/bin/argocd
          fi
          
          echo "$HOME/bin" >> $GITHUB_PATH

      - name: Login to Argo CD
        run: |
          echo "üîê Logging into Argo CD..."
          
          # Use port-forward or direct service access
          kubectl port-forward svc/argocd-server -n argocd 8080:443 &
          PF_PID=$!
          sleep 5
          
          # Get admin password
          ADMIN_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          
          # Login to Argo CD
          argocd login localhost:8080 \
            --username admin \
            --password "$ADMIN_PASSWORD" \
            --insecure
          
          # Clean up port-forward
          kill $PF_PID 2>/dev/null || true

      - name: Sync Argo CD applications
        run: |
          echo "üîÑ Syncing Argo CD applications..."
          
          # Sync platform project applications
          argocd app sync platform-apps --timeout ${{ inputs.sync-timeout || '600s' }}
          argocd app sync orchestrator --timeout ${{ inputs.sync-timeout || '600s' }}
          
          # Wait for sync to complete
          argocd app wait orchestrator --timeout ${{ inputs.sync-timeout || '600s' }}
          
          echo "‚úÖ Argo CD sync completed"

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          
          # Check pod status
          kubectl get pods -n orchestrator -o wide
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=orchestrator -n orchestrator --timeout=120s
          
          # Check Argo CD application status
          argocd app get orchestrator
          
          echo ""
          echo "‚úÖ Deployment verification complete!"
          echo "üì¶ Deployed: ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/orchestrator:${{ needs.build.outputs.version }}"

      - name: Show recent TaskRuns
        run: |
          echo "üìã Recent TaskRuns:"
          kubectl get coderuns,docsruns -A --sort-by=.metadata.creationTimestamp | tail -10 || echo "No TaskRuns found"

  # Rollback capability
  rollback:
    name: Rollback Deployment
    runs-on: [self-hosted, k8s-runner]
    if: failure() && github.event_name == 'workflow_dispatch'
    needs: [deploy-via-argocd]
    
    steps:
      - name: Setup Argo CD CLI
        run: |
          if [ ! -f /shared/argocd ]; then
            curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
            chmod +x /usr/local/bin/argocd
          fi

      - name: Rollback to previous version
        run: |
          echo "üîÑ Rolling back to previous version..."
          
          # Get previous successful revision
          PREVIOUS_REVISION=$(argocd app history orchestrator --output json | jq -r '.[1].revision')
          
          if [ "$PREVIOUS_REVISION" != "null" ]; then
            argocd app rollback orchestrator $PREVIOUS_REVISION
            argocd app wait orchestrator --timeout 300s
            echo "‚úÖ Rollback completed to revision $PREVIOUS_REVISION"
          else
            echo "‚ùå No previous revision found for rollback"
            exit 1
          fi