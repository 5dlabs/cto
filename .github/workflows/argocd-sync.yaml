---
name: ArgoCD Full Sync

on:
  # Trigger on any push to main (including merged PRs)
  push:
    branches:
      - main

  # Manual trigger for on-demand sync
  workflow_dispatch:
    inputs:
      wait_for_sync:
        description: 'Wait for sync to complete'
        required: false
        type: boolean
        default: true
      sync_timeout:
        description: 'Timeout per app in seconds'
        required: false
        type: number
        default: 300

jobs:
  argocd-sync:
    runs-on: [k8s-runner]

    steps:
      - name: Setup kubectl
        run: |
          mkdir -p $HOME/bin
          if [ -f /shared/kubectl ]; then
            cp /shared/kubectl $HOME/bin/
            chmod +x $HOME/bin/kubectl
          fi
          echo "$HOME/bin" >> $GITHUB_PATH

      - name: Trigger sync summary
        run: |
          echo "## ðŸ”„ ArgoCD Sync Triggered" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "**Trigger:** Push to main" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
            echo "**Author:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Trigger:** Manual dispatch" >> $GITHUB_STEP_SUMMARY
            echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Sync platform-apps (app-of-apps)
        run: |
          echo "ðŸ”„ Syncing platform-apps (app-of-apps)..."

          # Hard refresh to detect changes
          kubectl patch application platform-apps -n argocd --type merge \
            -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'

          # Wait a moment for refresh to process
          sleep 5

          # Trigger actual sync operation with ServerSideApply to handle large CRDs
          # (avoids 262144 byte annotation limit with kubectl.kubernetes.io/last-applied-configuration)
          kubectl patch application platform-apps -n argocd --type merge \
            -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"prune":true,"syncOptions":["ServerSideApply=true"]}}}'

          echo "âœ… platform-apps sync triggered"
          echo "- **platform-apps:** Sync triggered âœ…" >> $GITHUB_STEP_SUMMARY

      - name: Wait for platform-apps to sync
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.wait_for_sync == true)
        run: |
          echo "â³ Waiting for platform-apps to sync..."
          TIMEOUT="${{ inputs.sync_timeout || 300 }}"
          ELAPSED=0
          INTERVAL=10
          SEEN_RUNNING=false

          while [ $ELAPSED -lt $TIMEOUT ]; do
            STATUS=$(kubectl get application platform-apps -n argocd \
              -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH=$(kubectl get application platform-apps -n argocd \
              -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            OP_PHASE=$(kubectl get application platform-apps -n argocd \
              -o jsonpath='{.status.operationState.phase}' 2>/dev/null || echo "")

            echo "  platform-apps: Sync=$STATUS, Health=$HEALTH, Operation=$OP_PHASE"

            # Track if we've seen the operation start (avoids race condition)
            if [ "$OP_PHASE" = "Running" ]; then
              SEEN_RUNNING=true
            fi

            # Only consider complete if we've seen it running first, or operation explicitly succeeded
            if [ "$OP_PHASE" = "Succeeded" ] && [ "$STATUS" = "Synced" ]; then
              echo "âœ… platform-apps sync succeeded!"
              break
            elif [ "$SEEN_RUNNING" = "true" ] && [ "$OP_PHASE" != "Running" ] && [ "$STATUS" = "Synced" ]; then
              echo "âœ… platform-apps is synced!"
              break
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "âš ï¸ Timeout waiting for platform-apps (will continue with other apps)"
          fi

      - name: Sync all individual applications
        run: |
          echo "ðŸ”„ Syncing all individual ArgoCD applications..."
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Individual Application Syncs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get all applications in argocd namespace (excluding platform-apps which is already synced)
          APPS=$(kubectl get applications -n argocd -o jsonpath='{.items[*].metadata.name}' | tr ' ' '\n' | grep -v '^platform-apps$' | sort)

          for app in $APPS; do
            echo "  Syncing: $app"

            # Hard refresh first
            kubectl patch application "$app" -n argocd --type merge \
              -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}' 2>/dev/null || true

            # Trigger sync with ServerSideApply to handle large CRDs
            # (avoids 262144 byte annotation limit with kubectl.kubernetes.io/last-applied-configuration)
            kubectl patch application "$app" -n argocd --type merge \
              -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"prune":true,"syncOptions":["ServerSideApply=true"]}}}' 2>/dev/null || true

            echo "- **$app:** Sync triggered âœ…" >> $GITHUB_STEP_SUMMARY
          done

          echo "âœ… All applications sync triggered"

      - name: Wait for all apps to sync
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.wait_for_sync == true)
        run: |
          echo "â³ Waiting for all applications to sync..."
          TIMEOUT="${{ inputs.sync_timeout || 300 }}"

          # Get all apps (excluding platform-apps which was already waited for)
          APPS=$(kubectl get applications -n argocd -o jsonpath='{.items[*].metadata.name}' | tr ' ' '\n' | grep -v '^platform-apps$')

          for app in $APPS; do
            echo "  Waiting for $app..."
            ELAPSED=0
            INTERVAL=10
            SEEN_RUNNING=false

            while [ $ELAPSED -lt $TIMEOUT ]; do
              STATUS=$(kubectl get application "$app" -n argocd \
                -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
              OP_PHASE=$(kubectl get application "$app" -n argocd \
                -o jsonpath='{.status.operationState.phase}' 2>/dev/null || echo "")

              # Track if we've seen the operation start (avoids race condition)
              if [ "$OP_PHASE" = "Running" ]; then
                SEEN_RUNNING=true
              fi

              # Only consider complete if we've seen it running first, or operation explicitly succeeded
              if [ "$OP_PHASE" = "Succeeded" ] && [ "$STATUS" = "Synced" ]; then
                echo "    âœ… $app sync succeeded"
                break
              elif [ "$SEEN_RUNNING" = "true" ] && [ "$OP_PHASE" != "Running" ] && [ "$STATUS" = "Synced" ]; then
                echo "    âœ… $app synced"
                break
              fi

              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            done

            if [ $ELAPSED -ge $TIMEOUT ]; then
              echo "    âš ï¸ $app timeout (may still be syncing)"
            fi
          done

      - name: Final status check
        run: |
          echo "ðŸ” Final application status..."
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Final Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

          kubectl get applications -n argocd \
            -o custom-columns='NAME:.metadata.name,SYNC:.status.sync.status,HEALTH:.status.health.status,REVISION:.status.sync.revision' \
            | tee -a $GITHUB_STEP_SUMMARY

          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

          # Count statuses
          TOTAL=$(kubectl get applications -n argocd -o json | jq '.items | length')
          SYNCED=$(kubectl get applications -n argocd -o json | jq '[.items[] | select(.status.sync.status == "Synced")] | length')
          HEALTHY=$(kubectl get applications -n argocd -o json | jq '[.items[] | select(.status.health.status == "Healthy")] | length')

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Summary:** $SYNCED/$TOTAL synced, $HEALTHY/$TOTAL healthy" >> $GITHUB_STEP_SUMMARY

      - name: Summary
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ‰ **ArgoCD sync completed!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All applications have been synced. Check the ArgoCD UI for any issues." >> $GITHUB_STEP_SUMMARY
