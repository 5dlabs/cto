---
# Tools Release Workflow
#
# Builds and releases the tools MCP server:
# - Cross-platform binaries via cargo-dist (macOS, Linux, Windows)
# - Docker image for Kubernetes deployment
#
# Triggered by tags matching: tools-v*.*.*

name: Tools Release

permissions:
  contents: write
  packages: write

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., tools-v0.2.0)'
        required: true
        type: string
  push:
    tags:
      - 'tools-v*.*.*'

env:
  REGISTRY: ghcr.io
  IMAGE_BASE: 5dlabs

jobs:
  # Plan the release using cargo-dist
  plan:
    runs-on: ubuntu-22.04
    outputs:
      val: ${{ steps.plan.outputs.manifest }}
      tag: ${{ steps.determine-tag.outputs.tag }}
      tag-flag: ${{ steps.determine-tag.outputs.tag-flag }}
      publishing: ${{ steps.determine-tag.outputs.publishing }}
      version: ${{ steps.determine-tag.outputs.version }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Determine tag and version
        id: determine-tag
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG="${{ inputs.tag }}"
            if ! echo "$TAG" | grep -qE '^tools-v[0-9]+\.[0-9]+\.[0-9]+'; then
              echo "Error: Invalid tag format '$TAG'. Expected: tools-v1.0.0"
              exit 1
            fi
            PUBLISHING="true"
          elif [ "${{ github.event_name }}" = "push" ]; then
            TAG="${{ github.ref_name }}"
            PUBLISHING="true"
          else
            TAG=""
            PUBLISHING="false"
          fi

          # Extract version (remove 'tools-v' prefix)
          VERSION=${TAG#tools-v}

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          if [ -n "$TAG" ]; then
            echo "tag-flag=--tag=$TAG" >> "$GITHUB_OUTPUT"
          else
            echo "tag-flag=" >> "$GITHUB_OUTPUT"
          fi
          echo "publishing=$PUBLISHING" >> "$GITHUB_OUTPUT"

          echo "Tag: $TAG"
          echo "Version: $VERSION"
          echo "Publishing: $PUBLISHING"

      - name: Install cargo-dist
        shell: bash
        run: |
          curl --proto '=https' --tlsv1.2 -LsSf \
            https://github.com/axodotdev/cargo-dist/releases/download/v0.28.2/cargo-dist-installer.sh | sh

      - name: Cache dist binary
        uses: actions/upload-artifact@v4
        with:
          name: cargo-dist-cache
          path: ~/.cargo/bin/dist

      - name: Plan release
        id: plan
        working-directory: ./tools
        run: |
          if [ "${{ steps.determine-tag.outputs.publishing }}" = "true" ]; then
            dist host --steps=create --tag=${{ steps.determine-tag.outputs.tag }} --output-format=json > plan-dist-manifest.json
          else
            dist plan --output-format=json > plan-dist-manifest.json
          fi
          echo "dist plan completed"
          cat plan-dist-manifest.json
          echo "manifest=$(jq -c "." plan-dist-manifest.json)" >> "$GITHUB_OUTPUT"

      - name: Upload plan manifest
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-plan-dist-manifest
          path: tools/plan-dist-manifest.json

  # Build platform-specific binaries
  build-binaries:
    name: build (${{ join(matrix.targets, ', ') }})
    needs: plan
    if: ${{ fromJson(needs.plan.outputs.val).ci.github.artifacts_matrix.include != null && needs.plan.outputs.publishing == 'true' }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.plan.outputs.val).ci.github.artifacts_matrix }}
    runs-on: ${{ matrix.runner }}
    container: ${{ matrix.container && matrix.container.image || null }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      BUILD_MANIFEST_NAME: target/distrib/${{ join(matrix.targets, '-') }}-dist-manifest.json
    steps:
      - name: Enable Windows longpaths
        run: git config --global core.longpaths true

      - uses: actions/checkout@v4

      - name: Install Rust (container)
        if: ${{ matrix.container }}
        run: |
          if ! command -v cargo > /dev/null 2>&1; then
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          fi

      - name: Install cargo-dist
        run: ${{ matrix.install_dist.run }}

      - name: Fetch artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: target/distrib/
          merge-multiple: true

      - name: Install dependencies
        run: ${{ matrix.packages_install }}

      - name: Build binaries
        working-directory: ./tools
        run: |
          dist build ${{ needs.plan.outputs.tag-flag }} --print=linkage --output-format=json ${{ matrix.dist_args }} > dist-manifest.json
          echo "Build completed successfully"

      - name: Collect artifacts
        id: collect
        shell: bash
        working-directory: ./tools
        run: |
          echo "paths<<EOF" >> "$GITHUB_OUTPUT"
          dist print-upload-files-from-manifest --manifest dist-manifest.json >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          cp dist-manifest.json "$BUILD_MANIFEST_NAME"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-build-${{ join(matrix.targets, '_') }}
          path: |
            ${{ steps.collect.outputs.paths }}
            ${{ env.BUILD_MANIFEST_NAME }}

  # Build global artifacts (installers, checksums)
  build-global:
    needs: [plan, build-binaries]
    runs-on: ubuntu-22.04
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      BUILD_MANIFEST_NAME: target/distrib/global-dist-manifest.json
    steps:
      - uses: actions/checkout@v4

      - name: Install cached dist
        uses: actions/download-artifact@v4
        with:
          name: cargo-dist-cache
          path: ~/.cargo/bin/
      - run: chmod +x ~/.cargo/bin/dist

      - name: Fetch artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: target/distrib/
          merge-multiple: true

      - name: Build global artifacts
        id: build
        shell: bash
        working-directory: ./tools
        run: |
          dist build ${{ needs.plan.outputs.tag-flag }} --output-format=json "--artifacts=global" > dist-manifest.json
          echo "Global artifacts built"

          echo "paths<<EOF" >> "$GITHUB_OUTPUT"
          jq --raw-output ".upload_files[]" dist-manifest.json >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

          cp dist-manifest.json "$BUILD_MANIFEST_NAME"

      - name: Upload global artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-build-global
          path: |
            ${{ steps.build.outputs.paths }}
            ${{ env.BUILD_MANIFEST_NAME }}

  # Build Docker image using pre-built binaries
  build-docker:
    needs: [plan, build-binaries]
    if: needs.plan.outputs.publishing == 'true'
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4

      - name: Fetch pre-built binaries
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-build-*
          path: target/distrib/
          merge-multiple: true

      - name: Extract Linux binary for Docker
        run: |
          echo "ðŸ“¦ Extracting pre-built tools-server binary..."
          cd target/distrib

          # Find and extract the Linux x86_64 archive
          LINUX_ARCHIVE=$(ls -1 tools-*x86_64*linux*.tar.gz 2>/dev/null | head -1 || true)
          if [ -z "$LINUX_ARCHIVE" ]; then
            echo "âŒ No Linux x86_64 archive found"
            ls -la
            exit 1
          fi

          echo "Found archive: $LINUX_ARCHIVE"
          tar -xzf "$LINUX_ARCHIVE"

          # Find the extracted binary
          BINARY=$(find . -name "tools-server" -type f | head -1)
          if [ -z "$BINARY" ]; then
            echo "âŒ tools-server binary not found in archive"
            find . -type f
            exit 1
          fi

          # Copy to Docker context
          cp "$BINARY" ../../infra/images/tools/tools-server-linux
          chmod +x ../../infra/images/tools/tools-server-linux
          echo "âœ… Binary extracted: $(ls -lh ../../infra/images/tools/tools-server-linux)"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3

      - name: Log in to Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@ca052bb54ab0790a636c9b5f226502c73d547a25 # v5
        with:
          context: ./infra/images/tools
          file: ./infra/images/tools/Dockerfile
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/tools:${{ needs.plan.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/tools:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Generate summary
        run: |
          echo "## ðŸ³ Tools Docker Image" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/tools:${{ needs.plan.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/tools:${{ needs.plan.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # Create GitHub Release
  release:
    needs: [plan, build-binaries, build-global, build-docker]
    if: ${{ always() && needs.plan.outputs.publishing == 'true' && needs.build-binaries.result == 'success' && needs.build-global.result == 'success' && needs.build-docker.result == 'success' }}
    runs-on: ubuntu-22.04
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Install cached dist
        uses: actions/download-artifact@v4
        with:
          name: cargo-dist-cache
          path: ~/.cargo/bin/
      - run: chmod +x ~/.cargo/bin/dist

      - name: Fetch all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: target/distrib/
          merge-multiple: true

      - name: Upload to GitHub Release
        working-directory: ./tools
        run: |
          dist host ${{ needs.plan.outputs.tag-flag }} --steps=upload --steps=release --output-format=json > dist-manifest.json
          echo "Release artifacts uploaded"

      - name: Download artifacts for release
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: artifacts
          merge-multiple: true

      - name: Create GitHub Release
        env:
          VERSION: ${{ needs.plan.outputs.version }}
          TAG: ${{ needs.plan.outputs.tag }}
        run: |
          # Clean up manifest files
          rm -f artifacts/*-dist-manifest.json

          # Create release notes
          cat > $RUNNER_TEMP/notes.txt << 'EOF'
          ## Tools v${{ needs.plan.outputs.version }}

          Dynamic MCP (Model Context Protocol) tool management and proxy server.

          ### Installation

          **Shell (macOS/Linux):**
          ```bash
          curl --proto '=https' --tlsv1.2 -LsSf https://github.com/5dlabs/cto/releases/download/${{ needs.plan.outputs.tag }}/tools-installer.sh | sh
          ```

          **Docker:**
          ```bash
          docker pull ghcr.io/5dlabs/tools:${{ needs.plan.outputs.version }}
          ```

          ### Helm Chart

          ```bash
          helm upgrade tools infra/charts/tools \
            --set image.tag=${{ needs.plan.outputs.version }}
          ```
          EOF

          gh release create "$TAG" \
            --title "Tools v$VERSION" \
            --notes-file "$RUNNER_TEMP/notes.txt" \
            artifacts/* || echo "Release may already exist"
