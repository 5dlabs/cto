---
# Play Monitor Release Workflow
#
# Builds and releases the play-monitor CLI:
# - Cross-platform binaries via cargo-dist (macOS, Linux)
#
# Triggered by tags matching: play-monitor-v*.*.*

name: Play Monitor Release

permissions:
  contents: write
  packages: write

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., play-monitor-v0.2.0)'
        required: true
        type: string
  push:
    tags:
      - 'play-monitor-v*.*.*'

jobs:
  # Plan the release using cargo-dist
  plan:
    runs-on: ubuntu-22.04
    outputs:
      val: ${{ steps.plan.outputs.manifest }}
      tag: ${{ steps.determine-tag.outputs.tag }}
      tag-flag: ${{ steps.determine-tag.outputs.tag-flag }}
      publishing: ${{ steps.determine-tag.outputs.publishing }}
      version: ${{ steps.determine-tag.outputs.version }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Determine tag and version
        id: determine-tag
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG="${{ inputs.tag }}"
            if ! echo "$TAG" | grep -qE '^play-monitor-v[0-9]+\.[0-9]+\.[0-9]+'; then
              echo "Error: Invalid tag format '$TAG'. Expected: play-monitor-v1.0.0"
              exit 1
            fi
            PUBLISHING="true"
          elif [ "${{ github.event_name }}" = "push" ]; then
            TAG="${{ github.ref_name }}"
            PUBLISHING="true"
          else
            TAG=""
            PUBLISHING="false"
          fi

          # Extract version (remove 'play-monitor-v' prefix)
          VERSION=${TAG#play-monitor-v}

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          if [ -n "$TAG" ]; then
            echo "tag-flag=--tag=$TAG" >> "$GITHUB_OUTPUT"
          else
            echo "tag-flag=" >> "$GITHUB_OUTPUT"
          fi
          echo "publishing=$PUBLISHING" >> "$GITHUB_OUTPUT"

          echo "Tag: $TAG"
          echo "Version: $VERSION"
          echo "Publishing: $PUBLISHING"

      - name: Install cargo-dist
        shell: bash
        run: |
          curl --proto '=https' --tlsv1.2 -LsSf \
            https://github.com/axodotdev/cargo-dist/releases/download/v0.28.2/cargo-dist-installer.sh | sh

      - name: Cache dist binary
        uses: actions/upload-artifact@v4
        with:
          name: cargo-dist-cache
          path: ~/.cargo/bin/dist

      - name: Plan release
        id: plan
        working-directory: ./monitor
        run: |
          if [ "${{ steps.determine-tag.outputs.publishing }}" = "true" ]; then
            dist host --steps=create --tag=${{ steps.determine-tag.outputs.tag }} --output-format=json > plan-dist-manifest.json
          else
            dist plan --output-format=json > plan-dist-manifest.json
          fi
          echo "dist plan completed"
          cat plan-dist-manifest.json
          echo "manifest=$(jq -c "." plan-dist-manifest.json)" >> "$GITHUB_OUTPUT"

      - name: Upload plan manifest
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-plan-dist-manifest
          path: monitor/plan-dist-manifest.json

  # Build platform-specific binaries
  build-binaries:
    name: build (${{ join(matrix.targets, ', ') }})
    needs: plan
    if: ${{ fromJson(needs.plan.outputs.val).ci.github.artifacts_matrix.include != null && needs.plan.outputs.publishing == 'true' }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.plan.outputs.val).ci.github.artifacts_matrix }}
    runs-on: ${{ matrix.runner }}
    container: ${{ matrix.container && matrix.container.image || null }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      BUILD_MANIFEST_NAME: target/distrib/${{ join(matrix.targets, '-') }}-dist-manifest.json
    steps:
      - name: Enable Windows longpaths
        run: git config --global core.longpaths true

      - uses: actions/checkout@v4

      - name: Install Rust (container)
        if: ${{ matrix.container }}
        run: |
          if ! command -v cargo > /dev/null 2>&1; then
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          fi

      - name: Install cargo-dist
        run: ${{ matrix.install_dist.run }}

      - name: Fetch artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: target/distrib/
          merge-multiple: true

      - name: Install dependencies
        run: ${{ matrix.packages_install }}

      - name: Build binaries
        working-directory: ./monitor
        run: |
          dist build ${{ needs.plan.outputs.tag-flag }} --print=linkage --output-format=json ${{ matrix.dist_args }} > dist-manifest.json
          echo "Build completed successfully"

      - name: Collect artifacts
        id: collect
        shell: bash
        working-directory: ./monitor
        run: |
          echo "paths<<EOF" >> "$GITHUB_OUTPUT"
          dist print-upload-files-from-manifest --manifest dist-manifest.json >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          cp dist-manifest.json "$BUILD_MANIFEST_NAME"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-build-${{ join(matrix.targets, '_') }}
          path: |
            ${{ steps.collect.outputs.paths }}
            ${{ env.BUILD_MANIFEST_NAME }}

  # Build global artifacts (installers, checksums)
  build-global:
    needs: [plan, build-binaries]
    runs-on: ubuntu-22.04
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      BUILD_MANIFEST_NAME: target/distrib/global-dist-manifest.json
    steps:
      - uses: actions/checkout@v4

      - name: Install cached dist
        uses: actions/download-artifact@v4
        with:
          name: cargo-dist-cache
          path: ~/.cargo/bin/
      - run: chmod +x ~/.cargo/bin/dist

      - name: Fetch artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: target/distrib/
          merge-multiple: true

      - name: Build global artifacts
        id: build
        shell: bash
        working-directory: ./monitor
        run: |
          dist build ${{ needs.plan.outputs.tag-flag }} --output-format=json "--artifacts=global" > dist-manifest.json
          echo "Global artifacts built"

          echo "paths<<EOF" >> "$GITHUB_OUTPUT"
          jq --raw-output ".upload_files[]" dist-manifest.json >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

          cp dist-manifest.json "$BUILD_MANIFEST_NAME"

      - name: Upload global artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-build-global
          path: |
            ${{ steps.build.outputs.paths }}
            ${{ env.BUILD_MANIFEST_NAME }}

  # Create GitHub Release
  release:
    needs: [plan, build-binaries, build-global]
    if: ${{ always() && needs.plan.outputs.publishing == 'true' && needs.build-binaries.result == 'success' && needs.build-global.result == 'success' }}
    runs-on: ubuntu-22.04
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Install cached dist
        uses: actions/download-artifact@v4
        with:
          name: cargo-dist-cache
          path: ~/.cargo/bin/
      - run: chmod +x ~/.cargo/bin/dist

      - name: Fetch all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: target/distrib/
          merge-multiple: true

      - name: Upload to GitHub Release
        working-directory: ./monitor
        run: |
          dist host ${{ needs.plan.outputs.tag-flag }} --steps=upload --steps=release --output-format=json > dist-manifest.json
          echo "Release artifacts uploaded"

      - name: Download artifacts for release
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: artifacts
          merge-multiple: true

      - name: Create GitHub Release
        env:
          VERSION: ${{ needs.plan.outputs.version }}
          TAG: ${{ needs.plan.outputs.tag }}
        run: |
          # Clean up manifest files
          rm -f artifacts/*-dist-manifest.json

          # Create release notes
          cat > $RUNNER_TEMP/notes.txt << 'EOF'
          ## Play Monitor v${{ needs.plan.outputs.version }}

          E2E Watch system monitor CLI for Play workflow supervision.

          ### Installation

          **Shell (macOS/Linux):**
          ```bash
          curl --proto '=https' --tlsv1.2 -LsSf https://github.com/5dlabs/cto/releases/download/${{ needs.plan.outputs.tag }}/play-monitor-installer.sh | sh
          ```

          ### Features

          - Submit and monitor Play workflows
          - Poll workflow status until completion
          - Download and analyze workflow logs
          - Evaluate results against acceptance criteria
          - Integrate with E2E Watch system for automated remediation
          EOF

          gh release create "$TAG" \
            --title "Play Monitor v$VERSION" \
            --notes-file "$RUNNER_TEMP/notes.txt" \
            artifacts/* || echo "Release may already exist"
