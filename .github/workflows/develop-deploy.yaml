---
name: Deploy Agent Controller

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag to deploy (e.g., v0.1.4)'
        required: true
        type: string
  push:
    branches:
      - feature/*
      - feat/*
      - fix/*
      - hotfix/*

env:
  REGISTRY: ghcr.io
  IMAGE_BASE: 5dlabs

jobs:
  # Version determination
  version:
    runs-on: [k8s-runner]
    outputs:
      version: ${{ steps.version.outputs.version }}
      short-sha: ${{ steps.version.outputs.short-sha }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && format('refs/tags/{0}', inputs.tag) || github.ref }}

      - name: Set version from tag
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ inputs.tag }}"
          else
            # For push events, use latest
            VERSION="latest"
          fi
          SHORT_SHA=$(git rev-parse --short HEAD)

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Deploy version: ${VERSION}"


  # Build only controller (skip Claude Code for now)
  build-controller:
    needs: [version]
    runs-on: [k8s-runner]
    # No container needed - the Arc runners now have the rust-builder image!
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && format('refs/tags/{0}', inputs.tag) || github.ref }}

      - name: Setup optimized Rust environment
        run: |
          echo "ğŸš€ Setting up ULTRA-OPTIMIZED Rust build environment..."

          # Add cargo bin to PATH for this step and all subsequent steps
          echo "/home/runner/.cargo/bin" >> $GITHUB_PATH
          export PATH="/home/runner/.cargo/bin:$PATH"

          # Set up Rust toolchain (required for rust-builder image)
          echo "ğŸ¦€ Setting up Rust toolchain..."
          rustup default stable
          rustup update stable

          # Custom image already has most tools pre-installed, just verify
          echo "ğŸ” Verifying pre-installed tools..."
          rustc --version || echo "âš ï¸ Rust not found"
          cargo --version || echo "âš ï¸ Cargo not found"
          sccache --version || echo "âš ï¸ sccache not found"
          mold --version || echo "âš ï¸ mold not found"
          clang --version || echo "âš ï¸ clang not found"
          pkg-config --version || echo "âš ï¸ pkg-config not found"
          openssl version || echo "âš ï¸ openssl not found"

          # Show available resources
          echo "ğŸ’¾ Available resources:"
          echo "CPU cores: $(nproc)"
          echo "Memory: $(free -h | grep '^Mem:' | awk '{print $2}')"
          echo "Disk space: $(df -h . | tail -1 | awk '{print $4}')"

          # Show cache locations
          echo "ğŸ“ Cache locations:"
          echo "CARGO_HOME: ${CARGO_HOME:-$HOME/.cargo}"
          echo "SCCACHE_DIR: ${SCCACHE_DIR:-$HOME/.cache/sccache}"
          echo "RUSTUP_HOME: ${RUSTUP_HOME:-$HOME/.rustup}"

      - name: Setup sccache
        run: |
          echo "ğŸ—„ï¸ Setting up sccache for ULTRA-FAST builds..."

          # Ensure cargo bin is in PATH
          export PATH="/home/runner/.cargo/bin:$PATH"

          # Configure sccache
          export SCCACHE_CACHE_SIZE="50G"
          export SCCACHE_IDLE_TIMEOUT="0"

          # Ensure sccache is running
          sccache --stop-server 2>/dev/null || true
          sccache --start-server

          echo "ğŸ“Š Initial sccache stats:"
          sccache --show-stats

          # Verify mold is available
          echo "ğŸ”— Verifying mold linker:"
          mold --version

      - name: Verify pre-warmed dependencies
        run: |
          echo "ğŸ—‚ï¸ Checking pre-warmed dependency cache..."

          # Check if dependencies are pre-warmed in the image
          if [ -d "$CARGO_HOME/registry" ] && [ "$(ls -A $CARGO_HOME/registry 2>/dev/null)" ]; then
            echo "âœ… Pre-warmed dependencies found in image"
            echo "Registry cache size: $(du -sh $CARGO_HOME/registry 2>/dev/null || echo '0B')"
            echo "Git cache size: $(du -sh $CARGO_HOME/git 2>/dev/null || echo '0B')"
            echo "ğŸ“¦ Sample pre-warmed packages:"
            find $CARGO_HOME/registry -name "*.crate" 2>/dev/null | head -5 | xargs -I {} basename {} .crate || echo "Unable to list packages"
          else
            echo "âš ï¸ No pre-warmed dependencies found - will download at build time"
            echo "CARGO_HOME contents:"
            ls -la $CARGO_HOME/ 2>/dev/null || echo "CARGO_HOME not found"
          fi

      - name: Validate and regenerate Helm templates
        run: |
          echo "ğŸ”„ Validating and regenerating Helm templates before deployment..."
          cd infra/charts/controller
          
          # Store original for comparison
          cp templates/claude-templates-static.yaml templates/claude-templates-static.yaml.orig 2>/dev/null || true
          
          # Regenerate the templates
          ./scripts/generate-templates-configmap.sh
          
          # Check if templates were updated
          if [ -f templates/claude-templates-static.yaml.orig ]; then
            if ! diff -q templates/claude-templates-static.yaml.orig templates/claude-templates-static.yaml >/dev/null 2>&1; then
              echo "âš ï¸ WARNING: Templates were out of sync and have been regenerated!"
              echo "ğŸ“„ Template changes detected:"
              diff -u templates/claude-templates-static.yaml.orig templates/claude-templates-static.yaml | head -50 || true
              echo ""
              echo "ğŸ”§ Using regenerated templates for this deployment"
              echo "ğŸ“‹ ACTION REQUIRED: Commit the template updates to avoid this in future deployments:"
              echo "   cd infra/charts/controller"
              echo "   ./scripts/generate-templates-configmap.sh"
              echo "   git add templates/claude-templates-static.yaml"
              echo "   git commit -m 'chore: update claude-templates ConfigMap'"
              echo ""
              
              # For workflow_dispatch (manual deploys), this is critical
              if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
                echo "âš ï¸ MANUAL DEPLOYMENT: Proceeding with regenerated templates"
              fi
            else
              echo "âœ… Templates are up to date"
            fi
            rm -f templates/claude-templates-static.yaml.orig
          else
            echo "âœ… Templates generated successfully (no previous version to compare)"
          fi
          
          # Verify the generated ConfigMap is valid YAML
          echo "ğŸ” Validating generated ConfigMap YAML..."
          if command -v yamllint >/dev/null 2>&1; then
            yamllint -d relaxed templates/claude-templates-static.yaml || {
              echo "âŒ ERROR: Generated ConfigMap is not valid YAML!"
              exit 1
            }
          else
            # Basic validation without yamllint
            head -n 1 templates/claude-templates-static.yaml | grep -q "^#" || {
              echo "âŒ ERROR: Generated ConfigMap doesn't look valid!"
              exit 1
            }
          fi
          
          echo "âœ… Template ConfigMap is valid and ready for deployment"

      - name: Build release binary (ultra-fast)
        working-directory: ./controller
        env:
          CARGO_INCREMENTAL: "0"  # Disable for better sccache hits
          RUSTC_WRAPPER: "sccache"
          SCCACHE_CACHE_SIZE: "50G"
          SCCACHE_IDLE_TIMEOUT: "0"
          CARGO_NET_GIT_FETCH_WITH_CLI: "true"
          CARGO_REGISTRIES_CRATES_IO_PROTOCOL: "sparse"
          CARGO_TARGET_DIR: "$HOME/cache/target"  # Build to cache directory for persistence
        run: |
          echo "ğŸ—ï¸ Building controller binary with pre-warmed dependencies..."

          # Create cache directory
          mkdir -p $HOME/cache/target

          # Show build environment
          echo "Build environment:"
          echo "Available cores: $(nproc)"
          echo "RUSTFLAGS: $RUSTFLAGS"
          echo "RUSTC_WRAPPER: $RUSTC_WRAPPER"
          echo "CARGO_HOME: ${CARGO_HOME:-$HOME/.cargo}"
          echo "SCCACHE_DIR: ${SCCACHE_DIR:-$HOME/.cache/sccache}"

          # Pre-warm sccache
          sccache --start-server || true
          echo "ğŸ“Š Initial sccache stats:"
          sccache --show-stats

          # Set CARGO_TARGET_DIR to use cache directory
          export CARGO_TARGET_DIR=$HOME/cache/target

          # Build with detailed output
          echo "â±ï¸ Starting build..."
          cargo build --release --bin agent-controller

          # Show final sccache stats
          echo "ğŸ“Š Final sccache stats:"
          sccache --show-stats

          # Debug: Show what's in the target directory
          echo "ğŸ” Checking target directory contents:"
          echo "CARGO_TARGET_DIR is: ${CARGO_TARGET_DIR:-not set}"
          ls -la target/release/ || echo "target/release/ not found"
          ls -la $HOME/cache/target/release/ || echo "$HOME/cache/target/release/ not found"
          find target -name "*controller*" -type f 2>/dev/null || echo "No controller files found in target/"
          find $HOME/cache/target -name "*bridge*" -type f 2>/dev/null || echo "No bridge files found in target/"
          find $HOME/cache/target -name "*controller*" -type f 2>/dev/null || echo "No controller files found in $HOME/cache/target/"
          find $HOME/cache/target -name "*bridge*" -type f 2>/dev/null || echo "No bridge files found in $HOME/cache/target/"

          # Copy binary from cache target dir (where CARGO_TARGET_DIR points)
          cp $HOME/cache/target/release/agent-controller agent-controller

          # Show binary info
          echo "ğŸ“¦ Built binary info:"
          ls -lh agent-controller
          file agent-controller

          # Verify binary is present for Docker build context (controller/agent-controller)
          echo "ğŸ“‹ Verifying agent-controller binary for Docker build context"
          test -f agent-controller && echo "agent-controller present in ./controller" || (echo "agent-controller missing" && exit 1)
          ls -la agent-controller

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Controller image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./infra/images/controller/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/controller:${{ needs.version.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/controller:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/controller:${{ needs.version.outputs.short-sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Show GHCR controller tags
        run: |
          echo "ğŸ” Latest GHCR tags for controller:"
          gh api -H "Accept: application/vnd.github+json" \
            "/orgs/5dlabs/packages/container/cto%2Fcontroller/versions?per_page=1" \
            | jq -r '.[0].metadata.container.tags'

  build-sidecar:
    needs: [version]
    runs-on: [k8s-runner]
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && format('refs/tags/{0}', inputs.tag) || github.ref }}

      - name: Build sidecar binary
        working-directory: ./sidecar
        run: |
          echo "ğŸ—ï¸ Building sidecar binary"
          # Use sccache if available
          if command -v sccache >/dev/null 2>&1; then
            echo "Using sccache"
            export RUSTC_WRAPPER=sccache
            sccache --start-server || true
          else
            echo "sccache not found; building without wrapper"
          fi
          # Use shared target directory for better cache hits
          mkdir -p $HOME/cache/target
          export CARGO_TARGET_DIR=$HOME/cache/target
          cargo build --release
          command -v sccache >/dev/null 2>&1 && sccache --show-stats || true
          cp $HOME/cache/target/release/sidecar ./sidecar
          ls -lh ./sidecar

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push sidecar image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./infra/images/sidecar/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/sidecar:${{ needs.version.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/sidecar:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/sidecar:${{ needs.version.outputs.short-sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Show GHCR sidecar tags
        run: |
          echo "ğŸ” Latest GHCR tags for sidecar:"
          gh api -H "Accept: application/vnd.github+json" \
            "/orgs/5dlabs/packages/container/cto%2Fsidecar/versions?per_page=1" \
            | jq -r '.[0].metadata.container.tags'

  # Deploy immediately
  deploy:
    needs: [version, build-controller]
    runs-on: [k8s-runner]
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && format('refs/tags/{0}', inputs.tag) || github.ref }}

      - name: Setup tools
        run: |
          mkdir -p $HOME/bin
          if [ -f /shared/kubectl ]; then
            cp /shared/kubectl $HOME/bin/
            chmod +x $HOME/bin/kubectl
          fi
          if [ -f /shared/helm ]; then
            cp /shared/helm $HOME/bin/
            chmod +x $HOME/bin/helm
          fi
          echo "$HOME/bin" >> $GITHUB_PATH

      - name: Prepare template updates for ArgoCD
        id: template-check
        run: |
          echo "ğŸ“¦ Preparing template updates for ArgoCD deployment..."
          
          # Check if templates were regenerated in the build job
          cd infra/charts/controller
          
          # Regenerate templates again to ensure consistency
          ./scripts/generate-templates-configmap.sh
          
          # Create a patch file if templates differ from Git
          if ! git diff --quiet templates/claude-templates-static.yaml; then
            echo "templates-changed=true" >> $GITHUB_OUTPUT
            echo "ğŸ“ Creating template update patch..."
            git diff templates/claude-templates-static.yaml > /tmp/templates-update.patch
            
            # Also save the full updated file
            cp templates/claude-templates-static.yaml /tmp/claude-templates-static.yaml
            
            echo "âš ï¸ IMPORTANT: Templates have been updated!"
            echo "The regenerated templates will be used by ArgoCD for this deployment."
            echo ""
            echo "To make these changes permanent, apply this patch to your main branch:"
            echo "   git apply /tmp/templates-update.patch"
            echo "   git add infra/charts/controller/templates/claude-templates-static.yaml"
            echo "   git commit -m 'chore: update claude-templates ConfigMap'"
            echo "   git push"
          else
            echo "templates-changed=false" >> $GITHUB_OUTPUT
            echo "âœ… Templates are in sync with Git repository"
          fi
      
      - name: Upload template updates
        if: steps.template-check.outputs.templates-changed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: template-updates-${{ github.run_id }}
          path: |
            /tmp/templates-update.patch
            /tmp/claude-templates-static.yaml
          retention-days: 7

      - name: GitOps Update (Skipped)
        run: |
          echo "ğŸ“ GitOps configuration uses 'latest' tag - no update needed"
          echo "New image: ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/controller:latest"

      - name: Force ArgoCD Sync
        run: |
          echo "ğŸ”„ Forcing ArgoCD to sync the updated configuration"

          # Wait a moment for Git changes to propagate
          sleep 5

          # Force ArgoCD application refresh and sync
          kubectl patch application controller -n argocd --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'

          # Give ArgoCD time to process the sync (can't wait due to permissions)
          echo "â³ ArgoCD sync triggered, waiting 30s for processing..."
          sleep 30

          echo "âœ… ArgoCD sync triggered successfully"

      - name: Verify deployment
        run: |
          echo "ğŸ” Deployment verification..."
          kubectl get pods -n agent-platform -o wide
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=controller -n agent-platform --timeout=120s || true

          echo ""
          echo "âœ… Deployment complete!"
          echo "ğŸ“¦ Deployed: ${{ env.REGISTRY }}/${{ env.IMAGE_BASE }}/controller:latest"
          echo "ğŸ·ï¸ Version: ${{ needs.version.outputs.version }}"

      - name: Show recent TaskRuns
        run: |
          echo "ğŸ“‹ Recent TaskRuns:"
          kubectl get taskruns -A --sort-by=.metadata.creationTimestamp | tail -10 || echo "No TaskRuns found"
