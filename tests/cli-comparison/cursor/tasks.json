{
  "cli": "cursor",
  "duration_ms": 123470,
  "error": null,
  "model": "opus-4.5-thinking",
  "success": true,
  "task_count": 5,
  "tasks": [
    {
      "dependencies": [],
      "description": "Initialize the Task Manager API crate with required dependencies, database schema, and SQLx migrations. This establishes the core data layer that all other features depend on.",
      "details": "1. Create new crate `crates/taskapi/` with Cargo.toml:\n   - axum = { workspace = true }\n   - tokio = { workspace = true }\n   - sqlx = { version = \"0.8\", features = [\"runtime-tokio\", \"postgres\", \"uuid\", \"chrono\", \"migrate\"] }\n   - serde = { workspace = true }\n   - thiserror = { workspace = true }\n   - tracing = { workspace = true }\n   - uuid = { workspace = true }\n   - chrono = { workspace = true }\n\n2. Create database schema in `migrations/001_initial.sql`:\n   ```sql\n   CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n   \n   CREATE TYPE task_status AS ENUM ('pending', 'in_progress', 'done');\n   CREATE TYPE task_priority AS ENUM ('low', 'medium', 'high');\n   \n   CREATE TABLE users (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     email VARCHAR(255) UNIQUE NOT NULL,\n     password_hash VARCHAR(255) NOT NULL,\n     created_at TIMESTAMPTZ DEFAULT NOW(),\n     updated_at TIMESTAMPTZ DEFAULT NOW()\n   );\n   \n   CREATE TABLE tasks (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n     title VARCHAR(255) NOT NULL,\n     description TEXT,\n     status task_status DEFAULT 'pending',\n     priority task_priority DEFAULT 'medium',\n     created_at TIMESTAMPTZ DEFAULT NOW(),\n     updated_at TIMESTAMPTZ DEFAULT NOW()\n   );\n   \n   CREATE INDEX idx_tasks_user_id ON tasks(user_id);\n   CREATE INDEX idx_tasks_status ON tasks(status);\n   ```\n\n3. Create models in `src/models/mod.rs`:\n   ```rust\n   #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n   pub struct User {\n       pub id: Uuid,\n       pub email: String,\n       #[serde(skip_serializing)]\n       pub password_hash: String,\n       pub created_at: DateTime<Utc>,\n       pub updated_at: DateTime<Utc>,\n   }\n   \n   #[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]\n   #[sqlx(type_name = \"task_status\", rename_all = \"snake_case\")]\n   pub enum TaskStatus { Pending, InProgress, Done }\n   \n   #[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]\n   #[sqlx(type_name = \"task_priority\", rename_all = \"snake_case\")]\n   pub enum TaskPriority { Low, Medium, High }\n   ```\n\n4. Create database connection pool in `src/db.rs` using `PgPoolOptions::new().max_connections(5)`\n\n5. Follow existing codebase pattern: use thiserror for error types in `src/error.rs`",
      "id": "1",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Verify crate compiles: `cargo build -p taskapi`\n2. Run SQLx migrations against test database: `DATABASE_URL=postgres://... sqlx migrate run`\n3. Write unit test to verify database connection pool initialization\n4. Test model serialization/deserialization with serde_json::to_string and from_str\n5. Verify SQLx compile-time query checking works by running `cargo sqlx prepare`",
      "title": "Setup project foundation with database layer"
    },
    {
      "dependencies": [
        "1"
      ],
      "description": "Build the authentication layer with JWT token generation, validation, refresh capability, and Axum extractors. This provides the security foundation for protected task endpoints.",
      "details": "1. Add auth dependencies to Cargo.toml:\n   - jsonwebtoken = \"9.3\"\n   - argon2 = \"0.5\" (for password hashing, modern and secure)\n   - tower-http = { workspace = true }\n\n2. Create auth configuration in `src/auth/config.rs`:\n   ```rust\n   pub struct AuthConfig {\n       pub jwt_secret: String,\n       pub access_token_expiry: Duration,  // 15 minutes\n       pub refresh_token_expiry: Duration, // 7 days\n   }\n   ```\n\n3. Implement JWT claims in `src/auth/jwt.rs`:\n   ```rust\n   #[derive(Debug, Serialize, Deserialize)]\n   pub struct Claims {\n       pub sub: Uuid,  // user_id\n       pub exp: usize, // expiration timestamp\n       pub iat: usize, // issued at\n       pub token_type: TokenType, // access or refresh\n   }\n   \n   pub fn create_token(user_id: Uuid, config: &AuthConfig, token_type: TokenType) -> Result<String>\n   pub fn validate_token(token: &str, secret: &str) -> Result<Claims>\n   ```\n\n4. Create Axum extractor in `src/auth/extractor.rs`:\n   ```rust\n   pub struct AuthUser(pub Uuid);\n   \n   #[async_trait]\n   impl<S> FromRequestParts<S> for AuthUser\n   where S: Send + Sync {\n       type Rejection = AuthError;\n       async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {\n           // Extract Bearer token from Authorization header\n           // Validate JWT and return AuthUser(claims.sub)\n       }\n   }\n   ```\n\n5. Implement password hashing with argon2:\n   ```rust\n   pub fn hash_password(password: &str) -> Result<String>\n   pub fn verify_password(password: &str, hash: &str) -> Result<bool>\n   ```\n\n6. Create auth endpoints in `src/auth/handlers.rs`:\n   - POST /auth/register - create user with hashed password\n   - POST /auth/login - verify credentials, return access + refresh tokens\n   - POST /auth/refresh - exchange refresh token for new access token\n   - POST /auth/logout - (stateless, client discards token)\n\n7. Follow codebase error pattern: create AuthError enum with thiserror",
      "id": "2",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Unit test JWT token creation and validation with various expiry scenarios\n2. Unit test password hashing: verify hash_password produces valid argon2 hash, verify_password correctly validates\n3. Integration test: register user → login → verify token works → access protected endpoint\n4. Test token expiration: create expired token, verify rejection\n5. Test refresh flow: use refresh token to get new access token\n6. Test invalid credentials return 401 Unauthorized\n7. Test malformed JWT tokens are rejected",
      "title": "Implement JWT authentication system"
    },
    {
      "dependencies": [
        "1",
        "2"
      ],
      "description": "Implement the core task management REST API with all CRUD operations, filtering, and pagination. Tasks are user-scoped and require authentication.",
      "details": "1. Create task repository in `src/tasks/repository.rs`:\n   ```rust\n   pub struct TaskRepository {\n       pool: PgPool,\n   }\n   \n   impl TaskRepository {\n       pub async fn create(&self, user_id: Uuid, input: CreateTask) -> Result<Task>\n       pub async fn get_by_id(&self, user_id: Uuid, task_id: Uuid) -> Result<Option<Task>>\n       pub async fn list(&self, user_id: Uuid, filter: TaskFilter) -> Result<Vec<Task>>\n       pub async fn update(&self, user_id: Uuid, task_id: Uuid, input: UpdateTask) -> Result<Task>\n       pub async fn delete(&self, user_id: Uuid, task_id: Uuid) -> Result<()>\n   }\n   ```\n\n2. Define DTOs in `src/tasks/dto.rs`:\n   ```rust\n   #[derive(Deserialize)]\n   pub struct CreateTask {\n       pub title: String,\n       pub description: Option<String>,\n       pub priority: Option<TaskPriority>,\n   }\n   \n   #[derive(Deserialize)]\n   pub struct UpdateTask {\n       pub title: Option<String>,\n       pub description: Option<String>,\n       pub status: Option<TaskStatus>,\n       pub priority: Option<TaskPriority>,\n   }\n   \n   #[derive(Deserialize)]\n   pub struct TaskFilter {\n       pub status: Option<TaskStatus>,\n       pub priority: Option<TaskPriority>,\n       pub limit: Option<i64>,\n       pub offset: Option<i64>,\n   }\n   ```\n\n3. Create task handlers in `src/tasks/handlers.rs`:\n   ```rust\n   pub async fn create_task(\n       AuthUser(user_id): AuthUser,\n       State(state): State<AppState>,\n       Json(input): Json<CreateTask>,\n   ) -> Result<Json<Task>, ApiError>\n   \n   pub async fn get_task(\n       AuthUser(user_id): AuthUser,\n       State(state): State<AppState>,\n       Path(task_id): Path<Uuid>,\n   ) -> Result<Json<Task>, ApiError>\n   \n   pub async fn list_tasks(\n       AuthUser(user_id): AuthUser,\n       State(state): State<AppState>,\n       Query(filter): Query<TaskFilter>,\n   ) -> Result<Json<Vec<Task>>, ApiError>\n   \n   pub async fn update_task(...) -> Result<Json<Task>, ApiError>\n   pub async fn delete_task(...) -> Result<StatusCode, ApiError>\n   ```\n\n4. Build router following codebase pattern in `src/tasks/router.rs`:\n   ```rust\n   pub fn task_routes() -> Router<AppState> {\n       Router::new()\n           .route(\"/tasks\", post(create_task).get(list_tasks))\n           .route(\"/tasks/:id\", get(get_task).put(update_task).delete(delete_task))\n   }\n   ```\n\n5. Use SQLx compile-time checked queries:\n   ```rust\n   sqlx::query_as!(Task, r#\"\n       SELECT id, user_id, title, description,\n              status as \"status: TaskStatus\",\n              priority as \"priority: TaskPriority\",\n              created_at, updated_at\n       FROM tasks WHERE user_id = $1 AND id = $2\n   \"#, user_id, task_id)\n   ```",
      "id": "3",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Integration tests for each endpoint with authenticated requests\n2. Test task isolation: user A cannot access user B's tasks (return 404, not 403)\n3. Test create task with all fields, with minimal fields (defaults applied)\n4. Test update with partial fields (PATCH-like behavior)\n5. Test delete returns 204 No Content\n6. Test list with filters: by status, by priority, with pagination\n7. Test 404 for non-existent task\n8. Test validation errors return 400 Bad Request\n9. Verify updated_at timestamp changes on update",
      "title": "Build task CRUD API endpoints"
    },
    {
      "dependencies": [
        "1",
        "2",
        "3"
      ],
      "description": "Assemble the complete Axum application with all routes, middleware (CORS, tracing, timeouts), shared state, and graceful shutdown following existing codebase patterns.",
      "details": "1. Create AppState in `src/state.rs`:\n   ```rust\n   #[derive(Clone)]\n   pub struct AppState {\n       pub db: PgPool,\n       pub auth_config: Arc<AuthConfig>,\n   }\n   ```\n\n2. Build main router in `src/router.rs` following codebase pattern:\n   ```rust\n   pub fn build_router(state: AppState) -> Router {\n       Router::new()\n           .route(\"/health\", get(health_check))\n           .route(\"/ready\", get(readiness_check))\n           .nest(\"/api/v1\", api_routes())\n           .layer(\n               ServiceBuilder::new()\n                   .layer(\n                       TraceLayer::new_for_http()\n                           .make_span_with(DefaultMakeSpan::new().level(Level::INFO))\n                           .on_request(DefaultOnRequest::new().level(Level::INFO))\n                           .on_response(DefaultOnResponse::new().level(Level::INFO)),\n                   )\n                   .layer(CorsLayer::permissive())  // Configure properly for production\n                   .layer(TimeoutLayer::new(Duration::from_secs(30)))\n           )\n           .with_state(state)\n   }\n   \n   fn api_routes() -> Router<AppState> {\n       Router::new()\n           .merge(auth_routes())\n           .merge(task_routes())\n   }\n   ```\n\n3. Implement health endpoints:\n   ```rust\n   async fn health_check() -> Json<Value> {\n       Json(json!({ \"status\": \"healthy\", \"service\": \"taskapi\" }))\n   }\n   \n   async fn readiness_check(State(state): State<AppState>) -> Result<Json<Value>, StatusCode> {\n       // Check database connectivity\n       sqlx::query(\"SELECT 1\").execute(&state.db).await?;\n       Ok(Json(json!({ \"status\": \"ready\" })))\n   }\n   ```\n\n4. Create main binary in `src/bin/taskapi.rs`:\n   ```rust\n   #[tokio::main]\n   async fn main() -> Result<(), Box<dyn std::error::Error>> {\n       // Initialize tracing (match codebase pattern)\n       tracing_subscriber::registry()\n           .with(tracing_subscriber::EnvFilter::try_from_default_env()\n               .unwrap_or_else(|_| \"info,taskapi=debug\".into()))\n           .with(tracing_subscriber::fmt::layer())\n           .init();\n       \n       // Load config from env\n       let database_url = std::env::var(\"DATABASE_URL\")?;\n       let jwt_secret = std::env::var(\"JWT_SECRET\")?;\n       \n       // Create connection pool\n       let pool = PgPoolOptions::new()\n           .max_connections(5)\n           .connect(&database_url).await?;\n       \n       // Run migrations\n       sqlx::migrate!().run(&pool).await?;\n       \n       // Build app\n       let state = AppState { db: pool, auth_config: Arc::new(auth_config) };\n       let app = build_router(state);\n       \n       // Start server with graceful shutdown\n       let listener = TcpListener::bind(\"0.0.0.0:8080\").await?;\n       info!(\"Task API listening on 0.0.0.0:8080\");\n       \n       axum::serve(listener, app)\n           .with_graceful_shutdown(shutdown_signal())\n           .await?;\n       \n       Ok(())\n   }\n   ```\n\n5. Add binary entry to Cargo.toml:\n   ```toml\n   [[bin]]\n   name = \"taskapi\"\n   path = \"src/bin/taskapi.rs\"\n   ```",
      "id": "4",
      "priority": "medium",
      "status": "pending",
      "test_strategy": "1. Start server locally and verify /health returns 200 with JSON body\n2. Verify /ready checks database connectivity (fails gracefully if DB down)\n3. Test CORS headers present in responses\n4. Verify request tracing appears in logs\n5. Test graceful shutdown: send SIGTERM, verify in-flight requests complete\n6. Test timeout middleware: slow handler should return 504 after 30s\n7. Integration test: full request flow from auth to task operations\n8. Verify Clippy pedantic passes: `cargo clippy -p taskapi -- -D warnings -W clippy::pedantic`",
      "title": "Configure HTTP server with middleware stack"
    },
    {
      "dependencies": [
        "3",
        "4"
      ],
      "description": "Implement robust input validation with helpful error messages and standardized API error responses. This polishes the API for production readiness.",
      "details": "1. Add validation dependency:\n   - validator = { version = \"0.18\", features = [\"derive\"] }\n\n2. Add validation to DTOs:\n   ```rust\n   use validator::Validate;\n   \n   #[derive(Deserialize, Validate)]\n   pub struct CreateTask {\n       #[validate(length(min = 1, max = 255, message = \"Title must be 1-255 characters\"))]\n       pub title: String,\n       #[validate(length(max = 5000, message = \"Description too long\"))]\n       pub description: Option<String>,\n       pub priority: Option<TaskPriority>,\n   }\n   \n   #[derive(Deserialize, Validate)]\n   pub struct RegisterUser {\n       #[validate(email(message = \"Invalid email format\"))]\n       pub email: String,\n       #[validate(length(min = 8, message = \"Password must be at least 8 characters\"))]\n       pub password: String,\n   }\n   ```\n\n3. Create ValidatedJson extractor:\n   ```rust\n   pub struct ValidatedJson<T>(pub T);\n   \n   #[async_trait]\n   impl<T, S> FromRequest<S> for ValidatedJson<T>\n   where\n       T: DeserializeOwned + Validate,\n       S: Send + Sync,\n   {\n       type Rejection = ApiError;\n       \n       async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {\n           let Json(value) = Json::<T>::from_request(req, state).await\n               .map_err(|e| ApiError::BadRequest(e.to_string()))?;\n           value.validate().map_err(|e| ApiError::ValidationError(e))?;\n           Ok(Self(value))\n       }\n   }\n   ```\n\n4. Create standardized error response in `src/error.rs`:\n   ```rust\n   #[derive(Debug, thiserror::Error)]\n   pub enum ApiError {\n       #[error(\"Bad request: {0}\")]\n       BadRequest(String),\n       #[error(\"Validation failed\")]\n       ValidationError(validator::ValidationErrors),\n       #[error(\"Unauthorized\")]\n       Unauthorized,\n       #[error(\"Not found\")]\n       NotFound,\n       #[error(\"Conflict: {0}\")]\n       Conflict(String),\n       #[error(\"Internal server error\")]\n       Internal(#[from] anyhow::Error),\n   }\n   \n   impl IntoResponse for ApiError {\n       fn into_response(self) -> Response {\n           let (status, body) = match &self {\n               ApiError::BadRequest(msg) => (StatusCode::BAD_REQUEST, json!({\"error\": msg})),\n               ApiError::ValidationError(e) => (StatusCode::BAD_REQUEST, json!({\"errors\": format_validation_errors(e)})),\n               ApiError::Unauthorized => (StatusCode::UNAUTHORIZED, json!({\"error\": \"Unauthorized\"})),\n               ApiError::NotFound => (StatusCode::NOT_FOUND, json!({\"error\": \"Not found\"})),\n               ApiError::Conflict(msg) => (StatusCode::CONFLICT, json!({\"error\": msg})),\n               ApiError::Internal(_) => {\n                   tracing::error!(\"Internal error: {:?}\", self);\n                   (StatusCode::INTERNAL_SERVER_ERROR, json!({\"error\": \"Internal server error\"}))\n               }\n           };\n           (status, Json(body)).into_response()\n       }\n   }\n   ```\n\n5. Update handlers to use ValidatedJson:\n   ```rust\n   pub async fn create_task(\n       AuthUser(user_id): AuthUser,\n       State(state): State<AppState>,\n       ValidatedJson(input): ValidatedJson<CreateTask>,\n   ) -> Result<Json<Task>, ApiError>\n   ```\n\n6. Add duplicate email check on registration returning 409 Conflict",
      "id": "5",
      "priority": "medium",
      "status": "pending",
      "test_strategy": "1. Test title validation: empty string, > 255 chars both return 400 with clear message\n2. Test email validation: invalid format returns 400\n3. Test password validation: < 8 chars returns 400\n4. Test description max length validation\n5. Verify error response format is consistent JSON structure\n6. Test duplicate email registration returns 409 Conflict\n7. Test internal errors don't leak stack traces (return generic message)\n8. Verify all validation errors are aggregated (not just first error)\n9. Run full test suite: `cargo test -p taskapi`\n10. Verify linting passes: `cargo clippy -p taskapi -- -D warnings -W clippy::pedantic`",
      "title": "Add input validation and comprehensive error handling"
    }
  ],
  "theme_coverage": 100.0,
  "themes_covered": [
    "task",
    "error",
    "api",
    "database",
    "project",
    "auth",
    "jwt"
  ]
}