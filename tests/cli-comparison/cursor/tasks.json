{
  "cli": "cursor",
  "duration_ms": 88665,
  "error": null,
  "model": "opus-4.5-thinking",
  "success": true,
  "task_count": 5,
  "tasks": [
    {
      "dependencies": [],
      "description": "Initialize the Rust project with Axum web framework, SQLx for PostgreSQL database access, and essential dependencies. Establish the project structure, configuration management, and database connection pooling.",
      "details": "1. Create new Cargo project with workspace structure:\n   ```\n   task-manager-api/\n   ├── Cargo.toml\n   ├── src/\n   │   ├── main.rs\n   │   ├── config.rs\n   │   ├── db.rs\n   │   ├── error.rs\n   │   └── routes/mod.rs\n   └── migrations/\n   ```\n\n2. Add dependencies to Cargo.toml:\n   - axum = \"0.8.4\"\n   - tokio = { version = \"1.40\", features = [\"full\"] }\n   - sqlx = { version = \"0.8\", features = [\"runtime-tokio\", \"postgres\", \"uuid\", \"chrono\"] }\n   - tower = \"0.5\"\n   - tower-http = { version = \"0.6\", features = [\"trace\", \"cors\", \"timeout\"] }\n   - serde = { version = \"1.0\", features = [\"derive\"] }\n   - serde_json = \"1.0\"\n   - tracing = \"0.1\"\n   - tracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\n   - thiserror = \"2.0\"\n   - anyhow = \"1.0\"\n   - uuid = { version = \"1.10\", features = [\"v4\", \"serde\"] }\n   - chrono = { version = \"0.4\", features = [\"serde\"] }\n   - dotenvy = \"0.15\"\n\n3. Create config.rs with environment-based configuration:\n   ```rust\n   pub struct Config {\n       pub database_url: String,\n       pub jwt_secret: String,\n       pub server_port: u16,\n   }\n   impl Config {\n       pub fn from_env() -> Result<Self, anyhow::Error> { ... }\n   }\n   ```\n\n4. Create db.rs with SQLx connection pool:\n   ```rust\n   pub type DbPool = sqlx::PgPool;\n   pub async fn create_pool(database_url: &str) -> Result<DbPool, sqlx::Error> {\n       PgPoolOptions::new()\n           .max_connections(5)\n           .connect(database_url).await\n   }\n   ```\n\n5. Create error.rs with custom error types using thiserror:\n   ```rust\n   #[derive(Debug, thiserror::Error)]\n   pub enum AppError {\n       #[error(\"Database error: {0}\")]\n       Database(#[from] sqlx::Error),\n       #[error(\"Not found\")]\n       NotFound,\n       // ...\n   }\n   impl IntoResponse for AppError { ... }\n   ```\n\n6. Set up main.rs with basic Axum server following workspace patterns:\n   ```rust\n   let app = Router::new()\n       .route(\"/health\", get(health_check))\n       .layer(TraceLayer::new_for_http())\n       .with_state(app_state);\n   ```",
      "id": "1",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Verify `cargo build` succeeds without warnings\n2. Run `cargo clippy --all-targets -- -D warnings` passes\n3. Test database connection with `sqlx database create` and `sqlx migrate run`\n4. Verify health endpoint returns 200 OK with JSON response\n5. Test graceful shutdown handling with SIGTERM",
      "title": "Setup project foundation with Axum and PostgreSQL"
    },
    {
      "dependencies": [
        "1"
      ],
      "description": "Create SQLx migrations for users and tasks tables with proper constraints, indexes, and enum types for task status and priority. Implement the domain models with SQLx FromRow derive.",
      "details": "1. Create migration for users table (migrations/001_create_users.sql):\n   ```sql\n   CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n   \n   CREATE TABLE users (\n       id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n       email VARCHAR(255) UNIQUE NOT NULL,\n       password_hash VARCHAR(255) NOT NULL,\n       created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n       updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n   );\n   CREATE INDEX idx_users_email ON users(email);\n   ```\n\n2. Create migration for tasks table (migrations/002_create_tasks.sql):\n   ```sql\n   CREATE TYPE task_status AS ENUM ('pending', 'in_progress', 'done');\n   CREATE TYPE task_priority AS ENUM ('low', 'medium', 'high');\n   \n   CREATE TABLE tasks (\n       id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n       user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n       title VARCHAR(255) NOT NULL,\n       description TEXT,\n       status task_status NOT NULL DEFAULT 'pending',\n       priority task_priority NOT NULL DEFAULT 'medium',\n       created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n       updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n   );\n   CREATE INDEX idx_tasks_user_id ON tasks(user_id);\n   CREATE INDEX idx_tasks_status ON tasks(status);\n   ```\n\n3. Create src/models/mod.rs with domain types:\n   ```rust\n   #[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]\n   #[sqlx(type_name = \"task_status\", rename_all = \"snake_case\")]\n   pub enum TaskStatus { Pending, InProgress, Done }\n   \n   #[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]\n   #[sqlx(type_name = \"task_priority\", rename_all = \"snake_case\")]\n   pub enum TaskPriority { Low, Medium, High }\n   \n   #[derive(Debug, Clone, Serialize, sqlx::FromRow)]\n   pub struct User {\n       pub id: Uuid,\n       pub email: String,\n       #[serde(skip_serializing)]\n       pub password_hash: String,\n       pub created_at: DateTime<Utc>,\n       pub updated_at: DateTime<Utc>,\n   }\n   \n   #[derive(Debug, Clone, Serialize, sqlx::FromRow)]\n   pub struct Task {\n       pub id: Uuid,\n       pub user_id: Uuid,\n       pub title: String,\n       pub description: Option<String>,\n       pub status: TaskStatus,\n       pub priority: TaskPriority,\n       pub created_at: DateTime<Utc>,\n       pub updated_at: DateTime<Utc>,\n   }\n   ```\n\n4. Create src/repositories/ with user and task repository traits and implementations",
      "id": "2",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Run `sqlx migrate run` successfully against test database\n2. Write unit tests for model serialization/deserialization\n3. Test enum type mapping with SQLx round-trip queries\n4. Verify foreign key constraints work (cascade delete)\n5. Test index performance with EXPLAIN ANALYZE on common queries",
      "title": "Implement database schema and migrations for users and tasks"
    },
    {
      "dependencies": [
        "1",
        "2"
      ],
      "description": "Build JWT-based authentication with login, logout, and token refresh endpoints. Implement password hashing with argon2, JWT token generation/validation with jsonwebtoken crate, and Axum middleware extractor for protected routes.",
      "details": "1. Add authentication dependencies:\n   - jsonwebtoken = \"9.3\"\n   - argon2 = \"0.5\"\n\n2. Create src/auth/mod.rs with JWT handling:\n   ```rust\n   #[derive(Debug, Serialize, Deserialize)]\n   pub struct Claims {\n       pub sub: Uuid,  // user_id\n       pub exp: i64,   // expiration timestamp\n       pub iat: i64,   // issued at\n   }\n   \n   pub fn create_token(user_id: Uuid, secret: &str) -> Result<String, AppError> {\n       let claims = Claims {\n           sub: user_id,\n           exp: (Utc::now() + Duration::hours(24)).timestamp(),\n           iat: Utc::now().timestamp(),\n       };\n       encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_ref()))\n   }\n   \n   pub fn verify_token(token: &str, secret: &str) -> Result<Claims, AppError> {\n       decode::<Claims>(token, &DecodingKey::from_secret(secret.as_ref()), &Validation::default())\n   }\n   ```\n\n3. Create Axum extractor for authenticated requests:\n   ```rust\n   pub struct AuthUser(pub Uuid);\n   \n   #[async_trait]\n   impl<S> FromRequestParts<S> for AuthUser\n   where\n       S: Send + Sync,\n       AppState: FromRef<S>,\n   {\n       type Rejection = AppError;\n       \n       async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {\n           let auth_header = parts.headers.get(AUTHORIZATION)\n               .and_then(|h| h.to_str().ok())\n               .and_then(|h| h.strip_prefix(\"Bearer \"))\n               .ok_or(AppError::Unauthorized)?;\n           \n           let state = AppState::from_ref(state);\n           let claims = verify_token(auth_header, &state.config.jwt_secret)?;\n           Ok(AuthUser(claims.sub))\n       }\n   }\n   ```\n\n4. Create auth routes (src/routes/auth.rs):\n   ```rust\n   pub fn auth_routes() -> Router<AppState> {\n       Router::new()\n           .route(\"/register\", post(register))\n           .route(\"/login\", post(login))\n           .route(\"/refresh\", post(refresh_token))\n           .route(\"/logout\", post(logout))\n   }\n   \n   async fn register(State(state): State<AppState>, Json(req): Json<RegisterRequest>) -> Result<Json<AuthResponse>, AppError> {\n       let password_hash = hash_password(&req.password)?;\n       // Insert user, return token\n   }\n   \n   async fn login(State(state): State<AppState>, Json(req): Json<LoginRequest>) -> Result<Json<AuthResponse>, AppError> {\n       let user = get_user_by_email(&state.db, &req.email).await?;\n       verify_password(&req.password, &user.password_hash)?;\n       let token = create_token(user.id, &state.config.jwt_secret)?;\n       Ok(Json(AuthResponse { token, user_id: user.id }))\n   }\n   ```\n\n5. Password hashing with argon2:\n   ```rust\n   pub fn hash_password(password: &str) -> Result<String, AppError> {\n       let salt = SaltString::generate(&mut OsRng);\n       let argon2 = Argon2::default();\n       Ok(argon2.hash_password(password.as_bytes(), &salt)?.to_string())\n   }\n   ```",
      "id": "3",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Unit test JWT token creation and validation\n2. Test token expiration handling\n3. Test password hashing and verification\n4. Integration test login flow: register → login → access protected route\n5. Test invalid/expired token rejection\n6. Test refresh token flow\n7. Verify password is never returned in responses",
      "title": "Implement JWT authentication system"
    },
    {
      "dependencies": [
        "2",
        "3"
      ],
      "description": "Create RESTful endpoints for task management including create, read (single and list with filtering), update, and delete operations. All endpoints require authentication and scope tasks to the authenticated user.",
      "details": "1. Create task routes (src/routes/tasks.rs):\n   ```rust\n   pub fn task_routes() -> Router<AppState> {\n       Router::new()\n           .route(\"/\", get(list_tasks).post(create_task))\n           .route(\"/{id}\", get(get_task).put(update_task).delete(delete_task))\n   }\n   ```\n\n2. Define request/response DTOs:\n   ```rust\n   #[derive(Debug, Deserialize)]\n   pub struct CreateTaskRequest {\n       pub title: String,\n       pub description: Option<String>,\n       pub priority: Option<TaskPriority>,\n   }\n   \n   #[derive(Debug, Deserialize)]\n   pub struct UpdateTaskRequest {\n       pub title: Option<String>,\n       pub description: Option<String>,\n       pub status: Option<TaskStatus>,\n       pub priority: Option<TaskPriority>,\n   }\n   \n   #[derive(Debug, Deserialize)]\n   pub struct ListTasksQuery {\n       pub status: Option<TaskStatus>,\n       pub priority: Option<TaskPriority>,\n       pub limit: Option<i64>,\n       pub offset: Option<i64>,\n   }\n   ```\n\n3. Implement handlers with user scoping:\n   ```rust\n   async fn create_task(\n       State(state): State<AppState>,\n       AuthUser(user_id): AuthUser,\n       Json(req): Json<CreateTaskRequest>,\n   ) -> Result<(StatusCode, Json<Task>), AppError> {\n       let task = sqlx::query_as::<_, Task>(\n           r#\"INSERT INTO tasks (user_id, title, description, priority)\n              VALUES ($1, $2, $3, $4)\n              RETURNING *\"#\n       )\n       .bind(user_id)\n       .bind(&req.title)\n       .bind(&req.description)\n       .bind(req.priority.unwrap_or(TaskPriority::Medium))\n       .fetch_one(&state.db)\n       .await?;\n       \n       Ok((StatusCode::CREATED, Json(task)))\n   }\n   \n   async fn list_tasks(\n       State(state): State<AppState>,\n       AuthUser(user_id): AuthUser,\n       Query(params): Query<ListTasksQuery>,\n   ) -> Result<Json<Vec<Task>>, AppError> {\n       let mut query = QueryBuilder::new(\n           \"SELECT * FROM tasks WHERE user_id = \"\n       );\n       query.push_bind(user_id);\n       \n       if let Some(status) = params.status {\n           query.push(\" AND status = \").push_bind(status);\n       }\n       // ... build dynamic query\n   }\n   \n   async fn get_task(\n       State(state): State<AppState>,\n       AuthUser(user_id): AuthUser,\n       Path(task_id): Path<Uuid>,\n   ) -> Result<Json<Task>, AppError> {\n       sqlx::query_as::<_, Task>(\n           \"SELECT * FROM tasks WHERE id = $1 AND user_id = $2\"\n       )\n       .bind(task_id)\n       .bind(user_id)\n       .fetch_optional(&state.db)\n       .await?\n       .ok_or(AppError::NotFound)\n       .map(Json)\n   }\n   ```\n\n4. Wire routes in main.rs:\n   ```rust\n   let app = Router::new()\n       .route(\"/health\", get(health_check))\n       .nest(\"/api/auth\", auth_routes())\n       .nest(\"/api/tasks\", task_routes())\n       .layer(TraceLayer::new_for_http())\n       .with_state(app_state);\n   ```",
      "id": "4",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Test CRUD operations with valid authentication\n2. Verify user isolation (user A cannot access user B's tasks)\n3. Test filtering by status and priority\n4. Test pagination with limit/offset\n5. Test 404 for non-existent tasks\n6. Test 401 for unauthenticated requests\n7. Test partial updates (PATCH semantics via PUT)\n8. Verify updated_at timestamp changes on update",
      "title": "Implement Task CRUD API endpoints"
    },
    {
      "dependencies": [
        "3",
        "4"
      ],
      "description": "Implement comprehensive input validation using validator crate, standardize error responses, add request/response logging, and generate OpenAPI documentation with utoipa for API discoverability.",
      "details": "1. Add validation dependencies:\n   - validator = { version = \"0.18\", features = [\"derive\"] }\n   - utoipa = { version = \"5.3\", features = [\"axum_extras\", \"chrono\", \"uuid\"] }\n   - utoipa-swagger-ui = { version = \"8.1\", features = [\"axum\"] }\n\n2. Add validation to request DTOs:\n   ```rust\n   use validator::Validate;\n   \n   #[derive(Debug, Deserialize, Validate)]\n   pub struct CreateTaskRequest {\n       #[validate(length(min = 1, max = 255, message = \"Title must be 1-255 characters\"))]\n       pub title: String,\n       #[validate(length(max = 10000, message = \"Description too long\"))]\n       pub description: Option<String>,\n       pub priority: Option<TaskPriority>,\n   }\n   \n   #[derive(Debug, Deserialize, Validate)]\n   pub struct RegisterRequest {\n       #[validate(email(message = \"Invalid email format\"))]\n       pub email: String,\n       #[validate(length(min = 8, message = \"Password must be at least 8 characters\"))]\n       pub password: String,\n   }\n   ```\n\n3. Create validation extractor:\n   ```rust\n   pub struct ValidatedJson<T>(pub T);\n   \n   #[async_trait]\n   impl<T, S> FromRequest<S> for ValidatedJson<T>\n   where\n       T: DeserializeOwned + Validate,\n       S: Send + Sync,\n   {\n       type Rejection = AppError;\n       \n       async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {\n           let Json(value) = Json::<T>::from_request(req, state).await\n               .map_err(|e| AppError::BadRequest(e.to_string()))?;\n           value.validate().map_err(|e| AppError::Validation(e))?;\n           Ok(ValidatedJson(value))\n       }\n   }\n   ```\n\n4. Standardize error responses:\n   ```rust\n   #[derive(Debug, Serialize)]\n   pub struct ErrorResponse {\n       pub error: String,\n       pub code: String,\n       #[serde(skip_serializing_if = \"Option::is_none\")]\n       pub details: Option<serde_json::Value>,\n   }\n   \n   impl IntoResponse for AppError {\n       fn into_response(self) -> Response {\n           let (status, error_response) = match self {\n               AppError::NotFound => (StatusCode::NOT_FOUND, ErrorResponse { ... }),\n               AppError::Unauthorized => (StatusCode::UNAUTHORIZED, ErrorResponse { ... }),\n               AppError::Validation(e) => (StatusCode::BAD_REQUEST, ErrorResponse {\n                   error: \"Validation failed\".into(),\n                   code: \"VALIDATION_ERROR\".into(),\n                   details: Some(serde_json::to_value(e.field_errors()).unwrap()),\n               }),\n               // ...\n           };\n           (status, Json(error_response)).into_response()\n       }\n   }\n   ```\n\n5. Add OpenAPI documentation with utoipa:\n   ```rust\n   #[derive(OpenApi)]\n   #[openapi(\n       paths(\n           routes::auth::register,\n           routes::auth::login,\n           routes::tasks::create_task,\n           routes::tasks::list_tasks,\n           // ...\n       ),\n       components(schemas(Task, CreateTaskRequest, AuthResponse, ErrorResponse)),\n       tags((name = \"auth\", description = \"Authentication endpoints\")),\n       tags((name = \"tasks\", description = \"Task management endpoints\")),\n   )]\n   struct ApiDoc;\n   \n   // In main.rs:\n   .merge(SwaggerUi::new(\"/swagger-ui\").url(\"/api-docs/openapi.json\", ApiDoc::openapi()))\n   ```\n\n6. Add request ID middleware for tracing:\n   ```rust\n   async fn add_request_id(mut req: Request, next: Next) -> Response {\n       let request_id = Uuid::new_v4().to_string();\n       req.extensions_mut().insert(RequestId(request_id.clone()));\n       let mut response = next.run(req).await;\n       response.headers_mut().insert(\"x-request-id\", request_id.parse().unwrap());\n       response\n   }\n   ```",
      "id": "5",
      "priority": "medium",
      "status": "pending",
      "test_strategy": "1. Test validation errors return 400 with detailed field errors\n2. Test all error types return consistent JSON structure\n3. Verify x-request-id header present in all responses\n4. Test OpenAPI spec generates valid JSON at /api-docs/openapi.json\n5. Verify Swagger UI loads at /swagger-ui\n6. Test rate limiting behavior (if implemented)\n7. End-to-end test: invalid email format → proper validation message\n8. Run `cargo clippy --all-targets -- -D warnings` passes",
      "title": "Add input validation, error handling, and API documentation"
    }
  ],
  "theme_coverage": 100.0,
  "themes_covered": [
    "project",
    "error",
    "auth",
    "database",
    "task",
    "api",
    "jwt"
  ]
}