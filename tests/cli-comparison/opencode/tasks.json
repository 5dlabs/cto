{
  "cli": "opencode",
  "duration_ms": 175074,
  "error": null,
  "model": "anthropic/claude-opus-4-5",
  "success": true,
  "task_count": 5,
  "tasks": [
    {
      "dependencies": [],
      "description": "Initialize the Rust project with Axum framework, PostgreSQL connection via SQLx, and establish the foundational project structure with proper error handling patterns.",
      "details": "1. Initialize Cargo project:\n   cargo new task-manager-api && cd task-manager-api\n\n2. Configure Cargo.toml with dependencies:\n   ```toml\n   [dependencies]\n   axum = \"0.8\"\n   tokio = { version = \"1.40\", features = [\"full\"] }\n   tower-http = { version = \"0.5\", features = [\"trace\", \"cors\"] }\n   sqlx = { version = \"0.8\", features = [\"runtime-tokio\", \"tls-rustls-ring\", \"postgres\", \"uuid\", \"chrono\"] }\n   serde = { version = \"1.0\", features = [\"derive\"] }\n   serde_json = \"1.0\"\n   thiserror = \"2.0\"\n   anyhow = \"1.0\"\n   tracing = \"0.1\"\n   tracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\n   uuid = { version = \"1.0\", features = [\"v4\", \"serde\"] }\n   chrono = { version = \"0.4\", features = [\"serde\"] }\n   dotenvy = \"0.15\"\n   ```\n\n3. Create project structure:\n   src/\n   ├── main.rs           # Entry point, server bootstrap\n   ├── config.rs         # Environment configuration\n   ├── db/\n   │   ├── mod.rs\n   │   └── pool.rs       # PgPool setup with connection limits\n   ├── api/\n   │   ├── mod.rs\n   │   ├── routes.rs     # Router composition\n   │   └── handlers/     # Request handlers\n   ├── domain/\n   │   ├── mod.rs\n   │   └── errors.rs     # AppError with IntoResponse impl\n   └── services/\n\n4. Implement AppError enum with thiserror:\n   ```rust\n   #[derive(Error, Debug)]\n   pub enum AppError {\n       #[error(\"Not found\")] NotFound,\n       #[error(\"Unauthorized\")] Unauthorized,\n       #[error(\"Bad request: {0}\")] BadRequest(String),\n       #[error(\"Database error\")] Database(#[from] sqlx::Error),\n       #[error(\"Internal error\")] Internal(#[from] anyhow::Error),\n   }\n   ```\n\n5. Setup PgPool with connection pooling:\n   ```rust\n   PgPoolOptions::new()\n       .max_connections(20)\n       .min_connections(5)\n       .acquire_timeout(Duration::from_secs(3))\n       .connect(&database_url).await\n   ```\n\n6. Create AppState struct holding PgPool and config\n\n7. Bootstrap main.rs with tracing, router, and graceful shutdown",
      "id": "1",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Verify `cargo build` succeeds with no warnings\n2. Verify `cargo clippy -- -D warnings` passes\n3. Write integration test that app starts and /health endpoint returns 200 OK\n4. Verify database connection succeeds with valid DATABASE_URL\n5. Test that invalid DATABASE_URL produces clear error message",
      "title": "Setup Rust project with Axum and database infrastructure"
    },
    {
      "dependencies": [
        "1"
      ],
      "description": "Create PostgreSQL migrations for users table (authentication) and tasks table (task management) using sqlx-cli, establishing the data model foundation.",
      "details": "1. Install sqlx-cli:\n   cargo install sqlx-cli --no-default-features --features postgres\n\n2. Create migrations directory and .env file:\n   DATABASE_URL=postgres://user:pass@localhost:5432/task_manager\n\n3. Create users migration:\n   sqlx migrate add create_users_table\n   ```sql\n   CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n   \n   CREATE TABLE users (\n       id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n       email VARCHAR(255) NOT NULL UNIQUE,\n       password_hash VARCHAR(255) NOT NULL,\n       created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n       updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n   );\n   \n   CREATE INDEX idx_users_email ON users(email);\n   ```\n\n4. Create tasks migration:\n   sqlx migrate add create_tasks_table\n   ```sql\n   CREATE TYPE task_status AS ENUM ('pending', 'in_progress', 'done');\n   CREATE TYPE task_priority AS ENUM ('low', 'medium', 'high');\n   \n   CREATE TABLE tasks (\n       id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n       user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n       title VARCHAR(255) NOT NULL,\n       description TEXT,\n       status task_status NOT NULL DEFAULT 'pending',\n       priority task_priority NOT NULL DEFAULT 'medium',\n       created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n       updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n   );\n   \n   CREATE INDEX idx_tasks_user_id ON tasks(user_id);\n   CREATE INDEX idx_tasks_status ON tasks(status);\n   ```\n\n5. Create refresh_tokens table for JWT refresh:\n   sqlx migrate add create_refresh_tokens_table\n   ```sql\n   CREATE TABLE refresh_tokens (\n       id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n       user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n       token_hash VARCHAR(255) NOT NULL UNIQUE,\n       expires_at TIMESTAMPTZ NOT NULL,\n       revoked BOOLEAN NOT NULL DEFAULT FALSE,\n       created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n   );\n   \n   CREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);\n   ```\n\n6. Run migrations: sqlx migrate run\n\n7. Create Rust domain models:\n   ```rust\n   #[derive(Debug, sqlx::FromRow, Serialize)]\n   pub struct User {\n       pub id: Uuid,\n       pub email: String,\n       #[serde(skip)] pub password_hash: String,\n       pub created_at: DateTime<Utc>,\n   }\n   \n   #[derive(Debug, sqlx::Type, Serialize, Deserialize)]\n   #[sqlx(type_name = \"task_status\", rename_all = \"snake_case\")]\n   pub enum TaskStatus { Pending, InProgress, Done }\n   \n   #[derive(Debug, sqlx::Type, Serialize, Deserialize)]\n   #[sqlx(type_name = \"task_priority\", rename_all = \"snake_case\")]\n   pub enum TaskPriority { Low, Medium, High }\n   ```",
      "id": "2",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Run `sqlx migrate run` and verify all migrations apply cleanly\n2. Run `sqlx migrate revert` and `sqlx migrate run` to test idempotency\n3. Verify foreign key constraint by attempting to insert task with invalid user_id\n4. Verify enum types work correctly with test inserts\n5. Test unique constraint on users.email\n6. Verify indexes exist using pg_indexes query",
      "title": "Implement database schema and migrations for users and tasks"
    },
    {
      "dependencies": [
        "1",
        "2"
      ],
      "description": "Build complete authentication flow including user registration, login with JWT access token generation, and secure token refresh mechanism with rotation.",
      "details": "1. Add auth dependencies to Cargo.toml:\n   ```toml\n   jsonwebtoken = \"9.3\"\n   argon2 = \"0.5\"\n   rand = \"0.8\"\n   ```\n\n2. Create auth service (src/services/auth_service.rs):\n   ```rust\n   pub struct AuthService { pool: PgPool, jwt_secret: String }\n   \n   impl AuthService {\n       pub async fn register(&self, email: &str, password: &str) -> Result<User, AppError>;\n       pub async fn login(&self, email: &str, password: &str) -> Result<TokenPair, AppError>;\n       pub async fn refresh(&self, refresh_token: &str) -> Result<TokenPair, AppError>;\n       pub async fn logout(&self, user_id: Uuid) -> Result<(), AppError>;\n   }\n   ```\n\n3. Implement password hashing with Argon2:\n   ```rust\n   use argon2::{Argon2, PasswordHasher, PasswordVerifier, password_hash::SaltString};\n   \n   fn hash_password(password: &str) -> Result<String, AppError> {\n       let salt = SaltString::generate(&mut rand::thread_rng());\n       Ok(Argon2::default().hash_password(password.as_bytes(), &salt)?.to_string())\n   }\n   ```\n\n4. Implement JWT token generation:\n   ```rust\n   #[derive(Serialize, Deserialize)]\n   pub struct Claims {\n       pub sub: String,  // user_id\n       pub exp: usize,   // 15 minutes for access token\n       pub iat: usize,\n   }\n   \n   pub struct TokenPair {\n       pub access_token: String,\n       pub refresh_token: String,\n       pub expires_in: i64,\n   }\n   ```\n   - Access token: 15 minute expiry, HS256 algorithm\n   - Refresh token: 7 day expiry, stored hashed in DB\n\n5. Create auth middleware extractor:\n   ```rust\n   pub struct AuthUser(pub Uuid);\n   \n   impl<S> FromRequestParts<S> for AuthUser {\n       // Extract and validate Bearer token from Authorization header\n       // Decode JWT, validate expiry, return user_id\n   }\n   ```\n\n6. Create auth handlers (src/api/handlers/auth.rs):\n   ```rust\n   // POST /api/auth/register - CreateUserRequest { email, password }\n   // POST /api/auth/login - LoginRequest { email, password }\n   // POST /api/auth/refresh - RefreshRequest { refresh_token }\n   // POST /api/auth/logout - requires AuthUser\n   ```\n\n7. Implement refresh token rotation:\n   - On refresh, invalidate old token and issue new pair\n   - Hash refresh tokens before storing (SHA-256)\n   - Check revoked flag before accepting refresh\n\n8. Wire routes in router:\n   ```rust\n   Router::new()\n       .route(\"/api/auth/register\", post(register))\n       .route(\"/api/auth/login\", post(login))\n       .route(\"/api/auth/refresh\", post(refresh))\n       .route(\"/api/auth/logout\", post(logout))\n   ```",
      "id": "3",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Test registration creates user with hashed password (not plaintext)\n2. Test login returns valid JWT that decodes correctly\n3. Test login with wrong password returns 401\n4. Test duplicate email registration returns 400\n5. Test expired access token returns 401\n6. Test refresh token generates new valid access token\n7. Test refresh token rotation (old refresh token becomes invalid)\n8. Test logout invalidates refresh tokens\n9. Test AuthUser extractor rejects invalid/missing tokens\n10. Test password meets minimum requirements if implemented",
      "title": "Implement JWT authentication system with login, register, and token refresh"
    },
    {
      "dependencies": [
        "1",
        "2",
        "3"
      ],
      "description": "Build complete task management API with Create, Read, Update, Delete operations, ensuring users can only access their own tasks.",
      "details": "1. Create task repository (src/db/repositories/task_repo.rs):\n   ```rust\n   pub struct TaskRepository { pool: PgPool }\n   \n   impl TaskRepository {\n       pub async fn create(&self, user_id: Uuid, req: CreateTaskRequest) -> Result<Task, AppError>;\n       pub async fn find_by_id(&self, id: Uuid, user_id: Uuid) -> Result<Option<Task>, AppError>;\n       pub async fn find_all_by_user(&self, user_id: Uuid, filters: TaskFilters) -> Result<Vec<Task>, AppError>;\n       pub async fn update(&self, id: Uuid, user_id: Uuid, req: UpdateTaskRequest) -> Result<Task, AppError>;\n       pub async fn delete(&self, id: Uuid, user_id: Uuid) -> Result<(), AppError>;\n   }\n   ```\n\n2. Define request/response DTOs:\n   ```rust\n   #[derive(Deserialize)]\n   pub struct CreateTaskRequest {\n       pub title: String,\n       pub description: Option<String>,\n       pub priority: Option<TaskPriority>,  // defaults to medium\n   }\n   \n   #[derive(Deserialize)]\n   pub struct UpdateTaskRequest {\n       pub title: Option<String>,\n       pub description: Option<String>,\n       pub status: Option<TaskStatus>,\n       pub priority: Option<TaskPriority>,\n   }\n   \n   #[derive(Deserialize)]\n   pub struct TaskFilters {\n       pub status: Option<TaskStatus>,\n       pub priority: Option<TaskPriority>,\n   }\n   ```\n\n3. Implement handlers (src/api/handlers/tasks.rs):\n   ```rust\n   // All handlers require AuthUser extractor\n   \n   // POST /api/tasks\n   async fn create_task(\n       State(state): State<Arc<AppState>>,\n       AuthUser(user_id): AuthUser,\n       Json(req): Json<CreateTaskRequest>,\n   ) -> Result<impl IntoResponse, AppError> {\n       let task = state.task_repo.create(user_id, req).await?;\n       Ok((StatusCode::CREATED, Json(task)))\n   }\n   \n   // GET /api/tasks - list with optional status/priority filters\n   // GET /api/tasks/:id\n   // PUT /api/tasks/:id\n   // DELETE /api/tasks/:id\n   ```\n\n4. Implement SQL queries with compile-time checking:\n   ```rust\n   // Create\n   sqlx::query_as!(\n       Task,\n       r#\"INSERT INTO tasks (user_id, title, description, priority)\n          VALUES ($1, $2, $3, $4)\n          RETURNING id, user_id, title, description, \n                    status as \"status: TaskStatus\", \n                    priority as \"priority: TaskPriority\",\n                    created_at, updated_at\"#,\n       user_id, req.title, req.description, \n       req.priority.unwrap_or(TaskPriority::Medium) as TaskPriority\n   )\n   \n   // Update with dynamic fields\n   sqlx::query_as!(\n       Task,\n       r#\"UPDATE tasks SET \n          title = COALESCE($3, title),\n          description = COALESCE($4, description),\n          status = COALESCE($5, status),\n          priority = COALESCE($6, priority),\n          updated_at = NOW()\n          WHERE id = $1 AND user_id = $2\n          RETURNING ...\"#,\n       id, user_id, req.title, req.description, \n       req.status as Option<TaskStatus>, req.priority as Option<TaskPriority>\n   )\n   ```\n\n5. Wire routes (protected by auth):\n   ```rust\n   Router::new()\n       .route(\"/api/tasks\", post(create_task).get(list_tasks))\n       .route(\"/api/tasks/:id\", get(get_task).put(update_task).delete(delete_task))\n   ```\n\n6. Ensure authorization: All queries include `user_id` in WHERE clause",
      "id": "4",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Test create task returns 201 with valid task object\n2. Test create task without auth returns 401\n3. Test list tasks only returns current user's tasks\n4. Test get task by ID returns 404 for other user's task\n5. Test update task modifies only specified fields\n6. Test update task status transitions (pending -> in_progress -> done)\n7. Test delete task returns 204 and task is removed\n8. Test delete other user's task returns 404 (not 403, to avoid leaking existence)\n9. Test list tasks with status filter\n10. Test list tasks with priority filter\n11. Test input validation (empty title rejected)",
      "title": "Implement Task CRUD operations with user authorization"
    },
    {
      "dependencies": [
        "1",
        "2",
        "3",
        "4"
      ],
      "description": "Implement request validation, add OpenAPI documentation, configure CORS, rate limiting, and prepare the API for production deployment.",
      "details": "1. Add validation dependencies:\n   ```toml\n   validator = { version = \"0.18\", features = [\"derive\"] }\n   utoipa = { version = \"5.0\", features = [\"axum_extras\", \"uuid\", \"chrono\"] }\n   utoipa-swagger-ui = { version = \"8.0\", features = [\"axum\"] }\n   ```\n\n2. Add validation to request DTOs:\n   ```rust\n   use validator::Validate;\n   \n   #[derive(Deserialize, Validate)]\n   pub struct CreateTaskRequest {\n       #[validate(length(min = 1, max = 255))]\n       pub title: String,\n       #[validate(length(max = 5000))]\n       pub description: Option<String>,\n   }\n   \n   #[derive(Deserialize, Validate)]\n   pub struct RegisterRequest {\n       #[validate(email)]\n       pub email: String,\n       #[validate(length(min = 8, max = 128))]\n       pub password: String,\n   }\n   ```\n\n3. Create validation extractor:\n   ```rust\n   pub struct ValidatedJson<T>(pub T);\n   \n   impl<S, T> FromRequest<S> for ValidatedJson<T>\n   where T: DeserializeOwned + Validate {\n       // Deserialize then call .validate()\n       // Return 400 with validation errors if invalid\n   }\n   ```\n\n4. Add OpenAPI documentation with utoipa:\n   ```rust\n   #[derive(OpenApi)]\n   #[openapi(\n       paths(create_task, list_tasks, get_task, update_task, delete_task,\n             register, login, refresh, logout),\n       components(schemas(Task, CreateTaskRequest, UpdateTaskRequest, ...)),\n       tags((name = \"tasks\"), (name = \"auth\"))\n   )]\n   struct ApiDoc;\n   \n   // Add swagger UI route\n   Router::new()\n       .merge(SwaggerUi::new(\"/swagger-ui\").url(\"/api-docs/openapi.json\", ApiDoc::openapi()))\n   ```\n\n5. Configure CORS:\n   ```rust\n   use tower_http::cors::{CorsLayer, Any};\n   \n   let cors = CorsLayer::new()\n       .allow_origin(Any)  // Configure for production\n       .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE])\n       .allow_headers([AUTHORIZATION, CONTENT_TYPE]);\n   ```\n\n6. Add rate limiting (optional, using tower):\n   ```rust\n   use tower::limit::RateLimitLayer;\n   // Or use governor crate for more control\n   ```\n\n7. Add request tracing and logging:\n   ```rust\n   use tower_http::trace::TraceLayer;\n   \n   .layer(TraceLayer::new_for_http()\n       .make_span_with(|req| tracing::info_span!(\"request\", method = %req.method(), uri = %req.uri()))\n   )\n   ```\n\n8. Configure graceful shutdown:\n   ```rust\n   axum::serve(listener, app)\n       .with_graceful_shutdown(shutdown_signal())\n       .await\n   ```\n\n9. Add health check endpoint:\n   ```rust\n   // GET /health - returns 200 if DB connection is healthy\n   async fn health(State(state): State<Arc<AppState>>) -> impl IntoResponse {\n       match sqlx::query(\"SELECT 1\").execute(&state.pool).await {\n           Ok(_) => (StatusCode::OK, Json(json!({\"status\": \"healthy\"}))),\n           Err(_) => (StatusCode::SERVICE_UNAVAILABLE, Json(json!({\"status\": \"unhealthy\"}))),\n       }\n   }\n   ```\n\n10. Environment configuration:\n    - DATABASE_URL, JWT_SECRET (required)\n    - HOST, PORT, LOG_LEVEL (optional with defaults)",
      "id": "5",
      "priority": "medium",
      "status": "pending",
      "test_strategy": "1. Test validation rejects empty task title\n2. Test validation rejects invalid email format\n3. Test validation rejects password < 8 characters\n4. Test validation error response includes field names and messages\n5. Test OpenAPI spec is valid JSON at /api-docs/openapi.json\n6. Test Swagger UI loads at /swagger-ui\n7. Test CORS headers present in responses\n8. Test health endpoint returns healthy with valid DB\n9. Test health endpoint returns unhealthy with DB down\n10. Test graceful shutdown completes in-flight requests\n11. Test request tracing logs include request_id\n12. Integration test: full flow from register -> login -> create task -> list tasks",
      "title": "Add API validation, documentation, and production hardening"
    }
  ],
  "theme_coverage": 100.0,
  "themes_covered": [
    "error",
    "api",
    "task",
    "project",
    "database",
    "jwt",
    "docker",
    "auth"
  ]
}