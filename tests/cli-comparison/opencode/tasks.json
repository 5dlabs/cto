{
  "cli": "opencode",
  "duration_ms": 159529,
  "error": null,
  "model": "anthropic/claude-opus-4-5",
  "success": true,
  "task_count": 5,
  "tasks": [
    {
      "dependencies": [],
      "description": "Initialize the Rust project structure with all required dependencies, configuration, and database connection pool setup for the Task Manager API.",
      "details": "1. Create new Rust project with `cargo new task-manager-api`\n\n2. Configure Cargo.toml with dependencies:\n```toml\n[dependencies]\naxum = { version = \"0.8\", features = [\"macros\"] }\naxum-extra = { version = \"0.10\", features = [\"typed-header\"] }\ntokio = { version = \"1.44\", features = [\"full\"] }\ntower-http = { version = \"0.6\", features = [\"cors\", \"trace\"] }\njsonwebtoken = \"10.2\"\nsqlx = { version = \"0.8\", features = [\"runtime-tokio\", \"tls-rustls\", \"postgres\", \"uuid\", \"chrono\", \"migrate\"] }\nargon2 = { version = \"0.5\", features = [\"password-hash\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nchrono = { version = \"0.4\", features = [\"serde\"] }\nuuid = { version = \"1.0\", features = [\"v4\", \"serde\"] }\ndotenvy = \"0.15\"\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\nanyhow = \"1.0\"\nthiserror = \"2.0\"\n```\n\n3. Create project structure:\n```\nsrc/\n├── main.rs           # Entry point\n├── config.rs         # Config loading\n├── error.rs          # AppError type\n├── state.rs          # AppState with PgPool\n├── db/\n│   ├── mod.rs\n│   └── pool.rs       # Connection pool\n├── auth/\n│   └── mod.rs\n├── routes/\n│   └── mod.rs\n└── models/\n    └── mod.rs\nmigrations/\n```\n\n4. Implement database pool setup in `src/db/pool.rs`:\n```rust\nuse sqlx::postgres::{PgPool, PgPoolOptions};\nuse std::time::Duration;\n\npub async fn create_pool(database_url: &str) -> Result<PgPool, sqlx::Error> {\n    PgPoolOptions::new()\n        .max_connections(20)\n        .acquire_timeout(Duration::from_secs(3))\n        .connect(database_url)\n        .await\n}\n```\n\n5. Create AppState in `src/state.rs`:\n```rust\n#[derive(Clone)]\npub struct AppState {\n    pub db: PgPool,\n}\n```\n\n6. Setup basic main.rs with tracing, dotenvy, and health endpoint",
      "id": "1",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Run `cargo build` to verify all dependencies resolve\n2. Run `cargo clippy` for lint checks\n3. Create .env with DATABASE_URL pointing to test PostgreSQL\n4. Start server and verify GET /health returns 200 OK\n5. Verify tracing output appears in console\n6. Test database connection by checking pool connects successfully",
      "title": "Setup Rust project with Axum and dependencies"
    },
    {
      "dependencies": [
        "1"
      ],
      "description": "Design and implement PostgreSQL database schema for users and tasks tables with proper indexes and constraints using SQLx migrations.",
      "details": "1. Create migration file `migrations/20241207000001_initial_schema.sql`:\n```sql\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n-- Users table for authentication\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    email VARCHAR(255) NOT NULL UNIQUE,\n    password_hash TEXT NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_users_email ON users(email);\n\n-- Tasks table\nCREATE TYPE task_status AS ENUM ('pending', 'in_progress', 'done');\nCREATE TYPE task_priority AS ENUM ('low', 'medium', 'high');\n\nCREATE TABLE tasks (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    status task_status NOT NULL DEFAULT 'pending',\n    priority task_priority NOT NULL DEFAULT 'medium',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_tasks_user_id ON tasks(user_id);\nCREATE INDEX idx_tasks_status ON tasks(status);\nCREATE INDEX idx_tasks_priority ON tasks(priority);\n\n-- Refresh tokens for JWT refresh capability\nCREATE TABLE refresh_tokens (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    token_hash TEXT NOT NULL UNIQUE,\n    expires_at TIMESTAMPTZ NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);\n```\n\n2. Add migration runner to main.rs:\n```rust\nsqlx::migrate!(\"./migrations\").run(&pool).await?;\n```\n\n3. Create Rust models in `src/models/`:\n```rust\n// src/models/user.rs\n#[derive(Debug, Clone, sqlx::FromRow, Serialize)]\npub struct User {\n    pub id: Uuid,\n    pub email: String,\n    #[serde(skip_serializing)]\n    pub password_hash: String,\n    pub created_at: DateTime<Utc>,\n}\n\n// src/models/task.rs\n#[derive(Debug, Clone, sqlx::Type, Serialize, Deserialize)]\n#[sqlx(type_name = \"task_status\", rename_all = \"snake_case\")]\npub enum TaskStatus {\n    Pending,\n    InProgress,\n    Done,\n}\n\n#[derive(Debug, Clone, sqlx::Type, Serialize, Deserialize)]\n#[sqlx(type_name = \"task_priority\", rename_all = \"snake_case\")]\npub enum TaskPriority {\n    Low,\n    Medium,\n    High,\n}\n\n#[derive(Debug, Clone, sqlx::FromRow, Serialize)]\npub struct Task {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub title: String,\n    pub description: Option<String>,\n    pub status: TaskStatus,\n    pub priority: TaskPriority,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n```",
      "id": "2",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Run `sqlx migrate run` against test database\n2. Verify all tables created with `\\dt` in psql\n3. Verify enum types with `\\dT+`\n4. Test foreign key constraint by attempting orphan task insert\n5. Verify indexes exist with `\\di`\n6. Run `sqlx migrate info` to confirm migration status\n7. Test rollback capability if needed",
      "title": "Create database schema and migrations"
    },
    {
      "dependencies": [
        "1",
        "2"
      ],
      "description": "Build complete JWT authentication including password hashing with Argon2, token generation/validation, login/register endpoints, and token refresh capability.",
      "details": "1. Create password hashing module `src/auth/password.rs`:\n```rust\nuse argon2::{password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString}, Argon2};\n\npub fn hash_password(password: &str) -> Result<String, argon2::password_hash::Error> {\n    let salt = SaltString::generate(&mut OsRng);\n    let hash = Argon2::default().hash_password(password.as_bytes(), &salt)?;\n    Ok(hash.to_string())\n}\n\npub fn verify_password(password: &str, hash: &str) -> bool {\n    PasswordHash::new(hash)\n        .map(|h| Argon2::default().verify_password(password.as_bytes(), &h).is_ok())\n        .unwrap_or(false)\n}\n```\n\n2. Create JWT module `src/auth/jwt.rs`:\n```rust\nuse std::sync::LazyLock;\nuse jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey};\n\nstatic KEYS: LazyLock<Keys> = LazyLock::new(|| {\n    let secret = std::env::var(\"JWT_SECRET\").expect(\"JWT_SECRET required\");\n    Keys::new(secret.as_bytes())\n});\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Claims {\n    pub sub: String,  // user_id\n    pub email: String,\n    pub exp: usize,\n    pub iat: usize,\n}\n\nimpl Claims {\n    pub fn new(user_id: Uuid, email: &str, expires_in_secs: i64) -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            sub: user_id.to_string(),\n            email: email.to_owned(),\n            iat: now.timestamp() as usize,\n            exp: (now + chrono::Duration::seconds(expires_in_secs)).timestamp() as usize,\n        }\n    }\n}\n\npub fn create_access_token(claims: &Claims) -> Result<String, AuthError> { ... }\npub fn create_refresh_token(claims: &Claims) -> Result<String, AuthError> { ... }\npub fn verify_token(token: &str) -> Result<Claims, AuthError> { ... }\n```\n\n3. Implement FromRequestParts extractor for Claims (auto-auth middleware)\n\n4. Create auth routes `src/routes/auth.rs`:\n- POST /api/auth/register - Create user, hash password, return tokens\n- POST /api/auth/login - Verify credentials, return access + refresh tokens\n- POST /api/auth/refresh - Validate refresh token, issue new access token\n- POST /api/auth/logout - Invalidate refresh token in DB\n\n5. Token expiry strategy:\n- Access token: 15 minutes (900 seconds)\n- Refresh token: 7 days (604800 seconds)\n\n6. Store refresh token hash in DB for revocation support",
      "id": "3",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Unit test password hashing: hash then verify returns true\n2. Unit test password verification: wrong password returns false\n3. Unit test JWT creation and verification round-trip\n4. Unit test expired token rejection\n5. Integration test: POST /api/auth/register creates user, returns tokens\n6. Integration test: POST /api/auth/login with valid creds returns 200\n7. Integration test: POST /api/auth/login with invalid creds returns 401\n8. Integration test: POST /api/auth/refresh with valid refresh token returns new access token\n9. Integration test: Protected route without token returns 401\n10. Integration test: Protected route with expired token returns 401\n11. Verify refresh token is stored hashed in database",
      "title": "Implement JWT authentication system"
    },
    {
      "dependencies": [
        "2",
        "3"
      ],
      "description": "Create REST API endpoints for complete task management including create, read (single and list), update, and delete operations with proper authorization.",
      "details": "1. Create request/response DTOs in `src/models/task.rs`:\n```rust\n#[derive(Debug, Deserialize)]\npub struct CreateTaskRequest {\n    pub title: String,\n    pub description: Option<String>,\n    pub priority: Option<TaskPriority>,  // defaults to medium\n}\n\n#[derive(Debug, Deserialize)]\npub struct UpdateTaskRequest {\n    pub title: Option<String>,\n    pub description: Option<String>,\n    pub status: Option<TaskStatus>,\n    pub priority: Option<TaskPriority>,\n}\n\n#[derive(Debug, Serialize)]\npub struct TaskResponse {\n    pub id: Uuid,\n    pub title: String,\n    pub description: Option<String>,\n    pub status: TaskStatus,\n    pub priority: TaskPriority,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n```\n\n2. Implement task routes in `src/routes/tasks.rs`:\n```rust\n// All routes require authentication via Claims extractor\n\n// POST /api/tasks - Create new task\npub async fn create_task(\n    claims: Claims,\n    State(state): State<AppState>,\n    Json(payload): Json<CreateTaskRequest>,\n) -> Result<Json<TaskResponse>, AppError> {\n    let task = sqlx::query_as!(\n        Task,\n        r#\"INSERT INTO tasks (user_id, title, description, priority)\n           VALUES ($1, $2, $3, $4)\n           RETURNING id, user_id, title, description, \n                     status as \"status: TaskStatus\", \n                     priority as \"priority: TaskPriority\",\n                     created_at, updated_at\"#,\n        claims.user_id(), payload.title, payload.description,\n        payload.priority.unwrap_or(TaskPriority::Medium) as TaskPriority\n    ).fetch_one(&state.db).await?;\n    Ok(Json(task.into()))\n}\n\n// GET /api/tasks - List user's tasks (with optional filters)\n// GET /api/tasks/:id - Get single task (verify ownership)\n// PUT /api/tasks/:id - Update task (verify ownership)\n// DELETE /api/tasks/:id - Delete task (verify ownership)\n```\n\n3. Add query parameters for list endpoint:\n```rust\n#[derive(Debug, Deserialize)]\npub struct TaskFilters {\n    pub status: Option<TaskStatus>,\n    pub priority: Option<TaskPriority>,\n    pub limit: Option<i64>,   // default 50\n    pub offset: Option<i64>,  // default 0\n}\n```\n\n4. Ensure all task operations verify user_id matches authenticated user\n\n5. Register routes in main router:\n```rust\nRouter::new()\n    .route(\"/api/tasks\", post(create_task).get(list_tasks))\n    .route(\"/api/tasks/:id\", get(get_task).put(update_task).delete(delete_task))\n```",
      "id": "4",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Integration test: POST /api/tasks without auth returns 401\n2. Integration test: POST /api/tasks with valid data creates task, returns 201\n3. Integration test: GET /api/tasks returns only authenticated user's tasks\n4. Integration test: GET /api/tasks/:id returns task if owned by user\n5. Integration test: GET /api/tasks/:id returns 404 if not owned by user (not 403 to avoid enumeration)\n6. Integration test: PUT /api/tasks/:id updates task fields correctly\n7. Integration test: PUT /api/tasks/:id with status transition works\n8. Integration test: DELETE /api/tasks/:id removes task, returns 204\n9. Integration test: Filter by status returns correct subset\n10. Integration test: Filter by priority returns correct subset\n11. Integration test: Pagination with limit/offset works correctly\n12. Verify updated_at timestamp changes on update",
      "title": "Implement Task CRUD endpoints"
    },
    {
      "dependencies": [
        "3",
        "4"
      ],
      "description": "Implement production-ready middleware stack including CORS, request tracing, rate limiting, and comprehensive error handling with consistent API responses.",
      "details": "1. Create comprehensive error type in `src/error.rs`:\n```rust\nuse axum::{response::{IntoResponse, Response}, http::StatusCode, Json};\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum AppError {\n    #[error(\"Authentication required\")]\n    Unauthorized,\n    #[error(\"Resource not found\")]\n    NotFound,\n    #[error(\"Validation error: {0}\")]\n    Validation(String),\n    #[error(\"Database error\")]\n    Database(#[from] sqlx::Error),\n    #[error(\"Internal error\")]\n    Internal(#[from] anyhow::Error),\n}\n\nimpl IntoResponse for AppError {\n    fn into_response(self) -> Response {\n        let (status, message) = match &self {\n            AppError::Unauthorized => (StatusCode::UNAUTHORIZED, self.to_string()),\n            AppError::NotFound => (StatusCode::NOT_FOUND, self.to_string()),\n            AppError::Validation(msg) => (StatusCode::BAD_REQUEST, msg.clone()),\n            AppError::Database(_) => (StatusCode::INTERNAL_SERVER_ERROR, \"Database error\".into()),\n            AppError::Internal(_) => (StatusCode::INTERNAL_SERVER_ERROR, \"Internal error\".into()),\n        };\n        (status, Json(serde_json::json!({ \"error\": message }))).into_response()\n    }\n}\n```\n\n2. Configure middleware stack in main.rs:\n```rust\nuse tower_http::{cors::CorsLayer, trace::TraceLayer, compression::CompressionLayer};\n\nlet app = Router::new()\n    .nest(\"/api\", api_routes())\n    .with_state(state)\n    .layer(TraceLayer::new_for_http())\n    .layer(CompressionLayer::new())\n    .layer(CorsLayer::new()\n        .allow_origin([\"http://localhost:3000\".parse().unwrap()])\n        .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE])\n        .allow_headers([header::AUTHORIZATION, header::CONTENT_TYPE]));\n```\n\n3. Add request ID middleware for tracing:\n```rust\nuse uuid::Uuid;\nuse axum::middleware;\n\nasync fn add_request_id(mut req: Request, next: Next) -> Response {\n    let request_id = Uuid::new_v4().to_string();\n    req.extensions_mut().insert(RequestId(request_id.clone()));\n    let mut response = next.run(req).await;\n    response.headers_mut().insert(\"x-request-id\", request_id.parse().unwrap());\n    response\n}\n```\n\n4. Add graceful shutdown handling:\n```rust\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await?;\naxum::serve(listener, app)\n    .with_graceful_shutdown(shutdown_signal())\n    .await?;\n\nasync fn shutdown_signal() {\n    tokio::signal::ctrl_c().await.ok();\n    tracing::info!(\"Shutdown signal received\");\n}\n```\n\n5. Create OpenAPI documentation (optional, using utoipa):\n- Document all endpoints with request/response schemas\n- Add Swagger UI at /swagger-ui\n\n6. Add health and readiness endpoints:\n- GET /health - Basic liveness\n- GET /ready - Check DB connection",
      "id": "5",
      "priority": "medium",
      "status": "pending",
      "test_strategy": "1. Test CORS: OPTIONS request returns correct headers\n2. Test CORS: Request from allowed origin succeeds\n3. Test error responses: All errors return consistent JSON format\n4. Test 404: Unknown routes return proper JSON error, not HTML\n5. Test request ID: Response includes x-request-id header\n6. Test tracing: Requests logged with timing and status\n7. Test graceful shutdown: In-flight requests complete before exit\n8. Test /health returns 200 immediately\n9. Test /ready returns 503 when DB unavailable\n10. Load test: Verify no memory leaks under sustained traffic\n11. Test compression: Large responses are gzip compressed",
      "title": "Add API middleware, error handling, and documentation"
    }
  ],
  "theme_coverage": 100.0,
  "themes_covered": [
    "api",
    "error",
    "auth",
    "task",
    "project",
    "jwt",
    "database"
  ]
}