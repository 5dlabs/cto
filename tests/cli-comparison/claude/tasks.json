{
  "cli": "claude",
  "duration_ms": 210483,
  "error": null,
  "model": "claude-opus-4-5-20251101",
  "success": true,
  "task_count": 5,
  "tasks": [
    {
      "dependencies": [],
      "description": "Initialize the Rust project structure with Axum web framework, PostgreSQL database connectivity via sqlx, and essential dependencies. This task establishes the foundation for all subsequent features.",
      "details": "1. Create new crate structure following workspace pattern:\n   ```\n   crates/task-api/\n   ├── Cargo.toml\n   ├── src/\n   │   ├── main.rs\n   │   ├── lib.rs\n   │   ├── config.rs\n   │   └── db.rs\n   └── migrations/\n   ```\n\n2. Add dependencies to Cargo.toml:\n   ```toml\n   [dependencies]\n   axum = { workspace = true }  # 0.8.4\n   tokio = { workspace = true }  # 1.40\n   tower = { workspace = true }  # 0.5\n   tower-http = { workspace = true }\n   sqlx = { version = \"0.8\", features = [\"postgres\", \"runtime-tokio-rustls\", \"chrono\", \"uuid\", \"migrate\"] }\n   serde = { workspace = true }\n   serde_json = { workspace = true }\n   anyhow = { workspace = true }\n   thiserror = { workspace = true }\n   tracing = { workspace = true }\n   tracing-subscriber = { workspace = true }\n   uuid = { workspace = true }\n   chrono = { workspace = true }\n   ```\n\n3. Create config.rs for environment configuration:\n   ```rust\n   pub struct Config {\n       pub database_url: String,\n       pub jwt_secret: String,\n       pub server_port: u16,\n   }\n   \n   impl Config {\n       pub fn from_env() -> Result<Self, anyhow::Error> {\n           Ok(Self {\n               database_url: std::env::var(\"DATABASE_URL\")?,\n               jwt_secret: std::env::var(\"JWT_SECRET\")?,\n               server_port: std::env::var(\"PORT\").unwrap_or(\"3000\".into()).parse()?,\n           })\n       }\n   }\n   ```\n\n4. Create db.rs with connection pool:\n   ```rust\n   use sqlx::postgres::{PgPool, PgPoolOptions};\n   \n   pub async fn create_pool(database_url: &str) -> Result<PgPool, sqlx::Error> {\n       PgPoolOptions::new()\n           .max_connections(5)\n           .connect(database_url)\n           .await\n   }\n   ```\n\n5. Create initial migration (migrations/001_initial.sql):\n   ```sql\n   CREATE TYPE task_status AS ENUM ('pending', 'in_progress', 'done');\n   CREATE TYPE task_priority AS ENUM ('low', 'medium', 'high');\n   \n   CREATE TABLE users (\n       id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n       email VARCHAR(255) NOT NULL UNIQUE,\n       password_hash VARCHAR(255) NOT NULL,\n       created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n       updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n   );\n   \n   CREATE TABLE tasks (\n       id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n       user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n       title VARCHAR(255) NOT NULL,\n       description TEXT,\n       status task_status NOT NULL DEFAULT 'pending',\n       priority task_priority NOT NULL DEFAULT 'medium',\n       created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n       updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n   );\n   \n   CREATE INDEX idx_tasks_user_id ON tasks(user_id);\n   CREATE INDEX idx_tasks_status ON tasks(status);\n   ```\n\n6. Setup main.rs with basic server:\n   ```rust\n   #[tokio::main]\n   async fn main() -> Result<(), anyhow::Error> {\n       tracing_subscriber::fmt::init();\n       let config = Config::from_env()?;\n       let pool = create_pool(&config.database_url).await?;\n       sqlx::migrate!().run(&pool).await?;\n       \n       let state = AppState { db: pool, config };\n       let app = Router::new()\n           .route(\"/health\", get(|| async { Json(json!({\"status\": \"healthy\"})) }))\n           .with_state(state);\n       \n       let listener = tokio::net::TcpListener::bind(format!(\"0.0.0.0:{}\", config.server_port)).await?;\n       axum::serve(listener, app).await?;\n       Ok(())\n   }\n   ```",
      "id": "1",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Unit tests: Verify Config::from_env() parses environment variables correctly with valid and missing values\n2. Integration tests: Verify database connection pool creation succeeds with valid DATABASE_URL\n3. Migration tests: Run sqlx migrate to verify migrations apply without errors\n4. Health check test: GET /health returns 200 with {\"status\": \"healthy\"}\n5. Verify the server starts and binds to configured port",
      "title": "Setup project foundation with database"
    },
    {
      "dependencies": [
        "1"
      ],
      "description": "Build the authentication layer with JWT token generation, validation, password hashing, and login/logout/refresh endpoints. Uses jsonwebtoken crate for JWT operations and argon2 for secure password hashing.",
      "details": "1. Add auth dependencies to Cargo.toml:\n   ```toml\n   jsonwebtoken = \"9.3\"\n   argon2 = \"0.5\"\n   axum-extra = { version = \"0.10\", features = [\"typed-header\"] }\n   ```\n\n2. Create src/auth/mod.rs with JWT types:\n   ```rust\n   use serde::{Deserialize, Serialize};\n   use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey};\n   \n   #[derive(Debug, Serialize, Deserialize)]\n   pub struct Claims {\n       pub sub: String,  // user_id\n       pub exp: i64,\n       pub iat: i64,\n       pub token_type: TokenType,\n   }\n   \n   #[derive(Debug, Serialize, Deserialize, PartialEq)]\n   pub enum TokenType { Access, Refresh }\n   \n   pub fn generate_tokens(user_id: &str, secret: &str) -> Result<(String, String), Error> {\n       let now = chrono::Utc::now();\n       let access_claims = Claims {\n           sub: user_id.to_string(),\n           exp: (now + chrono::Duration::hours(1)).timestamp(),\n           iat: now.timestamp(),\n           token_type: TokenType::Access,\n       };\n       let refresh_claims = Claims {\n           sub: user_id.to_string(),\n           exp: (now + chrono::Duration::days(7)).timestamp(),\n           iat: now.timestamp(),\n           token_type: TokenType::Refresh,\n       };\n       let key = EncodingKey::from_secret(secret.as_bytes());\n       Ok((\n           encode(&Header::default(), &access_claims, &key)?,\n           encode(&Header::default(), &refresh_claims, &key)?,\n       ))\n   }\n   ```\n\n3. Create JWT extractor (src/auth/extractor.rs) following Axum 0.8 pattern:\n   ```rust\n   use axum::{async_trait, extract::FromRequestParts, http::request::Parts};\n   use axum_extra::headers::{Authorization, authorization::Bearer};\n   use axum_extra::TypedHeader;\n   \n   pub struct AuthUser {\n       pub user_id: uuid::Uuid,\n   }\n   \n   #[async_trait]\n   impl<S> FromRequestParts<S> for AuthUser\n   where S: Send + Sync {\n       type Rejection = (StatusCode, Json<Value>);\n       \n       async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {\n           let TypedHeader(Authorization::<Bearer>(bearer)) = \n               TypedHeader::<Authorization<Bearer>>::from_request_parts(parts, state)\n                   .await\n                   .map_err(|_| (StatusCode::UNAUTHORIZED, Json(json!({\"error\": \"Missing token\"}))))?;\n           \n           // Decode and validate token...\n       }\n   }\n   ```\n\n4. Create auth routes (src/auth/routes.rs):\n   ```rust\n   pub fn auth_routes() -> Router<AppState> {\n       Router::new()\n           .route(\"/login\", post(login))\n           .route(\"/register\", post(register))\n           .route(\"/refresh\", post(refresh_token))\n           .route(\"/logout\", post(logout))\n   }\n   \n   async fn login(State(state): State<AppState>, Json(req): Json<LoginRequest>) -> Result<Json<TokenResponse>, ApiError> {\n       let user = sqlx::query_as!(User, \"SELECT * FROM users WHERE email = $1\", req.email)\n           .fetch_optional(&state.db).await?\n           .ok_or(ApiError::Unauthorized)?;\n       \n       verify_password(&req.password, &user.password_hash)?;\n       let (access, refresh) = generate_tokens(&user.id.to_string(), &state.config.jwt_secret)?;\n       Ok(Json(TokenResponse { access_token: access, refresh_token: refresh, token_type: \"Bearer\" }))\n   }\n   ```\n\n5. Implement password hashing:\n   ```rust\n   use argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier};\n   use argon2::password_hash::SaltString;\n   \n   pub fn hash_password(password: &str) -> Result<String, Error> {\n       let salt = SaltString::generate(&mut rand::thread_rng());\n       Ok(Argon2::default().hash_password(password.as_bytes(), &salt)?.to_string())\n   }\n   \n   pub fn verify_password(password: &str, hash: &str) -> Result<(), Error> {\n       let parsed = PasswordHash::new(hash)?;\n       Argon2::default().verify_password(password.as_bytes(), &parsed)\n           .map_err(|_| Error::InvalidCredentials)\n   }\n   ```",
      "id": "2",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Unit tests for JWT generation: verify token structure, expiration times, and claims\n2. Unit tests for password hashing: verify hash_password produces valid argon2 hash, verify_password accepts correct password and rejects wrong password\n3. Integration tests for /auth/register: POST creates user, returns 201, stores hashed password in DB\n4. Integration tests for /auth/login: returns tokens for valid credentials, returns 401 for invalid\n5. Integration tests for /auth/refresh: returns new access token for valid refresh token, rejects expired tokens\n6. Test AuthUser extractor rejects missing/invalid/expired tokens with appropriate error responses",
      "title": "Implement JWT authentication system"
    },
    {
      "dependencies": [
        "1",
        "2"
      ],
      "description": "Build the core task management API with Create, Read, Update, Delete operations for tasks. Tasks are scoped to authenticated users and support status (pending/in_progress/done) and priority (low/medium/high) fields.",
      "details": "1. Create task models (src/tasks/models.rs):\n   ```rust\n   use serde::{Deserialize, Serialize};\n   use sqlx::FromRow;\n   \n   #[derive(Debug, Serialize, Deserialize, sqlx::Type)]\n   #[sqlx(type_name = \"task_status\", rename_all = \"snake_case\")]\n   pub enum TaskStatus { Pending, InProgress, Done }\n   \n   #[derive(Debug, Serialize, Deserialize, sqlx::Type)]\n   #[sqlx(type_name = \"task_priority\", rename_all = \"snake_case\")]\n   pub enum TaskPriority { Low, Medium, High }\n   \n   #[derive(Debug, Serialize, FromRow)]\n   pub struct Task {\n       pub id: uuid::Uuid,\n       pub user_id: uuid::Uuid,\n       pub title: String,\n       pub description: Option<String>,\n       pub status: TaskStatus,\n       pub priority: TaskPriority,\n       pub created_at: chrono::DateTime<chrono::Utc>,\n       pub updated_at: chrono::DateTime<chrono::Utc>,\n   }\n   \n   #[derive(Debug, Deserialize)]\n   pub struct CreateTask {\n       pub title: String,\n       pub description: Option<String>,\n       pub priority: Option<TaskPriority>,\n   }\n   \n   #[derive(Debug, Deserialize)]\n   pub struct UpdateTask {\n       pub title: Option<String>,\n       pub description: Option<String>,\n       pub status: Option<TaskStatus>,\n       pub priority: Option<TaskPriority>,\n   }\n   ```\n\n2. Create task routes (src/tasks/routes.rs):\n   ```rust\n   pub fn task_routes() -> Router<AppState> {\n       Router::new()\n           .route(\"/\", get(list_tasks).post(create_task))\n           .route(\"/:id\", get(get_task).put(update_task).delete(delete_task))\n   }\n   ```\n\n3. Implement handlers:\n   ```rust\n   // Create task\n   async fn create_task(\n       State(state): State<AppState>,\n       auth: AuthUser,\n       Json(req): Json<CreateTask>,\n   ) -> Result<(StatusCode, Json<Task>), ApiError> {\n       let task = sqlx::query_as!(\n           Task,\n           r#\"INSERT INTO tasks (user_id, title, description, priority)\n              VALUES ($1, $2, $3, $4)\n              RETURNING id, user_id, title, description, \n                        status as \"status: TaskStatus\",\n                        priority as \"priority: TaskPriority\",\n                        created_at, updated_at\"#,\n           auth.user_id, req.title, req.description,\n           req.priority.unwrap_or(TaskPriority::Medium) as TaskPriority\n       )\n       .fetch_one(&state.db).await?;\n       Ok((StatusCode::CREATED, Json(task)))\n   }\n   \n   // List tasks with optional filters\n   async fn list_tasks(\n       State(state): State<AppState>,\n       auth: AuthUser,\n       Query(params): Query<ListParams>,\n   ) -> Result<Json<Vec<Task>>, ApiError> {\n       let tasks = sqlx::query_as!(\n           Task,\n           r#\"SELECT id, user_id, title, description,\n                     status as \"status: TaskStatus\",\n                     priority as \"priority: TaskPriority\",\n                     created_at, updated_at\n              FROM tasks WHERE user_id = $1\n              ORDER BY created_at DESC\"#,\n           auth.user_id\n       )\n       .fetch_all(&state.db).await?;\n       Ok(Json(tasks))\n   }\n   \n   // Get single task\n   async fn get_task(\n       State(state): State<AppState>,\n       auth: AuthUser,\n       Path(task_id): Path<uuid::Uuid>,\n   ) -> Result<Json<Task>, ApiError> {\n       sqlx::query_as!(...)\n           .fetch_optional(&state.db).await?\n           .ok_or(ApiError::NotFound)\n           .map(Json)\n   }\n   \n   // Update task\n   async fn update_task(\n       State(state): State<AppState>,\n       auth: AuthUser,\n       Path(task_id): Path<uuid::Uuid>,\n       Json(req): Json<UpdateTask>,\n   ) -> Result<Json<Task>, ApiError> {\n       let task = sqlx::query_as!(\n           Task,\n           r#\"UPDATE tasks SET\n              title = COALESCE($3, title),\n              description = COALESCE($4, description),\n              status = COALESCE($5, status),\n              priority = COALESCE($6, priority),\n              updated_at = NOW()\n              WHERE id = $1 AND user_id = $2\n              RETURNING ...\"#,\n           task_id, auth.user_id, req.title, req.description,\n           req.status as Option<TaskStatus>,\n           req.priority as Option<TaskPriority>\n       )\n       .fetch_optional(&state.db).await?\n       .ok_or(ApiError::NotFound)?;\n       Ok(Json(task))\n   }\n   \n   // Delete task\n   async fn delete_task(\n       State(state): State<AppState>,\n       auth: AuthUser,\n       Path(task_id): Path<uuid::Uuid>,\n   ) -> Result<StatusCode, ApiError> {\n       let result = sqlx::query!(\n           \"DELETE FROM tasks WHERE id = $1 AND user_id = $2\",\n           task_id, auth.user_id\n       )\n       .execute(&state.db).await?;\n       \n       if result.rows_affected() == 0 {\n           Err(ApiError::NotFound)\n       } else {\n           Ok(StatusCode::NO_CONTENT)\n       }\n   }\n   ```\n\n4. Wire routes in main.rs:\n   ```rust\n   let app = Router::new()\n       .route(\"/health\", get(health))\n       .nest(\"/auth\", auth_routes())\n       .nest(\"/tasks\", task_routes())\n       .with_state(state);\n   ```",
      "id": "3",
      "priority": "high",
      "status": "pending",
      "test_strategy": "1. Integration tests for POST /tasks: creates task with valid token, returns 401 without token, validates required fields\n2. Integration tests for GET /tasks: returns only tasks belonging to authenticated user, empty array for new user\n3. Integration tests for GET /tasks/:id: returns task if owned by user, 404 for non-existent, 404 for other user's task (not 403 to avoid enumeration)\n4. Integration tests for PUT /tasks/:id: updates specified fields only, preserves unspecified fields, validates enum values for status/priority\n5. Integration tests for DELETE /tasks/:id: returns 204 on success, 404 for non-existent, removes task from database\n6. Test status transitions: pending -> in_progress -> done\n7. Test priority values: low, medium, high accepted; invalid values rejected with 400",
      "title": "Implement task CRUD operations"
    },
    {
      "dependencies": [
        "1",
        "2",
        "3"
      ],
      "description": "Implement comprehensive error handling with structured JSON error responses, input validation using validator crate, and consistent error formatting across all endpoints.",
      "details": "1. Add validation dependency:\n   ```toml\n   validator = { version = \"0.18\", features = [\"derive\"] }\n   ```\n\n2. Create error types (src/error.rs):\n   ```rust\n   use axum::{response::{IntoResponse, Response}, http::StatusCode, Json};\n   use serde_json::json;\n   \n   #[derive(Debug, thiserror::Error)]\n   pub enum ApiError {\n       #[error(\"Resource not found\")]\n       NotFound,\n       #[error(\"Unauthorized\")]\n       Unauthorized,\n       #[error(\"Invalid credentials\")]\n       InvalidCredentials,\n       #[error(\"Validation error: {0}\")]\n       Validation(String),\n       #[error(\"Conflict: {0}\")]\n       Conflict(String),\n       #[error(\"Internal server error\")]\n       Internal(#[from] anyhow::Error),\n       #[error(\"Database error\")]\n       Database(#[from] sqlx::Error),\n   }\n   \n   impl IntoResponse for ApiError {\n       fn into_response(self) -> Response {\n           let (status, error_code, message) = match &self {\n               ApiError::NotFound => (StatusCode::NOT_FOUND, \"NOT_FOUND\", self.to_string()),\n               ApiError::Unauthorized => (StatusCode::UNAUTHORIZED, \"UNAUTHORIZED\", self.to_string()),\n               ApiError::InvalidCredentials => (StatusCode::UNAUTHORIZED, \"INVALID_CREDENTIALS\", self.to_string()),\n               ApiError::Validation(msg) => (StatusCode::BAD_REQUEST, \"VALIDATION_ERROR\", msg.clone()),\n               ApiError::Conflict(msg) => (StatusCode::CONFLICT, \"CONFLICT\", msg.clone()),\n               ApiError::Internal(_) => (StatusCode::INTERNAL_SERVER_ERROR, \"INTERNAL_ERROR\", \"Internal server error\".into()),\n               ApiError::Database(e) => {\n                   tracing::error!(error = %e, \"Database error\");\n                   (StatusCode::INTERNAL_SERVER_ERROR, \"DATABASE_ERROR\", \"Database error\".into())\n               }\n           };\n           \n           (status, Json(json!({\n               \"error\": {\n                   \"code\": error_code,\n                   \"message\": message\n               }\n           }))).into_response()\n       }\n   }\n   ```\n\n3. Add validation to request structs:\n   ```rust\n   use validator::Validate;\n   \n   #[derive(Debug, Deserialize, Validate)]\n   pub struct CreateTask {\n       #[validate(length(min = 1, max = 255, message = \"Title must be 1-255 characters\"))]\n       pub title: String,\n       #[validate(length(max = 10000, message = \"Description too long\"))]\n       pub description: Option<String>,\n       pub priority: Option<TaskPriority>,\n   }\n   \n   #[derive(Debug, Deserialize, Validate)]\n   pub struct LoginRequest {\n       #[validate(email(message = \"Invalid email format\"))]\n       pub email: String,\n       #[validate(length(min = 8, message = \"Password must be at least 8 characters\"))]\n       pub password: String,\n   }\n   \n   #[derive(Debug, Deserialize, Validate)]\n   pub struct RegisterRequest {\n       #[validate(email(message = \"Invalid email format\"))]\n       pub email: String,\n       #[validate(length(min = 8, max = 128, message = \"Password must be 8-128 characters\"))]\n       pub password: String,\n   }\n   ```\n\n4. Create validated JSON extractor:\n   ```rust\n   use axum::{async_trait, extract::{FromRequest, Request}};\n   use validator::Validate;\n   \n   pub struct ValidatedJson<T>(pub T);\n   \n   #[async_trait]\n   impl<S, T> FromRequest<S> for ValidatedJson<T>\n   where\n       S: Send + Sync,\n       T: DeserializeOwned + Validate,\n   {\n       type Rejection = ApiError;\n       \n       async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {\n           let Json(value) = Json::<T>::from_request(req, state)\n               .await\n               .map_err(|e| ApiError::Validation(e.to_string()))?;\n           \n           value.validate()\n               .map_err(|e| ApiError::Validation(format_validation_errors(&e)))?;\n           \n           Ok(ValidatedJson(value))\n       }\n   }\n   \n   fn format_validation_errors(errors: &validator::ValidationErrors) -> String {\n       errors.field_errors()\n           .iter()\n           .flat_map(|(field, errs)| errs.iter().map(move |e| \n               format!(\"{}: {}\", field, e.message.as_ref().map(|m| m.to_string()).unwrap_or_default())\n           ))\n           .collect::<Vec<_>>()\n           .join(\"; \")\n   }\n   ```\n\n5. Handle database constraint violations:\n   ```rust\n   impl From<sqlx::Error> for ApiError {\n       fn from(e: sqlx::Error) -> Self {\n           match &e {\n               sqlx::Error::Database(db_err) if db_err.is_unique_violation() => {\n                   ApiError::Conflict(\"Resource already exists\".into())\n               }\n               _ => ApiError::Database(e)\n           }\n       }\n   }\n   ```",
      "id": "4",
      "priority": "medium",
      "status": "pending",
      "test_strategy": "1. Test validation errors: POST /auth/register with invalid email returns 400 with validation message\n2. Test validation errors: POST /tasks with empty title returns 400\n3. Test validation errors: POST /tasks with title > 255 chars returns 400\n4. Test not found: GET /tasks/{random-uuid} returns 404 with structured error\n5. Test conflict: POST /auth/register with existing email returns 409\n6. Test unauthorized: Access protected endpoint without token returns 401\n7. Test error response format: All errors return {\"error\": {\"code\": \"...\", \"message\": \"...\"}}\n8. Test internal errors don't leak stack traces to client",
      "title": "Add error handling and validation"
    },
    {
      "dependencies": [
        "1",
        "2",
        "3",
        "4"
      ],
      "description": "Add production-ready middleware including request tracing, CORS configuration, rate limiting, and request timeouts. Also add OpenAPI documentation generation and comprehensive health check endpoints.",
      "details": "1. Add middleware dependencies:\n   ```toml\n   tower-http = { version = \"0.5\", features = [\"trace\", \"cors\", \"limit\", \"timeout\", \"request-id\"] }\n   utoipa = { version = \"5\", features = [\"axum_extras\", \"chrono\", \"uuid\"] }\n   utoipa-swagger-ui = { version = \"8\", features = [\"axum\"] }\n   ```\n\n2. Configure middleware stack in main.rs:\n   ```rust\n   use tower::ServiceBuilder;\n   use tower_http::{\n       trace::TraceLayer,\n       cors::{CorsLayer, Any},\n       timeout::TimeoutLayer,\n       limit::RequestBodyLimitLayer,\n       request_id::{SetRequestIdLayer, PropagateRequestIdLayer},\n   };\n   use std::time::Duration;\n   \n   let middleware = ServiceBuilder::new()\n       .layer(SetRequestIdLayer::x_request_id(MakeRequestUuid))\n       .layer(PropagateRequestIdLayer::x_request_id())\n       .layer(TraceLayer::new_for_http()\n           .make_span_with(|request: &Request<_>| {\n               let request_id = request.headers()\n                   .get(\"x-request-id\")\n                   .and_then(|v| v.to_str().ok())\n                   .unwrap_or(\"unknown\");\n               tracing::info_span!(\"http_request\",\n                   method = %request.method(),\n                   uri = %request.uri(),\n                   request_id = %request_id\n               )\n           }))\n       .layer(TimeoutLayer::new(Duration::from_secs(30)))\n       .layer(RequestBodyLimitLayer::new(1024 * 1024))  // 1MB\n       .layer(CorsLayer::new()\n           .allow_origin(Any)\n           .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE])\n           .allow_headers([header::CONTENT_TYPE, header::AUTHORIZATION]));\n   \n   let app = Router::new()\n       // ... routes ...\n       .layer(middleware)\n       .with_state(state);\n   ```\n\n3. Add OpenAPI documentation with utoipa:\n   ```rust\n   use utoipa::OpenApi;\n   use utoipa_swagger_ui::SwaggerUi;\n   \n   #[derive(OpenApi)]\n   #[openapi(\n       paths(\n           auth::login, auth::register, auth::refresh_token,\n           tasks::create_task, tasks::list_tasks, tasks::get_task,\n           tasks::update_task, tasks::delete_task\n       ),\n       components(schemas(\n           Task, CreateTask, UpdateTask, TaskStatus, TaskPriority,\n           LoginRequest, RegisterRequest, TokenResponse, ApiError\n       )),\n       tags(\n           (name = \"auth\", description = \"Authentication endpoints\"),\n           (name = \"tasks\", description = \"Task management endpoints\")\n       )\n   )]\n   struct ApiDoc;\n   \n   // Add to router:\n   .merge(SwaggerUi::new(\"/swagger-ui\").url(\"/api-docs/openapi.json\", ApiDoc::openapi()))\n   ```\n\n4. Enhanced health check:\n   ```rust\n   #[derive(Serialize)]\n   struct HealthResponse {\n       status: &'static str,\n       version: &'static str,\n       database: DatabaseHealth,\n   }\n   \n   #[derive(Serialize)]\n   struct DatabaseHealth {\n       connected: bool,\n       latency_ms: Option<u64>,\n   }\n   \n   async fn health_check(State(state): State<AppState>) -> Json<HealthResponse> {\n       let start = std::time::Instant::now();\n       let db_ok = sqlx::query(\"SELECT 1\").execute(&state.db).await.is_ok();\n       let latency = start.elapsed().as_millis() as u64;\n       \n       Json(HealthResponse {\n           status: if db_ok { \"healthy\" } else { \"degraded\" },\n           version: env!(\"CARGO_PKG_VERSION\"),\n           database: DatabaseHealth {\n               connected: db_ok,\n               latency_ms: if db_ok { Some(latency) } else { None },\n           },\n       })\n   }\n   ```\n\n5. Add graceful shutdown:\n   ```rust\n   let listener = tokio::net::TcpListener::bind(addr).await?;\n   axum::serve(listener, app)\n       .with_graceful_shutdown(shutdown_signal())\n       .await?;\n   \n   async fn shutdown_signal() {\n       let ctrl_c = async {\n           tokio::signal::ctrl_c().await.expect(\"failed to listen for ctrl+c\");\n       };\n       #[cfg(unix)]\n       let terminate = async {\n           tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())\n               .expect(\"failed to install signal handler\")\n               .recv()\n               .await;\n       };\n       #[cfg(not(unix))]\n       let terminate = std::future::pending::<()>();\n       \n       tokio::select! {\n           _ = ctrl_c => {},\n           _ = terminate => {},\n       }\n       tracing::info!(\"Shutdown signal received\");\n   }\n   ```",
      "id": "5",
      "priority": "medium",
      "status": "pending",
      "test_strategy": "1. Test CORS: OPTIONS request returns correct CORS headers\n2. Test request timeout: Slow handler returns 408 after timeout\n3. Test body limit: Request > 1MB returns 413\n4. Test request ID: Response includes x-request-id header\n5. Test tracing: Logs include request_id, method, uri for each request\n6. Test health endpoint: Returns database connectivity status and latency\n7. Test OpenAPI: GET /api-docs/openapi.json returns valid OpenAPI spec\n8. Test Swagger UI: GET /swagger-ui loads documentation interface\n9. Test graceful shutdown: Server completes in-flight requests before terminating",
      "title": "Add middleware and API polish"
    }
  ],
  "theme_coverage": 100.0,
  "themes_covered": [
    "jwt",
    "project",
    "api",
    "error",
    "task",
    "auth",
    "database"
  ]
}