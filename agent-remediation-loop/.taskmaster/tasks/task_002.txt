# Task ID: 2
# Title: Implement Feedback Comment Parser
# Status: pending
# Dependencies: None
# Priority: high
# Description: Build robust parsing system to extract structured feedback from PR comments with 'ðŸ”´ Required Changes' format
# Details:
Create a comment parsing module in Rust that extracts structured feedback data from Tess QA comments. Implementation in controller/src/remediation/ module:

1. Define data structures for feedback (IssueType, Severity, etc.)
2. Implement regex patterns for extracting metadata
3. Parse markdown checkboxes for acceptance criteria
4. Handle edge cases and malformed comments
5. Validate author authorization (must be Tess or approved reviewer)

Key components:
- Rust module in controller/src/remediation/
- Compiled into controller binary for Rex container usage
- Regex patterns for Issue Type/Severity extraction
- Markdown parser for structured sections
- Error handling using anyhow with fallback to manual review
- Integration with existing controller patterns from controller/src/tasks/

Pseudo-code:
```rust
// controller/src/remediation/parser.rs
use anyhow::{Result, Context};
use regex::Regex;
use serde::{Serialize, Deserialize};

pub fn parse_feedback(comment: &str) -> Result<StructuredFeedback> {
    if !comment.contains("ðŸ”´ Required Changes") {
        return Err(anyhow::anyhow!("Not actionable feedback"));
    }
    
    let issue_type = extract_pattern(r"Issue Type.*\[(.*?)\]")?;
    let severity = extract_pattern(r"Severity.*\[(.*?)\]")?;
    let criteria = extract_checkboxes(comment)?;
    
    Ok(StructuredFeedback {
        issue_type: parse_issue_type(issue_type)?,
        severity: parse_severity(severity)?,
        criteria_not_met: criteria,
        // ... other fields
    })
}
```

# Test Strategy:
1. Unit tests with various comment formats (valid and invalid) in controller/src/remediation/tests/
2. Test edge cases: missing fields, special characters, long descriptions
3. Performance tests with large comments
4. Integration tests with actual GitHub comment payloads
5. Security tests for injection attacks in comment content
6. Test integration with controller API endpoints

# Subtasks:
## 1. Define Data Structures and Enums [pending]
### Dependencies: None
### Description: Create comprehensive data structures and enums for representing structured feedback components
### Details:
Define Rust structs in controller/src/remediation/types.rs for StructuredFeedback, IssueType enum (security, performance, quality, etc.), Severity enum (critical, high, medium, low), CriteriaStatus, and FeedbackMetadata. Include fields for author validation, timestamps, PR context, and nested structures for complex feedback scenarios. Use serde for proper serialization/deserialization support for JSON and implement Display traits for logging. Follow existing patterns from controller/src/tasks/types.rs.

## 2. Implement Regex Pattern Extraction [pending]
### Dependencies: 2.1
### Description: Build regex-based metadata extraction system for parsing Issue Type, Severity, and other structured fields
### Details:
Create a regex pattern library in controller/src/remediation/patterns.rs using the regex crate. Implement patterns for extracting Issue Type (r"Issue Type.*\[(.*?)\]"), Severity (r"Severity.*\[(.*?)\]"), affected files, line numbers, and custom metadata fields. Implement extract_pattern() function with proper error handling using anyhow::Result, support for multiline matching, and fallback strategies for variations in formatting. Include performance optimizations using lazy_static for compiled regex patterns.

## 3. Build Markdown Checkbox Parser [pending]
### Dependencies: 2.1
### Description: Implement parser for extracting and analyzing markdown checkboxes from acceptance criteria sections
### Details:
Create extract_checkboxes() function in controller/src/remediation/markdown.rs to parse markdown checkbox syntax (- [ ] and - [x]), maintain checkbox state and associated text, handle nested lists and indentation, and support various markdown flavors. Return structured data mapping criteria descriptions to their completion status using Vec<CriteriaStatus>. Handle edge cases like escaped characters, code blocks containing checkboxes, and malformed markdown. Consider using pulldown-cmark crate for robust markdown parsing.

## 4. Add Author Validation Logic [pending]
### Dependencies: 2.1
### Description: Implement authorization system to validate comment authors against approved reviewer list
### Details:
Build validate_author() function in controller/src/remediation/auth.rs checking if comment author is Tess QA bot or in approved reviewer allowlist. Implement configurable allowlist management using controller configuration, support for team-based permissions, and integration with GitHub API for user verification. Add special handling for bot accounts, service accounts, and admin overrides. Include caching mechanism using std::collections::HashMap or dashmap for authorization results to reduce API calls.

## 5. Implement Error Handling and Fallbacks [pending]
### Dependencies: 2.2, 2.3, 2.4
### Description: Create comprehensive error handling system with graceful degradation and manual review fallbacks
### Details:
Design custom error types in controller/src/remediation/error.rs using thiserror crate for parsing failures (MalformedComment, MissingRequiredField, InvalidAuthor). Implement anyhow::Result<StructuredFeedback> return types throughout the module, create fallback parsing strategies for partial extraction, and add structured logging using tracing crate with context for debugging. Implement retry logic for transient failures, queue malformed comments for manual review, and provide detailed error messages for operators.

## 6. Create Comprehensive Unit Tests [pending]
### Dependencies: 2.2, 2.3, 2.4, 2.5
### Description: Develop extensive test suite covering all parsing scenarios, edge cases, and security considerations
### Details:
Write unit tests in controller/src/remediation/tests/ for valid comment parsing with all field combinations, malformed comments with missing/invalid fields, edge cases (empty comments, special characters, Unicode), performance tests with large comments (>10MB), security tests for injection attacks (XSS, command injection), regex performance and catastrophic backtracking prevention, and integration tests with real GitHub webhook payloads. Use proptest crate for property-based testing and fuzzing input validation. Follow testing patterns from controller/src/tasks/tests/.

## 7. Integrate Parser with Controller API [pending]
### Dependencies: 2.5
### Description: Create controller API endpoints or library functions for Rex container to call the parser
### Details:
Implement controller API endpoint or exposed library function in controller/src/remediation/mod.rs that Rex container can invoke to parse feedback comments. Follow existing controller API patterns, ensure proper error propagation, add request/response logging, and implement appropriate access controls. Consider whether parser should be called via HTTP API, gRPC, or direct library linking when Rex runs in remediation mode.

