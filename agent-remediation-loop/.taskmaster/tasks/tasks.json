{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup GitHub Webhook Infrastructure",
        "description": "Create and configure Argo Events Sensor for detecting and processing PR comments with 'ðŸ”´ Required Changes' format from the existing GitHub webhook infrastructure",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "Leverage the existing GitHub webhook EventSource infrastructure to create a new remediation-specific Sensor that processes PR comments containing feedback. Implementation:\n1. Create new Sensor CRD that listens to the existing GitHub EventSource\n2. Configure event filtering for issue_comment events with 'ðŸ”´ Required Changes' pattern\n3. Extract task ID from PR labels and comment metadata\n4. Generate CodeRun resources with REMEDIATION_MODE=true\n5. Deploy alongside existing sensors in infra/gitops/resources/github-webhooks/\n\nExisting infrastructure components (already deployed):\n- GitHub EventSource at infra/gitops/resources/github-webhooks/eventsource.yaml\n- HTTPRoute for webhook ingress\n- Service accounts and RBAC\n- GitHub webhook secret\n- Working sensors: play-workflow-sensors.yaml, implementation-agent-remediation\n\nKey technologies:\n- Argo Events v1.9+ Sensor CRD\n- Existing GitHub webhook infrastructure\n- CodeRun CRD generation with remediation mode",
        "testStrategy": "1. Test sensor activation with PR comments containing 'ðŸ”´ Required Changes'\n2. Verify CodeRun creation with REMEDIATION_MODE=true environment variable\n3. Test event filtering to ensure only feedback comments trigger the sensor\n4. Validate task ID extraction from PR labels\n5. Test integration with existing play workflow infrastructure",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Remediation Sensor YAML Configuration",
            "description": "Design and create the Argo Events Sensor CRD that listens to the existing GitHub EventSource for PR feedback comments",
            "status": "pending",
            "dependencies": [],
            "details": "Create a new Sensor YAML manifest following the pattern of existing sensors (play-workflow-sensors.yaml and implementation-agent-remediation). Configure the sensor to:\n- Listen to the existing github-eventsource for issue_comment events\n- Filter for comments containing 'ðŸ”´ Required Changes' pattern\n- Extract task ID from PR labels using JSONPath expressions\n- Use the existing service account and RBAC permissions\n- Reference the sensor templates from existing configurations\nPlace the new sensor configuration in infra/gitops/resources/github-webhooks/ directory alongside existing sensors.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Event Filtering for Feedback Comments",
            "description": "Configure sensor event dependency to filter specifically for PR comments with required changes feedback",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Add event filtering logic to the sensor dependency configuration:\n- Filter for issue_comment events where action is 'created'\n- Check comment body contains 'ðŸ”´ Required Changes' marker\n- Verify comment is on a pull request (not issue)\n- Optionally validate comment author (Tess QA bot or authorized reviewers)\n- Use JSONPath expressions similar to existing sensors for data extraction\n- Ensure filtering excludes bot comments except from authorized accounts",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Configure CodeRun Resource Generation Trigger",
            "description": "Set up the sensor trigger to create CodeRun resources with remediation-specific configuration",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "Configure the Kubernetes resource trigger in the sensor to generate CodeRun CRDs:\n- Use resource template similar to implementation-agent-remediation sensor\n- Set REMEDIATION_MODE=true in environment variables\n- Extract and pass comment ID, PR number, and task ID as parameters\n- Configure proper labels including task ID, PR number, and remediation iteration\n- Set appropriate resource naming convention (e.g., coderun-remediation-task{id}-{hash})\n- Include feedback content in CodeRun spec for Rex agent context",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Deploy and Integrate with Existing Infrastructure",
            "description": "Deploy the remediation sensor to the cluster and verify integration with existing webhook infrastructure",
            "status": "pending",
            "dependencies": [
              3
            ],
            "details": "Deploy the new sensor to the Kubernetes cluster:\n- Apply the sensor YAML using kubectl or through GitOps\n- Verify sensor pod starts and connects to existing EventSource\n- Check sensor appears in Argo Events dashboard/logs\n- Validate sensor can receive events from the existing GitHub EventSource\n- Ensure no conflicts with existing sensors or workflows\n- Test that the sensor properly creates CodeRun resources when triggered\n- Verify RBAC permissions allow CodeRun creation in target namespace",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Test End-to-End Remediation Flow",
            "description": "Comprehensive testing of the feedback comment detection and CodeRun generation pipeline",
            "status": "pending",
            "dependencies": [
              4
            ],
            "details": "Perform end-to-end testing of the remediation sensor:\n- Create test PR with appropriate task labels\n- Post comment with 'ðŸ”´ Required Changes' format\n- Verify sensor receives and processes the webhook event\n- Confirm CodeRun is created with correct parameters and REMEDIATION_MODE=true\n- Test with various comment formats and edge cases\n- Validate integration with play workflow (ensure no interference)\n- Test concurrent feedback comments on multiple PRs\n- Document the remediation trigger flow and troubleshooting steps\n- Set up monitoring/alerts for sensor health and failures",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Feedback Comment Parser",
        "description": "Build robust parsing system to extract structured feedback from PR comments with 'ðŸ”´ Required Changes' format",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "Create a comment parsing module in Rust that extracts structured feedback data from Tess QA comments. Implementation in controller/src/remediation/ module:\n\n1. Define data structures for feedback (IssueType, Severity, etc.)\n2. Implement regex patterns for extracting metadata\n3. Parse markdown checkboxes for acceptance criteria\n4. Handle edge cases and malformed comments\n5. Validate author authorization (must be Tess or approved reviewer)\n\nKey components:\n- Rust module in controller/src/remediation/\n- Compiled into controller binary for Rex container usage\n- Regex patterns for Issue Type/Severity extraction\n- Markdown parser for structured sections\n- Error handling using anyhow with fallback to manual review\n- Integration with existing controller patterns from controller/src/tasks/\n\nPseudo-code:\n```rust\n// controller/src/remediation/parser.rs\nuse anyhow::{Result, Context};\nuse regex::Regex;\nuse serde::{Serialize, Deserialize};\n\npub fn parse_feedback(comment: &str) -> Result<StructuredFeedback> {\n    if !comment.contains(\"ðŸ”´ Required Changes\") {\n        return Err(anyhow::anyhow!(\"Not actionable feedback\"));\n    }\n    \n    let issue_type = extract_pattern(r\"Issue Type.*\\[(.*?)\\]\")?;\n    let severity = extract_pattern(r\"Severity.*\\[(.*?)\\]\")?;\n    let criteria = extract_checkboxes(comment)?;\n    \n    Ok(StructuredFeedback {\n        issue_type: parse_issue_type(issue_type)?,\n        severity: parse_severity(severity)?,\n        criteria_not_met: criteria,\n        // ... other fields\n    })\n}\n```",
        "testStrategy": "1. Unit tests with various comment formats (valid and invalid) in controller/src/remediation/tests/\n2. Test edge cases: missing fields, special characters, long descriptions\n3. Performance tests with large comments\n4. Integration tests with actual GitHub comment payloads\n5. Security tests for injection attacks in comment content\n6. Test integration with controller API endpoints",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Data Structures and Enums",
            "description": "Create comprehensive data structures and enums for representing structured feedback components",
            "status": "pending",
            "dependencies": [],
            "details": "Define Rust structs in controller/src/remediation/types.rs for StructuredFeedback, IssueType enum (security, performance, quality, etc.), Severity enum (critical, high, medium, low), CriteriaStatus, and FeedbackMetadata. Include fields for author validation, timestamps, PR context, and nested structures for complex feedback scenarios. Use serde for proper serialization/deserialization support for JSON and implement Display traits for logging. Follow existing patterns from controller/src/tasks/types.rs.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Regex Pattern Extraction",
            "description": "Build regex-based metadata extraction system for parsing Issue Type, Severity, and other structured fields",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Create a regex pattern library in controller/src/remediation/patterns.rs using the regex crate. Implement patterns for extracting Issue Type (r\"Issue Type.*\\[(.*?)\\]\"), Severity (r\"Severity.*\\[(.*?)\\]\"), affected files, line numbers, and custom metadata fields. Implement extract_pattern() function with proper error handling using anyhow::Result, support for multiline matching, and fallback strategies for variations in formatting. Include performance optimizations using lazy_static for compiled regex patterns.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build Markdown Checkbox Parser",
            "description": "Implement parser for extracting and analyzing markdown checkboxes from acceptance criteria sections",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Create extract_checkboxes() function in controller/src/remediation/markdown.rs to parse markdown checkbox syntax (- [ ] and - [x]), maintain checkbox state and associated text, handle nested lists and indentation, and support various markdown flavors. Return structured data mapping criteria descriptions to their completion status using Vec<CriteriaStatus>. Handle edge cases like escaped characters, code blocks containing checkboxes, and malformed markdown. Consider using pulldown-cmark crate for robust markdown parsing.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add Author Validation Logic",
            "description": "Implement authorization system to validate comment authors against approved reviewer list",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Build validate_author() function in controller/src/remediation/auth.rs checking if comment author is Tess QA bot or in approved reviewer allowlist. Implement configurable allowlist management using controller configuration, support for team-based permissions, and integration with GitHub API for user verification. Add special handling for bot accounts, service accounts, and admin overrides. Include caching mechanism using std::collections::HashMap or dashmap for authorization results to reduce API calls.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Error Handling and Fallbacks",
            "description": "Create comprehensive error handling system with graceful degradation and manual review fallbacks",
            "status": "pending",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Design custom error types in controller/src/remediation/error.rs using thiserror crate for parsing failures (MalformedComment, MissingRequiredField, InvalidAuthor). Implement anyhow::Result<StructuredFeedback> return types throughout the module, create fallback parsing strategies for partial extraction, and add structured logging using tracing crate with context for debugging. Implement retry logic for transient failures, queue malformed comments for manual review, and provide detailed error messages for operators.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create Comprehensive Unit Tests",
            "description": "Develop extensive test suite covering all parsing scenarios, edge cases, and security considerations",
            "status": "pending",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Write unit tests in controller/src/remediation/tests/ for valid comment parsing with all field combinations, malformed comments with missing/invalid fields, edge cases (empty comments, special characters, Unicode), performance tests with large comments (>10MB), security tests for injection attacks (XSS, command injection), regex performance and catastrophic backtracking prevention, and integration tests with real GitHub webhook payloads. Use proptest crate for property-based testing and fuzzing input validation. Follow testing patterns from controller/src/tasks/tests/.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Integrate Parser with Controller API",
            "description": "Create controller API endpoints or library functions for Rex container to call the parser",
            "status": "pending",
            "dependencies": [
              5
            ],
            "details": "Implement controller API endpoint or exposed library function in controller/src/remediation/mod.rs that Rex container can invoke to parse feedback comments. Follow existing controller API patterns, ensure proper error propagation, add request/response logging, and implement appropriate access controls. Consider whether parser should be called via HTTP API, gRPC, or direct library linking when Rex runs in remediation mode.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Create Remediation Sensor and Trigger",
        "description": "Deploy Argo Events Sensor to process feedback comments and trigger Rex remediation CodeRuns",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "details": "Implement Sensor that integrates with existing play workflow infrastructure to trigger Rex remediation:\n\n1. Create Sensor CRD following patterns from play-workflow-sensors.yaml\n2. Extract task ID from PR labels using JSONPath\n3. Generate CodeRun resources (not workflows) with REMEDIATION_MODE=true\n4. Pass comment ID and iteration count to Rex via environment variables\n5. Implement retry logic and error handling\n\nKey features:\n- Builds on existing GitHub webhook EventSource\n- Creates CodeRun resources for Rust controller to process\n- Integrates with implementation-agent-remediation sensor for cancellation\n- Uses ConfigMaps for state tracking (implemented separately)\n- JSONPath expressions for data extraction\n- Event deduplication\n\nImplementation:\n```yaml\napiVersion: argoproj.io/v1alpha1\nkind: Sensor\nmetadata:\n  name: pr-comment-remediation\n  namespace: github-webhooks\nspec:\n  eventBusName: default\n  dependencies:\n    - name: feedback-comment\n      eventSourceName: github\n      eventName: issue_comment\n      filters:\n        data:\n          - path: body.comment.body\n            type: string\n            comparator: \"~\"\n            value: \".*ðŸ”´ Required Changes.*\"\n  triggers:\n    - template:\n        name: create-remediation-coderun\n        k8s:\n          operation: create\n          source:\n            resource:\n              apiVersion: cto.5dlabs.com/v1alpha1\n              kind: CodeRun\n              metadata:\n                generateName: remediation-rex-\n                labels:\n                  task-id: \"\"  # Extracted from PR\n                  iteration: \"\"  # From ConfigMap\n              spec:\n                github_app: rex\n                remediation_mode: true\n                pr_comment_id: \"\"  # From event\n```\n\nWhen Rex pushes fixes, the existing implementation-agent-remediation sensor handles Cleo/Tess cancellation automatically.",
        "testStrategy": "1. Test sensor activation with valid feedback comments in play workflow\n2. Verify CodeRun creation with REMEDIATION_MODE=true\n3. Test filtering logic (should ignore non-feedback comments)\n4. Validate task ID extraction from PR labels\n5. Test integration with existing implementation-agent-remediation sensor\n6. Verify play workflow continues normally after Rex remediation",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Sensor CRD Following Existing Patterns",
            "description": "Create the Sensor CRD modeled after existing sensors in play-workflow-sensors.yaml",
            "status": "pending",
            "dependencies": [],
            "details": "Implement the Sensor CRD structure following existing patterns:\n- Place in infra/gitops/resources/github-webhooks/ alongside existing sensors\n- Metadata with name 'pr-comment-remediation' in namespace 'github-webhooks'\n- Use existing GitHub EventSource (already configured)\n- EventBus configuration matching other play workflow sensors\n- Proper API version (argoproj.io/v1alpha1) and kind\n- Labels and annotations consistent with play-workflow-sensors\n- Follow naming conventions from implementation-agent-remediation sensor",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure JSONPath Event Filters",
            "description": "Implement JSONPath expressions to filter PR comments containing feedback markers and extract required data fields",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Set up filtering logic matching existing sensor patterns:\n- Filter for comment body containing 'ðŸ”´ Required Changes' using regex comparator\n- Add eventName filter for 'issue_comment' events\n- Implement JSONPath for extracting PR number (body.issue.number)\n- Extract comment ID (body.comment.id) for passing to Rex\n- Extract PR labels array for task ID identification\n- Add filters to exclude bot comments except from Cleo/Tess\n- Use same filter structure as implementation-agent-remediation sensor",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create CodeRun Resource Template",
            "description": "Build the Kubernetes resource template for generating Rex remediation CodeRun objects",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "Design CodeRun generation template using existing CRD:\n- Use apiVersion: cto.5dlabs.com/v1alpha1, kind: CodeRun\n- Set github_app: rex (controller uses this for agent identification)\n- Add spec.remediation_mode: true flag for Rex to detect mode\n- Pass PR comment ID via spec.pr_comment_id field\n- Use generateName for unique CodeRun names\n- Add labels for task-id and iteration tracking\n- Match resource structure from existing CodeRun implementations\n- Controller will handle PVC mounting and container execution",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Task ID Extraction from PR Labels",
            "description": "Create logic to extract task IDs from PR labels and add to CodeRun metadata",
            "status": "pending",
            "dependencies": [
              3
            ],
            "details": "Build task identification using JSONPath:\n- Parse PR labels using body.issue.labels[?(@.name =~ 'task-.*')].name\n- Extract numeric task ID from 'task-X' label format\n- Add extracted task-id to CodeRun labels for tracking\n- Implement parameter mapping from event data to resource\n- Use same JSONPath patterns as other play workflow sensors\n- Handle missing task label scenario with default behavior\n- Task context will be loaded by Rex from ConfigMap (separate implementation)",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add Iteration Tracking via ConfigMap",
            "description": "Implement iteration counter using ConfigMap for state persistence across remediation cycles",
            "status": "pending",
            "dependencies": [
              4
            ],
            "details": "Create iteration management integrated with play workflow:\n- Read current iteration from ConfigMap (remediation-state-{task-id})\n- Increment counter and update ConfigMap via trigger\n- Pass iteration count to CodeRun via label or annotation\n- Rex will check iteration limit (MAX_ITERATIONS env var)\n- ConfigMap managed separately from sensor (controller responsibility)\n- Follow state management patterns from play workflow\n- Sensor only reads/updates counter, escalation handled elsewhere",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Configure Retry and Error Handling",
            "description": "Implement retry mechanisms matching existing sensor configurations",
            "status": "pending",
            "dependencies": [
              5
            ],
            "details": "Build reliability features consistent with play workflow:\n- Use same retry policy as implementation-agent-remediation sensor\n- Configure exponential backoff (if supported by trigger type)\n- Handle CodeRun creation failures gracefully\n- Add error logging to match existing sensor patterns\n- Leverage EventBus delivery guarantees\n- No custom dead letter queue (use platform defaults)\n- Timeout configurations matching other sensors\n- Errors logged but not blocking play workflow progression",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement Event Deduplication",
            "description": "Add deduplication to prevent duplicate CodeRuns from rapid comment edits",
            "status": "pending",
            "dependencies": [
              6
            ],
            "details": "Design deduplication following platform patterns:\n- Use event ID from GitHub webhook (built-in deduplication)\n- Leverage Argo Events' native deduplication features\n- Configure dependency filters to ignore duplicate events\n- Time window configuration (default 60 seconds)\n- No custom caching needed (platform handles this)\n- Test with GitHub's webhook retry behavior\n- Ensure idempotent CodeRun creation\n- Match deduplication approach from other play sensors",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement State Management System",
        "description": "Build ConfigMap-based state tracking for remediation iterations and feedback history in Rust controller",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "details": "Enhance the existing Rust controller to manage remediation state using Kubernetes ConfigMaps:\n\n1. Create remediation::state module in controller/src/\n2. Design ConfigMap schema for state storage\n3. Implement CRUD operations using Kube client\n4. Add atomic iteration counter with proper locking\n5. Store feedback history as JSON-serialized data\n6. Implement state recovery and cleanup patterns\n\nKey components:\n- Rust module at controller/src/remediation/state.rs\n- ConfigMap per task (task-{id}-state)\n- Atomic operations using Kube API\n- JSON serialization with serde\n- TTL-based cleanup following controller patterns\n\nImplementation approach:\n```rust\nuse kube::{Api, Client};\nuse k8s_openapi::api::core::v1::ConfigMap;\nuse serde::{Serialize, Deserialize};\n\n#[derive(Clone)]\npub struct StateManager {\n    client: Client,\n    namespace: String,\n}\n\nimpl StateManager {\n    pub async fn increment_iteration(&self, task_id: &str) -> Result<u32, Error> {\n        let api: Api<ConfigMap> = Api::namespaced(self.client.clone(), &self.namespace);\n        let cm_name = format!(\"task-{}-state\", task_id);\n        \n        // Use server-side apply for atomic updates\n        let mut cm = self.get_or_create_configmap(&cm_name).await?;\n        let iteration: u32 = cm.data.get(\"iteration\")\n            .and_then(|s| s.parse().ok())\n            .unwrap_or(0);\n        \n        if iteration >= MAX_ITERATIONS {\n            return Err(Error::MaxIterations);\n        }\n        \n        cm.data.insert(\"iteration\".to_string(), (iteration + 1).to_string());\n        cm.data.insert(\"last_update\".to_string(), Utc::now().to_rfc3339());\n        \n        api.replace(&cm_name, &PostParams::default(), &cm).await?;\n        Ok(iteration + 1)\n    }\n}\n```",
        "testStrategy": "1. Test ConfigMap creation and updates via Rust integration tests\n2. Verify atomic iteration increments using Kube client mocks\n3. Test state recovery after controller restart\n4. Validate JSON serialization with serde test cases\n5. Test cleanup of old state data with time-based mocking\n6. Integration tests with actual Kubernetes cluster",
        "subtasks": [
          {
            "id": 1,
            "title": "Design ConfigMap Schema and Data Structure",
            "description": "Design the schema for storing state data in Kubernetes ConfigMaps with proper field definitions and versioning, compatible with Rust serialization",
            "status": "pending",
            "dependencies": [],
            "details": "Define ConfigMap structure with fields: task_id, iteration (u32), feedback_history (Vec<FeedbackEntry> as JSON), last_update (RFC3339), status (enum), error_messages (Vec<String>), metadata (HashMap). Create naming convention 'task-{id}-state'. Define Rust structs with serde attributes for serialization. Design version field for schema evolution. Consider ConfigMap 1MB limit when designing JSON structure.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Rust StateManager in Controller",
            "description": "Build StateManager struct in controller/src/remediation/state.rs with CRUD operations using existing Kube client",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Create controller/src/remediation/state.rs module. Implement StateManager struct reusing controller's Kube client. Create async methods: get_or_create_configmap(task_id), update_state(task_id, data), get_state(task_id), delete_state(task_id). Use kube-rs retry mechanisms for transient failures. Implement optimistic locking using resourceVersion. Follow existing controller error handling patterns. Add proper logging with tracing crate.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build Atomic Iteration Counter in Rust",
            "description": "Implement thread-safe iteration counter using Kubernetes server-side apply for atomic operations",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "Create async increment_iteration(task_id) method using server-side apply for atomicity. Define MAX_ITERATIONS constant (10) in controller config. Add get_current_iteration(task_id) for reading. Use kube-rs retry logic for handling concurrent modification conflicts. Track iteration history with chrono timestamps. Return custom Error::MaxIterations when limit reached. Ensure atomicity across multiple controller replicas.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Feedback History with Serde JSON",
            "description": "Build JSON serialization system using serde for storing and retrieving feedback history in ConfigMaps",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "Create FeedbackEntry struct with serde derive macros: timestamp (DateTime<Utc>), author (String), severity (enum), issue_type (enum), description (String), resolved (bool). Implement async append_feedback(task_id, entry) and get_feedback_history(task_id) methods. Use serde_json for serialization with proper error handling. Implement compression with flate2 for large feedback arrays. Add JSON schema validation. Handle pagination for large histories using iterator pattern.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create State Recovery in Rust Controller",
            "description": "Implement state recovery system integrated with controller's reconciliation loop",
            "status": "pending",
            "dependencies": [
              3,
              4
            ],
            "details": "Build async recover_state(task_id) method to restore from ConfigMap after controller restarts. Integrate with controller's reconciliation loop for automatic recovery. Implement state validation using serde validation attributes. Create state snapshots before critical operations using ConfigMap annotations. Add consistency checks between iteration counter and feedback history. Implement automatic state repair for common corruption patterns. Add health check to controller's /healthz endpoint.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement TTL Cleanup with Tokio Tasks",
            "description": "Build automated cleanup system using tokio background tasks following controller patterns",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "Create tokio background task for periodic cleanup scans (every 6 hours) in controller startup. Implement TTL checking based on last_update timestamp (default 7 days from config). Add async cleanup_old_states() method with configurable retention. Use ConfigMap labels for soft delete with grace period. Implement cleanup metrics using prometheus crate. Add manual cleanup trigger via controller's admin API. Follow controller's existing background task patterns.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Enhance Rex Container for Remediation",
        "description": "Create a separate Rex remediation container script to handle remediation mode with feedback processing and iteration limits",
        "status": "pending",
        "dependencies": [
          2,
          4
        ],
        "priority": "high",
        "details": "Create a DEDICATED remediation container script for Rex (separate from the normal implementation script) to handle the remediation workflow. The remediation container needs completely different context preparation focused on fixing issues rather than implementing from scratch.\n\nNew remediation script location: infra/images/rex-remediation/ or container-rex-remediation.sh\n\nKey differences from normal Rex:\n- Different prompting strategy (fix specific issues vs implement features)\n- Needs BOTH original task context AND feedback context\n- More focused, targeted changes rather than broad implementation\n- Must preserve working functionality while fixing issues\n\nRemediation script requirements:\n1. Detect REMEDIATION_MODE environment variable (passed via CodeRun spec)\n2. Fetch original task details from Task Master or documentation\n3. Fetch PR comment using GitHub CLI (already available)\n4. Parse feedback and extract metadata\n5. Check iteration limits and trigger escalation if exceeded\n6. Prepare remediation-specific CLAUDE.md with:\n   - Original task context for understanding requirements\n   - Current feedback that needs addressing\n   - Clear fix-focused instructions\n   - Iteration count and limits\n\nExample remediation script structure:\n```bash\n#!/bin/bash\n# Rex Remediation Container Script - Separate from normal Rex\n\nif [ \"$REMEDIATION_MODE\" != \"true\" ]; then\n    echo \"Error: This script requires REMEDIATION_MODE=true\"\n    exit 1\nfi\n\necho \"ðŸ”§ REX REMEDIATION MODE - Iteration $ITERATION_COUNT/10\"\n\n# Fetch original task context\nORIGINAL_TASK=$(cat /workspace/docs/task-${TASK_ID}.md || echo \"Task context not found\")\n\n# Fetch feedback comment\nCOMMENT=$(gh api /repos/$OWNER/$REPO/issues/comments/$FEEDBACK_COMMENT_ID)\n\n# Check iteration limit\nif [ \"$ITERATION_COUNT\" -ge \"10\" ]; then\n    gh pr comment $PR_NUMBER --body \"âš ï¸ Max iterations reached. Human intervention required.\"\n    exit 1\nfi\n\n# Prepare remediation-specific context\ncat > /workspace/CLAUDE.md << EOF\n# REMEDIATION MODE - Fix Required Issues\n\nYou are in remediation mode (Iteration $ITERATION_COUNT/10).\nYour task is to FIX specific issues while preserving working functionality.\n\n## Original Task Requirements\n$ORIGINAL_TASK\n\n## Issues to Fix (Priority: $SEVERITY)\n$(echo $COMMENT | jq -r .body)\n\n## Instructions\n1. Review the original requirements to understand context\n2. Address ALL issues mentioned in the feedback\n3. Make targeted fixes without breaking working features\n4. Focus on the specific problems identified\n5. Do NOT reimplement from scratch\nEOF\n\n# Invoke Claude runner with remediation context\nexec /usr/local/bin/claude-runner\n```\n\nThe remediation container will:\n- Use GitHub CLI for fetching comments (existing auth)\n- Work with the existing CodeRun CRD\n- Be triggered by the remediation sensor\n- Push fixes that trigger implementation-agent-remediation sensor",
        "testStrategy": "1. Test separate remediation script activation via REMEDIATION_MODE\n2. Verify original task context fetching from Task Master/docs\n3. Test GitHub API calls for comment retrieval\n4. Validate remediation-specific context generation\n5. Test iteration limit enforcement and escalation\n6. Verify integration with existing play workflow and CodeRun CRD\n7. Test that normal Rex container remains unaffected\n8. Validate fix-focused prompting produces targeted changes",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Separate Rex Remediation Container Script",
            "description": "Create a new dedicated remediation container script separate from the existing Rex implementation script",
            "status": "pending",
            "dependencies": [],
            "details": "Create a new remediation-specific container script at infra/images/rex-remediation/ or container-rex-remediation.sh. This script will be completely separate from the normal Rex implementation script to handle the different context preparation and prompting strategies needed for remediation. The script should fail fast if REMEDIATION_MODE is not set, ensuring it's only used for remediation workflows. Structure the script with clear sections for task context fetching, feedback retrieval, context preparation, and Claude runner invocation.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Original Task Context Fetching",
            "description": "Add logic to fetch the original task details from Task Master or documentation to provide context for remediation",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Implement fetching of original task requirements from Task Master system or documentation files. Use TASK_ID environment variable to locate the correct task details (e.g., /workspace/docs/task-${TASK_ID}.md or via Task Master API). This context is critical for understanding what was supposed to be implemented originally. Handle cases where task context might not be available with appropriate fallbacks. Ensure the fetched context includes acceptance criteria, implementation requirements, and any relevant specifications.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add GitHub API Comment Fetching for Feedback",
            "description": "Implement GitHub CLI integration to fetch PR comment containing feedback",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Use the gh CLI tool to fetch the feedback comment from GitHub API endpoint /repos/$OWNER/$REPO/issues/comments/$FEEDBACK_COMMENT_ID. Leverage existing GitHub App authentication that Rex containers already use. Implement error handling for API failures including rate limiting and network issues. Parse JSON response using jq to extract comment body and metadata. Add retry logic with exponential backoff for transient failures.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Build Feedback Parser for Remediation Context",
            "description": "Create parsing logic to extract and format feedback for remediation-specific context",
            "status": "pending",
            "dependencies": [
              3
            ],
            "details": "Parse comment body to extract issue types, severity levels, and specific problems to fix. Use jq for JSON processing and text parsing for markdown content. Identify and preserve markdown formatting including checkboxes, code blocks, and issue descriptions. Extract metadata such as severity, issue categories, and specific file references. Format feedback into clear, actionable items for the AI context. Handle malformed comments gracefully with appropriate error messages.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Iteration Limit Checking",
            "description": "Add iteration counter validation with escalation logic specific to remediation",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Check ITERATION_COUNT environment variable against maximum threshold of 10 iterations. Implement escalation by posting a warning comment to the PR using gh CLI when limit is reached. Set appropriate exit codes (exit 1 for escalation, exit 0 for success). Log iteration status clearly for debugging and monitoring. Include iteration count in all output messages and the remediation context. Ensure escalation message clearly indicates human intervention is required.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create Remediation-Specific AI Context",
            "description": "Build specialized context preparation that combines original requirements with feedback for fix-focused prompting",
            "status": "pending",
            "dependencies": [
              2,
              4,
              5
            ],
            "details": "Generate a remediation-specific CLAUDE.md file that differs significantly from normal implementation context. Structure the context with clear sections: Original Task Requirements (from Task Master), Issues to Fix (from PR feedback), and Remediation Instructions. Emphasize fixing specific issues rather than reimplementing features. Include iteration count and severity prominently. Add explicit instructions to preserve working functionality while addressing problems. Format the context to guide targeted, surgical fixes rather than broad changes.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Configure Container Image and Deployment",
            "description": "Set up the remediation container image build and deployment configuration",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Create Dockerfile or container configuration for the remediation-specific Rex container if needed. Ensure all required tools are available: gh CLI, jq, bash, and Claude runner. Configure the container to use the remediation script as the entrypoint when REMEDIATION_MODE is set. Update Kubernetes manifests or Helm charts to reference the remediation container variant. Ensure proper volume mounts for workspace access and secret mounting for GitHub authentication.",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Test Remediation Container End-to-End",
            "description": "Validate the separate remediation container works correctly within the existing play workflow",
            "status": "pending",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Test remediation container activation via REMEDIATION_MODE environment variable. Verify original task context is successfully fetched and included. Test GitHub API integration for comment retrieval with existing authentication. Validate the remediation-specific context produces focused fixes rather than reimplementation. Test iteration limits and escalation behavior. Verify the container integrates properly with CodeRun CRD and remediation sensor. Ensure normal Rex containers remain unaffected by these changes. Test that fixes pushed by remediation container properly trigger the implementation-agent-remediation sensor.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Agent Cancellation System",
        "description": "Enhance existing agent cancellation system to handle concurrent operations and improve race condition handling when Rex pushes remediation fixes",
        "status": "pending",
        "dependencies": [
          1,
          3,
          4
        ],
        "priority": "high",
        "details": "Enhance the existing implementation-agent-remediation sensor with advanced cancellation capabilities:\n\n**Existing Foundation (Already Implemented):**\n- Rex push event detection via implementation-agent-remediation sensor\n- Basic CodeRun deletion for Cleo/Tess agents\n- PR label management (removes 'ready-for-qa', adds 'remediation-in-progress')\n\n**Required Enhancements:**\n1. Concurrent operation handling with distributed locking\n2. Advanced race condition prevention\n3. State-aware cancellation logic\n4. Integration with state management system (Task 4)\n5. Partial failure recovery mechanisms\n\n**Enhanced Sensor Configuration:**\n```yaml\napiVersion: argoproj.io/v1alpha1\nkind: Sensor\nmetadata:\n  name: implementation-agent-remediation  # Existing sensor\nspec:\n  dependencies:\n    - name: rex-push\n      filters:\n        data:\n          - path: body.pusher.name\n            value: [\"5DLabs-Rex[bot]\", \"5DLabs-Rex\"]\n  triggers:\n    - template:\n        k8s:\n          operation: patch  # Enhanced with state checks\n          source:\n            resource:\n              apiVersion: platform.5dlabs.com/v1\n              kind: CodeRun\n          labelSelector:\n            matchExpressions:\n              - {key: agent-type, operator: In, values: [cleo, tess]}\n              - {key: task-id, operator: Exists}\n```\n\n**Enhanced Go Controller Logic:**\n```go\nfunc (c *Controller) enhancedCancellation(prNumber int, taskID string) error {\n    // Acquire distributed lock\n    lock := c.acquireLock(fmt.Sprintf(\"cancel-%s\", taskID))\n    defer lock.Release()\n    \n    // Check current state from ConfigMap\n    state := c.getRemediationState(taskID)\n    if state.CancellationInProgress {\n        return nil // Already being handled\n    }\n    \n    // Mark cancellation started\n    state.CancellationInProgress = true\n    c.updateRemediationState(taskID, state)\n    \n    // Perform cancellation with retry logic\n    err := c.cancelWithRetry(taskID, 3)\n    \n    // Update labels atomically\n    c.updatePRLabelsAtomic(prNumber, state)\n    \n    return err\n}\n```",
        "testStrategy": "1. Test enhanced cancellation with 10+ concurrent agents\n2. Verify distributed locking prevents race conditions\n3. Test integration with state management system\n4. Validate partial failure recovery mechanisms\n5. Test atomic label transitions under load\n6. Verify no orphaned resources after concurrent cancellations",
        "subtasks": [
          {
            "id": 1,
            "title": "Enhance Existing Rex Push Event Sensor",
            "description": "Extend the implementation-agent-remediation sensor with advanced filtering and state checks",
            "status": "pending",
            "dependencies": [],
            "details": "Modify the existing sensor in infra/gitops/resources/github-webhooks/play-workflow-sensors.yaml to add: 1) Additional filtering for concurrent push events, 2) State validation before triggering cancellation, 3) Enhanced error handling for webhook processing, 4) Correlation ID generation for tracking related operations. Ensure backward compatibility with current functionality.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Distributed Locking for Concurrent Operations",
            "description": "Build distributed locking mechanism using Kubernetes leases to prevent race conditions",
            "status": "pending",
            "dependencies": [],
            "details": "Create Go module using k8s.io/client-go coordination/v1 API for distributed locking. Implement lease-based locking with automatic renewal and timeout. Add lock acquisition with exponential backoff. Create lock namespace isolation per task-id. Implement deadlock detection using lease annotations. Ensure locks are released on controller restart or crash.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Enhance CodeRun Deletion with State Awareness",
            "description": "Improve CodeRun deletion logic to check state before cancellation",
            "status": "pending",
            "dependencies": [
              1,
              2
            ],
            "details": "Extend existing deletion logic to: 1) Query state ConfigMap before deletion, 2) Verify agent hasn't already completed, 3) Implement graceful termination with SIGTERM before SIGKILL, 4) Add deletion confirmation via status check, 5) Update state after successful deletion. Integrate with Task 4's state management system.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Atomic Label Transitions",
            "description": "Enhance PR label management with atomic operations and conflict resolution",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "Improve existing label management to: 1) Use GitHub's ETag for optimistic concurrency control, 2) Implement compare-and-swap operations for label updates, 3) Add retry logic with exponential backoff for conflicts, 4) Batch label operations to reduce API calls, 5) Add validation that correct labels exist before/after operations.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Build Concurrent Cancellation Coordinator",
            "description": "Create coordination layer for managing multiple simultaneous cancellations",
            "status": "pending",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement coordinator that: 1) Tracks all active cancellations in shared ConfigMap, 2) Prevents duplicate cancellation requests, 3) Manages cancellation priority queue, 4) Implements circuit breaker for cascading failures, 5) Provides cancellation status API for monitoring. Add metrics for cancellation success/failure rates.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Advanced Recovery System",
            "description": "Build sophisticated recovery mechanism for partial failures during concurrent operations",
            "status": "pending",
            "dependencies": [
              5
            ],
            "details": "Create recovery system that: 1) Detects partial failures through state inconsistencies, 2) Implements automatic rollback for failed multi-step operations, 3) Adds manual intervention triggers for unrecoverable states, 4) Creates reconciliation loop running every 30 seconds, 5) Implements cleanup for orphaned locks and resources. Include comprehensive observability.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create Stress Tests for Concurrent Cancellations",
            "description": "Develop comprehensive test suite for high-concurrency scenarios",
            "status": "pending",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Build stress tests that: 1) Simulate 20+ concurrent Rex pushes, 2) Test with random network delays and failures, 3) Verify no lost cancellations or orphaned agents, 4) Test lock contention and timeout scenarios, 5) Validate state consistency after chaos testing, 6) Measure cancellation latency under load. Include performance regression tests.",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Integrate with State Management System",
            "description": "Connect enhanced cancellation system with Task 4's state management",
            "status": "pending",
            "dependencies": [
              3,
              5
            ],
            "details": "Implement integration that: 1) Updates remediation state during cancellation, 2) Records cancellation history in state ConfigMap, 3) Uses state to determine if re-cancellation is needed, 4) Implements state-based recovery decisions, 5) Adds state validation before and after cancellation operations.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Build Label-Based Workflow Orchestration",
        "description": "Implement PR label management system for tracking remediation state and iteration counts",
        "details": "Create comprehensive label management for workflow state tracking:\n\n1. Design label schema (task-{id}, iteration-{n}, status labels)\n2. Implement atomic label updates via GitHub API\n3. Handle label transitions based on workflow events\n4. Add skip-automation override detection\n5. Implement label cleanup after completion\n\nLabel state machine:\n- task-{id}: Persistent task association\n- iteration-{n}: Updated each remediation cycle\n- needs-remediation: Added by Tess\n- remediation-in-progress: Active during Rex fixes\n- ready-for-qa: Added after Cleo\n- approved: Final state\n- skip-automation: Human override\n\nImplementation:\n```typescript\nclass LabelOrchestrator {\n    async transitionState(pr: number, from: State, to: State) {\n        const labels = await this.getLabels(pr);\n        \n        if (labels.includes('skip-automation')) {\n            throw new Error('Automation disabled by human override');\n        }\n        \n        await this.removeLabel(pr, stateToLabel(from));\n        await this.addLabel(pr, stateToLabel(to));\n        \n        if (to === State.Remediation) {\n            const iteration = this.extractIteration(labels) + 1;\n            await this.updateIterationLabel(pr, iteration);\n        }\n    }\n}\n```",
        "testStrategy": "1. Test all label state transitions\n2. Verify iteration counter updates\n3. Test skip-automation override behavior\n4. Validate concurrent label updates\n5. Test label cleanup after task completion",
        "priority": "medium",
        "dependencies": [
          4,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Document Label Schema",
            "description": "Define comprehensive label schema for workflow state tracking including naming conventions, state transitions, and usage guidelines",
            "dependencies": [],
            "details": "Create detailed documentation for label schema including: task-{id} format for task association, iteration-{n} counter format, status labels (needs-remediation, remediation-in-progress, ready-for-qa, approved), skip-automation override label. Document valid state transitions, label lifecycle, and cleanup rules. Create TypeScript interfaces for label types and state machine definitions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement GitHub API Label Integration",
            "description": "Build GitHub API client wrapper for atomic label operations with rate limiting and retry logic",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement GitHub API integration layer with methods for: getLabels(), addLabel(), removeLabel(), updateLabel(). Include rate limiting handling, exponential backoff for retries, batch operations support, and error handling for API failures. Ensure atomic operations using GitHub's label locking mechanism. Add logging and metrics collection for API calls.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build State Transition Logic Engine",
            "description": "Implement core state machine for label transitions with validation and state consistency checks",
            "dependencies": [
              "7.1",
              "7.2"
            ],
            "details": "Create LabelOrchestrator class with transitionState() method implementing state machine logic. Build state validation to ensure legal transitions only. Implement iteration counter extraction and increment logic. Add state history tracking for audit purposes. Include rollback capability for failed transitions. Implement stateToLabel() and labelToState() conversion functions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add Skip-Automation Override Detection",
            "description": "Implement detection and handling of skip-automation label to disable automated workflows",
            "dependencies": [
              "7.3"
            ],
            "details": "Build override detection system that checks for skip-automation label before any state transition. Implement early exit with appropriate error messages when override detected. Add notification system to alert relevant parties when automation is skipped. Include audit logging for override events. Create bypass mechanism for emergency situations with proper authorization.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Label Cleanup System",
            "description": "Build automated cleanup for removing obsolete labels after workflow completion or termination",
            "dependencies": [
              "7.3"
            ],
            "details": "Create cleanup manager that removes workflow labels after task completion. Implement TTL-based cleanup for abandoned tasks. Build selective cleanup that preserves task-{id} labels for history. Add cleanup triggers for success, failure, and timeout scenarios. Include dry-run mode for testing cleanup operations. Implement cleanup scheduling to avoid conflicts with active workflows.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Handle Concurrent Label Updates",
            "description": "Implement concurrency control and conflict resolution for simultaneous label operations",
            "dependencies": [
              "7.2",
              "7.3"
            ],
            "details": "Build optimistic locking mechanism using ETags or version numbers. Implement conflict detection and resolution strategies (last-write-wins, merge, or retry). Add distributed lock support using Redis or similar for critical sections. Create queue-based label update system to serialize conflicting operations. Include deadlock detection and prevention. Add metrics for concurrent operation conflicts and resolution success rates.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Escalation and Termination Logic",
        "description": "Build escalation system for max iterations and implement various termination conditions",
        "details": "Create comprehensive termination and escalation handling:\n\n1. Implement iteration limit checking (max 10)\n2. Create escalation notification system\n3. Add timeout protection (4-hour limit)\n4. Implement success criteria detection\n5. Handle manual intervention requests\n\nEscalation triggers:\n- Max iterations reached\n- Timeout exceeded\n- Critical errors\n- Manual override requested\n\nImplementation:\n```rust\npub struct EscalationManager {\n    max_iterations: u8,\n    timeout_duration: Duration,\n    notification_channels: Vec<NotificationChannel>,\n}\n\nimpl EscalationManager {\n    pub async fn check_escalation(&self, state: &RemediationState) -> Result<EscalationAction> {\n        // Check iteration limit\n        if state.iteration >= self.max_iterations {\n            self.notify_escalation(\"Max iterations reached\", &state).await?;\n            return Ok(EscalationAction::StopAndNotify);\n        }\n        \n        // Check timeout\n        if Utc::now() - state.start_time > self.timeout_duration {\n            self.notify_escalation(\"Timeout exceeded\", &state).await?;\n            return Ok(EscalationAction::StopAndNotify);\n        }\n        \n        // Check for skip-automation label\n        if self.has_skip_label(&state.pr_number).await? {\n            return Ok(EscalationAction::SkipAutomation);\n        }\n        \n        Ok(EscalationAction::Continue)\n    }\n    \n    async fn post_escalation_comment(&self, pr: u32, reason: &str) {\n        let comment = format!(\n            \"## ðŸš¨ Remediation Escalation\\n\\n\\\n            **Reason**: {}\\n\\n\\\n            Automated remediation has been stopped. Human intervention required.\\\n            \\n\\ncc: @platform-team @cto\",\n            reason\n        );\n        \n        github_client.create_comment(pr, &comment).await?;\n    }\n}\n```",
        "testStrategy": "1. Test iteration limit enforcement\n2. Verify timeout detection and handling\n3. Test escalation notifications (PR comments, alerts)\n4. Validate skip-automation label detection\n5. Test graceful termination and cleanup",
        "priority": "high",
        "dependencies": [
          4,
          5,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Iteration Limit Checking",
            "description": "Create iteration counter and limit enforcement mechanism with max 10 iterations",
            "dependencies": [],
            "details": "Implement the iteration tracking and checking logic in EscalationManager. Create atomic counter updates in state management, implement check_iteration_limit() method that compares current iteration against max_iterations constant (10), and ensure thread-safe increment operations. Include proper error handling for state retrieval failures.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Timeout Detection System",
            "description": "Build 4-hour timeout detection mechanism with timestamp tracking",
            "dependencies": [],
            "details": "Create timeout monitoring system that tracks start_time in RemediationState, implements check_timeout() method comparing elapsed time against 4-hour Duration constant, handles timezone considerations using UTC timestamps, and includes grace period handling for long-running operations. Implement proper time calculation using chrono crate.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build Critical Error Detection",
            "description": "Implement system to identify and classify critical errors requiring escalation",
            "dependencies": [],
            "details": "Create error classification system with CriticalError enum defining error types (SystemFailure, AuthenticationError, RateLimitExceeded, etc.), implement is_critical_error() method to analyze error types and severity, add pattern matching for known critical error signatures, and include error context preservation for debugging. Handle both Rex agent errors and external API failures.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Manual Override Detection",
            "description": "Create system to detect and respond to manual intervention requests via PR labels",
            "dependencies": [],
            "details": "Build manual override detection using has_skip_label() method checking for 'skip-automation' label, implement label monitoring via GitHub API, add support for multiple override labels ('manual-review-required', 'pause-automation'), and include label change event handling. Ensure proper authorization checks for label modifications.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create Escalation Notification System",
            "description": "Build multi-channel notification system for escalation events",
            "dependencies": [
              "8.1",
              "8.2",
              "8.3",
              "8.4"
            ],
            "details": "Implement NotificationChannel trait with implementations for GitHub comments, Slack webhooks, and email notifications. Create notify_escalation() method that formats escalation messages with context, sends notifications to configured channels asynchronously, includes retry logic for failed notifications, and maintains notification history. Add @mentions for platform-team and CTO in GitHub comments.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement PR Comment Posting for Escalations",
            "description": "Create formatted GitHub PR comment system for escalation notifications",
            "dependencies": [
              "8.5"
            ],
            "details": "Build post_escalation_comment() method that creates structured markdown comments with escalation emoji (ðŸš¨), reason formatting, remediation history summary, and team mentions. Include comment deduplication to prevent spam, rate limiting compliance, and proper error handling for GitHub API failures. Add links to relevant logs and state information.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement Success Criteria Detection",
            "description": "Build system to detect successful remediation completion and exit gracefully",
            "dependencies": [],
            "details": "Create success detection logic checking for all tests passing, Tess approval comments, resolved feedback items, and clean CI status. Implement check_success_criteria() method that validates PR approval status, verifies no pending required changes, confirms all quality checks passed, and detects explicit success signals. Include success notification formatting.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Build Graceful Termination Procedures",
            "description": "Implement cleanup and state preservation during termination",
            "dependencies": [
              "8.1",
              "8.2",
              "8.3",
              "8.4",
              "8.7"
            ],
            "details": "Create terminate_remediation() method handling state persistence to ConfigMap, cleanup of temporary resources, final status comment posting, and metric recording. Implement proper cleanup for running Rex agents, label updates (remove 'remediation-in-progress'), state archival for debugging, and webhook notification of termination. Ensure idempotent cleanup operations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Create Comprehensive Termination Path Testing",
            "description": "Implement full test coverage for all escalation and termination scenarios",
            "dependencies": [
              "8.1",
              "8.2",
              "8.3",
              "8.4",
              "8.5",
              "8.6",
              "8.7",
              "8.8"
            ],
            "details": "Build test suite covering iteration limit boundary cases (9, 10, 11 iterations), timeout scenarios with time mocking, critical error escalation paths, manual override label detection, notification delivery verification, success criteria validation, and cleanup operation testing. Include integration tests simulating full escalation flows, concurrent termination handling, and recovery from partial failures. Add performance tests for high-load scenarios.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Create Monitoring and Observability",
        "description": "Implement comprehensive monitoring with Prometheus metrics, structured logging, and alerting",
        "details": "Build observability layer for remediation loop monitoring:\n\n1. Define and expose Prometheus metrics\n2. Implement structured JSON logging\n3. Create Grafana dashboards\n4. Set up alerting rules\n5. Add distributed tracing\n\nKey metrics:\n- remediation_cycles_total{task_id, outcome}\n- remediation_iteration_count{task_id}\n- remediation_duration_seconds{task_id, iteration}\n- agent_cancellations_total{agent_type}\n- escalations_total{reason}\n\nImplementation:\n```go\nvar (\n    remediationCycles = prometheus.NewCounterVec(\n        prometheus.CounterOpts{\n            Name: \"remediation_cycles_total\",\n            Help: \"Total remediation cycles by outcome\",\n        },\n        []string{\"task_id\", \"outcome\"},\n    )\n    \n    remediationDuration = prometheus.NewHistogramVec(\n        prometheus.HistogramOpts{\n            Name: \"remediation_duration_seconds\",\n            Help: \"Duration of remediation cycles\",\n            Buckets: prometheus.ExponentialBuckets(10, 2, 10),\n        },\n        []string{\"task_id\", \"iteration\"},\n    )\n)\n\n// Structured logging\nlogger.Info(\"remediation_started\",\n    zap.String(\"task_id\", taskID),\n    zap.Int(\"iteration\", iteration),\n    zap.String(\"severity\", severity),\n    zap.String(\"trigger\", \"pr_comment\"),\n)\n```\n\nAlerting rules:\n```yaml\nalerts:\n  - name: ExcessiveRemediationCycles\n    expr: remediation_iteration_count > 7\n    annotations:\n      summary: \"Task {{$labels.task_id}} has {{$value}} cycles\"\n  - name: RemediationStuck\n    expr: rate(remediation_cycles_total[2h]) == 0\n    annotations:\n      summary: \"No progress in 2 hours\"\n```",
        "testStrategy": "1. Verify metrics are correctly exposed and incremented\n2. Test structured logging output format\n3. Validate alerting rules trigger correctly\n4. Test dashboard data aggregation\n5. Verify trace propagation across services",
        "priority": "medium",
        "dependencies": [
          3,
          6,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Security and RBAC Controls",
        "description": "Set up security controls, RBAC permissions, and validation for the remediation system",
        "details": "Implement comprehensive security layer:\n\n1. Configure minimal GitHub token permissions\n2. Set up Kubernetes RBAC for agent operations\n3. Implement comment validation and sanitization\n4. Add rate limiting for API calls\n5. Implement audit logging\n\nSecurity measures:\n- Token scoping (repo:status, public_repo, write:discussion)\n- Input validation against injection attacks\n- Rate limiting (100 req/min per task)\n- Authorized reviewer allowlist\n- Audit trail for all operations\n\nRBAC configuration:\n```yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: remediation-controller\nrules:\n  - apiGroups: [\"\"]\n    resources: [\"configmaps\"]\n    verbs: [\"get\", \"list\", \"create\", \"update\", \"patch\"]\n  - apiGroups: [\"platform.5dlabs.com\"]\n    resources: [\"coderuns\"]\n    verbs: [\"get\", \"list\", \"create\", \"delete\"]\n  - apiGroups: [\"argoproj.io\"]\n    resources: [\"sensors\", \"eventsources\"]\n    verbs: [\"get\", \"list\", \"watch\"]\n```\n\nValidation implementation:\n```go\nfunc validateFeedback(feedback *StructuredFeedback, author string) error {\n    // Check authorized reviewers\n    if !isAuthorizedReviewer(author) {\n        return fmt.Errorf(\"unauthorized feedback source: %s\", author)\n    }\n    \n    // Sanitize input\n    feedback.Description = sanitizeHTML(feedback.Description)\n    \n    // Check for malicious patterns\n    if containsMaliciousPattern(feedback.Description) {\n        auditLog.Warn(\"malicious content detected\", \"author\", author)\n        return fmt.Errorf(\"invalid feedback content\")\n    }\n    \n    // Validate severity and type\n    if !isValidSeverity(feedback.Severity) || !isValidIssueType(feedback.IssueType) {\n        return fmt.Errorf(\"invalid feedback metadata\")\n    }\n    \n    return nil\n}\n```",
        "testStrategy": "1. Test token permission restrictions\n2. Verify RBAC prevents unauthorized operations\n3. Test input validation with malicious payloads\n4. Verify rate limiting enforcement\n5. Test audit logging completeness and accuracy",
        "priority": "high",
        "dependencies": [
          1,
          3,
          6
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-29T19:26:25.611Z",
      "updated": "2025-08-29T19:26:25.611Z",
      "description": "Tasks for master context"
    }
  }
}