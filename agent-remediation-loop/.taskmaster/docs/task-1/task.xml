<prompt>
    <role>You are a senior DevOps engineer specializing in Kubernetes, Argo Events, and webhook infrastructure.</role>
    <task>
        <id>1</id>
        <title>Setup GitHub Webhook Infrastructure</title>
        <description>Create and configure Argo Events Sensor resource for detecting and processing PR comments with 'ðŸ”´ Required Changes' format from the existing GitHub webhook infrastructure</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies>None</dependencies>
    </task>
    <technical_specifications>
        <spec>Use Argo Events v1.9+ Sensor CRD (existing in cluster)</spec>
        <spec>Integrate with existing GitHub EventSource at infra/gitops/resources/github-webhooks/eventsource.yaml</spec>
        <spec>Filter for issue_comment events containing 'ðŸ”´ Required Changes' pattern</spec>
        <spec>Extract task ID from PR labels using JSONPath expressions</spec>
        <spec>Generate CodeRun CRDs with REMEDIATION_MODE=true environment variable</spec>
        <spec>Deploy to argo-events namespace using existing service account</spec>
        <spec>Configure resource limits: 128Mi memory, 200m CPU</spec>
        <spec>Support concurrent event processing for multiple PRs</spec>
        <spec>Implement proper error handling and recovery</spec>
    </technical_specifications>
    <implementation_details>
        Create a new Argo Events Sensor resource that listens to the existing GitHub EventSource for PR comments containing feedback. The sensor should:
        
        1. Create sensor YAML at infra/gitops/resources/github-webhooks/remediation-feedback-sensor.yaml
        2. Configure event dependency on github-eventsource for issue_comment events
        3. Implement data filters:
           - Event header X-GitHub-Event = "issue_comment"
           - Body action = "created"
           - Comment body matches regex ".*ðŸ”´ Required Changes.*"
           - Issue has pull_request field (not null)
        4. Extract parameters using JSONPath:
           - PR number from body.issue.number
           - Comment ID from body.comment.id
           - Task ID from body.issue.labels (extract task-{number} pattern)
           - Comment author from body.comment.user.login
        5. Configure Kubernetes trigger to create CodeRun resources:
           - API version: platform.5dlabs.com/v1
           - Kind: CodeRun
           - Namespace: agent-platform
           - Generate name: rex-remediation-{hash}
           - Labels: task-id, pr-number, trigger-type, iteration
           - Spec fields: service, github_app, pr_number, pr_comment_id, continue_session
           - Environment variables: REMEDIATION_MODE, FEEDBACK_COMMENT_ID, ITERATION_COUNT
        6. Use existing RBAC and service account (argo-events-sa)
        7. Deploy using kubectl apply or GitOps workflow
        8. Verify integration with existing infrastructure
        
        The implementation must not interfere with existing sensors (play-workflow-sensors.yaml, implementation-agent-remediation) and should reuse existing infrastructure components (EventSource, HTTPRoute, secrets).
    </implementation_details>
    <acceptance_criteria>
        <criterion>Sensor successfully deployed and running in argo-events namespace</criterion>
        <criterion>PR comments with 'ðŸ”´ Required Changes' trigger sensor activation</criterion>
        <criterion>CodeRun resources created with correct parameters and environment variables</criterion>
        <criterion>Task ID correctly extracted from PR labels</criterion>
        <criterion>Only authorized users' comments trigger remediation (5DLabs-Tess, authorized reviewers)</criterion>
        <criterion>No interference with existing sensors or workflows</criterion>
        <criterion>Event processing latency less than 5 seconds</criterion>
        <criterion>Proper error handling for malformed events</criterion>
        <criterion>Resource usage within limits (128Mi memory, 200m CPU)</criterion>
        <criterion>Successful end-to-end test with real PR comment</criterion>
        <criterion>Concurrent comment processing works correctly</criterion>
        <criterion>Monitoring and logging properly configured</criterion>
    </acceptance_criteria>
    <test_strategy>
        1. Unit Testing:
           - Test event filter logic with sample webhook payloads
           - Validate JSONPath expressions for data extraction
           - Test CodeRun resource template generation
           - Verify regex patterns for comment matching
        
        2. Integration Testing:
           - Deploy sensor to test environment
           - Create test PR with task-{id} label
           - Post comment with feedback format
           - Verify sensor receives and processes event
           - Confirm CodeRun creation with correct configuration
           - Test with multiple concurrent comments
        
        3. Edge Cases:
           - Comments without feedback marker (should be ignored)
           - Comments from unauthorized users (should be filtered)
           - PRs without task labels (should handle gracefully)
           - Malformed webhook payloads (should not crash sensor)
           - Closed/merged PRs (should not trigger)
        
        4. Performance Testing:
           - Measure event processing latency
           - Monitor resource usage under load
           - Test with high volume of concurrent events
           - Verify no memory leaks during extended operation
        
        5. Rollback Testing:
           - Test sensor deletion and recreation
           - Verify no impact on other components
           - Validate state recovery after restart
    </test_strategy>
    <instructions>
        Think step-by-step about the implementation approach. Start by examining the existing sensor configurations in infra/gitops/resources/github-webhooks/ to understand the patterns and conventions used. Pay special attention to how the existing sensors handle event filtering, parameter extraction, and resource generation.
        
        Create a comprehensive sensor configuration that follows the established patterns while adding the remediation-specific logic. Ensure all JSONPath expressions are correct and test them with sample data before deployment.
        
        Provide complete, production-ready YAML configuration that includes proper resource limits, labels, and annotations. Include necessary RBAC configurations if not already present.
        
        Test your solution thoroughly in a development environment before deploying to production. Document any assumptions made and provide clear troubleshooting steps for common issues.
        
        Remember to handle error cases gracefully and ensure the sensor can recover from transient failures without manual intervention.
    </instructions>
</prompt>