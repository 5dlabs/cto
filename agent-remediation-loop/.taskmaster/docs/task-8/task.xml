<prompt>
    <role>You are a senior Rust systems engineer specializing in fault-tolerant distributed systems, escalation management, and automated incident response.</role>
    <task>
        <id>8</id>
        <title>Implement Escalation and Termination Logic</title>
        <description>Build escalation system for max iterations and implement various termination conditions</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies>4, 5, 7</dependencies>
    </task>
    <technical_specifications>
        <spec>Implement EscalationManager in Rust with max iterations limit enforcement (default 10)</spec>
        <spec>Build timeout detection system with 4-hour default limit and configurable overrides</spec>
        <spec>Create critical error classification system with automatic escalation triggers</spec>
        <spec>Implement manual override detection supporting skip-automation, manual-review-required labels</spec>
        <spec>Build multi-channel notification system supporting GitHub, Slack, Email, PagerDuty</spec>
        <spec>Create success criteria detection with PR approval, CI status, and feedback resolution validation</spec>
        <spec>Implement graceful termination with resource cleanup and state preservation</spec>
        <spec>Build comprehensive error handling with retry logic and fallback mechanisms</spec>
        <spec>Integration with Task 4's StateManager for iteration tracking and state consistency</spec>
        <spec>Support GitHub API integration with rate limiting, authentication, and structured comments</spec>
    </technical_specifications>
    <implementation_details>
        Build a comprehensive escalation and termination system for the Agent Remediation Loop:

        1. Implement iteration limit checking system:
           - Create EscalationManager struct with configurable max iterations (MAX_ITERATIONS = 10)
           - Build check_iteration_limit() method validating current iteration against maximum
           - Implement warning system triggering at 70% threshold (7 iterations)
           - Add escalation triggers when maximum iterations reached
           - Track iteration history with timestamps, outcomes, duration, and metadata
           - Integrate with Task 4's StateManager for consistent iteration counting

        2. Build timeout detection system:
           - Implement check_timeout() method monitoring elapsed time from task start
           - Set configurable timeout duration with 4-hour default (Duration::hours(4))
           - Add warning system at 75% of timeout duration (3 hours)
           - Handle timezone considerations using UTC timestamps exclusively
           - Create escalation triggers for timeout exceeded scenarios
           - Include grace period handling for long-running operations (15-minute buffer)

        3. Create critical error detection and classification:
           - Design CriticalErrorType enum: SystemFailure, AuthenticationError, RateLimitExceeded, etc.
           - Implement handle_error() method with automatic error classification using pattern matching
           - Build escalation logic for critical errors requiring immediate human attention
           - Add retry logic for recoverable errors (rate limits, temporary network failures)
           - Preserve error context with task_id, iteration, operation, and component details
           - Implement error aggregation and pattern detection for systemic issues

        4. Implement manual override detection system:
           - Build check_manual_override() method scanning PR labels for override indicators
           - Support multiple override types: skip-automation, manual-review-required, pause-remediation
           - Add comment-based intervention detection (@platform-team mentions, help requests)
           - Create bypass request system for emergency overrides with proper authorization
           - Implement comprehensive audit logging for all override events
           - Add override priority resolution for conflicting directives

        5. Create escalation notification system:
           - Implement NotificationChannel trait supporting GitHub, Slack, Email, PagerDuty
           - Build post_escalation_comment() method for structured GitHub PR comments
           - Create notification templates for different escalation reasons and contexts
           - Add team mention system (@platform-team, @cto) with appropriate urgency indicators
           - Implement retry logic with exponential backoff for notification delivery failures
           - Build fallback notification mechanisms when primary channels fail

        6. Build success criteria detection system:
           - Implement check_success_criteria() method with comprehensive validation
           - Check feedback resolution status against all historical feedback items
           - Validate PR approval status through GitHub reviews API integration
           - Monitor CI/CD status ensuring all required checks pass successfully
           - Detect explicit success signals in PR comments (Tess approvals, completion markers)
           - Handle implicit success recognition when all criteria met without explicit signal

        7. Implement graceful termination procedures:
           - Create terminate_remediation() method handling all termination scenarios
           - Build comprehensive resource cleanup for CodeRun resources and temporary data
           - Implement state archival system preserving data for post-mortem analysis
           - Update PR labels reflecting final termination status and outcomes
           - Record comprehensive metrics for monitoring, alerting, and optimization
           - Send final notifications with termination summary and next steps

        8. Build GitHub API integration:
           - Create GitHubClient with proper authentication, rate limiting, and error handling
           - Implement structured comment formatting with markdown for readability
           - Add comprehensive error handling for GitHub API failures with retry logic
           - Build efficient API usage patterns minimizing calls while maintaining functionality
           - Handle API rate limits with exponential backoff and queue management

        The system must provide reliable escalation while maintaining high performance and handling all failure scenarios gracefully.
    </implementation_details>
    <acceptance_criteria>
        <criterion>EscalationManager enforces max iterations limit (10) with proper escalation triggers</criterion>
        <criterion>Timeout detection prevents runaway processes with 4-hour limit and warnings</criterion>
        <criterion>Critical error classification triggers appropriate escalation responses</criterion>
        <criterion>Manual override detection respects human intervention requests correctly</criterion>
        <criterion>Multi-channel notification system delivers escalations reliably</criterion>
        <criterion>Success criteria detection recognizes completion automatically</criterion>
        <criterion>Graceful termination preserves state and cleans up resources properly</criterion>
        <criterion>GitHub API integration handles rate limits and failures robustly</criterion>
        <criterion>Integration with Task 4's StateManager maintains consistency</criterion>
        <criterion>Comprehensive error handling prevents escalation system failures</criterion>
        <criterion>Iteration history tracking provides complete audit trail</criterion>
        <criterion>Warning systems provide proactive notifications before limits reached</criterion>
        <criterion>Resource cleanup operations are idempotent and verifiable</criterion>
        <criterion>Performance requirements met: escalation checks < 5 seconds</criterion>
        <criterion>All termination scenarios handled with appropriate notifications</criterion>
    </acceptance_criteria>
    <test_strategy>
        1. Iteration Limit Testing:
           - Test boundary conditions: iterations 0, 9, 10, 11+
           - Validate warning triggers at 7th iteration
           - Test escalation behavior when max iterations reached
           - Verify iteration history tracking accuracy
           - Test concurrent iteration updates and consistency

        2. Timeout Detection Testing:
           - Test timeout scenarios with various durations (3h, 4h, 5h)
           - Validate warning triggers at 75% threshold (3 hours)
           - Test timezone handling and UTC consistency
           - Verify grace period behavior for long operations
           - Test timeout calculation accuracy across system restarts

        3. Critical Error Testing:
           - Test all error classification patterns with real error samples
           - Validate escalation triggers for critical vs non-critical errors
           - Test retry logic for recoverable errors (rate limits, timeouts)
           - Verify error context preservation and debugging information
           - Test error aggregation and pattern detection capabilities

        4. Manual Override Testing:
           - Test all override label types: skip-automation, manual-review-required
           - Validate comment-based intervention detection patterns
           - Test bypass request processing and authorization
           - Verify audit logging completeness and accuracy
           - Test override priority resolution with conflicting directives

        5. Notification System Testing:
           - Test all notification channels: GitHub, Slack, Email, PagerDuty
           - Validate notification delivery with channel failures
           - Test retry logic and exponential backoff mechanisms
           - Verify notification formatting and team mention accuracy
           - Test fallback mechanisms when primary channels unavailable

        6. Success Criteria Testing:
           - Test feedback resolution validation with various states
           - Validate PR approval detection with GitHub API mocking
           - Test CI/CD status monitoring and required check validation
           - Verify explicit and implicit success signal detection
           - Test success criteria edge cases and false positives

        7. Termination Testing:
           - Test all termination scenarios: success, max iterations, timeout, errors
           - Validate resource cleanup completeness and idempotency
           - Test state archival and preservation mechanisms
           - Verify final notification delivery and formatting
           - Test termination recovery from interruption scenarios

        8. Integration Testing:
           - Test StateManager integration with concurrent updates
           - Validate GitHub API integration under rate limiting
           - Test end-to-end escalation flows with real components
           - Verify monitoring and metrics collection accuracy
           - Test performance under realistic load conditions

        9. Performance Testing:
           - Benchmark escalation check latency under various loads
           - Test memory usage during sustained operation
           - Validate timeout detection efficiency and accuracy
           - Test notification delivery performance and throughput
           - Measure termination procedure completion times

        10. Reliability Testing:
            - Test system behavior during GitHub API outages
            - Validate recovery from notification delivery failures
            - Test escalation system resilience to component failures
            - Verify data consistency across failure scenarios
            - Test operational procedures and troubleshooting guides
    </test_strategy>
    <instructions>
        Begin by designing the complete escalation state machine and understanding all possible termination scenarios. Map out the decision tree for each escalation trigger and the corresponding actions.

        Focus on reliability and fault tolerance throughout the implementation. The escalation system is a critical safety net - its failure can leave the entire remediation loop in an unclear state.

        Implement comprehensive error handling for all external dependencies, especially GitHub API integration. Network failures, rate limits, and API changes should be handled gracefully.

        Pay special attention to timing and timeout calculations. Use UTC consistently and handle edge cases like system restarts, clock skew, and leap seconds.

        Build the notification system with redundancy in mind. If GitHub comments fail, ensure alternative notification channels work. Test delivery failure scenarios extensively.

        Design state preservation and cleanup procedures to be idempotent and resumable. Termination should never leave the system in an inconsistent state.

        Implement thorough logging and metrics collection for operational visibility. Escalation decisions should be traceable and debuggable.

        Test all integration points thoroughly, especially with Task 4's state management. State consistency is critical for accurate escalation decisions.

        Consider performance implications of escalation checks, especially timeout detection. These operations should not impact the performance of the main remediation flow.

        Build comprehensive test coverage including edge cases, race conditions, and failure scenarios. Use realistic data and timing patterns in tests.

        Document all escalation triggers, notification formats, and recovery procedures for operational teams.
    </instructions>
</prompt>