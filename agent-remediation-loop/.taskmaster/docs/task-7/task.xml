<prompt>
    <role>You are a senior software architect specializing in workflow orchestration, state machines, and GitHub API integration.</role>
    <task>
        <id>7</id>
        <title>Build Label-Based Workflow Orchestration</title>
        <description>Implement PR label management system for tracking remediation state and iteration counts</description>
        <priority>medium</priority>
        <status>pending</status>
        <dependencies>4, 6</dependencies>
    </task>
    <technical_specifications>
        <spec>Design comprehensive label schema with task-{id}, iteration-{n}, and status label patterns</spec>
        <spec>Implement GitHubLabelClient with rate limiting, retry logic, and ETag-based concurrency control</spec>
        <spec>Build LabelOrchestrator state machine handling all workflow transitions and conditions</spec>
        <spec>Create OverrideDetector supporting skip-automation, manual-review-required, pause-remediation labels</spec>
        <spec>Implement LabelCleanupManager with TTL-based cleanup and selective retention policies</spec>
        <spec>Build ConcurrentLabelManager with per-PR locking and atomic operation batching</spec>
        <spec>Integrate with Task 4's StateManager for iteration tracking and state consistency</spec>
        <spec>Support workflow states: initial, needs-remediation, remediation-in-progress, ready-for-qa, approved, failed-remediation</spec>
        <spec>Handle 100+ concurrent PRs with sub-5-second label operation latency</spec>
        <spec>Implement comprehensive error handling, recovery mechanisms, and monitoring integration</spec>
    </technical_specifications>
    <implementation_details>
        Build a comprehensive label-based workflow orchestration system for the Agent Remediation Loop:

        1. Design and document complete label schema:
           - Task association labels: task-{id} pattern for permanent task identification
           - Iteration tracking labels: iteration-{n} pattern for remediation cycle counting  
           - Status labels: needs-remediation, remediation-in-progress, ready-for-qa, approved, failed-remediation
           - Override labels: skip-automation, manual-review-required, pause-remediation
           - Create TypeScript interfaces defining label types, lifecycle rules, and validation
           - Document complete usage guidelines and naming conventions

        2. Implement robust GitHub API integration:
           - Create GitHubLabelClient class with proper authentication and token management
           - Implement comprehensive rate limiting using Octokit plugins with throttling
           - Add retry logic with exponential backoff for transient failures
           - Use ETag headers for optimistic concurrency control on label operations
           - Implement batch operations for efficient API usage and reduced calls
           - Handle all GitHub API error conditions with appropriate recovery strategies

        3. Build state machine orchestration engine:
           - Create LabelOrchestrator class with complete workflow state machine
           - Define all valid state transitions with trigger conditions and actions
           - Implement transitionState() method handling workflow progression
           - Add transition validation with condition checking (iteration limits, prerequisites)
           - Build action execution system for atomic label modifications
           - Integrate with Task 4's StateManager for iteration counter synchronization

        4. Implement override detection and handling:
           - Create OverrideDetector class supporting multiple override types
           - Add automatic detection of override labels before all operations
           - Implement notification system alerting relevant parties of override events
           - Build bypass request system for emergency override scenarios
           - Add comprehensive audit logging for all override activities
           - Handle override conflicts and priority resolution

        5. Build automated label cleanup system:
           - Create LabelCleanupManager with TTL-based cleanup policies
           - Implement selective cleanup preserving important historical labels
           - Add scheduled cleanup jobs with comprehensive result reporting
           - Build abandoned task detection with configurable retention periods
           - Handle cleanup conflicts gracefully without affecting active workflows
           - Implement dry-run mode for testing and validation

        6. Implement concurrency control mechanisms:
           - Create ConcurrentLabelManager with per-PR distributed locking
           - Build queue-based operation batching for improved efficiency
           - Implement atomic label operations with conflict resolution
           - Add optimistic concurrency control using GitHub ETags
           - Handle race conditions and concurrent modification scenarios
           - Build retry mechanisms with exponential backoff and jitter

        7. Add comprehensive integration capabilities:
           - Integrate seamlessly with Task 4's state management system
           - Connect with existing webhook sensors for automated triggers
           - Build notification system integration for status updates
           - Add monitoring and metrics collection for all operations
           - Implement health check endpoints and operational visibility

        The system must provide reliable workflow orchestration while maintaining high performance and handling concurrent operations safely.
    </implementation_details>
    <acceptance_criteria>
        <criterion>Complete label schema implemented with consistent naming conventions and lifecycle rules</criterion>
        <criterion>GitHubLabelClient handles rate limiting, retries, and concurrency control effectively</criterion>
        <criterion>LabelOrchestrator state machine manages all workflow transitions correctly</criterion>
        <criterion>Override detection system provides comprehensive human control capabilities</criterion>
        <criterion>Label cleanup system maintains hygiene without affecting active workflows</criterion>
        <criterion>Concurrent operations complete without conflicts using distributed locking</criterion>
        <criterion>Integration with Task 4's StateManager maintains consistency</criterion>
        <criterion>All workflow states supported: initial, needs-remediation, remediation-in-progress, ready-for-qa, approved, failed-remediation</criterion>
        <criterion>Performance requirements met: 100+ concurrent PRs, sub-5-second operations</criterion>
        <criterion>Comprehensive error handling and recovery mechanisms implemented</criterion>
        <criterion>Monitoring and observability provide full operational visibility</criterion>
        <criterion>Override labels (skip-automation, manual-review-required, pause-remediation) function correctly</criterion>
        <criterion>Iteration tracking synchronized between labels and state management</criterion>
        <criterion>Cleanup operations preserve historical data while removing obsolete labels</criterion>
        <criterion>Security requirements met with proper authentication and access control</criterion>
    </acceptance_criteria>
    <test_strategy>
        1. State Machine Testing:
           - Test all valid workflow state transitions with various trigger conditions
           - Validate invalid transition attempts are handled gracefully
           - Test condition checking for iteration limits and prerequisites
           - Verify state consistency between labels and internal state
           - Test rollback mechanisms for failed transitions

        2. Concurrency Testing:
           - Simulate multiple concurrent label operations on same PR
           - Test distributed locking with multiple process instances
           - Validate atomic operations prevent race conditions
           - Test conflict resolution with simultaneous GitHub API calls
           - Verify batch operations work correctly under high concurrency

        3. GitHub API Integration Testing:
           - Test rate limiting handling with high-volume operations
           - Validate retry logic with simulated API failures
           - Test ETag-based concurrency control with concurrent updates
           - Verify error handling for all GitHub API response codes
           - Test authentication and token refresh scenarios

        4. Override System Testing:
           - Test detection of all override label types
           - Validate workflow halting when override labels present
           - Test notification system for override events
           - Verify bypass request processing and approval workflow
           - Test priority resolution for multiple override types

        5. Cleanup System Testing:
           - Test TTL-based cleanup with various retention policies
           - Validate selective cleanup preserves important labels
           - Test cleanup of abandoned tasks with realistic datasets
           - Verify cleanup conflicts handled without data loss
           - Test scheduled cleanup job execution and reporting

        6. Performance Testing:
           - Benchmark label operations under realistic load (100+ PRs)
           - Measure GitHub API call efficiency and optimization
           - Profile memory usage during sustained high-load operation
           - Test cleanup performance with large datasets
           - Validate latency requirements under various conditions

        7. Integration Testing:
           - Test integration with Task 4's state management system
           - Validate webhook sensor integration and event processing
           - Test notification system integration and alert delivery
           - Verify monitoring and metrics collection accuracy
           - Test operational procedures and troubleshooting guides

        8. Security Testing:
           - Validate GitHub token security and access control
           - Test input validation and injection attack prevention
           - Verify audit logging captures all sensitive operations
           - Test authorization for override and administrative functions
           - Validate data privacy and sensitive information handling
    </test_strategy>
    <instructions>
        Begin by designing the complete label schema and state machine before implementing any components. Understanding the full workflow is crucial for building a robust system.

        Focus heavily on GitHub API integration reliability. The GitHub API can fail in many ways, and your system must handle all failure modes gracefully. Implement comprehensive retry logic and rate limiting from the start.

        Pay special attention to concurrency control. Multiple processes will be updating PR labels simultaneously, and race conditions can cause data corruption. Use distributed locking and atomic operations effectively.

        Build the state machine with clear separation between state determination, transition validation, and action execution. This separation makes the system easier to test and maintain.

        Implement override detection as a first-class concern. The ability for humans to override automation is critical for operational safety. Make override detection fast and reliable.

        Design the cleanup system carefully to avoid removing labels from active workflows. Test cleanup operations thoroughly with realistic data to ensure they work correctly.

        Focus on observability throughout the implementation. Every operation should be logged, metriced, and traceable for debugging and operational visibility.

        Test thoroughly with realistic concurrency patterns. Race conditions are often subtle and only appear under specific load conditions.

        Build comprehensive error handling that provides clear diagnostic information. Operators need to understand what went wrong and how to fix it.

        Consider operational excellence from the beginning. Build health checks, monitoring dashboards, and troubleshooting guides as part of the core implementation.
    </instructions>
</prompt>