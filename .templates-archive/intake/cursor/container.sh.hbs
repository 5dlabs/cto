#!/bin/sh
# =============================================================================
# Intake Documentation Template - Cursor CLI
# =============================================================================
# This template handles documentation generation phase for unified intake.
# It runs after TaskMaster has parsed the PRD and generated tasks.
# =============================================================================

# =============================================================================
# Error Handling - Prevent Silent Failures
# =============================================================================
# Write errors to shared PVC before exit to prevent silent failures (A2 alerts)
INTAKE_ERROR_DIR="${WORKSPACE_PVC:-/workspace}/intake-errors"
INTAKE_POD_NAME="${POD_NAME:-$(hostname)}"
INTAKE_START_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)

# Function to log errors to shared storage (POSIX sh compatible)
log_error_to_pvc() {
    error_exit_code="$1"
    error_line_no="$2"
    error_command="$3"
    error_timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    # Create error directory if it exists (shared PVC)
    mkdir -p "$INTAKE_ERROR_DIR" 2>/dev/null || true

    # Write error report
    error_file="$INTAKE_ERROR_DIR/error-${INTAKE_POD_NAME}-$(date +%s).log"
    {
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "INTAKE ERROR REPORT (Cursor Template)"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "Pod Name: $INTAKE_POD_NAME"
        echo "Start Time: $INTAKE_START_TIME"
        echo "Error Time: $error_timestamp"
        echo "Exit Code: $error_exit_code"
        echo "Failed at Line: $error_line_no"
        echo "Failed Command: $error_command"
        echo ""
        echo "Configuration:"
        echo "  Repository: ${REPO_URL:-unknown}"
        echo "  GitHub App: {{github_app}}"
        echo ""
        echo "Environment:"
        echo "  PWD: $(pwd)"
        echo "  USER: $(whoami)"
        echo ""
        echo "Last 50 lines of output available in container logs"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    } > "$error_file" 2>/dev/null || true

    echo "üìù Error logged to: $error_file" >&2
}

# Set up error handling (sh compatible)
set -e

# Track success for exit trap
INTAKE_SUCCESS=0

# Exit trap that only logs on failure
exit_handler() {
    exit_code=$?
    if [ "$exit_code" -ne 0 ] && [ "$INTAKE_SUCCESS" -eq 0 ]; then
        log_error_to_pvc "$exit_code" "unknown" "unknown"
        echo "‚ùå INTAKE FAILURE (exit code: $exit_code)" >&2
        sync 2>/dev/null || true
        sleep 1
    fi
}

trap 'exit_handler' EXIT

echo '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'
echo '‚ïë        INTAKE DOCUMENTATION GENERATION - CURSOR CLI          ‚ïë'
echo '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'
echo "üìç Template version: intake-cursor v1.1.0"
echo "üìÖ Timestamp: $INTAKE_START_TIME"
echo "üì¶ Pod: $INTAKE_POD_NAME"
echo "üéØ Agent: {{github_app}}"
echo "üìã Run Type: documentation"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

REPO_URL="{{repository_url}}"

# =============================================================================
# GitHub App Authentication (same as claude template)
# =============================================================================
echo ""
echo "üîê Setting up GitHub App authentication..."

generate_github_token() {
    if [ -z "$GITHUB_APP_PRIVATE_KEY" ] || [ -z "$GITHUB_APP_ID" ]; then
        echo "‚ùå GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
        return 1
    fi
    
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"
    
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
    REPO_OWNER=$(echo "$REPO_URL" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
    REPO_NAME=$(echo "$REPO_URL" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    
    INSTALLATION_RESPONSE=$(curl -s -L -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")
    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')
    
    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        ORG_INSTALLATION_RESPONSE=$(curl -s -L -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi
    
    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        rm -f "$TEMP_KEY_FILE"
        return 1
    fi
    
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    rm -f "$TEMP_KEY_FILE"
    
    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        return 1
    fi
    
    export GITHUB_TOKEN
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    echo "$GITHUB_TOKEN" | gh auth login --with-token
    echo "‚úì GitHub App authenticated successfully"
}

if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    generate_github_token || exit 1
else
    echo "‚ùå GitHub App credentials not found"
    exit 1
fi

# =============================================================================
# Git Configuration
# =============================================================================
echo ""
echo "üîß Configuring Git..."

GITHUB_APP="{{github_app}}"
slug=$(printf '%s' "$GITHUB_APP" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g')
GIT_AUTHOR_NAME="${slug}[bot]"
GIT_AUTHOR_EMAIL="${slug}[bot]@users.noreply.github.com"

git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"
git config --global --add safe.directory /workspace

export GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"

echo "‚úì Git configured as $GIT_AUTHOR_NAME"

# =============================================================================
# Workspace Setup
# =============================================================================
echo ""
echo "üìÅ Setting up workspace..."

WORKING_DIR="{{working_directory}}"
if [ -n "$WORKING_DIR" ] && [ "$WORKING_DIR" != "." ]; then
    CURSOR_WORK_DIR="/workspace/$WORKING_DIR"
else
    CURSOR_WORK_DIR="/workspace"
fi

cd "$CURSOR_WORK_DIR" || exit 1
echo "‚úì Working directory: $CURSOR_WORK_DIR"

# Copy ConfigMap files
if [ -d "/task-files" ]; then
    for md_file in /task-files/*.md; do
        [ -f "$md_file" ] && cp -f "$md_file" "$CURSOR_WORK_DIR/"
    done
fi

# =============================================================================
# Validate TaskMaster Setup
# =============================================================================
echo ""
echo "üìã Validating TaskMaster setup..."

if [ ! -d "$CURSOR_WORK_DIR/.taskmaster" ] || [ ! -f "$CURSOR_WORK_DIR/.taskmaster/tasks/tasks.json" ]; then
    echo "‚ùå TaskMaster not initialized or tasks.json not found"
    exit 1
fi

TASK_COUNT=$(jq -r '.tasks | length' "$CURSOR_WORK_DIR/.taskmaster/tasks/tasks.json" 2>/dev/null || echo "0")
echo "‚úì Found $TASK_COUNT tasks"

mkdir -p "$CURSOR_WORK_DIR/.taskmaster/docs"

# =============================================================================
# Create PR Branch
# =============================================================================
echo ""
echo "üåø Creating PR branch..."

SOURCE_BRANCH="{{source_branch}}"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
PR_BRANCH="docs/intake-${TIMESTAMP}-$(date +%s | tail -c 6)"

git checkout -b "$PR_BRANCH" "origin/$SOURCE_BRANCH" 2>/dev/null || exit 1
export SOURCE_BRANCH
echo "‚úì Created PR branch: $PR_BRANCH"

# =============================================================================
# Cursor Execution
# =============================================================================
echo ""
echo "ü§ñ Starting Cursor documentation generation..."

cd "$CURSOR_WORK_DIR"

# Cursor CLI command (headless mode)
CURSOR_CMD="cursor --headless --output-format stream-json"

# Add project rules if available
if [ -f "$CURSOR_WORK_DIR/.cursorrules" ]; then
    echo "‚úì Found .cursorrules"
fi

# Build the documentation prompt
DOC_PROMPT="Generate comprehensive documentation for all tasks in .taskmaster/tasks/tasks.json.

For EACH task, create in .taskmaster/docs/task-{id}/:
- task.md: Task overview and implementation guide
- prompt.md: Autonomous prompt for AI agents
- acceptance-criteria.md: Clear acceptance criteria
- task.xml: XML-structured prompt for LLMs

Add agent hints: 'frontend' for UI tasks, 'backend' for API tasks, 'integration' for cross-system tasks."

echo "Starting Cursor with documentation prompt..."
echo "$DOC_PROMPT" | $CURSOR_CMD &
CURSOR_PID=$!

wait "$CURSOR_PID"
echo "Cursor completed with exit code: $?"

# =============================================================================
# PR Creation
# =============================================================================
echo ""
echo "üìù Creating pull request..."

cd "$CURSOR_WORK_DIR"
git add .taskmaster/
STAGED_FILES=$(git status --porcelain | grep "^[AM]" | wc -l)

if [ "$STAGED_FILES" -gt 0 ]; then
    git commit -m "docs: generate TaskMaster documentation

ü§ñ Auto-generated by Unified Intake (Cursor CLI)"

    git push -u origin "$PR_BRANCH"
    
    gh pr create \
        --title "docs: TaskMaster documentation for project intake" \
        --body "Auto-generated TaskMaster documentation.

**Branch:** \`$PR_BRANCH\` ‚Üí \`$SOURCE_BRANCH\`
**Tasks:** $TASK_COUNT

ü§ñ Generated by Cursor CLI" \
        --base "$SOURCE_BRANCH" --head "$PR_BRANCH" || echo "‚ö†Ô∏è PR creation failed"
else
    echo "‚ö†Ô∏è No documentation changes to commit"
fi

# Mark as successful to prevent exit trap from logging error
INTAKE_SUCCESS=1

echo ""
echo "‚úÖ Intake documentation generation complete!"





