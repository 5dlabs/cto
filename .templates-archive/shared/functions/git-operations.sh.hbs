# =========================================================================
# Git Operations - Shared Functions
# 
# Common git helper functions used across all CLI containers.
# Provides safe wrappers, credential management, and state cleanup.
# =========================================================================

# Write git credentials file for HTTPS authentication
write_git_credentials() {
  if [ -z "${GITHUB_TOKEN:-}" ]; then
    return
  fi
  printf 'https://x-access-token:%s@github.com\n' "$GITHUB_TOKEN" >"$CREDENTIALS_FILE"
  chmod 600 "$CREDENTIALS_FILE" 2>/dev/null || true
}

# Write GitHub CLI hosts configuration
write_gh_hosts_config() {
  if [ -z "${GITHUB_TOKEN:-}" ]; then
    return
  fi

  local hosts_dir="${GH_CONFIG_DIR:-$HOME/.config/gh}"
  mkdir -p "$hosts_dir"

  cat >"$hosts_dir/hosts.yml" <<EOF
github.com:
    user: x-access-token
    oauth_token: ${GITHUB_TOKEN}
    git_protocol: https
EOF

  chmod 600 "$hosts_dir/hosts.yml" 2>/dev/null || true
}

# Find the gh CLI hosts file
gh_hosts_file() {
  if [ -n "${GH_CONFIG_DIR:-}" ] && [ -f "${GH_CONFIG_DIR}/hosts.yml" ]; then
    printf '%s\n' "${GH_CONFIG_DIR}/hosts.yml"
    return
  fi
  if [ -f "$HOME/.config/gh/hosts.yml" ]; then
    printf '%s\n' "$HOME/.config/gh/hosts.yml"
    return
  fi
  printf ''
}

# Sync gh hosts config to a target directory
sync_gh_hosts_to_path() {
  local target="$1"
  if [ -z "$target" ]; then
    return
  fi
  local source
  source=$(gh_hosts_file)
  if [ -z "$source" ] || [ ! -f "$source" ]; then
    return
  fi
  local dest_dir="$target/.config/gh"
  mkdir -p "$dest_dir"
  if cp "$source" "$dest_dir/hosts.yml" >/dev/null 2>&1; then
    chmod 600 "$dest_dir/hosts.yml" 2>/dev/null || true
  fi
}

# Cleanup stale git state (merge conflicts, rebase, etc.)
cleanup_git_state() {
  if [ ! -d ".git" ]; then
    return
  fi

  # Check for unresolved merge conflicts
  if git status --porcelain 2>/dev/null | grep -q "^UU\|^AA\|^DD\|^..U\|^U..\|^AU\|^UA\|^DU\|^UD"; then
    echo "‚ö†Ô∏è Detecting unresolved merge conflicts, aborting merge..."
    git merge --abort 2>/dev/null || true
    echo "‚úì Merge conflicts aborted"
  fi

  # Check for incomplete git operations
  if [ -f ".git/REBASE_HEAD" ] || [ -f ".git/CHERRY_PICK_HEAD" ] || [ -f ".git/MERGE_HEAD" ]; then
    echo "‚ö†Ô∏è Detecting incomplete git operation, resetting..."
    git rebase --abort 2>/dev/null || true
    git cherry-pick --abort 2>/dev/null || true
    git merge --abort 2>/dev/null || true
    if ! git diff-index --quiet HEAD 2>/dev/null; then
      git reset --hard HEAD 2>/dev/null || true
    fi
    echo "‚úì Git operations reset"
  fi
}

# Cleanup locked refs from git fetch error log
cleanup_locked_refs_from_log() {
  local log_file="$1"
  local cleaned=0

  while IFS= read -r line; do
    if echo "$line" | grep -qE "cannot lock ref.*exists"; then
      ref_name=$(echo "$line" | sed -n "s/.*cannot lock ref '\([^']*\)'.*/\1/p")
      if [ -n "$ref_name" ]; then
        echo "üßπ Cleaning stale ref: $ref_name"
        git update-ref -d "$ref_name" 2>/dev/null || true
        cleaned=1
      fi
    fi
  done < "$log_file"

  if [ $cleaned -eq 1 ]; then
    git remote prune origin >/dev/null 2>&1 || true
    return 0
  fi

  return 1
}

# Check if error is transient (retryable)
is_transient_git_error() {
  local log_file="$1"

  # HTTP 5xx errors are transient
  if grep -qE "(500|502|503|504|Internal Server Error|Bad Gateway|Service Unavailable|Gateway Timeout)" "$log_file" 2>/dev/null; then
    return 0
  fi

  # Network/connection errors are transient
  if grep -qE "(Could not resolve host|Connection refused|Connection timed out|Connection reset|Network is unreachable|Temporary failure|SSL connection)" "$log_file" 2>/dev/null; then
    return 0
  fi

  # Rate limiting is transient
  if grep -qE "(rate limit|429|Too Many Requests)" "$log_file" 2>/dev/null; then
    return 0
  fi

  return 1
}

# Generic retry wrapper for git commands with exponential backoff
# Usage: git_retry <max_attempts> <initial_delay> <command> [args...]
git_retry() {
  local max_attempts="${1:-3}"
  local initial_delay="${2:-2}"
  shift 2

  local attempt=1
  local delay="$initial_delay"
  local log_file
  log_file=$(mktemp)

  while [ $attempt -le "$max_attempts" ]; do
    if "$@" >"$log_file" 2>&1; then
      rm -f "$log_file"
      return 0
    fi

    local exit_code=$?

    # Check if error is transient and worth retrying
    if ! is_transient_git_error "$log_file"; then
      # Non-transient error - fail immediately
      cat "$log_file"
      rm -f "$log_file"
      return $exit_code
    fi

    if [ $attempt -lt "$max_attempts" ]; then
      echo "‚ö†Ô∏è Git operation failed (attempt $attempt/$max_attempts), retrying in ${delay}s..."
      head -5 "$log_file"
      sleep "$delay"
      delay=$((delay * 2))  # Exponential backoff
      attempt=$((attempt + 1))
    else
      echo "‚ùå Git operation failed after $max_attempts attempts"
      cat "$log_file"
      rm -f "$log_file"
      return $exit_code
    fi
  done

  rm -f "$log_file"
  return 1
}

# Safe git fetch with automatic locked ref cleanup and transient error retry
safe_git_fetch() {
  local log_file
  log_file=$(mktemp)
  local max_attempts=3
  local attempt=1
  local delay=2

  while [ $attempt -le $max_attempts ]; do
    if git fetch "$@" >"$log_file" 2>&1; then
      rm -f "$log_file"
      return 0
    fi

    # Try to clean locked refs first
    if cleanup_locked_refs_from_log "$log_file"; then
      echo "üîß Cleaned stale remote refs; retrying git fetch $*"
      if git fetch "$@" >"$log_file" 2>&1; then
        rm -f "$log_file"
        return 0
      fi
    fi

    # Check if error is transient and worth retrying
    if is_transient_git_error "$log_file"; then
      if [ $attempt -lt $max_attempts ]; then
        echo "‚ö†Ô∏è Git fetch failed due to transient error (attempt $attempt/$max_attempts), retrying in ${delay}s..."
        head -3 "$log_file"
        sleep "$delay"
        delay=$((delay * 2))
        attempt=$((attempt + 1))
        continue
      fi
    fi

    # Non-transient error or max attempts reached
    cat "$log_file"
    rm -f "$log_file"
    return 1
  done

  rm -f "$log_file"
  return 1
}

# Safe git clone with transient error retry
safe_git_clone() {
  git_retry 3 2 git clone "$@"
}

# Safe git pull with transient error retry
safe_git_pull() {
  git_retry 3 2 git pull "$@"
}

# Safe git push with transient error retry
safe_git_push() {
  git_retry 3 2 git push "$@"
}

# Resolve merge conflicts by rebasing on main with fallback to manual resolution
# Returns 0 on success, 1 if manual intervention needed
resolve_merge_conflicts() {
  local branch_name
  branch_name=$(git branch --show-current 2>/dev/null)
  
  if [ -z "$branch_name" ]; then
    echo "‚ùå Not on a branch - cannot resolve conflicts"
    return 1
  fi

  echo "üîÄ Attempting to resolve merge conflicts for $branch_name..."
  
  # Fetch latest main
  if ! git fetch origin main 2>/dev/null; then
    echo "‚ö†Ô∏è Failed to fetch origin main"
    return 1
  fi

  # Try rebase first (cleanest approach)
  if git rebase origin/main 2>/dev/null; then
    echo "‚úÖ Rebase successful"
    if git push origin HEAD --force-with-lease 2>/dev/null; then
      echo "‚úÖ Pushed rebased branch"
      return 0
    fi
  fi

  # Rebase failed - abort and try merge
  git rebase --abort 2>/dev/null || true

  # Try merge as fallback
  if git merge origin/main --no-edit 2>/dev/null; then
    echo "‚úÖ Merge successful"
    if git push origin HEAD 2>/dev/null; then
      echo "‚úÖ Pushed merged branch"
      return 0
    fi
  fi

  # Both failed - need manual intervention
  git merge --abort 2>/dev/null || true
  
  echo "‚ùå Automatic conflict resolution failed"
  echo "üìã Manual resolution required:"
  echo "   1. git fetch origin main"
  echo "   2. git rebase origin/main"
  echo "   3. Resolve conflicts in each file (remove <<<<<<<, =======, >>>>>>> markers)"
  echo "   4. git add <resolved-files>"
  echo "   5. git rebase --continue"
  echo "   6. git push origin HEAD --force-with-lease"
  
  return 1
}

# Check if a PR has merge conflicts
check_pr_mergeable() {
  local pr_number="$1"
  
  if [ -z "$pr_number" ]; then
    # Try to get PR number from current branch
    pr_number=$(gh pr view --json number -q '.number' 2>/dev/null || echo "")
  fi
  
  if [ -z "$pr_number" ]; then
    echo "UNKNOWN"
    return 1
  fi
  
  local mergeable
  mergeable=$(gh pr view "$pr_number" --json mergeable -q '.mergeable' 2>/dev/null || echo "UNKNOWN")
  echo "$mergeable"
  
  case "$mergeable" in
    "MERGEABLE") return 0 ;;
    "CONFLICTING") return 2 ;;
    *) return 1 ;;
  esac
}

# Safe git config with retry logic and lock file cleanup
safe_git_config() {
  local max_attempts=5
  local attempt=1
  local sleep_time=1
  
  while [ $attempt -le $max_attempts ]; do
    # Clean up stale lock files before attempting
    if [ -f "${GIT_CONFIG_GLOBAL}.lock" ]; then
      # Check if lock file is stale (older than 10 seconds)
      if find "${GIT_CONFIG_GLOBAL}.lock" -mmin +0.17 2>/dev/null | grep -q .; then
        echo "‚ö†Ô∏è  Removing stale git config lock file"
        rm -f "${GIT_CONFIG_GLOBAL}.lock" 2>/dev/null || true
      fi
    fi

    # Attempt the git config operation
    if git config "$@" 2>/dev/null; then
      return 0
    fi

    # Operation failed, retry with exponential backoff
    local exit_code=$?
    if [ $exit_code -ne 0 ] && [ $attempt -lt $max_attempts ]; then
      echo "‚ö†Ô∏è  Git config attempt $attempt/$max_attempts failed (exit $exit_code), retrying in ${sleep_time}s..."
      rm -f "${GIT_CONFIG_GLOBAL}.lock" 2>/dev/null || true
      sleep "$sleep_time"
      attempt=$((attempt + 1))
      sleep_time=$((sleep_time * 2))  # Exponential backoff
    else
      break
    fi
  done
  
  if [ $attempt -gt $max_attempts ]; then
    echo "‚ùå Git config failed after $max_attempts attempts: git config $*"
    return 1
  fi
  
  return 0
}


