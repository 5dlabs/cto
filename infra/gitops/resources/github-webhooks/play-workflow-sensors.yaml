---
# Sensor for PR Created Event - Resume after implementation work
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: play-workflow-pr-created
  namespace: argo
spec:
  replicas: 1
  deploymentStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: github-pr-created
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for pull_request opened events
          - path: headers.X-Github-Event
            type: string
            value: ["pull_request"]
          - path: body.action
            type: string
            value: ["opened"]
  triggers:
    - template:
        name: resume-after-pr-created
        conditions: "github-pr-created"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: resume-pr-created-
                namespace: agent-platform
                labels:
                  type: webhook-resume
                  target-stage: waiting-pr-created
              spec:
                entrypoint: resume-workflow
                serviceAccountName: argo-workflow
                templates:
                  - name: resume-workflow
                    script:
                      image: alpine/k8s:1.31.0
                      command: [bash]
                      env:
                        - name: GITHUB_APP_ID
                          valueFrom:
                            secretKeyRef:
                              name: github-app-5dlabs-morgan
                              key: app-id
                        - name: GITHUB_APP_PRIVATE_KEY
                          valueFrom:
                            secretKeyRef:
                              name: github-app-5dlabs-morgan
                              key: private-key
                      source: |
                        #!/bin/bash
                        set -euo pipefail

                        echo "=== PR Created Workflow Resume ==="

                        ensure_jq() {
                          if command -v jq >/dev/null 2>&1; then
                            return 0
                          fi

                          if command -v apk >/dev/null 2>&1; then
                            apk add --no-cache jq >/dev/null 2>&1 && return 0
                          elif command -v apt-get >/dev/null 2>&1; then
                            apt-get update >/dev/null 2>&1 && apt-get install -y jq >/dev/null 2>&1 && rm -rf /var/lib/apt/lists/*
                            return 0
                          elif command -v microdnf >/dev/null 2>&1; then
                            microdnf -y install jq >/dev/null 2>&1 && return 0
                          fi

                          echo "❌ Failed to install jq"
                          return 1
                        }

                        ensure_argo_cli() {
                          if command -v argo >/dev/null 2>&1; then
                            ARGO_BIN=$(command -v argo)
                            return 0
                          fi

                          ARGO_VERSION="${ARGO_VERSION:-v3.7.1}"
                          ARGO_BIN="/tmp/argo"

                          if [ ! -x "$ARGO_BIN" ]; then
                            echo "Downloading argo CLI ($ARGO_VERSION)..."
                            if command -v wget >/dev/null 2>&1; then
                              wget -qO "$ARGO_BIN" "https://github.com/argoproj/argo-workflows/releases/download/$ARGO_VERSION/argo-linux-amd64"
                            elif command -v curl >/dev/null 2>&1; then
                              curl -sSL -o "$ARGO_BIN" "https://github.com/argoproj/argo-workflows/releases/download/$ARGO_VERSION/argo-linux-amd64"
                            else
                              echo "Neither wget nor curl is available"
                              return 1
                            fi
                            chmod +x "$ARGO_BIN"
                          fi
                        }

                        build_kubeconfig() {
                          local kubeconfig_path="/tmp/argo-kubeconfig"
                          if [ -f "$kubeconfig_path" ]; then
                            echo "$kubeconfig_path"
                            return 0
                          fi

                          local ca_cert="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                          local token_file="/var/run/secrets/kubernetes.io/serviceaccount/token"

                          if [ ! -f "$token_file" ]; then
                            echo "Service account token not found"
                            return 1
                          fi

                          local server="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"
                          local token
                          token=$(cat "$token_file")

                          {
                            echo "apiVersion: v1"
                            echo "kind: Config"
                            echo "clusters:"
                            echo "  - cluster:"
                            printf '      certificate-authority: %s\n' "$ca_cert"
                            printf '      server: %s\n' "$server"
                            echo "    name: in-cluster"
                            echo "contexts:"
                            echo "  - context:"
                            echo "      cluster: in-cluster"
                            echo "      namespace: agent-platform"
                            echo "      user: sensor-sa"
                            echo "    name: in-cluster"
                            echo "current-context: in-cluster"
                            echo "users:"
                            echo "  - name: sensor-sa"
                            echo "    user:"
                            printf '      token: %s\n' "$token"
                          } > "$kubeconfig_path"

                          echo "$kubeconfig_path"
                        }

                        resume_workflow() {
                          ensure_argo_cli || return 1
                          local kubeconfig_path
                          kubeconfig_path=$(build_kubeconfig) || return 1

                          if "$ARGO_BIN" --auth-mode kubeconfig --kubeconfig "$kubeconfig_path" \
                            -n agent-platform resume "$WORKFLOW_NAME" >/tmp/argo-resume.log 2>&1; then
                            echo "✅ Workflow resumed successfully"
                            return 0
                          fi

                          echo "⚠️ Failed to resume via argo CLI; output:"
                          cat /tmp/argo-resume.log
                          return 1
                        }

                        get_installation_token() {
                          if [ -z "${GITHUB_APP_ID:-}" ] || [ -z "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
                            return 1
                          fi

                          local temp_key="/tmp/github-app-key.pem"
                          printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$temp_key"
                          chmod 600 "$temp_key"

                          local now exp hdr pay sig jwt installation_id token
                          now=$(date +%s)
                          exp=$((now + 600))
                          hdr=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w0 2>/dev/null || printf '{"alg":"RS256","typ":"JWT"}' | base64)
                          hdr=$(echo -n "$hdr" | tr '+/' '-_' | tr -d '=')
                          pay=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$now" "$exp" "$GITHUB_APP_ID" | base64 -w0 2>/dev/null || printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$now" "$exp" "$GITHUB_APP_ID" | base64)
                          pay=$(echo -n "$pay" | tr '+/' '-_' | tr -d '=')
                          sig=$(printf '%s.%s' "$hdr" "$pay" | openssl dgst -sha256 -sign "$temp_key" -binary | base64 -w0 2>/dev/null || openssl dgst -sha256 -sign "$temp_key" -binary | base64)
                          sig=$(echo -n "$sig" | tr '+/' '-_' | tr -d '=')
                          jwt="$hdr.$pay.$sig"

                          installation_id=$(curl -s -L \
                            -H "Authorization: Bearer $jwt" \
                            -H "Accept: application/vnd.github+json" \
                            "https://api.github.com/repos/${REPO}/installation" | jq -r '.id')

                          if [ -z "$installation_id" ] || [ "$installation_id" = "null" ]; then
                            installation_id=$(curl -s -L \
                              -H "Authorization: Bearer $jwt" \
                              -H "Accept: application/vnd.github+json" \
                              "https://api.github.com/orgs/${OWNER}/installation" | jq -r '.id')
                          fi

                          if [ -n "$installation_id" ] && [ "$installation_id" != "null" ]; then
                            token=$(curl -s -X POST \
                              -H "Authorization: Bearer $jwt" \
                              -H "Accept: application/vnd.github+json" \
                              "https://api.github.com/app/installations/$installation_id/access_tokens" | jq -r '.token')
                          fi

                          rm -f "$temp_key"

                          if [ -n "$token" ] && [ "$token" != "null" ]; then
                            echo "$token"
                            return 0
                          fi

                          return 1
                        }

                        pr_has_label() {
                          local label="$1"
                          local response
                          if [ -n "$AUTH_HEADER" ]; then
                            response=$(curl -s -L -H "Accept: application/vnd.github+json" -H "$AUTH_HEADER" "$PR_API_URL")
                          else
                            response=$(curl -s -L -H "Accept: application/vnd.github+json" "$PR_API_URL")
                          fi

                          echo "$response" | jq -e --arg label "$label" '((.labels // []) | map(.name) | index($label)) != null' >/dev/null 2>&1
                        }

                        update_workflow_pr_metadata() {
                          local workflow_name="$1"
                          local pr_url="$2"
                          local pr_number="$3"
                          local workflow_json patch_json

                          workflow_json=$(kubectl get workflow "$workflow_name" -n agent-platform -o json 2>/dev/null)
                          if [ -z "$workflow_json" ]; then
                            echo "⚠️ Unable to fetch workflow $workflow_name for PR metadata update"
                            return 1
                          fi

                          set +e
                          patch_json=$(echo "$workflow_json" | jq --arg prUrl "$pr_url" --arg prNumber "$pr_number" '
                            .spec.arguments.parameters = (
                              ( .spec.arguments.parameters // [] )
                              | (if (map(.name) | index("pr-url")) != null
                                   then map(if .name == "pr-url" then (.value = $prUrl) else . end)
                                   else . + [{"name":"pr-url","value":$prUrl}]
                                 end)
                              | (if (map(.name) | index("pr-number")) != null
                                   then map(if .name == "pr-number" then (.value = $prNumber) else . end)
                                   else . + [{"name":"pr-number","value":$prNumber}]
                                 end)
                            )
                            | {spec:{arguments:{parameters:.spec.arguments.parameters}}}
                          ')
                          local jq_exit=$?
                          set -e

                          if [ $jq_exit -ne 0 ]; then
                            echo "⚠️ jq failed while constructing PR metadata patch for $workflow_name"
                            return 1
                          fi

                          if [ -z "$patch_json" ]; then
                            echo "⚠️ Failed to construct PR metadata patch payload for $workflow_name"
                            return 1
                          fi

                          kubectl patch workflow "$workflow_name" -n agent-platform --type='merge' -p "$patch_json"
                        }

                        advance_stage_if_needed() {
                          local workflow_name="$1"
                          local task_id="$2"
                          local repo_label="$3"

                          local workflow_json resource_version patch_json
                          workflow_json=$(kubectl get workflow "$workflow_name" -n agent-platform -o json 2>/dev/null)
                          if [ -z "$workflow_json" ]; then
                            echo "⚠️ Unable to fetch workflow $workflow_name for stage update"
                            return 1
                          fi

                          local current_stage
                          current_stage=$(echo "$workflow_json" | jq -r '.metadata.labels["current-stage"] // ""')
                          if [ "$current_stage" != "waiting-pr-created" ]; then
                            echo "ℹ️ Workflow $workflow_name no longer at waiting-pr-created (found '$current_stage')"
                            return 0
                          fi

                          resource_version=$(echo "$workflow_json" | jq -r '.metadata.resourceVersion // ""')
                          if [ -z "$resource_version" ]; then
                            echo "⚠️ Missing resourceVersion for $workflow_name"
                            return 1
                          fi

                          patch_json=$(cat <<EOF
{"metadata":{"resourceVersion":"$resource_version","labels":{"previous-stage":"waiting-pr-created","current-stage":"waiting-quality-complete","task-id":"$task_id","repository":"$repo_label"}}}
EOF
)

                          kubectl patch workflow "$workflow_name" -n agent-platform --type='merge' -p "$patch_json"
                        }

                        ensure_jq

                        OWNER="{{ .Input.body.repository.owner.login }}"
                        REPO_NAME="{{ .Input.body.repository.name }}"
                        REPO="${OWNER}/${REPO_NAME}"
                        PR_NUMBER="{{ .Input.body.pull_request.number }}"
                        PR_URL="{{ .Input.body.pull_request.html_url }}"
                        PR_API_URL="https://api.github.com/repos/${REPO}/issues/${PR_NUMBER}"
                        TARGET_LABEL="needs-cleo"

                        extract_task_id() {
                          echo "$1" | tr '[:upper:]' '[:lower:]' | grep -oE 'task[-_/ ]*([0-9]+)' | head -n1 | grep -oE '[0-9]+' || true
                        }

                        TASK_ID=""
                        TASK_LABELS_JSON='{{ .Input.body.pull_request.labels | toJson }}'
                        if [ "$TASK_LABELS_JSON" != "null" ] && [ -n "$TASK_LABELS_JSON" ]; then
                          TASK_ID=$(echo "$TASK_LABELS_JSON" |
                            jq -er '.[] | (.name // "") | ascii_downcase | capture("task[-_/ ]*(?<id>[0-9]+)") | .id' 2>/dev/null | head -1 || true)
                        fi

                        if [ -z "$TASK_ID" ]; then
                          TASK_ID=$(extract_task_id '{{ .Input.body.pull_request.head.ref }}')
                        fi

                        if [ -z "$TASK_ID" ]; then
                          TASK_ID=$(extract_task_id '{{ .Input.body.pull_request.title }}')
                        fi

                        if [ -z "$TASK_ID" ]; then
                          echo "❌ Unable to determine task ID from PR payload"
                          exit 1
                        fi

                        echo "Task ID: $TASK_ID"

                        AUTH_HEADER=""
                        INSTALLATION_TOKEN=""
                        if INSTALLATION_TOKEN=$(get_installation_token); then
                          AUTH_HEADER="Authorization: Bearer $INSTALLATION_TOKEN"
                          echo "Using GitHub App installation token for API calls"
                        else
                          echo "ℹ️ Proceeding without GitHub App token (unauthenticated GitHub API)"
                        fi

                        echo "Waiting for Rex to apply '$TARGET_LABEL' label to PR #$PR_NUMBER..."
                        MAX_LABEL_ATTEMPTS=90
                        LABEL_WAIT_SECONDS=10
                        LABEL_ATTEMPT=1
                        LABEL_READY=false
                        while [ $LABEL_ATTEMPT -le $MAX_LABEL_ATTEMPTS ]; do
                          if pr_has_label "$TARGET_LABEL"; then
                            LABEL_READY=true
                            echo "✅ Detected label '$TARGET_LABEL' on PR"
                            break
                          fi

                          echo "⏳ Label not present yet (attempt $LABEL_ATTEMPT/$MAX_LABEL_ATTEMPTS); waiting ${LABEL_WAIT_SECONDS}s"
                          sleep $LABEL_WAIT_SECONDS
                          LABEL_ATTEMPT=$((LABEL_ATTEMPT + 1))
                        done

                        if [ "$LABEL_READY" != true ]; then
                          echo "⚠️ Timed out waiting for '$TARGET_LABEL' label; skipping resume"
                          exit 0
                        fi

                        echo "Polling for workflow reaching wait-for-pr-created suspend point..."
                        MAX_WORKFLOW_ATTEMPTS=90
                        WORKFLOW_WAIT_SECONDS=10
                        WORKFLOW_ATTEMPT=1
                        WORKFLOW_NAME=""
                        SUSPEND_READY=false

                        while [ $WORKFLOW_ATTEMPT -le $MAX_WORKFLOW_ATTEMPTS ]; do
                          WORKFLOW_JSON=$(kubectl get workflows -n agent-platform \
                            -l task-id=$TASK_ID,workflow-type=play-orchestration \
                            -o json 2>/dev/null || echo "")

                          WORKFLOW_NAME=""
                          if [ -n "$WORKFLOW_JSON" ]; then
                            WORKFLOW_NAME=$(echo "$WORKFLOW_JSON" | jq -r '.items[0].metadata.name // ""' 2>/dev/null || echo "")
                          fi

                          if [ -n "$WORKFLOW_NAME" ]; then
                            CURRENT_STAGE=$(echo "$WORKFLOW_JSON" | jq -r '.items[0].metadata.labels["current-stage"] // ""' 2>/dev/null || echo "")
                            SUSPEND_PHASE=$(echo "$WORKFLOW_JSON" | jq -r '(.items[0].status.nodes // {}) | to_entries[]? | select(.value.displayName == "wait-for-pr-created") | .value.phase' 2>/dev/null || echo "")

                            if [ "$CURRENT_STAGE" = "waiting-pr-created" ] && [ "$SUSPEND_PHASE" = "Running" ]; then
                              SUSPEND_READY=true
                              echo "✅ Workflow $WORKFLOW_NAME is waiting for PR-created event"
                              break
                            fi

                            echo "⏳ Workflow $WORKFLOW_NAME stage=$CURRENT_STAGE suspend-phase=${SUSPEND_PHASE:-none}; waiting ${WORKFLOW_WAIT_SECONDS}s"
                          else
                            echo "⏳ No workflow discovered for task-id=$TASK_ID yet; waiting ${WORKFLOW_WAIT_SECONDS}s"
                          fi

                          sleep $WORKFLOW_WAIT_SECONDS
                          WORKFLOW_ATTEMPT=$((WORKFLOW_ATTEMPT + 1))
                        done

                        if [ "$SUSPEND_READY" != true ]; then
                          echo "⚠️ Workflow did not reach wait-for-pr-created suspend point in time; skipping resume"
                          exit 0
                        fi

                        echo "Updating workflow metadata with PR details"
                        if ! update_workflow_pr_metadata "$WORKFLOW_NAME" "$PR_URL" "$PR_NUMBER"; then
                          echo "⚠️ Failed to update workflow with PR metadata"
                        fi

                        REPO_LABEL=$(echo "$REPO" | tr '/' '-')
                        if ! advance_stage_if_needed "$WORKFLOW_NAME" "$TASK_ID" "$REPO_LABEL"; then
                          echo "⚠️ Failed to advance workflow stage"
                          exit 0
                        fi

                        echo "Resuming workflow $WORKFLOW_NAME"
                        if ! resume_workflow; then
                          echo "⚠️ Resume attempt failed"
                          exit 0
                        fi

                        echo "Finished processing PR-created event"
        steps: 2  # Minimal retries for reliability
        duration: "5s"
        factor: 2
        jitter: 0.1

---
# Enhanced Sensor for Implementation Agent Remediation - Cancel outdated work with advanced concurrency control
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: implementation-agent-remediation
  namespace: argo
spec:
  replicas: 1
  deploymentStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    serviceAccountName: argo-events-sa
    container:
      resources:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "256Mi"
          cpu: "300m"
  dependencies:
    - name: github-rex-push
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for push events from Rex implementation agent
          - path: headers.X-Github-Event
            type: string
            value: ["push"]
          - path: body.pusher.name
            type: string
            value: ["rex-5dlabs[bot]"]
          # Enhanced filtering for concurrent push events
          - path: body.ref
            type: string
            comparator: "~"
            value: ["refs/heads/feature/.*", "refs/heads/task-.*"]
        exprs:
          # Additional validation for concurrent push events
          - expr: 'body.commits | length > 0'
            fields:
              - name: has_commits
                path: body.commits
          - expr: 'body.repository.name != ""'
            fields:
              - name: repo_name
                path: body.repository.name
          - expr: 'body.head_commit.message != ""'
            fields:
              - name: commit_message
                path: body.head_commit.message
  triggers:
    - template:
        name: enhanced-agent-cancellation
        conditions: "github-rex-push"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: enhanced-cancellation-
                namespace: agent-platform
                labels:
                  type: enhanced-remediation
                  version: v2
              spec:
                entrypoint: enhanced-cancellation-workflow
                serviceAccountName: agent-cancellation-sa
                arguments:
                  parameters:
                    - name: pusher-name
                      value: "{{ .Input.body.pusher.name }}"
                    - name: ref
                      value: "{{ .Input.body.ref }}"
                    - name: head-commit
                      value: "{{ .Input.body.head_commit.id }}"
                    - name: commit-message
                      value: "{{ .Input.body.head_commit.message }}"
                    - name: repo-name
                      value: "{{ .Input.body.repository.name }}"
                    - name: correlation-id
                      value: "{{ uuidv4() }}"
                templates:
                  - name: enhanced-cancellation-workflow
                    script:
                      image: agent-cancellation:latest
                      command: [bash]
                      source: |
                        #!/bin/bash
                        set -euo pipefail

                        echo "=== Enhanced Agent Cancellation System ==="
                        echo "🔧 Version: 2.0 - Concurrent Safe"
                        echo "📊 Correlation ID: {{workflow.parameters.correlation-id}}"
                        echo "🤖 Pusher: {{workflow.parameters.pusher-name}}"
                        echo "📋 Ref: {{workflow.parameters.ref}}"
                        echo "💾 Head Commit: {{workflow.parameters.head-commit}}"
                        echo "📝 Message: {{workflow.parameters.commit-message}}"

                        # Enhanced environment setup
                        export CORRELATION_ID="{{workflow.parameters.correlation-id}}"
                        export REPO_NAME="{{workflow.parameters.repo-name}}"
                        export PUSH_REF="{{workflow.parameters.ref}}"
                        export HEAD_COMMIT="{{workflow.parameters.head-commit}}"
                        export COMMIT_MESSAGE="{{workflow.parameters.commit-message}}"

                        # Extract and validate task information
                        BRANCH_NAME=$(echo "$PUSH_REF" | sed 's|refs/heads/||')
                        echo "🌿 Branch: $BRANCH_NAME"

                        # Enhanced task ID extraction with validation
                        TASK_ID=$(echo "$BRANCH_NAME" | grep -oE 'task-?([0-9]+)' | head -1 | sed 's/task-\?//')

                        if [ -z "$TASK_ID" ]; then
                          echo "⚠️  No task ID found in branch name, skipping enhanced cancellation"
                          echo "📝 Branch name: $BRANCH_NAME"
                          exit 0
                        fi

                        echo "🎯 Task ID: $TASK_ID"

                        # Enhanced PR number extraction from commit message
                        PR_NUMBER=""
                        if echo "$COMMIT_MESSAGE" | grep -qE '\(\#[0-9]+\)'; then
                          PR_NUMBER=$(echo "$COMMIT_MESSAGE" | grep -oE '\(#[0-9]+\)' | sed 's/[#(]//g')
                        elif echo "$COMMIT_MESSAGE" | grep -qE '#[0-9]+'; then
                          PR_NUMBER=$(echo "$COMMIT_MESSAGE" | grep -oE '#[0-9]+' | sed 's/#//')
                        fi

                        if [ -n "$PR_NUMBER" ]; then
                          echo "🔗 Associated PR: #$PR_NUMBER"
                          export PR_NUMBER="$PR_NUMBER"
                        else
                          echo "ℹ️  No PR number found in commit message"
                        fi

                        # Enhanced state-aware cancellation with distributed locking
                        echo ""
                        echo "🔐 Initializing Enhanced Cancellation System..."

                        # Check if enhanced cancellation controller is available
                        if command -v enhanced-cancellation-controller >/dev/null 2>&1; then
                          echo "✅ Enhanced cancellation controller found"
                          exec enhanced-cancellation-controller
                        else
                          echo "⚠️  Enhanced controller not available, falling back to basic cancellation"

                          # Fallback to basic cancellation logic
                          echo ""
                          echo "🔄 Executing Basic Cancellation Fallback..."

                          # Find CodeRuns for quality and testing agents on this task
                          echo "Looking for outdated CodeRuns to cancel..."
                          kubectl get coderuns -n agent-platform \
                            -l task-id=$TASK_ID \
                            -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.metadata.labels.agent-type}{"\t"}{.status.phase}{"\n"}{end}' | \
                          while read coderun_name agent_type phase; do
                            if [ "$agent_type" = "cleo" ] || [ "$agent_type" = "tess" ]; then
                              echo "📋 Found CodeRun: $coderun_name (agent: $agent_type, phase: $phase)"

                              # Enhanced phase checking
                              if [ "$phase" = "Running" ] || [ "$phase" = "Pending" ]; then
                                echo "🛑 Cancelling outdated CodeRun: $coderun_name (agent: $agent_type)"
                                kubectl delete coderun $coderun_name -n agent-platform --ignore-not-found=true
                              elif [ "$phase" = "Succeeded" ] || [ "$phase" = "Failed" ]; then
                                echo "✅ CodeRun $coderun_name already completed (phase: $phase), skipping"
                              else
                                echo "❓ CodeRun $coderun_name in unknown phase: $phase, attempting cancellation"
                                kubectl delete coderun $coderun_name -n agent-platform --ignore-not-found=true --timeout=30s
                              fi
                            fi
                          done

                          echo "✅ Basic remediation completed"
                        fi
      retryStrategy:
        steps: 3  # Enhanced retries for reliability
        duration: "10s"
        factor: 2
        jitter: 0.1
