---
# Sensor for PR Created Event - Resume after implementation work
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: play-workflow-pr-created
  namespace: argo
spec:
  replicas: 1
  deploymentStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: github-pr-created
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for pull_request opened events
          - path: headers.X-Github-Event
            type: string
            value: ["pull_request"]
          - path: body.action
            type: string
            value: ["opened"]
  triggers:
    - template:
        name: resume-after-pr-created
        conditions: "github-pr-created"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: resume-pr-created-
                namespace: agent-platform
                labels:
                  type: webhook-resume
                  target-stage: waiting-pr-created
              spec:
                entrypoint: resume-workflow
                serviceAccountName: argo-workflow
                templates:
                  - name: resume-workflow
                    script:
                      image: alpine/k8s:1.31.0
                      command: [bash]
                      source: |
                        #!/bin/bash
                        set -e

                        echo "=== PR Created Workflow Resume ==="

                        # This sensor was triggered by a PR creation
                        # We need to find the most recent implementation workflow waiting for PR

                        # Find workflows waiting for PR creation (with retry to avoid race with stage update)
                        MAX_WAIT_ATTEMPTS=6
                        WAIT_INTERVAL=10
                        ATTEMPT=1
                        WAITING_WORKFLOWS=""
                        while [ $ATTEMPT -le $MAX_WAIT_ATTEMPTS ]; do
                          WAITING_WORKFLOWS=$(kubectl get workflows -n agent-platform \
                            -l current-stage=waiting-pr-created,workflow-type=play-orchestration \
                            -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")

                          if [ -n "$WAITING_WORKFLOWS" ]; then
                            break
                          fi

                          echo "No workflows waiting for PR creation (attempt $ATTEMPT/$MAX_WAIT_ATTEMPTS); waiting ${WAIT_INTERVAL}s"
                          sleep $WAIT_INTERVAL
                          ATTEMPT=$((ATTEMPT+1))
                        done

                        if [ -z "$WAITING_WORKFLOWS" ]; then
                          echo "No workflows waiting for PR creation after polling"
                          exit 0
                        fi

                        if ! command -v jq >/dev/null 2>&1; then
                          echo "Installing jq"
                          if ! apk add --no-cache jq >/tmp/jq-install.log 2>&1; then
                            echo "‚ùå Failed to install jq"
                            cat /tmp/jq-install.log
                            exit 1
                          fi
                        fi

                        ensure_argo_cli() {
                          if command -v argo >/dev/null 2>&1; then
                            ARGO_BIN=$(command -v argo)
                            return 0
                          fi

                          ARGO_VERSION="${ARGO_VERSION:-v3.7.1}"
                          ARGO_BIN="/tmp/argo"

                          if [ ! -x "$ARGO_BIN" ]; then
                            echo "Downloading argo CLI ($ARGO_VERSION)..."
                            if command -v wget >/dev/null 2>&1; then
                              wget -qO "$ARGO_BIN" "https://github.com/argoproj/argo-workflows/releases/download/$ARGO_VERSION/argo-linux-amd64"
                            elif command -v curl >/dev/null 2>&1; then
                              curl -sSL -o "$ARGO_BIN" "https://github.com/argoproj/argo-workflows/releases/download/$ARGO_VERSION/argo-linux-amd64"
                            else
                              echo "Neither wget nor curl is available"
                              return 1
                            fi
                            chmod +x "$ARGO_BIN"
                          fi
                        }

                        build_kubeconfig() {
                          KUBECONFIG_PATH="/tmp/argo-kubeconfig"
                          if [ -f "$KUBECONFIG_PATH" ]; then
                            echo "$KUBECONFIG_PATH"
                            return 0
                          fi

                          CA_CERT="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                          TOKEN_FILE="/var/run/secrets/kubernetes.io/serviceaccount/token"

                          if [ ! -f "$TOKEN_FILE" ]; then
                            echo "Service account token not found"
                            return 1
                          fi

                          SERVER="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"
                          TOKEN=$(cat "$TOKEN_FILE")

                          {
                            echo "apiVersion: v1"
                            echo "kind: Config"
                            echo "clusters:"
                            echo "  - cluster:"
                            printf '      certificate-authority: %s\n' "${CA_CERT}"
                            printf '      server: %s\n' "${SERVER}"
                            echo "    name: in-cluster"
                            echo "contexts:"
                            echo "  - context:"
                            echo "      cluster: in-cluster"
                            echo "      namespace: agent-platform"
                            echo "      user: sensor-sa"
                            echo "    name: in-cluster"
                            echo "current-context: in-cluster"
                            echo "users:"
                            echo "  - name: sensor-sa"
                            echo "    user:"
                            printf '      token: %s\n' "${TOKEN}"
                          } > "$KUBECONFIG_PATH"

                          echo "$KUBECONFIG_PATH"
                        }

                        resume_workflow() {
                          ensure_argo_cli || return 1
                          KUBECONFIG_PATH=$(build_kubeconfig) || return 1

                          if "$ARGO_BIN" --auth-mode kubeconfig --kubeconfig "$KUBECONFIG_PATH" \
                            -n agent-platform resume "$WORKFLOW_NAME" >/tmp/argo-resume.log 2>&1; then
                            echo "‚úÖ Workflow resumed successfully"
                          else
                            echo "‚ö†Ô∏è Failed to resume via argo CLI; output:"
                            cat /tmp/argo-resume.log
                            return 1
                          fi
                        }

                        update_workflow_pr_metadata() {
                          local workflow_name="$1"
                          local pr_url="$2"
                          local pr_number="$3"

                          WORKFLOW_JSON=$(kubectl get workflow "$workflow_name" -n agent-platform -o json 2>/dev/null)
                          if [ -z "$WORKFLOW_JSON" ]; then
                            echo "‚ö†Ô∏è Unable to fetch workflow $workflow_name for PR metadata update"
                            return 1
                          fi

                          PATCH_JSON=$(echo "$WORKFLOW_JSON" | jq --arg prUrl "$pr_url" --arg prNumber "$pr_number" '
                            .spec.arguments.parameters = (
                              ( .spec.arguments.parameters // [] )
                              | (if (map(.name) | index("pr-url")) != null
                                   then map(if .name == "pr-url" then (.value = $prUrl) else . end)
                                   else . + [{"name":"pr-url","value":$prUrl}]
                                 end)
                              | (if (map(.name) | index("pr-number")) != null
                                   then map(if .name == "pr-number" then (.value = $prNumber) else . end)
                                   else . + [{"name":"pr-number","value":$prNumber}]
                                 end)
                            )
                            | {spec:{arguments:{parameters:.spec.arguments.parameters}}}
                          ')

                          if [ -z "$PATCH_JSON" ]; then
                            echo "‚ö†Ô∏è Failed to construct PR metadata patch payload for $workflow_name"
                            return 1
                          fi

                          kubectl patch workflow "$workflow_name" -n agent-platform --type='merge' -p "$PATCH_JSON"
                        }

                        # Process each waiting workflow
                        for WORKFLOW_NAME in $WAITING_WORKFLOWS; do
                          echo "Processing workflow: $WORKFLOW_NAME"

                          # Get task ID from workflow
                          TASK_ID=$(kubectl get workflow $WORKFLOW_NAME -n agent-platform \
                            -o jsonpath='{.metadata.labels.task-id}')

                          if [ -z "$TASK_ID" ]; then
                            echo "No task ID found for workflow, skipping"
                            continue
                          fi

                          echo "Task ID: $TASK_ID"

                          # Check if there's a recent succeeded implementation CodeRun for this task
                          CODERUN=$(kubectl get coderun -n agent-platform \
                            -l task-id=$TASK_ID,workflow-stage=implementation \
                            -o json 2>/dev/null | \
                            jq -r '.items[] | select(.status.phase=="Succeeded") | .metadata.name' | head -n1 || echo "")

                          if [ -z "$CODERUN" ]; then
                            echo "No succeeded implementation CodeRun for task $TASK_ID, skipping"
                            continue
                          fi

                          echo "Found CodeRun: $CODERUN"

                          # Get PR URL from the CodeRun status
                          PR_URL=$(kubectl get coderun $CODERUN -n agent-platform \
                            -o jsonpath='{.status.pullRequestUrl}' 2>/dev/null || echo "")

                          if [ -z "$PR_URL" ]; then
                            echo "No PR URL in CodeRun status, skipping"
                            continue
                          fi

                          # Extract PR number from URL
                          PR_NUMBER=$(echo "$PR_URL" | sed 's/.*\/pull\///' | sed 's/[^0-9].*//')

                          if [ -z "$PR_NUMBER" ]; then
                            echo "‚ö†Ô∏è Unable to parse PR number from URL $PR_URL; skipping"
                            continue
                          fi

                          echo "PR URL: $PR_URL"
                          echo "PR Number: $PR_NUMBER"

                          if ! update_workflow_pr_metadata "$WORKFLOW_NAME" "$PR_URL" "$PR_NUMBER"; then
                            echo "‚ö†Ô∏è Failed to update PR metadata for $WORKFLOW_NAME; skipping"
                            continue
                          fi

                          CURRENT_STAGE=$(kubectl get workflow "$WORKFLOW_NAME" -n agent-platform \
                            -o jsonpath='{.metadata.labels.current-stage}' 2>/dev/null || echo "")
                          if [ "$CURRENT_STAGE" != "waiting-pr-created" ]; then
                            echo "‚ÑπÔ∏è Workflow $WORKFLOW_NAME not in waiting-pr-created (found '$CURRENT_STAGE'); skipping stage update and resume"
                            continue
                          else
                            STAGE_PATCH='{"metadata":{"labels":{"previous-stage":"waiting-pr-created","current-stage":"waiting-quality-complete"}}}'
                            if ! kubectl patch workflow "$WORKFLOW_NAME" -n agent-platform \
                              --type='merge' -p "$STAGE_PATCH"; then
                              echo "‚ö†Ô∏è Failed to advance stage for $WORKFLOW_NAME; skipping resume"
                              continue
                            fi
                          fi

                          echo "Resuming workflow $WORKFLOW_NAME"
                          if ! resume_workflow; then
                            echo "‚ö†Ô∏è Resume attempt failed for $WORKFLOW_NAME"
                            continue
                          fi
                        done

                        echo "Finished processing waiting workflows"
      retryStrategy:
        steps: 2  # Minimal retries for reliability
        duration: "5s"
        factor: 2
        jitter: 0.1

---
# Enhanced Sensor for Implementation Agent Remediation - Cancel outdated work with advanced concurrency control
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: implementation-agent-remediation
  namespace: argo
spec:
  replicas: 1
  deploymentStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    serviceAccountName: argo-events-sa
    container:
      resources:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "256Mi"
          cpu: "300m"
  dependencies:
    - name: github-rex-push
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for push events from Rex implementation agent
          - path: headers.X-Github-Event
            type: string
            value: ["push"]
          - path: body.pusher.name
            type: string
            value: ["rex-5dlabs[bot]"]
          # Enhanced filtering for concurrent push events
          - path: body.ref
            type: string
            comparator: "~"
            value: ["refs/heads/feature/.*", "refs/heads/task-.*"]
        exprs:
          # Additional validation for concurrent push events
          - expr: 'body.commits | length > 0'
            fields:
              - name: has_commits
                path: body.commits
          - expr: 'body.repository.name != ""'
            fields:
              - name: repo_name
                path: body.repository.name
          - expr: 'body.head_commit.message != ""'
            fields:
              - name: commit_message
                path: body.head_commit.message
  triggers:
    - template:
        name: enhanced-agent-cancellation
        conditions: "github-rex-push"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: enhanced-cancellation-
                namespace: agent-platform
                labels:
                  type: enhanced-remediation
                  version: v2
              spec:
                entrypoint: enhanced-cancellation-workflow
                serviceAccountName: agent-cancellation-sa
                arguments:
                  parameters:
                    - name: pusher-name
                      value: "{{ .Input.body.pusher.name }}"
                    - name: ref
                      value: "{{ .Input.body.ref }}"
                    - name: head-commit
                      value: "{{ .Input.body.head_commit.id }}"
                    - name: commit-message
                      value: "{{ .Input.body.head_commit.message }}"
                    - name: repo-name
                      value: "{{ .Input.body.repository.name }}"
                    - name: correlation-id
                      value: "{{ uuidv4() }}"
                templates:
                  - name: enhanced-cancellation-workflow
                    script:
                      image: agent-cancellation:latest
                      command: [bash]
                      source: |
                        #!/bin/bash
                        set -euo pipefail

                        echo "=== Enhanced Agent Cancellation System ==="
                        echo "üîß Version: 2.0 - Concurrent Safe"
                        echo "üìä Correlation ID: {{workflow.parameters.correlation-id}}"
                        echo "ü§ñ Pusher: {{workflow.parameters.pusher-name}}"
                        echo "üìã Ref: {{workflow.parameters.ref}}"
                        echo "üíæ Head Commit: {{workflow.parameters.head-commit}}"
                        echo "üìù Message: {{workflow.parameters.commit-message}}"

                        # Enhanced environment setup
                        export CORRELATION_ID="{{workflow.parameters.correlation-id}}"
                        export REPO_NAME="{{workflow.parameters.repo-name}}"
                        export PUSH_REF="{{workflow.parameters.ref}}"
                        export HEAD_COMMIT="{{workflow.parameters.head-commit}}"
                        export COMMIT_MESSAGE="{{workflow.parameters.commit-message}}"

                        # Extract and validate task information
                        BRANCH_NAME=$(echo "$PUSH_REF" | sed 's|refs/heads/||')
                        echo "üåø Branch: $BRANCH_NAME"

                        # Enhanced task ID extraction with validation
                        TASK_ID=$(echo "$BRANCH_NAME" | grep -oE 'task-?([0-9]+)' | head -1 | sed 's/task-\?//')

                        if [ -z "$TASK_ID" ]; then
                          echo "‚ö†Ô∏è  No task ID found in branch name, skipping enhanced cancellation"
                          echo "üìù Branch name: $BRANCH_NAME"
                          exit 0
                        fi

                        echo "üéØ Task ID: $TASK_ID"

                        # Enhanced PR number extraction from commit message
                        PR_NUMBER=""
                        if echo "$COMMIT_MESSAGE" | grep -qE '\(\#[0-9]+\)'; then
                          PR_NUMBER=$(echo "$COMMIT_MESSAGE" | grep -oE '\(#[0-9]+\)' | sed 's/[#(]//g')
                        elif echo "$COMMIT_MESSAGE" | grep -qE '#[0-9]+'; then
                          PR_NUMBER=$(echo "$COMMIT_MESSAGE" | grep -oE '#[0-9]+' | sed 's/#//')
                        fi

                        if [ -n "$PR_NUMBER" ]; then
                          echo "üîó Associated PR: #$PR_NUMBER"
                          export PR_NUMBER="$PR_NUMBER"
                        else
                          echo "‚ÑπÔ∏è  No PR number found in commit message"
                        fi

                        # Enhanced state-aware cancellation with distributed locking
                        echo ""
                        echo "üîê Initializing Enhanced Cancellation System..."

                        # Check if enhanced cancellation controller is available
                        if command -v enhanced-cancellation-controller >/dev/null 2>&1; then
                          echo "‚úÖ Enhanced cancellation controller found"
                          exec enhanced-cancellation-controller
                        else
                          echo "‚ö†Ô∏è  Enhanced controller not available, falling back to basic cancellation"

                          # Fallback to basic cancellation logic
                          echo ""
                          echo "üîÑ Executing Basic Cancellation Fallback..."

                          # Find CodeRuns for quality and testing agents on this task
                          echo "Looking for outdated CodeRuns to cancel..."
                          kubectl get coderuns -n agent-platform \
                            -l task-id=$TASK_ID \
                            -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.metadata.labels.agent-type}{"\t"}{.status.phase}{"\n"}{end}' | \
                          while read coderun_name agent_type phase; do
                            if [ "$agent_type" = "cleo" ] || [ "$agent_type" = "tess" ]; then
                              echo "üìã Found CodeRun: $coderun_name (agent: $agent_type, phase: $phase)"

                              # Enhanced phase checking
                              if [ "$phase" = "Running" ] || [ "$phase" = "Pending" ]; then
                                echo "üõë Cancelling outdated CodeRun: $coderun_name (agent: $agent_type)"
                                kubectl delete coderun $coderun_name -n agent-platform --ignore-not-found=true
                              elif [ "$phase" = "Succeeded" ] || [ "$phase" = "Failed" ]; then
                                echo "‚úÖ CodeRun $coderun_name already completed (phase: $phase), skipping"
                              else
                                echo "‚ùì CodeRun $coderun_name in unknown phase: $phase, attempting cancellation"
                                kubectl delete coderun $coderun_name -n agent-platform --ignore-not-found=true --timeout=30s
                              fi
                            fi
                          done

                          echo "‚úÖ Basic remediation completed"
                        fi
      retryStrategy:
        steps: 3  # Enhanced retries for reliability
        duration: "10s"
        factor: 2
        jitter: 0.1
