---
# Sensor for PR Created Event - Resume after implementation work
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: play-workflow-pr-created
  namespace: argo
spec:
  replicas: 1
  deploymentStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: github-pr-created
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for pull_request opened events
          - path: body.X-GitHub-Event
            type: string
            value: ["pull_request"]
          - path: body.action
            type: string
            value: ["opened"]
  triggers:
    - template:
        name: resume-after-pr-created
        conditions: "github-pr-created"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: resume-pr-created-
                namespace: agent-platform
                labels:
                  type: webhook-resume
                  target-stage: waiting-pr-created
              spec:
                entrypoint: resume-workflow
                serviceAccountName: argo-workflow
                arguments:
                  parameters:
                    - name: pr-branch-ref
                      value: ""
                    - name: pr-title
                      value: ""
                    - name: pr-number
                      value: ""
                    - name: pr-url
                      value: ""
                    - name: pr-labels
                      value: ""
                    - name: repo-owner
                      value: ""
                    - name: repo-name
                      value: ""
                templates:
                  - name: resume-workflow
                    script:
                      image: alpine/k8s:1.31.0
                      command: [bash]
                      env:
                        - name: GITHUB_APP_ID
                          valueFrom:
                            secretKeyRef:
                              name: github-app-5dlabs-morgan
                              key: app-id
                        - name: GITHUB_APP_PRIVATE_KEY
                          valueFrom:
                            secretKeyRef:
                              name: github-app-5dlabs-morgan
                              key: private-key
                      source: |
                        #!/bin/bash
                        set -euo pipefail

                        echo "=== PR Created Workflow Resume ==="

                        ensure_jq() {
                          if command -v jq >/dev/null 2>&1; then
                            return 0
                          fi

                          if command -v apk >/dev/null 2>&1; then
                            apk add --no-cache jq >/dev/null 2>&1 && return 0
                          elif command -v apt-get >/dev/null 2>&1; then
                            apt-get update >/dev/null 2>&1 && apt-get install -y jq >/dev/null 2>&1 && rm -rf /var/lib/apt/lists/* && return 0
                          elif command -v microdnf >/dev/null 2>&1; then
                            microdnf -y install jq >/dev/null 2>&1 && return 0
                          fi

                          echo "‚ùå Failed to install jq"
                          return 1
                        }

                        ensure_openssl() {
                          if command -v openssl >/dev/null 2>&1; then
                            return 0
                          fi

                          if command -v apk >/dev/null 2>&1; then
                            apk add --no-cache openssl >/dev/null 2>&1 && return 0
                          elif command -v apt-get >/dev/null 2>&1; then
                            apt-get update >/dev/null 2>&1 && apt-get install -y openssl >/dev/null 2>&1 && rm -rf /var/lib/apt/lists/* && return 0
                          elif command -v microdnf >/dev/null 2>&1; then
                            microdnf -y install openssl >/dev/null 2>&1 && return 0
                          fi

                          echo "‚ùå Failed to install openssl"
                          return 1
                        }

                        ensure_argo_cli() {
                          if command -v argo >/dev/null 2>&1; then
                            ARGO_BIN=$(command -v argo)
                            return 0
                          fi

                          ARGO_VERSION="${ARGO_VERSION:-v3.7.1}"
                          ARGO_BIN="/tmp/argo"

                          if [ ! -x "$ARGO_BIN" ]; then
                            echo "Downloading argo CLI ($ARGO_VERSION)..."
                            if command -v wget >/dev/null 2>&1; then
                              wget -qO "$ARGO_BIN" "https://github.com/argoproj/argo-workflows/releases/download/$ARGO_VERSION/argo-linux-amd64"
                            elif command -v curl >/dev/null 2>&1; then
                              curl -sSL -o "$ARGO_BIN" "https://github.com/argoproj/argo-workflows/releases/download/$ARGO_VERSION/argo-linux-amd64"
                            else
                              echo "Neither wget nor curl is available"
                              return 1
                            fi
                            chmod +x "$ARGO_BIN"
                          fi
                        }

                        build_kubeconfig() {
                          local kubeconfig_path="/tmp/argo-kubeconfig"
                          if [ -f "$kubeconfig_path" ]; then
                            echo "$kubeconfig_path"
                            return 0
                          fi

                          local ca_cert="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                          local token_file="/var/run/secrets/kubernetes.io/serviceaccount/token"

                          if [ ! -f "$token_file" ]; then
                            echo "Service account token not found"
                            return 1
                          fi

                          local server="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"
                          local token
                          token=$(cat "$token_file")

                          {
                            echo "apiVersion: v1"
                            echo "kind: Config"
                            echo "clusters:"
                            echo "  - cluster:"
                            printf '      certificate-authority: %s\n' "$ca_cert"
                            printf '      server: %s\n' "$server"
                            echo "    name: in-cluster"
                            echo "contexts:"
                            echo "  - context:"
                            echo "      cluster: in-cluster"
                            echo "      namespace: agent-platform"
                            echo "      user: sensor-sa"
                            echo "    name: in-cluster"
                            echo "current-context: in-cluster"
                            echo "users:"
                            echo "  - name: sensor-sa"
                            echo "    user:"
                            printf '      token: %s\n' "$token"
                          } > "$kubeconfig_path"

                          echo "$kubeconfig_path"
                        }

                        resume_workflow() {
                          ensure_argo_cli || return 1
                          local kubeconfig_path
                          kubeconfig_path=$(build_kubeconfig) || return 1

                          if "$ARGO_BIN" --auth-mode kubeconfig --kubeconfig "$kubeconfig_path" \
                            -n agent-platform resume "$WORKFLOW_NAME" >/tmp/argo-resume.log 2>&1; then
                            echo "‚úÖ Workflow resumed successfully"
                            return 0
                          fi

                          echo "‚ö†Ô∏è Failed to resume via argo CLI; output:"
                          cat /tmp/argo-resume.log
                          return 1
                        }

                        get_installation_token() {
                          if [ -z "${GITHUB_APP_ID:-}" ] || [ -z "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
                            return 1
                          fi

                          local temp_key="/tmp/github-app-key.pem"
                          printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$temp_key"
                          chmod 600 "$temp_key"

                          local now exp hdr pay sig jwt installation_id token=""
                          now=$(date +%s)
                          exp=$((now + 600))
                          hdr=$( \
                            printf '{"alg":"RS256","typ":"JWT"}' | base64 -w0 2>/dev/null \
                              || printf '{"alg":"RS256","typ":"JWT"}' | base64
                          )
                          hdr=$(echo -n "$hdr" | tr '+/' '-_' | tr -d '=')
                          pay=$( \
                            printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$now" "$exp" "$GITHUB_APP_ID" | base64 -w0 2>/dev/null \
                              || printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$now" "$exp" "$GITHUB_APP_ID" | base64
                          )
                          pay=$(echo -n "$pay" | tr '+/' '-_' | tr -d '=')
                          sig=$( \
                            printf '%s.%s' "$hdr" "$pay" | openssl dgst -sha256 -sign "$temp_key" -binary | base64 -w0 2>/dev/null \
                              || openssl dgst -sha256 -sign "$temp_key" -binary | base64
                          )
                          sig=$(echo -n "$sig" | tr '+/' '-_' | tr -d '=')
                          jwt="$hdr.$pay.$sig"

                          installation_id=$(curl -s -L \
                            -H "Authorization: Bearer $jwt" \
                            -H "Accept: application/vnd.github+json" \
                            "https://api.github.com/repos/${REPO}/installation" | jq -r '.id')

                          if [ -z "$installation_id" ] || [ "$installation_id" = "null" ]; then
                            installation_id=$(curl -s -L \
                              -H "Authorization: Bearer $jwt" \
                              -H "Accept: application/vnd.github+json" \
                              "https://api.github.com/orgs/${OWNER}/installation" | jq -r '.id')
                          fi

                          if [ -n "$installation_id" ] && [ "$installation_id" != "null" ]; then
                            token=$(curl -s -X POST \
                              -H "Authorization: Bearer $jwt" \
                              -H "Accept: application/vnd.github+json" \
                              "https://api.github.com/app/installations/$installation_id/access_tokens" | jq -r '.token')
                          fi

                          rm -f "$temp_key"

                          if [ -n "$token" ] && [ "$token" != "null" ]; then
                            echo "$token"
                            return 0
                          fi

                          return 1
                        }

                        pr_has_label() {
                          local label="$1"
                          local response
                          if [ -n "$AUTH_HEADER" ]; then
                            response=$(curl -s -L -H "Accept: application/vnd.github+json" -H "$AUTH_HEADER" "$PR_API_URL")
                          else
                            response=$(curl -s -L -H "Accept: application/vnd.github+json" "$PR_API_URL")
                          fi

                          echo "$response" | jq -e --arg label "$label" '((.labels // []) | map(.name) | index($label)) != null' >/dev/null 2>&1
                        }

                        update_workflow_pr_metadata() {
                          local workflow_name="$1"
                          local pr_url="$2"
                          local pr_number="$3"
                          local workflow_json patch_json

                          workflow_json=$(kubectl get workflow "$workflow_name" -n agent-platform -o json 2>/dev/null)
                          if [ -z "$workflow_json" ]; then
                            echo "‚ö†Ô∏è Unable to fetch workflow $workflow_name for PR metadata update"
                            return 1
                          fi

                          set +e
                          patch_json=$(echo "$workflow_json" | jq --arg prUrl "$pr_url" --arg prNumber "$pr_number" '
                            .spec.arguments.parameters = (
                              ( .spec.arguments.parameters // [] )
                              | (if (map(.name) | index("pr-url")) != null
                                   then map(if .name == "pr-url" then (.value = $prUrl) else . end)
                                   else . + [{"name":"pr-url","value":$prUrl}]
                                 end)
                              | (if (map(.name) | index("pr-number")) != null
                                   then map(if .name == "pr-number" then (.value = $prNumber) else . end)
                                   else . + [{"name":"pr-number","value":$prNumber}]
                                 end)
                            )
                            | {spec:{arguments:{parameters:.spec.arguments.parameters}}}
                          ')
                          local jq_exit=$?
                          set -e

                          if [ $jq_exit -ne 0 ]; then
                            echo "‚ö†Ô∏è jq failed while constructing PR metadata patch for $workflow_name"
                            return 1
                          fi

                          if [ -z "$patch_json" ]; then
                            echo "‚ö†Ô∏è Failed to construct PR metadata patch payload for $workflow_name"
                            return 1
                          fi

                          kubectl patch workflow "$workflow_name" -n agent-platform --type='merge' -p "$patch_json"
                        }

                        advance_stage_if_needed() {
                          local workflow_name="$1"
                          local task_id="$2"
                          local repo_label="$3"

                          local workflow_json resource_version patch_json
                          workflow_json=$(kubectl get workflow "$workflow_name" -n agent-platform -o json 2>/dev/null)
                          if [ -z "$workflow_json" ]; then
                            echo "‚ö†Ô∏è Unable to fetch workflow $workflow_name for stage update"
                            return 1
                          fi

                          local current_stage
                          current_stage=$(echo "$workflow_json" | jq -r '.metadata.labels["current-stage"] // ""')
                          if [ "$current_stage" != "waiting-pr-created" ]; then
                            echo "‚ÑπÔ∏è Workflow $workflow_name no longer at waiting-pr-created (found '$current_stage')"
                            return 0
                          fi

                          resource_version=$(echo "$workflow_json" | jq -r '.metadata.resourceVersion // ""')
                          if [ -z "$resource_version" ]; then
                            echo "‚ö†Ô∏è Missing resourceVersion for $workflow_name"
                            return 1
                          fi

                          patch_json=$(jq -n \
                            --arg rv "$resource_version" \
                            --arg task "$task_id" \
                            --arg repo "$repo_label" \
                            '{
                              metadata: {
                                resourceVersion: $rv,
                                labels: {
                                  "previous-stage": "waiting-pr-created",
                                  "current-stage": "waiting-quality-complete",
                                  "task-id": $task,
                                  repository: $repo
                                }
                              }
                            }')

                          kubectl patch workflow "$workflow_name" -n agent-platform --type='merge' -p "$patch_json"
                        }

                        ensure_jq
                        ensure_openssl

                        # Debug: Print values from workflow parameters
                        echo "=== DEBUG: PR Event Data (from workflow params) ==="
                        echo "pr-branch-ref: {{workflow.parameters.pr-branch-ref}}"
                        echo "pr-title: {{workflow.parameters.pr-title}}"
                        echo "pr-number: {{workflow.parameters.pr-number}}"
                        echo "pr-url: {{workflow.parameters.pr-url}}"
                        echo "pr-labels: {{workflow.parameters.pr-labels}}"
                        echo "repo-owner: {{workflow.parameters.repo-owner}}"
                        echo "repo-name: {{workflow.parameters.repo-name}}"
                        echo "=================================="

                        OWNER="{{workflow.parameters.repo-owner}}"
                        REPO_NAME="{{workflow.parameters.repo-name}}"
                        REPO="${OWNER}/${REPO_NAME}"
                        PR_NUMBER="{{workflow.parameters.pr-number}}"
                        PR_URL="{{workflow.parameters.pr-url}}"
                        PR_API_URL="https://api.github.com/repos/${REPO}/issues/${PR_NUMBER}"

                        AUTH_HEADER=""
                        INSTALLATION_TOKEN=""
                        if INSTALLATION_TOKEN=$(get_installation_token); then
                          AUTH_HEADER="Authorization: Bearer $INSTALLATION_TOKEN"
                          echo "Using GitHub App installation token for API calls"
                        else
                          echo "‚ÑπÔ∏è Proceeding without GitHub App token (unauthenticated GitHub API)"
                        fi

                        extract_task_id() {
                          echo "$1" | tr '[:upper:]' '[:lower:]' | grep -oE 'task[-_/ ]*([0-9]+)' | head -n1 | grep -oE '[0-9]+' || true
                        }

                        fetch_task_id_via_api() {
                          local response label_name candidate title body

                          if [ -n "$AUTH_HEADER" ]; then
                            response=$(curl -s -L -H "Accept: application/vnd.github+json" -H "$AUTH_HEADER" "$PR_API_URL")
                          else
                            response=$(curl -s -L -H "Accept: application/vnd.github+json" "$PR_API_URL")
                          fi

                          if [ -z "$response" ] || [ "$response" = "null" ]; then
                            echo ""
                            return 1
                          fi

                          while IFS= read -r label_name; do
                            candidate=$(extract_task_id "$label_name")
                            if [ -n "$candidate" ]; then
                              echo "$candidate"
                              return 0
                            fi
                          done < <(echo "$response" | jq -r '(.labels // [])[]?.name // ""')

                          title=$(echo "$response" | jq -r '.title // ""')
                          if [ -n "$title" ]; then
                            candidate=$(extract_task_id "$title")
                            if [ -n "$candidate" ]; then
                              echo "$candidate"
                              return 0
                            fi
                          fi

                          body=$(echo "$response" | jq -r '.body // ""')
                          if [ -n "$body" ]; then
                            candidate=$(extract_task_id "$body")
                            if [ -n "$candidate" ]; then
                              echo "$candidate"
                              return 0
                            fi
                          fi

                          echo ""
                          return 1
                        }

                        TASK_ID=""

                        # Debug: Show what we received from workflow parameters
                        BRANCH_REF='{{workflow.parameters.pr-branch-ref}}'
                        PR_TITLE='{{workflow.parameters.pr-title}}'
                        echo "üîç Debug - Branch ref: '$BRANCH_REF'"
                        echo "üîç Debug - PR title: '$PR_TITLE'"

                        # Try extracting from branch name first (most reliable)
                        if [ -n "$BRANCH_REF" ]; then
                          TASK_ID=$(extract_task_id "$BRANCH_REF")
                          if [ -n "$TASK_ID" ]; then
                            echo "‚úÖ Extracted task ID from branch: $TASK_ID"
                          fi
                        fi

                        # Try labels if branch didn't work
                        if [ -z "$TASK_ID" ]; then
                          TASK_LABELS_JSON='{{workflow.parameters.pr-labels}}'
                          echo "üîç Debug - Labels JSON: '$TASK_LABELS_JSON'"
                          if [ "$TASK_LABELS_JSON" != "null" ] && [ -n "$TASK_LABELS_JSON" ]; then
                            TASK_ID=$(echo "$TASK_LABELS_JSON" |
                              jq -er '.[] | (.name // "") | ascii_downcase | capture("task[-_/ ]*(?<id>[0-9]+)") | .id' 2>/dev/null | head -1 || true)
                            if [ -n "$TASK_ID" ]; then
                              echo "‚úÖ Extracted task ID from labels: $TASK_ID"
                            fi
                          fi
                        fi

                        # Try title as fallback
                        if [ -z "$TASK_ID" ]; then
                          TASK_ID=$(extract_task_id "$PR_TITLE")
                          if [ -n "$TASK_ID" ]; then
                            echo "‚úÖ Extracted task ID from title: $TASK_ID"
                          fi
                        fi

                        # Final fallback to API
                        if [ -z "$TASK_ID" ]; then
                          echo "‚ÑπÔ∏è Task ID not present in webhook payload; querying GitHub API for labels/title/body"
                          TASK_ID=$(fetch_task_id_via_api || true)
                        fi

                        if [ -z "$TASK_ID" ]; then
                          echo "‚ÑπÔ∏è No task ID found in PR payload (not a play workflow PR)"
                          exit 0
                        fi

                        echo "Task ID: $TASK_ID"

                        # Note: No longer waiting for status labels (needs-cleo, etc.)
                        # System now uses GitHub PR reviews for stage transitions
                        # PR creation event itself triggers the resume

                        echo "Polling for workflow reaching wait-for-pr-created suspend point..."
                        MAX_WORKFLOW_ATTEMPTS=90
                        WORKFLOW_WAIT_SECONDS=10
                        WORKFLOW_ATTEMPT=1
                        WORKFLOW_NAME=""
                        SUSPEND_READY=false

                        while [ $WORKFLOW_ATTEMPT -le $MAX_WORKFLOW_ATTEMPTS ]; do
                          WORKFLOW_JSON=$(kubectl get workflows -n agent-platform \
                            -l task-id=$TASK_ID,workflow-type=play-orchestration \
                            -o json 2>/dev/null || echo "")

                          WORKFLOW_NAME=""
                          if [ -n "$WORKFLOW_JSON" ]; then
                            WORKFLOW_NAME=$(echo "$WORKFLOW_JSON" | \
                              jq -r '.items[0].metadata.name // ""' 2>/dev/null || echo "")
                          fi

                          if [ -n "$WORKFLOW_NAME" ]; then
                            CURRENT_STAGE=$(echo "$WORKFLOW_JSON" | \
                              jq -r '.items[0].metadata.labels["current-stage"] // ""' 2>/dev/null || echo "")
                            SUSPEND_PHASE=$(echo "$WORKFLOW_JSON" | \
                              jq -r '(.items[0].status.nodes // {})
                                | to_entries[]?
                                | select(.value.displayName == "wait-for-pr-created")
                                | .value.phase' 2>/dev/null || echo "")

                            if [ "$CURRENT_STAGE" = "waiting-pr-created" ] && [ "$SUSPEND_PHASE" = "Running" ]; then
                              SUSPEND_READY=true
                              echo "‚úÖ Workflow $WORKFLOW_NAME is waiting for PR-created event"
                              break
                            fi

                            echo "‚è≥ Workflow $WORKFLOW_NAME stage=$CURRENT_STAGE suspend-phase=${SUSPEND_PHASE:-none};"
                            echo "   waiting ${WORKFLOW_WAIT_SECONDS}s"
                          else
                            echo "‚è≥ No workflow discovered for task-id=$TASK_ID yet; waiting ${WORKFLOW_WAIT_SECONDS}s"
                          fi

                          sleep $WORKFLOW_WAIT_SECONDS
                          WORKFLOW_ATTEMPT=$((WORKFLOW_ATTEMPT + 1))
                        done

                        if [ "$SUSPEND_READY" != true ]; then
                          echo "‚ö†Ô∏è Workflow did not reach wait-for-pr-created suspend point in time; skipping resume"
                          exit 0
                        fi

                        echo "Updating workflow metadata with PR details"
                        if ! update_workflow_pr_metadata "$WORKFLOW_NAME" "$PR_URL" "$PR_NUMBER"; then
                          echo "‚ö†Ô∏è Failed to update workflow with PR metadata"
                        fi

                        REPO_LABEL=$(echo "$REPO" | tr '/' '-')
                        if ! advance_stage_if_needed "$WORKFLOW_NAME" "$TASK_ID" "$REPO_LABEL"; then
                          echo "‚ö†Ô∏è Failed to advance workflow stage"
                          exit 0
                        fi

                        echo "Resuming workflow $WORKFLOW_NAME"
                        if ! resume_workflow; then
                          echo "‚ö†Ô∏è Resume attempt failed"
                          exit 0
                        fi

                        echo "Finished processing PR-created event"
          parameters:
            - src:
                dependencyName: github-pr-created
                dataKey: body.pull_request.head.ref
              dest: spec.arguments.parameters.0.value
            - src:
                dependencyName: github-pr-created
                dataKey: body.pull_request.title
              dest: spec.arguments.parameters.1.value
            - src:
                dependencyName: github-pr-created
                dataKey: body.pull_request.number
              dest: spec.arguments.parameters.2.value
            - src:
                dependencyName: github-pr-created
                dataKey: body.pull_request.html_url
              dest: spec.arguments.parameters.3.value
            - src:
                dependencyName: github-pr-created
                dataTemplate: "{{ .Input.body.pull_request.labels | toJson }}"
              dest: spec.arguments.parameters.4.value
            - src:
                dependencyName: github-pr-created
                dataKey: body.repository.owner.login
              dest: spec.arguments.parameters.5.value
            - src:
                dependencyName: github-pr-created
                dataKey: body.repository.name
              dest: spec.arguments.parameters.6.value
        retryStrategy:
          steps: 2
          duration: "5s"
          factor: 2
          jitter: 0.1

---
# Enhanced Sensor for Implementation Agent Remediation - Cancel outdated work with advanced concurrency control
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: implementation-agent-remediation
  namespace: argo
spec:
  replicas: 1
  deploymentStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    serviceAccountName: argo-events-sa
    container:
      resources:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "256Mi"
          cpu: "300m"
  dependencies:
    - name: github-rex-push
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for push events from Rex implementation agent
          - path: body.X-GitHub-Event
            type: string
            value: ["push"]
          - path: body.pusher.name
            type: string
            value: ["rex-5dlabs[bot]"]
          # Enhanced filtering for concurrent push events
          - path: body.ref
            type: string
            comparator: "~"
            value: ["refs/heads/feature/.*", "refs/heads/task-.*"]
        exprs:
          # Additional validation for concurrent push events
          - expr: 'body.commits | length > 0'
            fields:
              - name: has_commits
                path: body.commits
          - expr: 'body.repository.name != ""'
            fields:
              - name: repo_name
                path: body.repository.name
          - expr: 'body.head_commit.message != ""'
            fields:
              - name: commit_message
                path: body.head_commit.message
  triggers:
    - template:
        name: enhanced-agent-cancellation
        conditions: "github-rex-push"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: enhanced-cancellation-
                namespace: agent-platform
                labels:
                  type: enhanced-remediation
                  version: v2
              spec:
                entrypoint: enhanced-cancellation-workflow
                serviceAccountName: agent-cancellation-sa
                arguments:
                  parameters:
                    - name: pusher-name
                      value: "{{ .Input.body.pusher.name }}"
                    - name: ref
                      value: "{{ .Input.body.ref }}"
                    - name: head-commit
                      value: "{{ .Input.body.head_commit.id }}"
                    - name: commit-message
                      value: "{{ .Input.body.head_commit.message }}"
                    - name: repo-name
                      value: "{{ .Input.body.repository.name }}"
                    - name: correlation-id
                      value: "{{ uuidv4() }}"
                templates:
                  - name: enhanced-cancellation-workflow
                    script:
                      image: agent-cancellation:latest
                      command: [bash]
                      source: |
                        #!/bin/bash
                        set -euo pipefail

                        echo "=== Enhanced Agent Cancellation System ==="
                        echo "üîß Version: 2.0 - Concurrent Safe"
                        echo "üìä Correlation ID: {{workflow.parameters.correlation-id}}"
                        echo "ü§ñ Pusher: {{workflow.parameters.pusher-name}}"
                        echo "üìã Ref: {{workflow.parameters.ref}}"
                        echo "üíæ Head Commit: {{workflow.parameters.head-commit}}"
                        echo "üìù Message: {{workflow.parameters.commit-message}}"

                        # Enhanced environment setup
                        export CORRELATION_ID="{{workflow.parameters.correlation-id}}"
                        export REPO_NAME="{{workflow.parameters.repo-name}}"
                        export PUSH_REF="{{workflow.parameters.ref}}"
                        export HEAD_COMMIT="{{workflow.parameters.head-commit}}"
                        export COMMIT_MESSAGE="{{workflow.parameters.commit-message}}"

                        # Extract and validate task information
                        BRANCH_NAME=$(echo "$PUSH_REF" | sed 's|refs/heads/||')
                        echo "üåø Branch: $BRANCH_NAME"

                        # Enhanced task ID extraction with validation
                        TASK_ID=$(echo "$BRANCH_NAME" | grep -oE 'task-?([0-9]+)' | head -1 | sed 's/task-\?//')

                        if [ -z "$TASK_ID" ]; then
                          echo "‚ö†Ô∏è  No task ID found in branch name, skipping enhanced cancellation"
                          echo "üìù Branch name: $BRANCH_NAME"
                          exit 0
                        fi

                        echo "üéØ Task ID: $TASK_ID"

                        # Enhanced PR number extraction from commit message
                        PR_NUMBER=""
                        if echo "$COMMIT_MESSAGE" | grep -qE '\(\#[0-9]+\)'; then
                          PR_NUMBER=$(echo "$COMMIT_MESSAGE" | grep -oE '\(#[0-9]+\)' | sed 's/[#(]//g')
                        elif echo "$COMMIT_MESSAGE" | grep -qE '#[0-9]+'; then
                          PR_NUMBER=$(echo "$COMMIT_MESSAGE" | grep -oE '#[0-9]+' | sed 's/#//')
                        fi

                        if [ -n "$PR_NUMBER" ]; then
                          echo "üîó Associated PR: #$PR_NUMBER"
                          export PR_NUMBER="$PR_NUMBER"
                        else
                          echo "‚ÑπÔ∏è  No PR number found in commit message"
                        fi

                        # Enhanced state-aware cancellation with distributed locking
                        echo ""
                        echo "üîê Initializing Enhanced Cancellation System..."

                        # Check if enhanced cancellation controller is available
                        if command -v enhanced-cancellation-controller >/dev/null 2>&1; then
                          echo "‚úÖ Enhanced cancellation controller found"
                          exec enhanced-cancellation-controller
                        else
                          echo "‚ö†Ô∏è  Enhanced controller not available, falling back to basic cancellation"

                          # Fallback to basic cancellation logic
                          echo ""
                          echo "üîÑ Executing Basic Cancellation Fallback..."

                          # Find CodeRuns for quality and testing agents on this task
                          echo "Looking for outdated CodeRuns to cancel..."
                          kubectl get coderuns -n agent-platform \
                            -l task-id=$TASK_ID \
                            -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.metadata.labels.agent-type}{"\t"}{.status.phase}{"\n"}{end}' | \
                          while read coderun_name agent_type phase; do
                            if [ "$agent_type" = "cleo" ] || [ "$agent_type" = "tess" ]; then
                              echo "üìã Found CodeRun: $coderun_name (agent: $agent_type, phase: $phase)"

                              # Enhanced phase checking
                              if [ "$phase" = "Running" ] || [ "$phase" = "Pending" ]; then
                                echo "üõë Cancelling outdated CodeRun: $coderun_name (agent: $agent_type)"
                                kubectl delete coderun $coderun_name -n agent-platform --ignore-not-found=true
                              elif [ "$phase" = "Succeeded" ] || [ "$phase" = "Failed" ]; then
                                echo "‚úÖ CodeRun $coderun_name already completed (phase: $phase), skipping"
                              else
                                echo "‚ùì CodeRun $coderun_name in unknown phase: $phase, attempting cancellation"
                                kubectl delete coderun $coderun_name -n agent-platform --ignore-not-found=true --timeout=30s
                              fi
                            fi
                          done

                          echo "‚úÖ Basic remediation completed"
                        fi
      retryStrategy:
        steps: 3  # Enhanced retries for reliability
        duration: "10s"
        factor: 2
        jitter: 0.1

---
# Sensor for ready-for-security label - Resume workflow at security stage (Cleo ‚Üí Cipher handoff)
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: play-workflow-ready-for-security
  namespace: argo
spec:
  replicas: 1
  deploymentStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: github-label-added
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for pull_request labeled events
          - path: body.X-GitHub-Event
            type: string
            value: ["pull_request"]
          - path: body.action
            type: string
            value: ["labeled"]
          - path: body.label.name
            type: string
            value: ["ready-for-security"]
  triggers:
    - template:
        name: resume-security-stage
        conditions: "github-label-added"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: resume-security-stage-
                namespace: agent-platform
                labels:
                  type: webhook-resume
                  target-stage: security-in-progress
              spec:
                entrypoint: resume-workflow
                serviceAccountName: argo-workflow
                arguments:
                  parameters:
                    - name: pr-number
                      value: ""
                    - name: pr-url
                      value: ""
                    - name: repo-owner
                      value: ""
                    - name: repo-name
                      value: ""
                templates:
                  - name: resume-workflow
                    script:
                      image: alpine/k8s:1.31.0
                      command: [bash]
                      env:
                        - name: GITHUB_APP_ID
                          valueFrom:
                            secretKeyRef:
                              name: github-app-5dlabs-cipher
                              key: app-id
                        - name: GITHUB_APP_PRIVATE_KEY
                          valueFrom:
                            secretKeyRef:
                              name: github-app-5dlabs-cipher
                              key: private-key
                      source: |
                        #!/bin/bash
                        set -euo pipefail

                        echo "=== ready-for-security Label Workflow Resume ==="

                        ensure_jq() {
                          if command -v jq >/dev/null 2>&1; then
                            return 0
                          fi

                          if command -v apk >/dev/null 2>&1; then
                            apk add --no-cache jq >/dev/null 2>&1 && return 0
                          elif command -v apt-get >/dev/null 2>&1; then
                            apt-get update >/dev/null 2>&1 && apt-get install -y jq >/dev/null 2>&1 && rm -rf /var/lib/apt/lists/* && return 0
                          elif command -v microdnf >/dev/null 2>&1; then
                            microdnf -y install jq >/dev/null 2>&1 && return 0
                          fi

                          echo "‚ùå Failed to install jq"
                          return 1
                        }

                        ensure_argo_cli() {
                          if command -v argo >/dev/null 2>&1; then
                            ARGO_BIN=$(command -v argo)
                            return 0
                          fi

                          ARGO_VERSION="${ARGO_VERSION:-v3.7.1}"
                          ARGO_BIN="/tmp/argo"

                          if [ ! -x "$ARGO_BIN" ]; then
                            echo "Downloading argo CLI ($ARGO_VERSION)..."
                            if command -v wget >/dev/null 2>&1; then
                              wget -qO "$ARGO_BIN" "https://github.com/argoproj/argo-workflows/releases/download/$ARGO_VERSION/argo-linux-amd64"
                            elif command -v curl >/dev/null 2>&1; then
                              curl -sSL -o "$ARGO_BIN" "https://github.com/argoproj/argo-workflows/releases/download/$ARGO_VERSION/argo-linux-amd64"
                            else
                              echo "Neither wget nor curl is available"
                              return 1
                            fi
                            chmod +x "$ARGO_BIN"
                          fi
                        }

                        build_kubeconfig() {
                          local kubeconfig_path="/tmp/argo-kubeconfig"
                          if [ -f "$kubeconfig_path" ]; then
                            echo "$kubeconfig_path"
                            return 0
                          fi

                          local ca_cert="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                          local token_file="/var/run/secrets/kubernetes.io/serviceaccount/token"

                          if [ ! -f "$token_file" ]; then
                            echo "Service account token not found"
                            return 1
                          fi

                          local server="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"
                          local token
                          token=$(cat "$token_file")

                          {
                            echo "apiVersion: v1"
                            echo "kind: Config"
                            echo "clusters:"
                            echo "  - cluster:"
                            printf '      certificate-authority: %s\n' "$ca_cert"
                            printf '      server: %s\n' "$server"
                            echo "    name: in-cluster"
                            echo "contexts:"
                            echo "  - context:"
                            echo "      cluster: in-cluster"
                            echo "      namespace: agent-platform"
                            echo "      user: sensor-sa"
                            echo "    name: in-cluster"
                            echo "current-context: in-cluster"
                            echo "users:"
                            echo "  - name: sensor-sa"
                            echo "    user:"
                            printf '      token: %s\n' "$token"
                          } > "$kubeconfig_path"

                          echo "$kubeconfig_path"
                        }

                        resume_workflow() {
                          ensure_argo_cli || return 1
                          local kubeconfig_path
                          kubeconfig_path=$(build_kubeconfig) || return 1

                          if "$ARGO_BIN" --auth-mode kubeconfig --kubeconfig "$kubeconfig_path" \
                            -n agent-platform resume "$WORKFLOW_NAME" >/tmp/argo-resume.log 2>&1; then
                            echo "‚úÖ Workflow resumed successfully"
                            return 0
                          fi

                          echo "‚ö†Ô∏è Failed to resume via argo CLI; output:"
                          cat /tmp/argo-resume.log
                          return 1
                        }

                        ensure_jq

                        # Debug: Print values from workflow parameters
                        echo "=== DEBUG: ready-for-security Label Event Data ==="
                        echo "pr-number: {{workflow.parameters.pr-number}}"
                        echo "pr-url: {{workflow.parameters.pr-url}}"
                        echo "repo-owner: {{workflow.parameters.repo-owner}}"
                        echo "repo-name: {{workflow.parameters.repo-name}}"
                        echo "=================================="

                        OWNER="{{workflow.parameters.repo-owner}}"
                        REPO_NAME="{{workflow.parameters.repo-name}}"
                        REPO="${OWNER}/${REPO_NAME}"
                        PR_NUMBER="{{workflow.parameters.pr-number}}"
                        PR_URL="{{workflow.parameters.pr-url}}"
                        PR_API_URL="https://api.github.com/repos/${REPO}/issues/${PR_NUMBER}"

                        extract_task_id() {
                          echo "$1" | tr '[:upper:]' '[:lower:]' | grep -oE 'task[-_/ ]*([0-9]+)' | head -n1 | grep -oE '[0-9]+' || true
                        }

                        fetch_task_id_via_api() {
                          local response label_name candidate title body

                          response=$(curl -s -L -H "Accept: application/vnd.github+json" "$PR_API_URL")

                          if [ -z "$response" ] || [ "$response" = "null" ]; then
                            echo ""
                            return 1
                          fi

                          while IFS= read -r label_name; do
                            candidate=$(extract_task_id "$label_name")
                            if [ -n "$candidate" ]; then
                              echo "$candidate"
                              return 0
                            fi
                          done < <(echo "$response" | jq -r '(.labels // [])[]?.name // ""')

                          title=$(echo "$response" | jq -r '.title // ""')
                          if [ -n "$title" ]; then
                            candidate=$(extract_task_id "$title")
                            if [ -n "$candidate" ]; then
                              echo "$candidate"
                              return 0
                            fi
                          fi

                          body=$(echo "$response" | jq -r '.body // ""')
                          if [ -n "$body" ]; then
                            candidate=$(extract_task_id "$body")
                            if [ -n "$candidate" ]; then
                              echo "$candidate"
                              return 0
                            fi
                          fi

                          echo ""
                          return 1
                        }

                        TASK_ID=""

                        # Query GitHub API for task ID (from labels, title, or body)
                        echo "‚ÑπÔ∏è Querying GitHub API for task ID in PR #${PR_NUMBER}"
                        TASK_ID=$(fetch_task_id_via_api || true)

                        if [ -z "$TASK_ID" ]; then
                          echo "‚ö†Ô∏è No task ID found in PR #${PR_NUMBER} (not a play workflow PR)"
                          exit 0
                        fi

                        echo "Task ID: $TASK_ID"

                        # Extract repository for precise correlation
                        REPO_FULL="${OWNER}/${REPO_NAME}"
                        REPO_LABEL=$(echo "$REPO_FULL" | tr '/' '-')
                        echo "Repository: $REPO_FULL (label: $REPO_LABEL)"

                        echo "Polling for workflow reaching security-in-progress stage..."
                        MAX_WORKFLOW_ATTEMPTS=90
                        WORKFLOW_WAIT_SECONDS=10
                        WORKFLOW_ATTEMPT=1
                        WORKFLOW_NAME=""
                        SUSPEND_READY=false

                        while [ $WORKFLOW_ATTEMPT -le $MAX_WORKFLOW_ATTEMPTS ]; do
                          WORKFLOW_JSON=$(kubectl get workflows -n agent-platform \
                            -l task-id=$TASK_ID,workflow-type=play-orchestration,repository=$REPO_LABEL \
                            -o json 2>/dev/null || echo "")

                          WORKFLOW_NAME=""
                          if [ -n "$WORKFLOW_JSON" ]; then
                            WORKFLOW_NAME=$(echo "$WORKFLOW_JSON" | \
                              jq -r '.items[0].metadata.name // ""' 2>/dev/null || echo "")
                          fi

                          if [ -n "$WORKFLOW_NAME" ]; then
                            CURRENT_STAGE=$(echo "$WORKFLOW_JSON" | \
                              jq -r '.items[0].metadata.labels["current-stage"] // ""' 2>/dev/null || echo "")
                            SUSPEND_NODE=$(echo "$WORKFLOW_JSON" | \
                              jq -r '(.items[0].status.nodes // {})
                                | to_entries[]?
                                | select(.value.displayName == "wait-for-cipher-approval")
                                | .value.phase' 2>/dev/null || echo "")

                            if [ "$CURRENT_STAGE" = "security-in-progress" ] && [ "$SUSPEND_NODE" = "Running" ]; then
                              SUSPEND_READY=true
                              echo "‚úÖ Workflow $WORKFLOW_NAME is suspended at security-in-progress stage"
                              break
                            fi

                            echo "‚è≥ Workflow $WORKFLOW_NAME stage=$CURRENT_STAGE suspend-node=${SUSPEND_NODE:-none};"
                            echo "   waiting ${WORKFLOW_WAIT_SECONDS}s"
                          else
                            echo "‚è≥ No workflow discovered for task-id=$TASK_ID and repository=$REPO_LABEL yet;"
                            echo "   waiting ${WORKFLOW_WAIT_SECONDS}s"
                          fi

                          sleep $WORKFLOW_WAIT_SECONDS
                          WORKFLOW_ATTEMPT=$((WORKFLOW_ATTEMPT + 1))
                        done

                        if [ "$SUSPEND_READY" != true ]; then
                          echo "‚ö†Ô∏è Workflow did not reach security-in-progress suspend point in time; skipping resume"
                          exit 0
                        fi

                        echo "Resuming workflow $WORKFLOW_NAME"
                        if ! resume_workflow; then
                          echo "‚ö†Ô∏è Resume attempt failed"
                          exit 0
                        fi

                        echo "‚úÖ Finished processing ready-for-security label event"
          parameters:
            - src:
                dependencyName: github-label-added
                dataKey: body.pull_request.number
              dest: spec.arguments.parameters.0.value
            - src:
                dependencyName: github-label-added
                dataKey: body.pull_request.html_url
              dest: spec.arguments.parameters.1.value
            - src:
                dependencyName: github-label-added
                dataKey: body.repository.owner.login
              dest: spec.arguments.parameters.2.value
            - src:
                dependencyName: github-label-added
                dataKey: body.repository.name
              dest: spec.arguments.parameters.3.value
        retryStrategy:
          steps: 2
          duration: "5s"
          factor: 2
          jitter: 0.1

---
# Sensor for ready-for-qa label - Resume workflow at QA stage (Cleo ‚Üí Tess handoff)
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: play-workflow-ready-for-qa
  namespace: argo
spec:
  replicas: 1
  deploymentStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: github-label-added
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for pull_request labeled events
          - path: body.X-GitHub-Event
            type: string
            value: ["pull_request"]
          - path: body.action
            type: string
            value: ["labeled"]
          - path: body.label.name
            type: string
            value: ["ready-for-qa"]
  triggers:
    - template:
        name: resume-qa-stage
        conditions: "github-label-added"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: resume-qa-stage-
                namespace: agent-platform
                labels:
                  type: webhook-resume
                  target-stage: waiting-ready-for-qa
              spec:
                entrypoint: resume-workflow
                serviceAccountName: argo-workflow
                arguments:
                  parameters:
                    - name: pr-number
                      value: ""
                    - name: pr-url
                      value: ""
                    - name: repo-owner
                      value: ""
                    - name: repo-name
                      value: ""
                templates:
                  - name: resume-workflow
                    script:
                      image: alpine/k8s:1.31.0
                      command: [bash]
                      source: |
                        #!/bin/bash
                        set -euo pipefail

                        echo "=== ready-for-qa Label Workflow Resume ==="

                        ensure_jq() {
                          if command -v jq >/dev/null 2>&1; then
                            return 0
                          fi

                          if command -v apk >/dev/null 2>&1; then
                            apk add --no-cache jq >/dev/null 2>&1 && return 0
                          elif command -v apt-get >/dev/null 2>&1; then
                            apt-get update >/dev/null 2>&1 && apt-get install -y jq >/dev/null 2>&1 && rm -rf /var/lib/apt/lists/* && return 0
                          elif command -v microdnf >/dev/null 2>&1; then
                            microdnf -y install jq >/dev/null 2>&1 && return 0
                          fi

                          echo "‚ùå Failed to install jq"
                          return 1
                        }

                        ensure_argo_cli() {
                          if command -v argo >/dev/null 2>&1; then
                            ARGO_BIN=$(command -v argo)
                            return 0
                          fi

                          ARGO_VERSION="${ARGO_VERSION:-v3.7.1}"
                          ARGO_BIN="/tmp/argo"

                          if [ ! -x "$ARGO_BIN" ]; then
                            echo "Downloading argo CLI ($ARGO_VERSION)..."
                            if command -v wget >/dev/null 2>&1; then
                              wget -qO "$ARGO_BIN" "https://github.com/argoproj/argo-workflows/releases/download/$ARGO_VERSION/argo-linux-amd64"
                            elif command -v curl >/dev/null 2>&1; then
                              curl -sSL -o "$ARGO_BIN" "https://github.com/argoproj/argo-workflows/releases/download/$ARGO_VERSION/argo-linux-amd64"
                            else
                              echo "Neither wget nor curl is available"
                              return 1
                            fi
                            chmod +x "$ARGO_BIN"
                          fi
                        }

                        build_kubeconfig() {
                          local kubeconfig_path="/tmp/argo-kubeconfig"
                          if [ -f "$kubeconfig_path" ]; then
                            echo "$kubeconfig_path"
                            return 0
                          fi

                          local ca_cert="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                          local token_file="/var/run/secrets/kubernetes.io/serviceaccount/token"

                          if [ ! -f "$token_file" ]; then
                            echo "Service account token not found"
                            return 1
                          fi

                          local server="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"
                          local token
                          token=$(cat "$token_file")

                          {
                            echo "apiVersion: v1"
                            echo "kind: Config"
                            echo "clusters:"
                            echo "  - cluster:"
                            printf '      certificate-authority: %s\n' "$ca_cert"
                            printf '      server: %s\n' "$server"
                            echo "    name: in-cluster"
                            echo "contexts:"
                            echo "  - context:"
                            echo "      cluster: in-cluster"
                            echo "      namespace: agent-platform"
                            echo "      user: sensor-sa"
                            echo "    name: in-cluster"
                            echo "current-context: in-cluster"
                            echo "users:"
                            echo "  - name: sensor-sa"
                            echo "    user:"
                            printf '      token: %s\n' "$token"
                          } > "$kubeconfig_path"

                          echo "$kubeconfig_path"
                        }

                        resume_workflow() {
                          ensure_argo_cli || return 1
                          local kubeconfig_path
                          kubeconfig_path=$(build_kubeconfig) || return 1

                          if "$ARGO_BIN" --auth-mode kubeconfig --kubeconfig "$kubeconfig_path" \
                            -n agent-platform resume "$WORKFLOW_NAME" >/tmp/argo-resume.log 2>&1; then
                            echo "‚úÖ Workflow resumed successfully"
                            return 0
                          fi

                          echo "‚ö†Ô∏è Failed to resume via argo CLI; output:"
                          cat /tmp/argo-resume.log
                          return 1
                        }

                        ensure_jq

                        # Debug: Print values from workflow parameters
                        echo "=== DEBUG: ready-for-qa Label Event Data ==="
                        echo "pr-number: {{workflow.parameters.pr-number}}"
                        echo "pr-url: {{workflow.parameters.pr-url}}"
                        echo "repo-owner: {{workflow.parameters.repo-owner}}"
                        echo "repo-name: {{workflow.parameters.repo-name}}"
                        echo "=================================="

                        OWNER="{{workflow.parameters.repo-owner}}"
                        REPO_NAME="{{workflow.parameters.repo-name}}"
                        REPO="${OWNER}/${REPO_NAME}"
                        PR_NUMBER="{{workflow.parameters.pr-number}}"
                        PR_URL="{{workflow.parameters.pr-url}}"
                        PR_API_URL="https://api.github.com/repos/${REPO}/issues/${PR_NUMBER}"

                        extract_task_id() {
                          echo "$1" | tr '[:upper:]' '[:lower:]' | grep -oE 'task[-_/ ]*([0-9]+)' | head -n1 | grep -oE '[0-9]+' || true
                        }

                        fetch_task_id_via_api() {
                          local response label_name candidate title body

                          response=$(curl -s -L -H "Accept: application/vnd.github+json" "$PR_API_URL")

                          if [ -z "$response" ] || [ "$response" = "null" ]; then
                            echo ""
                            return 1
                          fi

                          while IFS= read -r label_name; do
                            candidate=$(extract_task_id "$label_name")
                            if [ -n "$candidate" ]; then
                              echo "$candidate"
                              return 0
                            fi
                          done < <(echo "$response" | jq -r '(.labels // [])[]?.name // ""')

                          title=$(echo "$response" | jq -r '.title // ""')
                          if [ -n "$title" ]; then
                            candidate=$(extract_task_id "$title")
                            if [ -n "$candidate" ]; then
                              echo "$candidate"
                              return 0
                            fi
                          fi

                          body=$(echo "$response" | jq -r '.body // ""')
                          if [ -n "$body" ]; then
                            candidate=$(extract_task_id "$body")
                            if [ -n "$candidate" ]; then
                              echo "$candidate"
                              return 0
                            fi
                          fi

                          echo ""
                          return 1
                        }

                        TASK_ID=""

                        # Query GitHub API for task ID (from labels, title, or body)
                        echo "‚ÑπÔ∏è Querying GitHub API for task ID in PR #${PR_NUMBER}"
                        TASK_ID=$(fetch_task_id_via_api || true)

                        if [ -z "$TASK_ID" ]; then
                          echo "‚ö†Ô∏è No task ID found in PR #${PR_NUMBER} (not a play workflow PR)"
                          exit 0
                        fi

                        echo "Task ID: $TASK_ID"

                        # Extract repository for precise correlation
                        REPO_LABEL=$(echo "$REPO" | tr '/' '-')
                        echo "Repository: $REPO (label: $REPO_LABEL)"

                        echo "Polling for workflow reaching waiting-ready-for-qa stage..."
                        MAX_WORKFLOW_ATTEMPTS=90
                        WORKFLOW_WAIT_SECONDS=10
                        WORKFLOW_ATTEMPT=1
                        WORKFLOW_NAME=""
                        SUSPEND_READY=false

                        while [ $WORKFLOW_ATTEMPT -le $MAX_WORKFLOW_ATTEMPTS ]; do
                          WORKFLOW_JSON=$(kubectl get workflows -n agent-platform \
                            -l task-id=$TASK_ID,workflow-type=play-orchestration,repository=$REPO_LABEL \
                            -o json 2>/dev/null || echo "")

                          WORKFLOW_NAME=""
                          if [ -n "$WORKFLOW_JSON" ]; then
                            WORKFLOW_NAME=$(echo "$WORKFLOW_JSON" | \
                              jq -r '.items[0].metadata.name // ""' 2>/dev/null || echo "")
                          fi

                          if [ -n "$WORKFLOW_NAME" ]; then
                            CURRENT_STAGE=$(echo "$WORKFLOW_JSON" | \
                              jq -r '.items[0].metadata.labels["current-stage"] // ""' 2>/dev/null || echo "")
                            SUSPEND_NODE=$(echo "$WORKFLOW_JSON" | \
                              jq -r '(.items[0].status.nodes // {})
                                | to_entries[]?
                                | select(.value.displayName == "wait-for-tess-approval")
                                | .value.phase' 2>/dev/null || echo "")

                            if [ "$CURRENT_STAGE" = "waiting-ready-for-qa" ] && [ "$SUSPEND_NODE" = "Running" ]; then
                              SUSPEND_READY=true
                              echo "‚úÖ Workflow $WORKFLOW_NAME is suspended at waiting-ready-for-qa stage"
                              break
                            fi

                            echo "‚è≥ Workflow $WORKFLOW_NAME stage=$CURRENT_STAGE suspend-node=${SUSPEND_NODE:-none};"
                            echo "   waiting ${WORKFLOW_WAIT_SECONDS}s"
                          else
                            echo "‚è≥ No workflow discovered for task-id=$TASK_ID and repository=$REPO_LABEL yet;"
                            echo "   waiting ${WORKFLOW_WAIT_SECONDS}s"
                          fi

                          sleep $WORKFLOW_WAIT_SECONDS
                          WORKFLOW_ATTEMPT=$((WORKFLOW_ATTEMPT + 1))
                        done

                        if [ "$SUSPEND_READY" != true ]; then
                          echo "‚ö†Ô∏è Workflow did not reach waiting-ready-for-qa suspend point in time; skipping resume"
                          exit 0
                        fi

                        echo "Resuming workflow $WORKFLOW_NAME"
                        if ! resume_workflow; then
                          echo "‚ö†Ô∏è Resume attempt failed"
                          exit 0
                        fi

                        echo "‚úÖ Finished processing ready-for-qa label event"
          parameters:
            - src:
                dependencyName: github-label-added
                dataKey: body.pull_request.number
              dest: spec.arguments.parameters.0.value
            - src:
                dependencyName: github-label-added
                dataKey: body.pull_request.html_url
              dest: spec.arguments.parameters.1.value
            - src:
                dependencyName: github-label-added
                dataKey: body.repository.owner.login
              dest: spec.arguments.parameters.2.value
            - src:
                dependencyName: github-label-added
                dataKey: body.repository.name
              dest: spec.arguments.parameters.3.value
        retryStrategy:
          steps: 2
          duration: "5s"
          factor: 2
          jitter: 0.1
