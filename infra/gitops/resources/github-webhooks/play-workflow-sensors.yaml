---
# Sensor for PR Created Event - Resume after implementation work
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: play-workflow-pr-created
  namespace: argo
spec:
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: github-pr-created
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for pull_request opened events
          - path: headers.X-Github-Event
            type: string
            value: ["pull_request"]
          - path: body.action
            type: string
            value: ["opened"]
  triggers:
    - template:
        name: resume-after-pr-created
        conditions: "github-pr-created"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: resume-pr-created-
                namespace: agent-platform
                labels:
                  type: webhook-resume
                  target-stage: waiting-pr-created
              spec:
                entrypoint: resume-workflow
                serviceAccountName: argo-workflow
                arguments:
                  parameters:
                    - name: pr-number
                      value: "{{ .Input.body.pull_request.number }}"
                    - name: pr-url
                      value: "{{ .Input.body.pull_request.html_url }}"
                    - name: pr-labels
                      value: "{{ .Input.body.pull_request.labels | toJson }}"
                templates:
                  - name: resume-workflow
                    script:
                      image: alpine/k8s:1.31.0
                      command: [bash]
                      source: |
                        #!/bin/bash
                        set -e

                        echo "=== PR Created Workflow Resume ==="
                        echo "PR Number: {{workflow.parameters.pr-number}}"
                        echo "PR URL: {{workflow.parameters.pr-url}}"

                        # Extract task ID from PR labels
                        TASK_ID=$(echo '{{workflow.parameters.pr-labels}}' | \
                          jq -r '.[] | select(.name | startswith("task-")) | .name | capture("task-(?<id>[0-9]+)") | .id' | head -1)

                        if [ -z "$TASK_ID" ]; then
                          echo "ERROR: No task-* label found on PR"
                          exit 1
                        fi

                        echo "Task ID: $TASK_ID"

                        # Find workflow by labels (since actual names have random suffixes)
                        WORKFLOW_NAME=$(kubectl get workflows -n agent-platform \
                          -l task-id=$TASK_ID,workflow-type=play-orchestration \
                          -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

                        if [ -z "$WORKFLOW_NAME" ]; then
                          echo "ERROR: No workflow found for task-id=$TASK_ID"
                          exit 1
                        fi

                        echo "Found workflow: $WORKFLOW_NAME"

                        # Check if workflow exists and is at correct stage
                        CURRENT_STAGE=$(kubectl get workflow $WORKFLOW_NAME \
                          -n agent-platform \
                          -o jsonpath='{.metadata.labels.current-stage}' \
                          2>/dev/null || echo "")

                        if [ "$CURRENT_STAGE" = "waiting-pr-created" ]; then
                          echo "Found workflow at correct stage, resuming..."

                          # Store PR details in environment variables to prevent injection
                          PR_URL="{{workflow.parameters.pr-url}}"
                          PR_NUMBER="{{workflow.parameters.pr-number}}"

                          # Update workflow parameters with PR details using strategic patch
                          kubectl patch workflow $WORKFLOW_NAME \
                            -n agent-platform \
                            --type='strategic' \
                            --patch="{
                              \"spec\": {
                                \"arguments\": {
                                  \"parameters\": [
                                    {\"name\": \"pr-url\", \"value\": \"$PR_URL\"},
                                    {\"name\": \"pr-number\", \"value\": \"$PR_NUMBER\"}
                                  ]
                                }
                              }
                            }"

                          # Resume the workflow
                          argo resume $WORKFLOW_NAME -n agent-platform

                          echo "✅ Workflow resumed successfully"
                        else
                          echo "Workflow not at expected stage (current: $CURRENT_STAGE)"
                          echo "Skipping resume to prevent incorrect stage progression"
                        fi
      retryStrategy:
        steps: 3
        duration: "10s"
        factor: 2
        jitter: 0.1

---
# Sensor for Ready-for-QA Label Added - Resume after quality work
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: play-workflow-ready-for-qa
  namespace: argo
spec:
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: github-label-added
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for pull_request labeled events and ensure it's a stage transition
          - path: headers.X-Github-Event
            type: string
            value: ["pull_request"]
          - path: body.action
            type: string
            value: ["labeled"]
          # Check if the label added is "ready-for-qa" AND sender is Cleo
          - path: body.label.name
            type: string
            value: ["ready-for-qa"]
          - path: body.sender.login
            type: string
            comparator: "~"
            value: ["cleo-5dlabs\\[bot\\]"]
  triggers:
    - template:
        name: resume-after-ready-for-qa
        conditions: "github-label-added"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: resume-ready-qa-
                namespace: agent-platform
                labels:
                  type: webhook-resume
                  target-stage: waiting-ready-for-qa
              spec:
                entrypoint: resume-workflow
                serviceAccountName: argo-workflow
                templates:
                  - name: resume-workflow
                    script:
                      image: alpine/k8s:1.31.0
                      command: [bash]
                      source: |
                        #!/bin/bash
                        set -e

                        echo "=== Ready-for-QA Workflow Resume ==="
                        echo "Label Added: {{ .Input.body.label.name }}"
                        echo "Added By: {{ .Input.body.sender.login }}"

                        # Extract task ID from PR labels
                        TASK_ID=$(echo '{{ .Input.body.pull_request.labels }}' | \
                          jq -r '.[] | select(.name | startswith("task-")) | .name | capture("task-(?<id>[0-9]+)") | .id' | head -1)

                        if [ -z "$TASK_ID" ]; then
                          echo "ERROR: No task-* label found on PR"
                          exit 1
                        fi

                        echo "Task ID: $TASK_ID"

                        # Find workflow by labels (since actual names have random suffixes)
                        WORKFLOW_NAME=$(kubectl get workflows -n agent-platform \
                          -l task-id=$TASK_ID,workflow-type=play-orchestration \
                          -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

                        if [ -z "$WORKFLOW_NAME" ]; then
                          echo "ERROR: No workflow found for task-id=$TASK_ID"
                          exit 1
                        fi

                        echo "Found workflow: $WORKFLOW_NAME"

                        # Check if workflow exists and is at correct stage
                        CURRENT_STAGE=$(kubectl get workflow $WORKFLOW_NAME \
                          -n agent-platform \
                          -o jsonpath='{.metadata.labels.current-stage}' \
                          2>/dev/null || echo "")

                        if [ "$CURRENT_STAGE" = "waiting-ready-for-qa" ]; then
                          echo "Found workflow at correct stage, resuming..."

                          # Update workflow parameters using strategic patch to preserve existing parameters
                          kubectl patch workflow $WORKFLOW_NAME \
                            -n agent-platform \
                            --type='strategic' \
                            --patch='{"spec": {"arguments": {"parameters": [{"name": "qa-status", "value": "ready"}]}}}'

                          # Resume the workflow
                          argo resume $WORKFLOW_NAME -n agent-platform

                          echo "✅ Workflow resumed successfully"
                        else
                          echo "Workflow not at expected stage (current: $CURRENT_STAGE)"
                          echo "Skipping resume to prevent incorrect stage progression"
                        fi
      retryStrategy:
        steps: 3
        duration: "10s"
        factor: 2
        jitter: 0.1

---
# Sensor for PR Approved - Resume after testing work
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: play-workflow-pr-approved
  namespace: argo
spec:
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: github-pr-approved
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for pull_request_review events
          - path: headers.X-Github-Event
            type: string
            value: ["pull_request_review"]
          - path: body.action
            type: string
            value: ["submitted"]
          # Check if the review state is approved
          - path: body.review.state
            type: string
            value: ["approved"]
          # Check if reviewer is Tess
          - path: body.review.user.login
            type: string
            comparator: "~"
            value: ["tess-5dlabs\\[bot\\]"]
  triggers:
    - template:
        name: resume-after-pr-approved
        conditions: "github-pr-approved"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: resume-pr-approved-
                namespace: agent-platform
                labels:
                  type: webhook-resume
                  target-stage: waiting-pr-approved
              spec:
                entrypoint: resume-workflow
                serviceAccountName: argo-workflow
                templates:
                  - name: resume-workflow
                    script:
                      image: alpine/k8s:1.31.0
                      command: [bash]
                      source: |
                        #!/bin/bash
                        set -e

                        echo "=== PR Approved Workflow Resume ==="
                        echo "Reviewer: {{ .Input.body.review.user.login }}"
                        echo "Review State: {{ .Input.body.review.state }}"

                        # Extract task ID from PR labels
                        TASK_ID=$(echo '{{ .Input.body.pull_request.labels }}' | \
                          jq -r '.[] | select(.name | startswith("task-")) | .name | capture("task-(?<id>[0-9]+)") | .id' | head -1)

                        if [ -z "$TASK_ID" ]; then
                          echo "ERROR: No task-* label found on PR"
                          exit 1
                        fi

                        echo "Task ID: $TASK_ID"

                        # Find workflow by labels (since actual names have random suffixes)
                        WORKFLOW_NAME=$(kubectl get workflows -n agent-platform \
                          -l task-id=$TASK_ID,workflow-type=play-orchestration \
                          -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

                        if [ -z "$WORKFLOW_NAME" ]; then
                          echo "ERROR: No workflow found for task-id=$TASK_ID"
                          exit 1
                        fi

                        echo "Found workflow: $WORKFLOW_NAME"

                        # Check if workflow exists and is at correct stage
                        CURRENT_STAGE=$(kubectl get workflow $WORKFLOW_NAME \
                          -n agent-platform \
                          -o jsonpath='{.metadata.labels.current-stage}' \
                          2>/dev/null || echo "")

                        if [ "$CURRENT_STAGE" = "waiting-pr-approved" ]; then
                          echo "Found workflow at correct stage, resuming..."

                          # Store merge SHA in environment variable to prevent injection
                          MERGE_SHA="{{ .Input.body.pull_request.merge_commit_sha }}"

                          # Update workflow parameters using strategic patch to preserve existing parameters
                          kubectl patch workflow $WORKFLOW_NAME \
                            -n agent-platform \
                            --type='strategic' \
                            --patch="{
                              \"spec\": {
                                \"arguments\": {
                                  \"parameters\": [
                                    {\"name\": \"qa-status\", \"value\": \"approved\"},
                                    {\"name\": \"merge-sha\", \"value\": \"$MERGE_SHA\"}
                                  ]
                                }
                              }
                            }"

                          # Resume the workflow
                          argo resume $WORKFLOW_NAME -n agent-platform

                          echo "✅ Workflow resumed successfully"
                        else
                          echo "Workflow not at expected stage (current: $CURRENT_STAGE)"
                          echo "Skipping resume to prevent incorrect stage progression"
                        fi
      retryStrategy:
        steps: 3
        duration: "10s"
        factor: 2
        jitter: 0.1

---
# Sensor for Implementation Agent Remediation - Cancel running quality/testing agents
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: implementation-agent-remediation
  namespace: argo
  labels:
    sensor-type: multi-agent-orchestration
    agent-class: implementation
spec:
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: implementation-push-event
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for push events
          - path: headers.X-Github-Event
            type: string
            value: ["push"]
          # Match any 5DLabs implementation agent (Rex, Blaze, Morgan)
          - path: body.pusher.name
            type: string
            comparator: "~"
            value: ["(rex|blaze|morgan)-5dlabs\\[bot\\]"]
          # Ensure push is to a task branch
          - path: body.ref
            type: string
            comparator: "~"
            value: ["refs/heads/(task|feature/task)-.*"]
  triggers:
    # Cancel running quality/testing agents
    - template:
        name: cancel-quality-agents
        conditions: "implementation-push-event"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: batch/v1
              kind: Job
              metadata:
                generateName: cancel-quality-agents-
                namespace: agent-platform
              spec:
                template:
                  spec:
                    serviceAccountName: argo-events-sa
                    restartPolicy: Never
                    containers:
                      - name: cancel-agents
                        image: bitnami/kubectl:latest
                        command:
                          - /bin/sh
                          - -c
                          - |
                            echo "Implementation agent pushed, canceling quality/testing agents..."

                            # Get task ID from branch name
                            BRANCH="{{ .Input.body.ref }}"
                            TASK_ID=$(echo "$BRANCH" | grep -oE 'task-[0-9]+' | cut -d'-' -f2)
                            echo "Task ID: $TASK_ID"

                            # Cancel Cleo and Tess CodeRuns for this task
                            kubectl delete coderun -n agent-platform -l task-id=$TASK_ID,github-app=5DLabs-Cleo --ignore-not-found=true
                            kubectl delete coderun -n agent-platform -l task-id=$TASK_ID,github-app=5DLabs-Tess --ignore-not-found=true

                            echo "Quality agents canceled for task $TASK_ID"
                ttlSecondsAfterFinished: 60
      retryStrategy:
        steps: 2
        duration: "5s"
