---
# Stage-Aware Atlas Integration Sensor - Tess Approval
# Launches Atlas integration after Tess approves and resumes play workflows
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: stage-aware-tess-approval
  namespace: argo
  labels:
    task: "7"
    type: stage-management
    component: atlas-integration
spec:
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: tess-approved-event
      eventSourceName: github
      eventName: org
      filters:
        data:
          - path: body.X-GitHub-Event
            type: string
            value: ["pull_request_review"]
          - path: body.action
            type: string
            value: ["submitted"]
          - path: body.review.state
            type: string
            value: ["approved"]
          - path: body.review.user.login
            type: string
            value: ["5DLabs-Tess[bot]", "5DLabs-Tess", "tess-5dlabs"]

  triggers:
    - template:
        name: atlas-integration-after-tess
        conditions: "tess-approved-event"
        parameters:
          - src:
              dependencyName: tess-approved-event
              dataKey: body.pull_request.number
            dest: spec.arguments.parameters.0.value
          - src:
              dependencyName: tess-approved-event
              dataKey: body.pull_request.html_url
            dest: spec.arguments.parameters.1.value
          - src:
              dependencyName: tess-approved-event
              dataKey: body.repository.owner.login
            dest: spec.arguments.parameters.2.value
          - src:
              dependencyName: tess-approved-event
              dataKey: body.repository.name
            dest: spec.arguments.parameters.3.value
          - src:
              dependencyName: tess-approved-event
              dataTemplate: "{{ .Input.body.pull_request.labels | toJson }}"
            dest: spec.arguments.parameters.4.value
          - src:
              dependencyName: tess-approved-event
              dataKey: body.pull_request.title
            dest: spec.arguments.parameters.5.value
          - src:
              dependencyName: tess-approved-event
              dataKey: body.pull_request.head.ref
            dest: spec.arguments.parameters.6.value
          - src:
              dependencyName: tess-approved-event
              dataKey: body.pull_request.head.repo.clone_url
            dest: spec.arguments.parameters.7.value
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: stage-resume-atlas-integration-
                namespace: agent-platform
                labels:
                  type: stage-resume
                  target-stage: waiting-atlas-integration
              spec:
                entrypoint: atlas-integration-gate
                serviceAccountName: argo-workflow
                ttlStrategy:
                  secondsAfterCompletion: 300
                  secondsAfterFailure: 3600
                podGC:
                  strategy: OnPodCompletion
                arguments:
                  parameters:
                    - name: pr-number
                      value: ""
                    - name: pr-url
                      value: ""
                    - name: repo-owner
                      value: ""
                    - name: repo-name
                      value: ""
                    - name: pr-labels
                      value: ""
                    - name: pr-title
                      value: ""
                    - name: pr-branch-ref
                      value: ""
                    - name: repo-clone-url
                      value: ""
                templates:
                  - name: atlas-integration-gate
                    script:
                      image: alpine/k8s:1.31.0
                      command: [bash]
                      env:
                        - name: GITHUB_APP_ID
                          valueFrom:
                            secretKeyRef:
                              name: github-app-5dlabs-atlas
                              key: app-id
                        - name: GITHUB_APP_PRIVATE_KEY
                          valueFrom:
                            secretKeyRef:
                              name: github-app-5dlabs-atlas
                              key: private-key
                      source: |-
                        #!/bin/bash
                        set -euo pipefail

                        ensure_jq() {
                          if command -v jq >/dev/null 2>&1; then
                            return 0
                          fi

                          if command -v apk >/dev/null 2>&1; then
                            apk add --no-cache jq >/dev/null 2>&1 && return 0
                          elif command -v apt-get >/dev/null 2>&1; then
                            apt-get update >/dev/null 2>&1 && apt-get install -y jq >/dev/null 2>&1 && rm -rf /var/lib/apt/lists/* && return 0
                          elif command -v microdnf >/dev/null 2>&1; then
                            microdnf -y install jq >/dev/null 2>&1 && return 0
                          fi

                          echo "❌ Failed to install jq"
                          return 1
                        }

                        ensure_argo_cli() {
                          if command -v argo >/dev/null 2>&1; then
                            ARGO_BIN=$(command -v argo)
                            return 0
                          fi

                          ARGO_VERSION="${ARGO_VERSION:-v3.7.1}"
                          ARGO_BIN="/tmp/argo"

                          if [ ! -x "$ARGO_BIN" ]; then
                            echo "Downloading argo CLI ($ARGO_VERSION)..."
                            if command -v wget >/dev/null 2>&1; then
                              wget -qO "$ARGO_BIN" "https://github.com/argoproj/argo-workflows/releases/download/$ARGO_VERSION/argo-linux-amd64"
                            elif command -v curl >/dev/null 2>&1; then
                              curl -sSL -o "$ARGO_BIN" "https://github.com/argoproj/argo-workflows/releases/download/$ARGO_VERSION/argo-linux-amd64"
                            else
                              echo "Neither wget nor curl is available"
                              return 1
                            fi
                            chmod +x "$ARGO_BIN"
                          fi
                        }

                        build_kubeconfig() {
                          local kubeconfig_path="/tmp/argo-kubeconfig"
                          if [ -f "$kubeconfig_path" ]; then
                            echo "$kubeconfig_path"
                            return 0
                          fi

                          local ca_cert="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                          local token_file="/var/run/secrets/kubernetes.io/serviceaccount/token"

                          if [ ! -f "$token_file" ]; then
                            echo "Service account token not found"
                            return 1
                          fi

                          local server="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"
                          local token
                          token=$(cat "$token_file")

                          {
                            echo "apiVersion: v1"
                            echo "kind: Config"
                            echo "clusters:"
                            echo "  - cluster:"
                            printf '      certificate-authority: %s\n' "$ca_cert"
                            printf '      server: %s\n' "$server"
                            echo "    name: in-cluster"
                            echo "contexts:"
                            echo "  - context:"
                            echo "      cluster: in-cluster"
                            echo "      namespace: agent-platform"
                            echo "      user: sensor-sa"
                            echo "    name: in-cluster"
                            echo "current-context: in-cluster"
                            echo "users:"
                            echo "  - name: sensor-sa"
                            echo "    user:"
                            printf '      token: %s\n' "$token"
                          } > "$kubeconfig_path"

                          echo "$kubeconfig_path"
                        }

                        resume_workflow() {
                          ensure_argo_cli || return 1
                          local kubeconfig_path
                          kubeconfig_path=$(build_kubeconfig) || return 1

                          if "$ARGO_BIN" --auth-mode kubeconfig --kubeconfig "$kubeconfig_path" \
                            -n agent-platform resume "$WORKFLOW_NAME" >/tmp/argo-resume.log 2>&1; then
                            echo "✅ Workflow resumed successfully"
                            return 0
                          fi

                          echo "⚠️ Failed to resume via argo CLI; output:"
                          cat /tmp/argo-resume.log
                          return 1
                        }

                        extract_task_id() {
                          echo "$1" | tr '[:upper:]' '[:lower:]' \
                            | grep -oE 'task[-_/ ]*([0-9]+)' | head -n1 \
                            | grep -oE '[0-9]+' || true
                        }

                        get_installation_token() {
                          if [ -z "${GITHUB_APP_ID:-}" ] || [ -z "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
                            return 1
                          fi

                          local temp_key="/tmp/github-app-key.pem"
                          printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$temp_key"
                          chmod 600 "$temp_key"

                          local now exp hdr pay sig jwt installation_id token=""
                          now=$(date +%s)
                          exp=$((now + 600))
                          hdr=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w0 2>/dev/null \
                            || printf '{"alg":"RS256","typ":"JWT"}' | base64)
                          hdr=$(echo -n "$hdr" | tr '+/' '-_' | tr -d '=')
                          pay=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$now" "$exp" "$GITHUB_APP_ID" \
                            | base64 -w0 2>/dev/null || printf '{"iat":%d,"exp":%d,"iss":"%s"}' \
                            "$now" "$exp" "$GITHUB_APP_ID" | base64)
                          pay=$(echo -n "$pay" | tr '+/' '-_' | tr -d '=')
                          sig=$(printf '%s.%s' "$hdr" "$pay" | openssl dgst -sha256 -sign "$temp_key" \
                            -binary | base64 -w0 2>/dev/null || openssl dgst -sha256 -sign "$temp_key" \
                            -binary | base64)
                          sig=$(echo -n "$sig" | tr '+/' '-_' | tr -d '=')
                          jwt="$hdr.$pay.$sig"

                          installation_id=$(curl -s -L \
                            -H "Authorization: Bearer $jwt" \
                            -H "Accept: application/vnd.github+json" \
                            "https://api.github.com/repos/${OWNER}/${REPO_NAME}/installation" | jq -r '.id')

                          if [ -z "$installation_id" ] || [ "$installation_id" = "null" ]; then
                            installation_id=$(curl -s -L \
                              -H "Authorization: Bearer $jwt" \
                              -H "Accept: application/vnd.github+json" \
                              "https://api.github.com/orgs/${OWNER}/installation" | jq -r '.id')
                          fi

                          if [ -n "$installation_id" ] && [ "$installation_id" != "null" ]; then
                            token=$(curl -s -X POST \
                              -H "Authorization: Bearer $jwt" \
                              -H "Accept: application/vnd.github+json" \
                              "https://api.github.com/app/installations/$installation_id/access_tokens" \
                              | jq -r '.token')
                          fi

                          rm -f "$temp_key"

                          if [ -n "$token" ] && [ "$token" != "null" ]; then
                            echo "$token"
                            return 0
                          fi

                          return 1
                        }

                        fetch_task_id_via_api() {
                          local response candidate title body
                          if [ -n "$INSTALLATION_TOKEN" ]; then
                            response=$(curl -s -L \
                              -H "Accept: application/vnd.github+json" \
                              -H "Authorization: Bearer $INSTALLATION_TOKEN" \
                              "$PR_API_URL")
                          else
                            response=$(curl -s -L \
                              -H "Accept: application/vnd.github+json" \
                              "$PR_API_URL")
                          fi

                          if [ -z "$response" ] || [ "$response" = "null" ]; then
                            echo ""
                            return 1
                          fi

                          while IFS= read -r label_name; do
                            candidate=$(extract_task_id "$label_name")
                            if [ -n "$candidate" ]; then
                              echo "$candidate"
                              return 0
                            fi
                          done < <(echo "$response" | jq -r '(.labels // [])[]?.name // ""')

                          title=$(echo "$response" | jq -r '.title // ""')
                          if [ -n "$title" ]; then
                            candidate=$(extract_task_id "$title")
                            if [ -n "$candidate" ]; then
                              echo "$candidate"
                              return 0
                            fi
                          fi

                          body=$(echo "$response" | jq -r '.body // ""')
                          if [ -n "$body" ]; then
                            candidate=$(extract_task_id "$body")
                            if [ -n "$candidate" ]; then
                              echo "$candidate"
                              return 0
                            fi
                          fi

                          echo ""
                          return 1
                        }

                        patch_workflow_stage() {
                          local target_stage="$1"
                          local workflow_json
                          workflow_json=$(kubectl get workflow "$WORKFLOW_NAME" \
                            -n agent-platform -o json 2>/dev/null)
                          if [ -z "$workflow_json" ]; then
                            echo "⚠️ Unable to fetch workflow for stage update"
                            return 1
                          fi

                          local resource_version
                          resource_version=$(echo "$workflow_json" \
                            | jq -r '.metadata.resourceVersion // ""')
                          local previous_stage
                          previous_stage=$(echo "$workflow_json" \
                            | jq -r '.metadata.labels["current-stage"] // ""')

                          local patch_json
                          patch_json=$(jq -n \
                            --arg rv "$resource_version" \
                            --arg stage "$target_stage" \
                            --arg prev "$previous_stage" \
                            --arg repo "$REPO_LABEL" \
                            --arg task "$TASK_ID" \
                            '{metadata:{resourceVersion:$rv,labels:{"current-stage":$stage,"previous-stage":$prev,"repository":$repo,"task-id":$task}}}')

                          kubectl patch workflow "$WORKFLOW_NAME" -n agent-platform \
                            --type='merge' -p "$patch_json"
                        }

                        ensure_integration_coderun() {
                          local existing_json
                          existing_json=$(kubectl get coderuns -n agent-platform \
                            -l agent=atlas,role=integration,pr-number="$PR_NUMBER" \
                            -o json 2>/dev/null || echo '{"items":[]}')

                          local running_name
                          running_name=$(echo "$existing_json" | jq -r '.items[] | select(
                            (.status.phase == "Running") or
                            (.status.phase == "Pending") or
                            (.status == null)
                          ) | .metadata.name' | head -n1)

                          if [ -n "$running_name" ]; then
                            echo "$running_name"
                            return 0
                          fi

                          cat <<EOF_MANIFEST | kubectl create -f -
                          apiVersion: agents.platform/v1
                          kind: CodeRun
                          metadata:
                            generateName: coderun-atlas-integration-
                            namespace: agent-platform
                            labels:
                              agent: atlas
                              role: integration
                              stage: integration
                              pr-number: "$PR_NUMBER"
                              repository: "$REPO_LABEL"
                              workflow: "$WORKFLOW_NAME"
                          spec:
                            taskId: "$TASK_ID"
                            service: "atlas"
                            githubApp: "5DLabs-Atlas"
                            model: "claude-sonnet-4-5-20250929"
                            repositoryUrl: "$REPO_URL"
                            docsRepositoryUrl: "$REPO_URL"
                            docsProjectDirectory: "docs"
                            workingDirectory: "."
                            continueSession: false
                            overwriteMemory: false
                            env:
                              - name: PR_NUMBER
                                value: "$PR_NUMBER"
                              - name: PR_URL
                                value: "$PR_URL"
                              - name: WORKFLOW_NAME
                                value: "$WORKFLOW_NAME"
                              - name: TASK_ID
                                value: "$TASK_ID"
                              - name: REPOSITORY_SLUG
                                value: "$REPO_FULL"
                              - name: REPOSITORY_OWNER
                                value: "$OWNER"
                              - name: REPOSITORY_NAME
                                value: "$REPO_NAME"
                              - name: ATLAS_MODE
                                value: "integration-gate"
                              - name: ATLAS_MAX_CYCLES
                                value: "120"
                              - name: ATLAS_POLL_INTERVAL
                                value: "30"
                          EOF_MANIFEST
                        }

                        wait_for_coderun() {
                          local name="$1"
                          while true; do
                            local status_json
                            status_json=$(kubectl get coderun "$name" -n agent-platform -o json 2>/dev/null || echo "")
                            if [ -z "$status_json" ]; then
                              echo "⚠️ Unable to fetch CodeRun $name"
                              sleep 20
                              continue
                            fi

                            local phase
                            phase=$(echo "$status_json" | jq -r '.status.phase // ""')
                            case "$phase" in
                              Succeeded)
                                echo "✅ Atlas integration CodeRun $name succeeded"
                                return 0
                                ;;
                              Failed)
                                local message
                                message=$(echo "$status_json" | jq -r '.status.message // "Atlas integration failed"')
                                echo "❌ CodeRun $name failed: $message"
                                return 1
                                ;;
                              Pending|"")
                                echo "⏳ CodeRun $name pending..."
                                ;;
                              Running)
                                echo "⏳ CodeRun $name running..."
                                ;;
                              *)
                                echo "⏳ CodeRun $name phase: $phase"
                                ;;
                            esac
                            sleep 30
                          done
                        }

                        ensure_jq

                        PR_NUMBER="{{workflow.parameters.pr-number}}"
                        PR_URL="{{workflow.parameters.pr-url}}"
                        OWNER="{{workflow.parameters.repo-owner}}"
                        REPO_NAME="{{workflow.parameters.repo-name}}"
                        REPO_FULL="$OWNER/$REPO_NAME"
                        REPO_LABEL=$(echo "$REPO_FULL" | tr '/' '-')
                        PR_TITLE="{{workflow.parameters.pr-title}}"
                        BRANCH_REF="{{workflow.parameters.pr-branch-ref}}"
                        TASK_LABELS_JSON='{{workflow.parameters.pr-labels}}'
                        REPO_URL="{{workflow.parameters.repo-clone-url}}"
                        if [ -z "$REPO_URL" ] || [ "$REPO_URL" = "null" ]; then
                          REPO_URL="https://github.com/${REPO_FULL}"
                        fi
                        PR_API_URL="https://api.github.com/repos/${REPO_FULL}/issues/${PR_NUMBER}"

                        echo "=== Atlas Integration Gate ==="
                        echo "Repository: $REPO_FULL"
                        echo "PR #: $PR_NUMBER"
                        echo "Branch: $BRANCH_REF"

                        TASK_ID=""
                        if [ -n "$BRANCH_REF" ]; then
                          TASK_ID=$(extract_task_id "$BRANCH_REF")
                        fi
                        if [ -z "$TASK_ID" ] && [ -n "$TASK_LABELS_JSON" ] && [ "$TASK_LABELS_JSON" != "null" ]; then
                          TASK_ID=$(echo "$TASK_LABELS_JSON" | jq -er '.[]? | .name? | ascii_downcase | select(test("task-[0-9]+")) | capture("task-(?<id>[0-9]+)") | .id' 2>/dev/null || echo "")
                        fi

                        if [ -z "$TASK_ID" ] && [ -n "$PR_TITLE" ] && [ "$PR_TITLE" != "null" ]; then
                          TASK_ID=$(extract_task_id "$PR_TITLE")
                        fi

                        INSTALLATION_TOKEN=$(get_installation_token || true)
                        if [ -z "$TASK_ID" ]; then
                          TASK_ID=$(fetch_task_id_via_api || true)
                        fi

                        if [ -z "$TASK_ID" ]; then
                          echo "ℹ️ Unable to determine task correlation for PR #$PR_NUMBER"
                          exit 0
                        fi

                        echo "Task ID: $TASK_ID"

                        WORKFLOW_NAME=$(kubectl get workflows -n agent-platform \
                          -l task-id=$TASK_ID,workflow-type=play-orchestration,repository=$REPO_LABEL \
                          -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

                        if [ -z "$WORKFLOW_NAME" ]; then
                          echo "ℹ️ No workflow found for task-id=$TASK_ID and repo=$REPO_LABEL"
                          exit 0
                        fi

                        echo "Workflow: $WORKFLOW_NAME"

                        WORKFLOW_JSON=$(kubectl get workflow "$WORKFLOW_NAME" -n agent-platform -o json 2>/dev/null || echo "")
                        if [ -z "$WORKFLOW_JSON" ]; then
                          echo "⚠️ Unable to fetch workflow state"
                          exit 0
                        fi

                        CURRENT_STAGE=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.labels["current-stage"] // ""')
                        SUSPEND_PHASE=$(echo "$WORKFLOW_JSON" | jq -r '(.status.nodes // {}) | to_entries[]? | select(.value.displayName == "wait-for-atlas-integration") | .value.phase' 2>/dev/null | head -n1)

                        if [ "$CURRENT_STAGE" != "waiting-atlas-integration" ] || [ "$SUSPEND_PHASE" != "Running" ]; then
                          echo "Workflow not ready (stage=$CURRENT_STAGE, suspend=$SUSPEND_PHASE)"
                          exit 0
                        fi

                        patch_workflow_stage "atlas-integration-in-progress" || true

                        CODERUN_NAME=$(ensure_integration_coderun || echo "")
                        if [ -z "$CODERUN_NAME" ]; then
                          echo "❌ Failed to create Atlas integration CodeRun"
                          patch_workflow_stage "waiting-atlas-integration" || true
                          exit 1
                        fi

                        if wait_for_coderun "$CODERUN_NAME"; then
                          if resume_workflow; then
                            echo "✅ Atlas integration completed and workflow resumed"
                            exit 0
                          fi
                          echo "⚠️ Atlas succeeded but resume failed"
                          exit 0
                        fi

                        echo "ℹ️ Atlas integration failed, reverting stage"
                        patch_workflow_stage "waiting-atlas-integration" || true
                        exit 0
