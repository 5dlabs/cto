---
# Stage-Aware Workflow Resume Sensor - PR Created
# Targets workflows based on current-stage label for precise event correlation
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: stage-aware-pr-created
  namespace: automation
  labels:
    task: "7"
    type: stage-management
    component: atomic-transitions
spec:
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    # PR Created Event - Resume workflows waiting for this
    - name: pr-created-event
      eventSourceName: github
      eventName: org
      filters:
        data:
          - path: body.X-GitHub-Event
            type: string
            value: ["pull_request"]
          - path: body.action
            type: string
            value: ["opened"]

  triggers:
    # Resume workflows at waiting-pr-created stage
    - template:
        name: resume-waiting-pr-created
        conditions: "pr-created-event"
        parameters:
          - src:
              dependencyName: pr-created-event
              dataKey: body.pull_request.number
            dest: spec.arguments.parameters.0.value
          - src:
              dependencyName: pr-created-event
              dataKey: body.pull_request.html_url
            dest: spec.arguments.parameters.1.value
          - src:
              dependencyName: pr-created-event
              dataKey: body.pull_request.head.ref
            dest: spec.arguments.parameters.2.value
          - src:
              dependencyName: pr-created-event
              dataKey: body.pull_request.title
            dest: spec.arguments.parameters.3.value
          - src:
              dependencyName: pr-created-event
              dataTemplate: "{{ .Input.body.pull_request.labels | toJson }}"
            dest: spec.arguments.parameters.4.value
          - src:
              dependencyName: pr-created-event
              dataKey: body.repository.full_name
            dest: spec.arguments.parameters.5.value
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: stage-resume-pr-created-
                namespace: cto
                labels:
                  type: stage-resume
                  target-stage: waiting-pr-created
              spec:
                entrypoint: resume-workflow
                serviceAccountName: argo-workflow
                # Auto-cleanup after completion
                ttlStrategy:
                  secondsAfterCompletion: 300  # 5 minutes
                  secondsAfterFailure: 3600    # 1 hour
                podGC:
                  strategy: OnPodCompletion
                arguments:
                  parameters:
                    - name: pr-number
                      value: ""
                    - name: pr-url
                      value: ""
                    - name: pr-branch
                      value: ""
                    - name: pr-title
                      value: ""
                    - name: pr-labels
                      value: "[]"
                    - name: repo-full
                      value: ""
                templates:
                  - name: resume-workflow
                    script:
                      image: alpine/k8s:1.31.0
                      command: [bash]
                      source: |
                        #!/bin/bash
                        set -e

                        # Ensure jq is available (some downstream commands/scripts rely on it)
                        if ! command -v jq >/dev/null 2>&1; then
                          if command -v apk >/dev/null 2>&1; then
                            apk add --no-cache jq
                          elif command -v apt-get >/dev/null 2>&1; then
                            apt-get update && apt-get install -y jq && rm -rf /var/lib/apt/lists/*
                          elif command -v microdnf >/dev/null 2>&1; then
                            microdnf -y install jq || true
                          else
                            echo "jq not found and no supported package manager available"
                          fi
                        fi

                        update_workflow_pr_metadata() {
                          local workflow_name="$1"
                          local pr_url="$2"
                          local pr_number="$3"

                          WORKFLOW_JSON=$(kubectl get workflow "$workflow_name" -n cto -o json 2>/dev/null)
                          if [ -z "$WORKFLOW_JSON" ]; then
                            echo "ERROR: Unable to fetch workflow $workflow_name for PR metadata update"
                            return 1
                          fi

                          set +e
                          PATCH_JSON=$(echo "$WORKFLOW_JSON" | jq --arg prUrl "$pr_url" --arg prNumber "$pr_number" '
                            .spec.arguments.parameters = (
                              ( .spec.arguments.parameters // [] )
                              | (if (map(.name) | index("pr-url")) != null
                                   then map(if .name == "pr-url" then (.value = $prUrl) else . end)
                                   else . + [{"name":"pr-url","value":$prUrl}]
                                 end)
                              | (if (map(.name) | index("pr-number")) != null
                                   then map(if .name == "pr-number" then (.value = $prNumber) else . end)
                                   else . + [{"name":"pr-number","value":$prNumber}]
                                 end)
                            )
                            | {spec:{arguments:{parameters:.spec.arguments.parameters}}}
                          ')
                          JQ_EXIT=$?
                          set -e

                          if [ $JQ_EXIT -ne 0 ]; then
                            echo "ERROR: jq failed while constructing PR metadata patch for $workflow_name"
                            return 1
                          fi

                          if [ -z "$PATCH_JSON" ]; then
                            echo "ERROR: Failed to construct PR metadata patch payload for $workflow_name"
                            return 1
                          fi

                          kubectl patch workflow "$workflow_name" -n cto --type='merge' -p "$PATCH_JSON"
                        }

                        # Extract workflow parameters (populated by Argo Events sensor)
                        PR_NUMBER='{{workflow.parameters.pr-number}}'
                        PR_URL='{{workflow.parameters.pr-url}}'
                        PR_BRANCH='{{workflow.parameters.pr-branch}}'
                        PR_TITLE='{{workflow.parameters.pr-title}}'
                        PR_LABELS='{{workflow.parameters.pr-labels}}'
                        REPO_FULL='{{workflow.parameters.repo-full}}'

                        # Validate required parameters are present
                        if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "null" ] || [ "$PR_NUMBER" = "" ]; then
                          echo "ℹ️ PR number not provided - webhook data may not have been interpolated"
                          echo "   This is expected if event source data is malformed or missing"
                          exit 0
                        fi

                        echo "=== Stage-Aware Workflow Resume ==="
                        echo "Target Stage: waiting-pr-created"
                        echo "PR Number: $PR_NUMBER"

                        extract_task_id() {
                          echo "$1" | tr '[:upper:]' '[:lower:]' | grep -oE 'task[-_/ ]*([0-9]+)' | head -n1 | grep -oE '[0-9]+' || true
                        }

                        TASK_ID=""
                        if [ "$PR_LABELS" != "null" ] && [ -n "$PR_LABELS" ] && [ "$PR_LABELS" != "[]" ]; then
                          TASK_ID=$(echo "$PR_LABELS" |
                            jq -er '.[] | (.name // "") | ascii_downcase | capture("task[-_/ ]*(?<id>[0-9]+)") | .id' 2>/dev/null | head -1 || true)
                        fi

                        if [ -z "$TASK_ID" ] && [ -n "$PR_BRANCH" ] && [ "$PR_BRANCH" != "null" ]; then
                          TASK_ID=$(extract_task_id "$PR_BRANCH")
                        fi

                        if [ -z "$TASK_ID" ] && [ -n "$PR_TITLE" ] && [ "$PR_TITLE" != "null" ]; then
                          TASK_ID=$(extract_task_id "$PR_TITLE")
                        fi

                        if [ -z "$TASK_ID" ]; then
                          echo "ℹ️ No task ID found in PR data (not a play workflow PR)"
                          exit 0
                        fi

                        echo "Task ID: $TASK_ID"

                        # Extract repository for precise correlation (critical for parallel batch execution)
                        REPO_LABEL=$(echo "$REPO_FULL" | tr '/' '-')
                        echo "Repository: $REPO_FULL (label: $REPO_LABEL)"

                        # Find workflow by labels (include repository for precise matching in parallel scenarios)
                        WORKFLOW_NAME=$(kubectl get workflows -n cto \
                          -l task-id=$TASK_ID,workflow-type=play-orchestration,repository=$REPO_LABEL \
                          -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

                        if [ -z "$WORKFLOW_NAME" ]; then
                          echo "ℹ️ No workflow found for task-id=$TASK_ID and repository=$REPO_LABEL"
                          exit 0
                        fi

                        echo "Found workflow: $WORKFLOW_NAME"
                        echo "Checking workflow stage..."

                        # Check if workflow exists and is at correct stage
                        CURRENT_STAGE=$(kubectl get workflow $WORKFLOW_NAME \
                          -n cto \
                          -o jsonpath='{.metadata.labels.current-stage}' \
                          2>/dev/null || echo "")

                        WORKFLOW_PHASE=$(kubectl get workflow $WORKFLOW_NAME \
                          -n cto \
                          -o jsonpath='{.status.phase}' \
                          2>/dev/null || echo "")

                        echo "Workflow stage: $CURRENT_STAGE, phase: $WORKFLOW_PHASE"

                        # NOTE: wait-for-pr-created suspend node was removed
                        # Workflows now poll for PR in implementation-cycle
                        # We just need to update PR metadata - the workflow will detect it
                        if [ "$CURRENT_STAGE" = "implementation-in-progress" ] && [ "$WORKFLOW_PHASE" = "Running" ]; then
                          echo "✅ Workflow is in implementation stage - updating PR metadata..."

                          # Update workflow parameters with PR details
                          if ! update_workflow_pr_metadata "$WORKFLOW_NAME" \
                              "$PR_URL" \
                              "$PR_NUMBER"; then
                            echo "⚠️ Failed to update PR metadata on $WORKFLOW_NAME"
                            echo "   Workflow will continue polling GitHub API for PR"
                          else
                            echo "✅ PR metadata updated - workflow proceeds to quality"
                          fi
                        elif [ "$CURRENT_STAGE" = "quality-in-progress" ] || \
                             [ "$CURRENT_STAGE" = "security-in-progress" ] || \
                             [ "$CURRENT_STAGE" = "testing-in-progress" ]; then
                          echo "ℹ️ Workflow past implementation (stage: $CURRENT_STAGE)"
                          echo "   No action needed"
                        else
                          echo "ℹ️ Workflow not in expected stage (current: $CURRENT_STAGE, phase: $WORKFLOW_PHASE)"
                          echo "   Skipping to prevent incorrect stage progression"
                        fi
      retryStrategy:
        steps: 3
        duration: "10s"
        factor: 2
