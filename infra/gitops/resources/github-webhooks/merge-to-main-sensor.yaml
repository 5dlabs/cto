---
# Sensor for PR Merged to Main - Complete task and start next
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: play-workflow-pr-merged
  namespace: argo
spec:
  replicas: 1
  deploymentStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: github-pr-merged
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for pull_request closed events with merged=true
          - path: headers.X-Github-Event
            type: string
            value: ["pull_request"]
          - path: body.action
            type: string
            value: ["closed"]
          - path: body.pull_request.merged
            type: string
            value: ["true"]
          - path: body.pull_request.base.ref
            type: string
            value: ["main"]
      # NOTE: Argo Events has built-in deduplication that caches event IDs
      # for 5 minutes to prevent duplicate processing automatically
  triggers:
    - template:
        name: task-completion-handler
        conditions: "github-pr-merged"
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: task-complete-
                namespace: agent-platform
                labels:
                  type: task-completion
                  trigger: merge-to-main
              spec:
                entrypoint: handle-task-completion
                serviceAccountName: argo-workflow
                activeDeadlineSeconds: 7200  # 2 hour timeout for finding suspend node
                arguments:
                  parameters:
                    - name: pr-title
                      # Will be populated from event
                    - name: pr-number
                      # Will be populated from event
                    - name: pr-url
                      # Will be populated from event
                    - name: merge-sha
                      # Will be populated from event
                    - name: merged-by
                      # Will be populated from event
                templates:
                  - name: handle-task-completion
                    script:
                      image: alpine/k8s:1.31.0
                      command: [bash]
                      env:
                        - name: GITHUB_APP_ID
                          valueFrom:
                            secretKeyRef:
                              name: github-app-5dlabs-morgan
                              key: app-id
                        - name: GITHUB_APP_PRIVATE_KEY
                          valueFrom:
                            secretKeyRef:
                              name: github-app-5dlabs-morgan
                              key: private-key
                      source: |
                        #!/bin/bash
                        set -e

                                                # Install required tools if not present
                        MISSING_TOOLS=""
                        if ! command -v git >/dev/null 2>&1; then
                          MISSING_TOOLS="$MISSING_TOOLS git"
                        fi
                        if ! command -v curl >/dev/null 2>&1; then
                          MISSING_TOOLS="$MISSING_TOOLS curl"
                        fi
                        if ! command -v jq >/dev/null 2>&1; then
                          MISSING_TOOLS="$MISSING_TOOLS jq"
                        fi
                        if ! command -v openssl >/dev/null 2>&1; then
                          MISSING_TOOLS="$MISSING_TOOLS openssl"
                        fi

                        if [ -n "$MISSING_TOOLS" ]; then
                          echo "Installing missing tools:$MISSING_TOOLS"
                          apk add --no-cache $MISSING_TOOLS
                        else
                          echo "All required tools are already available"
                        fi

                        # =============================================================================
                        # GITHUB APP AUTHENTICATION
                        # =============================================================================
                        echo "🔐 Authenticating with Morgan GitHub App..."

                        if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
                            # Create temporary private key file
                            TEMP_KEY_FILE="/tmp/github-app-key.pem"
                            printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
                            chmod 600 "$TEMP_KEY_FILE"

                            # Generate JWT token for GitHub App
                            JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | \
                              base64 -w 0 | tr '+/' '-_' | tr -d '=')
                            NOW=$(date +%s)
                            EXP=$((NOW + 600))
                            JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | \
                              base64 -w 0 | tr '+/' '-_' | tr -d '=')
                            JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | \
                              openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | \
                              base64 -w 0 | tr '+/' '-_' | tr -d '=')
                            JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

                            # Get installation access token for organization
                            INSTALLATIONS_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
                                -H "Accept: application/vnd.github.v3+json" \
                                "https://api.github.com/app/installations")

                            INSTALLATION_ID=$(echo "$INSTALLATIONS_RESPONSE" | jq -r '.[0].id')

                            if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
                                echo "❌ Failed to get installation ID"
                                echo "Response: $INSTALLATIONS_RESPONSE"
                                rm -f "$TEMP_KEY_FILE"
                                exit 1
                            fi

                            TOKEN_RESPONSE=$(curl -s -X POST \
                                -H "Authorization: Bearer $JWT_TOKEN" \
                                -H "Accept: application/vnd.github.v3+json" \
                                "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

                            GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

                            if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
                                echo "❌ Failed to get installation access token"
                                echo "Response: $TOKEN_RESPONSE"
                                rm -f "$TEMP_KEY_FILE"
                                exit 1
                            fi

                            # Clean up temporary key file
                            rm -f "$TEMP_KEY_FILE"

                            # Export the token for git to use
                            export GITHUB_TOKEN

                            # Configure git to use the token
                            git config --global credential.helper store
                            echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials

                            echo "✅ Morgan GitHub App authenticated successfully"

                        else
                            echo "❌ GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
                            exit 1
                        fi

                        # Configure git
                        git config --global user.name "Task Orchestrator (Morgan)"
                        git config --global user.email "5DLabs-Morgan[bot]@users.noreply.github.com"

                        echo "════════════════════════════════════════════════════════════════"
                        echo "║                 TASK COMPLETION HANDLER                      ║"
                        echo "════════════════════════════════════════════════════════════════"
                        echo "📋 PR Title: {{workflow.parameters.pr-title}}"
                        echo "🔢 PR Number: {{workflow.parameters.pr-number}}"
                        echo "🔗 PR URL: {{workflow.parameters.pr-url}}"
                        echo "📦 Merge SHA: {{workflow.parameters.merge-sha}}"
                        echo "👤 Merged by: {{workflow.parameters.merged-by}}"
                        echo "════════════════════════════════════════════════════════════════"

                        # IDEMPOTENCY CHECK: Prevent duplicate processing
                        PR_NUMBER="{{workflow.parameters.pr-number}}"
                        CURRENT_WORKFLOW_NAME="{{workflow.name}}"

                        # Check if ANY workflow exists for this PR (not just Succeeded)
                        # This prevents race conditions where duplicate workflows are created
                        # before the first one reaches Succeeded status
                        # We need to exclude the current workflow from this check
                        EXISTING_WORKFLOWS=$(kubectl get workflows -n agent-platform \
                          -l type=task-completion,pr-number=$PR_NUMBER \
                          -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")

                        for workflow in $EXISTING_WORKFLOWS; do
                          if [ "$workflow" != "$CURRENT_WORKFLOW_NAME" ]; then
                            echo "⚠️ PR #$PR_NUMBER already being processed by workflow: $workflow"
                            echo "Current workflow: $CURRENT_WORKFLOW_NAME"
                            echo "Skipping duplicate processing"
                            exit 0
                          fi
                        done

                        echo "✅ No other workflows processing PR #$PR_NUMBER, continuing..."

                        # Extract task ID from PR title (e.g., "Task 1: Initialize..." -> "1")
                        PR_TITLE="{{workflow.parameters.pr-title}}"
                        TASK_ID=$(echo "$PR_TITLE" | grep -oE '[Tt]ask[- ]?([0-9]+)' | sed -E 's/[Tt]ask[- ]?//')

                        if [ -z "$TASK_ID" ]; then
                          echo "⚠️ No task ID found in PR title, checking PR body and branch..."
                          # Could also check branch name or PR body for task ID
                          exit 0
                        fi

                        echo "✅ Task $TASK_ID completed via merge to main"

                        # ============================================================
                        # STEP 1: Move completed task to .completed folder
                        # ============================================================
                        echo ""
                        echo "📝 Moving completed task to .completed folder..."

                        # Extract repository from PR URL (e.g., "https://github.com/5dlabs/cto/pull/123" -> "5dlabs/cto")
                        PR_URL="{{workflow.parameters.pr-url}}"
                        REPO_PATH=$(echo "$PR_URL" | sed -E 's|https://github.com/([^/]+/[^/]+)/pull/.*|\1|')

                        if [ -z "$REPO_PATH" ]; then
                          echo "⚠️ Could not extract repository from PR URL, skipping task move"
                          exit 0
                        fi

                        echo "📚 Repository: $REPO_PATH"

                        # Clone the repo to move the task file
                        PROGRESS_REPO="/tmp/task-move-$$"
                        CLONE_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO_PATH}.git"
                        if ! git clone --depth 1 "$CLONE_URL" "$PROGRESS_REPO" 2>/dev/null; then
                          echo "⚠️ Failed to clone repo, continuing anyway..."
                        else
                          cd "$PROGRESS_REPO"

                          # Try multiple possible task directory structures
                          TASK_MOVED=false
                          TASK_DIRS=(
                            "docs/.taskmaster/docs/task-${TASK_ID}"
                            "task-${TASK_ID}"
                            ".taskmaster/docs/task-${TASK_ID}"
                            "task/task-${TASK_ID}"
                          )

                          COMPLETED_DIRS=(
                            "docs/.taskmaster/docs/.completed"
                            ".taskmaster/docs/.completed"
                            ".completed"
                            "task/.completed"
                          )

                          for TASK_DIR in "${TASK_DIRS[@]}"; do
                            if [ -d "$TASK_DIR" ]; then
                              echo "📁 Found task directory: $TASK_DIR"

                              # Determine corresponding completed directory
                              if [[ "$TASK_DIR" == docs/.taskmaster/docs/* ]]; then
                                COMPLETED_DIR="docs/.taskmaster/docs/.completed"
                              elif [[ "$TASK_DIR" == .taskmaster/docs/* ]]; then
                                COMPLETED_DIR=".taskmaster/docs/.completed"
                              elif [[ "$TASK_DIR" == task/* ]]; then
                                COMPLETED_DIR="task/.completed"
                              else
                                COMPLETED_DIR=".completed"
                              fi

                              # Create completed directory if it doesn't exist
                              mkdir -p "$COMPLETED_DIR"

                              # Move the task directory
                              if mv "$TASK_DIR" "$COMPLETED_DIR/task-${TASK_ID}"; then
                                echo "✅ Moved $TASK_DIR to $COMPLETED_DIR/"
                                TASK_MOVED=true

                                # Commit and push the change
                                git config user.name "Task Orchestrator (Morgan)"
                                git config user.email "5DLabs-Morgan[bot]@users.noreply.github.com"
                                git add -A
                                git commit -m "chore: move task-${TASK_ID} to .completed/" || \
                                  echo "No changes to commit"

                                if ! git push origin main 2>/dev/null; then
                                  echo "⚠️ Failed to push task move, continuing anyway..."
                                else
                                  echo "✅ Task $TASK_ID moved to .completed/ folder"
                                fi
                                break
                              else
                                echo "⚠️ Failed to move $TASK_DIR"
                              fi
                            fi
                          done

                          if [ "$TASK_MOVED" = false ]; then
                            echo "ℹ️ No task directory found for task-${TASK_ID}, may already be moved"
                          fi

                          # Clean up
                          cd /
                          rm -rf "$PROGRESS_REPO"
                        fi

                        # ============================================================
                        # STEP 2: Complete current orchestration workflow
                        # ============================================================
                        echo ""
                        echo "🔍 Looking for orchestration workflow for task $TASK_ID..."

                        # LESSON LEARNED: Race condition - workflow might still be transitioning
                        # Try multiple times with delay
                        MAX_ATTEMPTS=12  # 1 minute total
                        ATTEMPT=1
                        CURRENT_WORKFLOW=""

                        while [ $ATTEMPT -le $MAX_ATTEMPTS ] && [ -z "$CURRENT_WORKFLOW" ]; do
                          echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Looking for workflow..."

                          # Don't filter by Running status - workflow might be suspended
                          CURRENT_WORKFLOW=$(kubectl get workflows -n agent-platform \
                            -l task-id=$TASK_ID,workflow-type=play-orchestration \
                            -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

                          if [ -z "$CURRENT_WORKFLOW" ] && [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                            echo "Workflow not found yet, waiting 5 seconds..."
                            sleep 5
                          fi
                          ATTEMPT=$((ATTEMPT + 1))
                        done

                        if [ -n "$CURRENT_WORKFLOW" ]; then
                          echo "Found workflow: $CURRENT_WORKFLOW"

                          # LESSON LEARNED: Check workflow phase to understand state
                          WORKFLOW_PHASE=$(kubectl get workflow $CURRENT_WORKFLOW -n agent-platform \
                            -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
                          echo "Workflow phase: $WORKFLOW_PHASE"

                          # LESSON LEARNED: Webhook might arrive before suspend node is created
                          # Wait up to 60 seconds for the suspend node to appear (Tess might still be running)
                          MAX_WAIT=60
                          WAIT_TIME=0
                          NODE_ID=""

                          echo "Looking for wait-merge-to-main suspend node..."
                          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
                            NODE_ID=$(kubectl get workflow $CURRENT_WORKFLOW -n agent-platform -o json | \
                              jq -r '.status.nodes | to_entries | .[] |
                              select(.value.displayName == "wait-merge-to-main" and .value.type == "Suspend") |
                              .key')

                            if [ -n "$NODE_ID" ]; then
                              echo "Found suspend node after ${WAIT_TIME}s: $NODE_ID"
                              break
                            fi

                            if [ $WAIT_TIME -eq 0 ]; then
                              echo "Suspend node not found yet, waiting for Tess to complete..."
                            else
                              echo "Still waiting... (${WAIT_TIME}s / ${MAX_WAIT}s)"
                            fi

                            sleep 5
                            WAIT_TIME=$((WAIT_TIME + 5))
                          done

                          if [ -n "$NODE_ID" ]; then

                            # LESSON LEARNED: Check node phase before trying to resume
                            NODE_PHASE=$(kubectl get workflow $CURRENT_WORKFLOW -n agent-platform -o json | \
                              jq -r ".status.nodes.\"$NODE_ID\".phase")
                            echo "Node phase: $NODE_PHASE"

                            if [ "$NODE_PHASE" = "Running" ]; then
                              echo "Resuming suspend node..."
                              kubectl patch workflow $CURRENT_WORKFLOW -n agent-platform \
                                --type='merge' -p "{\"status\":{\"nodes\":{\"$NODE_ID\":{\"phase\":\"Succeeded\"}}}}"
                              echo "✅ Task $TASK_ID workflow completed successfully"
                            else
                              echo "⚠️ Node already in phase: $NODE_PHASE"
                            fi
                          else
                            echo "⚠️ No wait-merge-to-main suspend node found after waiting ${MAX_WAIT}s"
                            echo "Tess might still be running or workflow might be in unexpected state"
                            # Try legacy wait-pr-approved node
                            NODE_ID=$(kubectl get workflow $CURRENT_WORKFLOW -n agent-platform -o json | \
                              jq -r '.status.nodes | to_entries | .[] |
                              select(.value.displayName == "wait-pr-approved" and .value.type == "Suspend") |
                              .key')
                            if [ -n "$NODE_ID" ]; then
                              NODE_PHASE=$(kubectl get workflow $CURRENT_WORKFLOW -n agent-platform -o json | \
                                jq -r ".status.nodes.\"$NODE_ID\".phase")
                              if [ "$NODE_PHASE" = "Running" ]; then
                                echo "Found legacy wait-pr-approved node, resuming..."
                                kubectl patch workflow $CURRENT_WORKFLOW -n agent-platform \
                                  --type='merge' -p "{\"status\":{\"nodes\":{\"$NODE_ID\":{\"phase\":\"Succeeded\"}}}}"
                                echo "✅ Task $TASK_ID workflow completed (legacy)"
                              else
                                echo "⚠️ Legacy node already in phase: $NODE_PHASE"
                              fi
                            fi
                          fi
                        else
                          echo "ℹ️ No orchestration workflow found for task $TASK_ID"
                        fi

                        # ============================================================
                        # STEP 3: Start next task in queue
                        # ============================================================

                        # Find the next sequential task
                        echo "🔍 Looking for next sequential task..."

                        # Calculate next task ID (simple increment)
                        NEXT_TASK_ID=$((TASK_ID + 1))

                        # Clone repo to verify the next task exists
                        TASK_CHECK_REPO="/tmp/task-check-$$"
                        if ! git clone --depth 1 "$CLONE_URL" "$TASK_CHECK_REPO" 2>/dev/null; then
                          echo "⚠️ Failed to clone repo for task verification"
                          echo "🚀 Proceeding with calculated next task: $NEXT_TASK_ID"
                        else
                          cd "$TASK_CHECK_REPO"

                          # Check if the next sequential task exists and is not completed
                          TASK_PATHS=(
                            "docs/.taskmaster/docs/task-${NEXT_TASK_ID}"
                            "task-${NEXT_TASK_ID}"
                            ".taskmaster/docs/task-${NEXT_TASK_ID}"
                            "task/task-${NEXT_TASK_ID}"
                          )

                          TASK_FOUND=false
                          for TASK_PATH in "${TASK_PATHS[@]}"; do
                            if [ -d "$TASK_PATH" ]; then
                              echo "✅ Found next task at: $TASK_PATH"
                              TASK_FOUND=true
                              break
                            fi
                          done

                          # Check if already completed
                          COMPLETED_PATHS=(
                            "docs/.taskmaster/docs/.completed/task-${NEXT_TASK_ID}"
                            ".taskmaster/docs/.completed/task-${NEXT_TASK_ID}"
                            ".completed/task-${NEXT_TASK_ID}"
                          )

                          for COMPLETED_PATH in "${COMPLETED_PATHS[@]}"; do
                            if [ -d "$COMPLETED_PATH" ]; then
                              echo "⚠️ Task $NEXT_TASK_ID already completed"
                              TASK_FOUND=false
                              break
                            fi
                          done

                          cd /
                          rm -rf "$TASK_CHECK_REPO"

                          if [ "$TASK_FOUND" = false ]; then
                            echo "🎉 No more tasks found or task $NEXT_TASK_ID already completed!"
                            exit 0
                          fi
                        fi

                        echo ""
                        echo "🚀 Preparing to start Task $NEXT_TASK_ID..."

                        # Check if we've reached the end of tasks
                        MAX_TASKS=29  # Configure this based on your task set
                        if [ $NEXT_TASK_ID -gt $MAX_TASKS ]; then
                          echo "🎉 All tasks completed! No more tasks in queue."
                          exit 0
                        fi

                        # Check if next task is already running or recently completed (avoid duplicates)
                        EXISTING_NEXT=$(kubectl get workflows -n agent-platform \
                          -l task-id=$NEXT_TASK_ID,workflow-type=play-orchestration \
                          -o jsonpath='{range .items[*]}{.metadata.name}{" "}{.status.phase}{"\n"}{end}' 2>/dev/null)

                        if [ -n "$EXISTING_NEXT" ]; then
                          echo "Existing workflows for Task $NEXT_TASK_ID:"
                          echo "$EXISTING_NEXT"

                          # Check if any are still running or succeeded recently
                          SKIP_CREATION=false
                          while IFS=' ' read -r workflow_name phase; do
                            if [ -n "$workflow_name" ]; then
                              if [ "$phase" = "Running" ] || [ "$phase" = "Pending" ]; then
                                echo "⚠️ Task $NEXT_TASK_ID is already active: $workflow_name ($phase)"
                                SKIP_CREATION=true
                                break
                              elif [ "$phase" = "Succeeded" ]; then
                                # Check if completed within last 5 minutes
                                COMPLETION_TIME=$(kubectl get workflow $workflow_name -n agent-platform \
                                  -o jsonpath='{.status.finishedAt}' 2>/dev/null || echo "")
                                if [ -n "$COMPLETION_TIME" ]; then
                                  COMPLETION_EPOCH=$(date -d "$COMPLETION_TIME" +%s 2>/dev/null || echo "0")
                                  CURRENT_EPOCH=$(date +%s)
                                  AGE_SECONDS=$((CURRENT_EPOCH - COMPLETION_EPOCH))
                                  # Only skip if completed within 5 minutes (300 seconds)
                                  # This prevents duplicate creation from webhook retries
                                  # but allows legitimate restarts after a reasonable time
                                  if [ $AGE_SECONDS -lt 300 ]; then
                                    echo "⚠️ Task $NEXT_TASK_ID was recently completed: $workflow_name (${AGE_SECONDS}s ago)"
                                    echo "Skipping to prevent duplicate from webhook retry"
                                    SKIP_CREATION=true
                                    break
                                  else
                                    echo "Task $NEXT_TASK_ID completed ${AGE_SECONDS}s ago, allowing restart"
                                  fi
                                fi
                              fi
                            fi
                          done <<< "$EXISTING_NEXT"

                          if [ "$SKIP_CREATION" = true ]; then
                            exit 0
                          fi
                        fi

                        echo "Creating orchestration workflow for Task $NEXT_TASK_ID..."

                        # Parse owner and repo from REPO_PATH (e.g., "5dlabs/cto" -> owner: 5dlabs, repo: cto)
                        GITHUB_OWNER=$(echo "$REPO_PATH" | cut -d'/' -f1)
                        GITHUB_REPO=$(echo "$REPO_PATH" | cut -d'/' -f2)

                        # Extract service name from repo name (e.g., "cto-play-test" -> "cto")
                        # Handle edge cases where removal would result in empty string
                        SERVICE_NAME=$(echo "$GITHUB_REPO" | sed 's/-play-test$//' | sed 's/-test$//')

                        # Ensure SERVICE_NAME is not empty - fallback to repo name if needed
                        if [ -z "$SERVICE_NAME" ]; then
                          SERVICE_NAME="$GITHUB_REPO"
                        fi

                        # Ensure SERVICE_NAME is valid for Kubernetes (no leading/trailing hyphens)
                        SERVICE_NAME=$(echo "$SERVICE_NAME" | sed 's/^[-]*//' | sed 's/[-]*$//')

                        # Final fallback if still empty
                        if [ -z "$SERVICE_NAME" ]; then
                          SERVICE_NAME="service"
                        fi

                        # Create the next task workflow
                        cat <<EOF | kubectl create -f -
                        apiVersion: argoproj.io/v1alpha1
                        kind: Workflow
                        metadata:
                          generateName: ${SERVICE_NAME}-task-${NEXT_TASK_ID}-play-
                          namespace: agent-platform
                          labels:
                            task-id: "$NEXT_TASK_ID"
                            workflow-type: play-orchestration
                            triggered-by: task-completion
                            previous-task: "$TASK_ID"
                        spec:
                          entrypoint: orchestrate
                          serviceAccountName: argo-workflow
                          activeDeadlineSeconds: 172800  # 48 hours
                          arguments:
                            parameters:
                              - name: task-id
                                value: "$NEXT_TASK_ID"
                              - name: service
                                value: "$SERVICE_NAME"
                              - name: github-owner
                                value: "$GITHUB_OWNER"
                              - name: github-repo
                                value: "$GITHUB_REPO"
                              - name: docs-repo
                                value: "$GITHUB_REPO"
                          templates:
                            - name: orchestrate
                              steps:
                                # Stage 1: Rex Implementation
                                - - name: implementation
                                    template: run-rex

                                # Stage 2: Wait for PR creation
                                - - name: wait-pr-created
                                    template: suspend-for-stage
                                    arguments:
                                      parameters:
                                        - name: stage
                                          value: "waiting-pr-created"

                                # Stage 3: Cleo Code Quality
                                - - name: quality
                                    template: run-cleo

                                # Stage 4: Wait for ready-for-qa label
                                - - name: wait-ready-for-qa
                                    template: suspend-for-stage
                                    arguments:
                                      parameters:
                                        - name: stage
                                          value: "waiting-ready-for-qa"

                                # Stage 5: Tess QA Testing
                                - - name: testing
                                    template: run-tess

                                # Stage 6: Wait for merge to main
                                - - name: wait-merge-to-main
                                    template: suspend-for-stage
                                    arguments:
                                      parameters:
                                        - name: stage
                                          value: "waiting-merge-to-main"

                                # Stage 7: Task complete
                                - - name: task-complete
                                    template: log-completion

                            - name: suspend-for-stage
                              inputs:
                                parameters:
                                  - name: stage
                              suspend: {}
                              metadata:
                                labels:
                                  current-stage: "{{`{{inputs.parameters.stage}}`}}"

                            - name: run-rex
                              resource:
                                action: create
                                manifest: |
                                  apiVersion: agents.platform/v1
                                  kind: CodeRun
                                  metadata:
                                    generateName: ${SERVICE_NAME}-t${NEXT_TASK_ID}-rex-
                                    namespace: agent-platform
                                    labels:
                                      task-id: "${NEXT_TASK_ID}"
                                      workflow-stage: "implementation"
                                      agent-type: "rex"
                                  spec:
                                    taskId: ${NEXT_TASK_ID}
                                    service: "${SERVICE_NAME}"
                                    repositoryUrl: "${GITHUB_OWNER}/${GITHUB_REPO}"
                                    docsRepositoryUrl: "https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}"
                                    docsProjectDirectory: "docs"
                                    workingDirectory: "."
                                    githubApp: "5DLabs-Rex"
                                    model: "claude-sonnet-4-20250514"
                                    continueSession: true
                                    overwriteMemory: false
                                    contextVersion: 1

                            - name: run-cleo
                              resource:
                                action: create
                                manifest: |
                                  apiVersion: agents.platform/v1
                                  kind: CodeRun
                                  metadata:
                                    generateName: ${SERVICE_NAME}-t${NEXT_TASK_ID}-cleo-
                                    namespace: agent-platform
                                    labels:
                                      task-id: "${NEXT_TASK_ID}"
                                      workflow-stage: "quality"
                                      agent-type: "cleo"
                                  spec:
                                    taskId: ${NEXT_TASK_ID}
                                    service: "${SERVICE_NAME}"
                                    repositoryUrl: "${GITHUB_OWNER}/${GITHUB_REPO}"
                                    docsRepositoryUrl: "https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}"
                                    docsProjectDirectory: "docs"
                                    workingDirectory: "."
                                    githubApp: "5DLabs-Cleo"
                                    model: "claude-sonnet-4-20250514"
                                    continueSession: true
                                    overwriteMemory: false
                                    contextVersion: 1
                                    # Cleo will find the PR created by Rex

                            - name: run-tess
                              resource:
                                action: create
                                manifest: |
                                  apiVersion: agents.platform/v1
                                  kind: CodeRun
                                  metadata:
                                    generateName: ${SERVICE_NAME}-t${NEXT_TASK_ID}-tess-
                                    namespace: agent-platform
                                    labels:
                                      task-id: "${NEXT_TASK_ID}"
                                      workflow-stage: "testing"
                                      agent-type: "tess"
                                  spec:
                                    taskId: ${NEXT_TASK_ID}
                                    service: "${SERVICE_NAME}"
                                    repositoryUrl: "${GITHUB_OWNER}/${GITHUB_REPO}"
                                    docsRepositoryUrl: "https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}"
                                    docsProjectDirectory: "docs"
                                    workingDirectory: "."
                                    githubApp: "5DLabs-Tess"
                                    model: "claude-sonnet-4-20250514"
                                    continueSession: true
                                    overwriteMemory: false
                                    contextVersion: 1
                                    # Tess will find the PR with ready-for-qa label

                            - name: log-completion
                              script:
                                image: alpine:3.18
                                command: [sh]
                                source: |
                                  echo "✅ Task ${NEXT_TASK_ID} completed successfully!"
                                  echo "Merged to main and ready for production."
                        EOF

                        if [ $? -eq 0 ]; then
                          echo "✅ Successfully started Task $NEXT_TASK_ID workflow"
                          echo ""
                          echo "════════════════════════════════════════════════════════════════"
                          echo "║                    TASK PROGRESSION                          ║"
                          echo "════════════════════════════════════════════════════════════════"
                          echo "✅ Task $TASK_ID: COMPLETED"
                          echo "🚀 Task $NEXT_TASK_ID: STARTED"
                          echo "📊 Progress: $TASK_ID/$MAX_TASKS tasks completed"
                          echo "════════════════════════════════════════════════════════════════"
                        else
                          echo "❌ Failed to start Task $NEXT_TASK_ID workflow"
                          exit 1
                        fi
          parameters:
            # Add PR number to workflow labels for idempotency tracking
            - dest: metadata.labels.pr-number
              src:
                dependencyName: github-pr-merged
                dataKey: body.pull_request.number
            # Workflow parameters
            - dest: spec.arguments.parameters.0.value
              src:
                dependencyName: github-pr-merged
                dataKey: body.pull_request.title
            - dest: spec.arguments.parameters.1.value
              src:
                dependencyName: github-pr-merged
                dataKey: body.pull_request.number
            - dest: spec.arguments.parameters.2.value
              src:
                dependencyName: github-pr-merged
                dataKey: body.pull_request.html_url
            - dest: spec.arguments.parameters.3.value
              src:
                dependencyName: github-pr-merged
                dataKey: body.pull_request.merge_commit_sha
            - dest: spec.arguments.parameters.4.value
              src:
                dependencyName: github-pr-merged
                dataKey: body.pull_request.merged_by.login
      # Retry strategy removed to prevent duplicate workflow creation
      # GitHub already provides webhook retry on failure
      # Deduplication and idempotency checks handle any edge cases
