---
apiVersion: v1
data:
  github-projects-helpers.sh.hbs: "#!/bin/bash\n# GitHub Projects V2 API Helper Functions\n# GraphQL-based operations for managing GitHub Projects\n# These functions are sourced by Morgan PM scripts\n# Patterns adapted from 5dlabs/tasks reference implementation\n\n# ============================================================================\n# GraphQL QUERY HELPERS WITH RETRY LOGIC\n# ============================================================================\n\nretry_with_backoff() {\n  local max_attempts=\"$1\"\n  shift\n  local operation_name=\"$1\"\n  shift\n  # Remaining args are the command to execute\n  \n  local attempt=1\n  local delay=2\n  \n  while [[ $attempt -le $max_attempts ]]; do\n    log \"\U0001F504 Attempt $attempt/$max_attempts: $operation_name\"\n    \n    # Execute the command\n    if \"$@\"; then\n      log \"✅ $operation_name succeeded on attempt $attempt\"\n      return 0\n    fi\n    \n    local exit_code=$?\n    \n    if [[ $attempt -lt $max_attempts ]]; then\n      log \"⏳ Attempt $attempt failed (exit $exit_code), retrying in ${delay}s...\"\n      sleep $delay\n      delay=$((delay * 2))  # Exponential backoff: 2s, 4s, 8s, 16s...\n      attempt=$((attempt + 1))\n    else\n      log \"❌ All $max_attempts attempts failed for: $operation_name\"\n      return $exit_code\n    fi\n  done\n}\n\ngraphql_query() {\n  local query=\"$1\"\n  local variables=\"${2:-{}}\"\n  local max_retries=3\n  local retry_count=0\n  \n  while [ $retry_count -lt $max_retries ]; do\n    local result=$(gh api graphql -f query=\"$query\" -F variables=\"$variables\" 2>&1)\n    local exit_code=$?\n    \n    if [ $exit_code -eq 0 ]; then\n      echo \"$result\"\n      return 0\n    fi\n    \n    # Check if rate limited\n    if echo \"$result\" | grep -q \"rate limit\"; then\n      retry_count=$((retry_count + 1))\n      local backoff=$((2 ** retry_count))\n      echo \"⚠️  Rate limited, retrying in ${backoff}s...\" >&2\n      sleep \"$backoff\"\n    else\n      echo \"{}\" \n      return 1\n    fi\n  done\n  \n  echo \"{}\"\n  return 1\n}\n\n# ============================================================================\n# PROJECT MANAGEMENT\n# ============================================================================\n\nget_repository_id() {\n  local owner=\"$1\"\n  local repo_name=\"$2\"\n  \n  local query='\n    query($owner: String!, $repo: String!) {\n      repository(owner: $owner, name: $repo) {\n        id\n      }\n    }\n  '\n  \n  local result=$(gh api graphql -f query=\"$query\" -f owner=\"$owner\" -f repo=\"$repo_name\" 2>&1)\n  \n  local repo_id=$(echo \"$result\" | jq -r '.data.repository.id // \"\"')\n  \n  if [[ -z \"$repo_id\" ]] || [[ \"$repo_id\" == \"null\" ]]; then\n    log \"❌ Could not get repository ID for $owner/$repo_name\" >&2\n    echo \"$result\" >&2\n    echo \"\"\n    return 1\n  fi\n  \n  echo \"$repo_id\"\n}\n\nget_or_create_project_smart() {\n  local owner=\"$1\"\n  local repo_name=\"$2\"\n  local title=\"$3\"\n  local prefer_repo_level=\"${4:-false}\"  # Can be set via env var or param\n  \n  local project_id=\"\"\n  \n  # Try repo-level first if preferred (simpler permissions, auto-linked)\n  if [[ \"$prefer_repo_level\" == \"true\" ]]; then\n    log \"\U0001F4CA Attempting repo-level project (preferred mode)...\"\n    project_id=$(get_or_create_repo_project \"$owner\" \"$repo_name\" \"$title\")\n    \n    if [[ -n \"$project_id\" ]] && [[ \"$project_id\" != \"null\" ]]; then\n      log \"✅ Using repo-level project: $project_id\"\n      echo \"$project_id\"\n      return 0\n    else\n      log \"⚠️  Repo-level project creation failed, falling back to org-level...\"\n    fi\n  fi\n  \n  # Try org-level (default or fallback)\n  log \"\U0001F4CA Attempting org-level project...\"\n  project_id=$(get_or_create_org_project \"$owner\" \"$repo_name\" \"$title\")\n  \n  if [[ -n \"$project_id\" ]] && [[ \"$project_id\" != \"null\" ]]; then\n    log \"✅ Using org-level project: $project_id\"\n    echo \"$project_id\"\n    return 0\n  fi\n  \n  # If org-level failed and we haven't tried repo-level yet\n  if [[ \"$prefer_repo_level\" != \"true\" ]]; then\n    log \"⚠️  Org-level project failed, trying repo-level as fallback...\"\n    project_id=$(get_or_create_repo_project \"$owner\" \"$repo_name\" \"$title\")\n    \n    if [[ -n \"$project_id\" ]] && [[ \"$project_id\" != \"null\" ]]; then\n      log \"✅ Using repo-level project (fallback): $project_id\"\n      echo \"$project_id\"\n      return 0\n    fi\n  fi\n  \n  log \"❌ Failed to create project at any level\"\n  echo \"null\"\n  return 1\n}\n\nget_or_create_repo_project() {\n  local owner=\"$1\"\n  local repo_name=\"$2\"\n  local title=\"$3\"\n  \n  # Get repository ID\n  local repo_id=$(get_repository_id \"$owner\" \"$repo_name\")\n  \n  if [[ -z \"$repo_id\" ]] || [[ \"$repo_id\" == \"null\" ]]; then\n    return 1\n  fi\n  \n  # Try to find existing repo-level project\n  local find_query='\n    query($owner: String!, $repo: String!) {\n      repository(owner: $owner, name: $repo) {\n        projectsV2(first: 20) {\n          nodes {\n            id\n            title\n            owner {\n              __typename\n            }\n          }\n        }\n      }\n    }\n  '\n  \n  local result=$(gh api graphql -f query=\"$find_query\" -f owner=\"$owner\" -f repo=\"$repo_name\")\n  \n  # Find repo-level project (owner type is Repository, not Organization)\n  local existing_id=$(echo \"$result\" | jq -r --arg title \"$title\" \\\n    '.data.repository.projectsV2.nodes[] | select(.title == $title and .owner.__typename == \"Repository\") | .id' | head -1)\n  \n  if [[ -n \"$existing_id\" ]] && [[ \"$existing_id\" != \"null\" ]]; then\n    echo \"$existing_id\"\n    return 0\n  fi\n  \n  # Create new repo-level project\n  local create_mutation='\n    mutation($repositoryId: ID!, $title: String!) {\n      createProjectV2(input: {\n        repositoryId: $repositoryId\n        title: $title\n      }) {\n        projectV2 {\n          id\n          title\n        }\n      }\n    }\n  '\n  \n  local create_result=$(gh api graphql \\\n    -f query=\"$create_mutation\" \\\n    -f repositoryId=\"$repo_id\" \\\n    -f title=\"$title\")\n  \n  if echo \"$create_result\" | jq -e '.errors' >/dev/null 2>&1; then\n    echo \"$create_result\" | jq '.errors' >&2\n    echo \"null\"\n    return 1\n  fi\n  \n  local project_id=$(echo \"$create_result\" | jq -r '.data.createProjectV2.projectV2.id // \"null\"')\n  \n  # CRITICAL FIX: Create board view for repo-level projects too\n  # This was missing and caused board columns not to be configured\n  if [[ -n \"$project_id\" ]] && [[ \"$project_id\" != \"null\" ]]; then\n    create_default_board_view \"$project_id\"\n  fi\n  \n  echo \"$project_id\"\n}\n\nget_or_create_org_project() {\n  local owner=\"$1\"\n  local repo_name=\"$2\"\n  local title=\"$3\"\n  \n  # Get repository node ID - needed for linking project to repo\n  local repo_result=$(gh api graphql -f query='\n    query($owner: String!, $repo: String!) {\n      repository(owner: $owner, name: $repo) {\n        id\n      }\n    }\n  ' -f owner=\"$owner\" -f repo=\"$repo_name\" 2>&1)\n  \n  local repo_id=$(echo \"$repo_result\" | jq -r '.data.repository.id // \"\"')\n  \n  if [[ -z \"$repo_id\" ]] || [[ \"$repo_id\" == \"null\" ]]; then\n    echo \"ERROR: Could not get repository ID for $owner/$repo_name\" >&2\n    echo \"$repo_result\" >&2\n    echo \"\"\n    return 1\n  fi\n  \n  # Try to find existing project (check both org and linked projects)\n  local query='\n    query($owner: String!, $repo: String!) {\n      repository(owner: $owner, name: $repo) {\n        projectsV2(first: 20) {\n          nodes {\n            id\n            title\n          }\n        }\n      }\n    }\n  '\n  \n  local result=$(gh api graphql -f query=\"$query\" -f owner=\"$owner\" -f repo=\"$repo_name\")\n  \n  # Check if project exists\n  local project_id=$(echo \"$result\" | jq -r \\\n    --arg title \"$title\" \\\n    '.data.repository.projectsV2.nodes[] | select(.title == $title) | .id')\n  \n  if [[ -n \"$project_id\" ]] && [[ \"$project_id\" != \"null\" ]]; then\n    echo \"$project_id\"\n    return 0\n  fi\n  \n  # GitHub Projects V2 are created at org/user level, then linked to repos\n  # Get owner ID for project creation\n  echo \"Creating org-level project and linking to repository $owner/$repo_name\" >&2\n  \n  local owner_result=$(gh api graphql -f query='\n    query($owner: String!) {\n      repositoryOwner(login: $owner) {\n        id\n      }\n    }\n  ' -f owner=\"$owner\" 2>&1)\n  \n  local owner_id=$(echo \"$owner_result\" | jq -r '.data.repositoryOwner.id // \"\"')\n  \n  if [[ -z \"$owner_id\" ]] || [[ \"$owner_id\" == \"null\" ]]; then\n    echo \"ERROR: Could not get owner ID for $owner\" >&2\n    echo \"$owner_result\" >&2\n    echo \"\"\n    return 1\n  fi\n  \n  echo \"Owner ID: $owner_id\" >&2\n  \n  local create_mutation='\n    mutation($ownerId: ID!, $title: String!) {\n      createProjectV2(input: {\n        ownerId: $ownerId\n        title: $title\n      }) {\n        projectV2 {\n          id\n        }\n      }\n    }\n  '\n  \n  local create_result=$(gh api graphql \\\n    -f query=\"$create_mutation\" \\\n    -f ownerId=\"$owner_id\" \\\n    -f title=\"$title\" 2>&1)\n  \n  # Check for errors in response\n  if echo \"$create_result\" | jq -e '.errors' >/dev/null 2>&1; then\n    echo \"ERROR: Failed to create project\" >&2\n    echo \"$create_result\" | jq -r '.errors[0].message' >&2\n    echo \"\"\n    return 1\n  fi\n  \n  local project_id=$(echo \"$create_result\" | jq -r '.data.createProjectV2.projectV2.id // \"\"')\n  \n  if [[ -z \"$project_id\" ]] || [[ \"$project_id\" == \"null\" ]]; then\n    echo \"ERROR: No project ID returned\" >&2\n    echo \"$create_result\" >&2\n    echo \"\"\n    return 1\n  fi\n  \n  # Link the project to the repository so it appears on repo page\n  echo \"Linking project $project_id to repository $repo_id\" >&2\n  \n  local link_mutation='\n    mutation($projectId: ID!, $repositoryId: ID!) {\n      linkProjectV2ToRepository(input: {\n        projectId: $projectId\n        repositoryId: $repositoryId\n      }) {\n        repository {\n          id\n        }\n      }\n    }\n  '\n  \n  # Redirect both stdout and stderr to avoid contaminating the return value\n  gh api graphql \\\n    -f query=\"$link_mutation\" \\\n    -f projectId=\"$project_id\" \\\n    -f repositoryId=\"$repo_id\" >/dev/null 2>&1 || {\n      echo \"WARNING: Could not link project to repository (project still works)\" >&2\n    }\n  \n  # Create board view and set as default\n  create_default_board_view \"$project_id\"\n  \n  # Return only the project ID (not mutation output)\n  echo \"$project_id\"\n}\n\nensure_project_linked_to_repository() {\n  local project_id=\"$1\"\n  local repo_owner=\"$2\"\n  local repo_name=\"$3\"\n  \n  log \"\U0001F517 Verifying project is linked to repository $repo_owner/$repo_name...\"\n  \n  # Check if already linked\n  local check_query='\n    query($projectId: ID!) {\n      node(id: $projectId) {\n        ... on ProjectV2 {\n          repositories(first: 20) {\n            nodes {\n              owner {\n                login\n              }\n              name\n            }\n          }\n        }\n      }\n    }\n  '\n  \n  local result=$(gh api graphql -f query=\"$check_query\" -f projectId=\"$project_id\")\n  \n  # Check if our repo is in the list\n  local is_linked=$(echo \"$result\" | jq -r --arg owner \"$repo_owner\" --arg name \"$repo_name\" \\\n    '.data.node.repositories.nodes[] | select(.owner.login == $owner and .name == $name) | .name' | head -1)\n  \n  if [[ -n \"$is_linked\" ]]; then\n    log \"✅ Project already linked to repository\"\n    return 0\n  fi\n  \n  log \"\U0001F4CE Linking project to repository...\"\n  \n  # Get repository ID\n  local repo_id=$(get_repository_id \"$repo_owner\" \"$repo_name\")\n  \n  if [[ -z \"$repo_id\" ]] || [[ \"$repo_id\" == \"null\" ]]; then\n    log \"❌ Could not get repository ID\"\n    return 1\n  fi\n  \n  # Link project to repository\n  local link_mutation='\n    mutation($projectId: ID!, $repositoryId: ID!) {\n      linkProjectV2ToRepository(input: {\n        projectId: $projectId\n        repositoryId: $repositoryId\n      }) {\n        repository {\n          id\n          nameWithOwner\n        }\n      }\n    }\n  '\n  \n  local link_result=$(gh api graphql \\\n    -f query=\"$link_mutation\" \\\n    -f projectId=\"$project_id\" \\\n    -f repositoryId=\"$repo_id\")\n  \n  # Check for errors\n  if echo \"$link_result\" | jq -e '.errors' >/dev/null 2>&1; then\n    log \"❌ Failed to link project to repository:\"\n    echo \"$link_result\" | jq '.errors'\n    return 1\n  fi\n  \n  local linked_repo=$(echo \"$link_result\" | jq -r '.data.linkProjectV2ToRepository.repository.nameWithOwner // \"\"')\n  \n  if [[ \"$linked_repo\" == \"$repo_owner/$repo_name\" ]]; then\n    log \"✅ Successfully verified project link to: $linked_repo\"\n    return 0\n  else\n    log \"❌ Link verification failed - expected $repo_owner/$repo_name, got $linked_repo\"\n    return 1\n  fi\n}\n\ncreate_default_board_view() {\n  local project_id=\"$1\"\n  \n  echo \"Setting up agent-based board view as default...\" >&2\n  \n  # Using built-in Status field - board columns auto-create!\n  echo \"✅ Board will use Status field for automatic column creation\" >&2\n  \n  # First, get existing views (GitHub auto-creates a default table view)\n  local views_query='\n    query($projectId: ID!) {\n      node(id: $projectId) {\n        ... on ProjectV2 {\n          views(first: 10) {\n            nodes {\n              id\n              name\n              layout\n            }\n          }\n        }\n      }\n    }\n  '\n  \n  local views_result\n  views_result=$(gh api graphql \\\n    -f query=\"$views_query\" \\\n    -f projectId=\"$project_id\" 2>/dev/null) || {\n    echo \"⚠️  Could not query existing views\" >&2\n    return 1\n  }\n  \n  # Create board view with agent-based columns\n  local view_mutation='\n    mutation($projectId: ID!) {\n      createProjectV2View(input: {\n        projectId: $projectId\n        name: \"Agent Workflow Board\"\n        layout: BOARD_LAYOUT\n      }) {\n        projectV2View {\n          id\n          number\n        }\n      }\n    }\n  '\n  \n  local view_result\n  view_result=$(gh api graphql \\\n    -f query=\"$view_mutation\" \\\n    -f projectId=\"$project_id\" 2>/dev/null) || {\n    echo \"⚠️  Could not create board view\" >&2\n    return 1\n  }\n  \n  local view_id=$(echo \"$view_result\" | jq -r '.data.createProjectV2View.projectV2View.id // \"\"' 2>/dev/null)\n  local view_number=$(echo \"$view_result\" | jq -r '.data.createProjectV2View.projectV2View.number // \"\"' 2>/dev/null)\n  \n  if [[ -n \"$view_id\" ]] && [[ \"$view_id\" != \"null\" ]]; then\n    echo \"✅ Created agent workflow board view (ID: $view_id, Number: $view_number)\" >&2\n    \n    # Note: GitHub Projects V2 API doesn't support setting groupByFieldId during creation via GraphQL\n    # The board will use default grouping (by Status typically)\n    # Users can manually configure grouping by \"Stage\" field in the UI\n    # The Stage field contains agent names: Pending, Rex (Implementation), Cleo (Quality), etc.\n    \n    echo \"\U0001F4A1 To group by agents in the UI:\" >&2\n    echo \"   1. Open the project board\" >&2\n    echo \"   2. Click 'Group by' → Select 'Status' (auto-generated columns)\" >&2\n    echo \"   3. Columns will show: Pending | Rex | Cleo | Cipher | Tess | Atlas | Bolt | Complete ✅\" >&2\n    echo \"   \U0001F501 Legacy boards that still group by 'Stage' stay accurate because Morgan now mirrors values into both fields.\" >&2\n    \n    # Delete ALL table views - GitHub Projects V2 API doesn't support configuring field visibility\n    # Table views will show default columns (Assignees, Sub-issues progress) which we don't want\n    # Users can manually create a table view and configure columns if needed\n    # For now, we only use the board view which shows agent-based columns correctly\n    local all_table_views=$(echo \"$views_result\" | jq -r '.data.node.views.nodes[]? | select(.layout == \"TABLE_LAYOUT\") | .id' 2>/dev/null)\n    \n    if [[ -n \"$all_table_views\" ]]; then\n      echo \"Removing all table views (board view will be the default)...\" >&2\n      \n      while IFS= read -r table_view_id; do\n        if [[ -n \"$table_view_id\" ]] && [[ \"$table_view_id\" != \"null\" ]]; then\n          local delete_mutation='\n            mutation($viewId: ID!) {\n              deleteProjectV2View(input: {\n                viewId: $viewId\n              }) {\n                projectV2View {\n                  id\n                }\n              }\n            }\n          '\n          \n          if gh api graphql \\\n            -f query=\"$delete_mutation\" \\\n            -f viewId=\"$table_view_id\" >/dev/null 2>&1; then\n            echo \"✅ Deleted table view (ID: $table_view_id)\" >&2\n          else\n            echo \"⚠️  Could not delete table view (ID: $table_view_id)\" >&2\n          fi\n        fi\n      done <<< \"$all_table_views\"\n      \n      echo \"✅ All table views removed - board view is now the default!\" >&2\n      echo \"\U0001F4A1 If you need a table view, create it manually and hide 'Assignees' and 'Sub-issues progress' columns\" >&2\n    else\n      echo \"✅ No table views found - board view will be the default\" >&2\n    fi\n  else\n    echo \"⚠️  Could not create board view (project still works)\" >&2\n  fi\n}\n\n# ============================================================================\n# CUSTOM FIELDS SETUP\n# ============================================================================\n\nsetup_custom_fields() {\n  local project_id=\"$1\"\n  \n  # CRITICAL: Use GitHub's BUILT-IN \"Status\" field with agent names and roles\n  # This causes board columns to AUTO-CREATE without manual configuration!\n  # Pattern from 5dlabs/tasks - Status field triggers automatic column creation\n  create_single_select_field \"$project_id\" \"Status\" \\\n    \"Pending\" \"Rex (Implementation)\" \"Blaze (Frontend)\" \"Cleo (Quality)\" \"Cipher (Security)\" \"Tess (QA)\" \"Atlas (Integration)\" \"Bolt (Deployment)\" \"Complete ✅\"\n  \n  # Legacy compatibility: keep Stage field populated so historical boards continue to work\n  create_single_select_field \"$project_id\" \"Stage\" \\\n    \"Pending\" \"Rex (Implementation)\" \"Blaze (Frontend)\" \"Cleo (Quality)\" \"Cipher (Security)\" \"Tess (QA)\" \"Atlas (Integration)\" \"Bolt (Deployment)\" \"Complete ✅\"\n  \n  # Create \"Task ID\" field (text)\n  create_text_field \"$project_id\" \"Task ID\" || true\n  \n  # Create \"Priority\" field for filtering\n  create_single_select_field \"$project_id\" \"Priority\" \\\n    \"High\" \"Medium\" \"Low\" || true\n  \n  echo \"✅ Custom fields setup completed\" >&2\n}\n\ncreate_single_select_field() {\n  local project_id=\"$1\"\n  local field_name=\"$2\"\n  shift 2\n  local options=(\"$@\")\n  \n  # Check if field already exists\n  local existing_field=$(get_project_field \"$project_id\" \"$field_name\")\n  if [[ -n \"$existing_field\" ]] && [[ \"$existing_field\" != \"null\" ]]; then\n    log \"✅ Field '$field_name' already exists\"\n    \n    # CRITICAL: Status/Stage fields may exist but have NO options - add them!\n    if [[ \"$field_name\" == \"Status\" ]] || [[ \"$field_name\" == \"Stage\" ]]; then\n      log \"\U0001F527 Ensuring $field_name field has agent options...\"\n      local colors=(\"GRAY\" \"RED\" \"ORANGE\" \"YELLOW\" \"GREEN\" \"BLUE\" \"PURPLE\" \"PINK\")\n      local opts_json=\"[]\"\n      for i in \"${!options[@]}\"; do\n        local color=\"${colors[$((i % ${#colors[@]}))]}\"\n        opts_json=$(echo \"$opts_json\" | jq --arg n \"${options[$i]}\" --arg c \"$color\" '. += [{\"name\": $n, \"color\": $c, \"description\": $n}]')\n      done\n      \n      local upd=$(jq -n --arg q 'mutation($fieldId: ID!, $options: [ProjectV2SingleSelectFieldOptionInput!]!) { updateProjectV2Field(input: {fieldId: $fieldId, singleSelectOptions: $options}) { projectV2Field { ... on ProjectV2SingleSelectField { id options { name } } } } }' --arg fieldId \"$existing_field\" --argjson options \"$opts_json\" '{query: $q, variables: {fieldId: $fieldId, options: $options}}')\n      \n      log \"\U0001F50D DEBUG: Updating $field_name field with options: $(echo \"$opts_json\" | jq -c '[.[] | .name]')\"\n      \n      local result=$(echo \"$upd\" | gh api graphql --input - 2>&1)\n      \n      if echo \"$result\" | jq -e '.errors' >/dev/null 2>&1; then\n        log \"❌ GraphQL ERROR updating $field_name field options:\"\n        echo \"$result\" | jq '.errors' | tee -a \"$SYNC_LOG\" >&2\n      elif echo \"$result\" | jq -e '.data.updateProjectV2Field.projectV2Field.options' >/dev/null 2>&1; then\n        local added_opts=$(echo \"$result\" | jq -r '.data.updateProjectV2Field.projectV2Field.options[].name' | tr '\\n' ', ')\n        log \"✅ Added agent options to $field_name field: $added_opts\"\n      else\n        log \"⚠️  $field_name field update returned but no confirmation\"\n        echo \"$result\" | jq '.' | tee -a \"$SYNC_LOG\" >&2\n      fi\n    fi\n    \n    return 0\n  fi\n  \n  log \"\U0001F527 Creating field '$field_name' with ${#options[@]} options...\"\n  \n  # Build options JSON using jq for proper formatting\n  # Note: GitHub's ProjectV2SingleSelectFieldOptionInput requires name, color, AND description (all NON_NULL)\n  local options_json=\"[]\"\n  local colors=(\"RED\" \"BLUE\" \"GREEN\" \"YELLOW\" \"ORANGE\" \"PURPLE\" \"PINK\" \"GRAY\")\n  for i in \"${!options[@]}\"; do\n    local color=\"${colors[$((i % ${#colors[@]}))]}\"\n    local option_name=\"${options[$i]}\"\n    # Use option name as description for simplicity\n    options_json=$(echo \"$options_json\" | jq --arg name \"$option_name\" --arg color \"$color\" --arg desc \"$option_name\" \\\n      '. += [{\"name\": $name, \"color\": $color, \"description\": $desc}]')\n  done\n  \n  log \"\U0001F50D DEBUG: options_json = $options_json\"\n  \n  # Validate that all options have required fields (name, color, description)\n  local validation_errors=$(echo \"$options_json\" | jq -r '\n    map(\n      select(\n        (.name == null or .name == \"\") or \n        (.color == null or .color == \"\") or \n        (.description == null)\n      )\n    ) | \n    if length > 0 then \n      \"Missing required fields in options: \" + (map(.name // \"unnamed\") | join(\", \"))\n    else \n      \"\"\n    end\n  ')\n  \n  if [[ -n \"$validation_errors\" ]]; then\n    log \"❌ Validation error: $validation_errors\"\n    return 1\n  fi\n  \n  local mutation='\n    mutation($projectId: ID!, $name: String!, $options: [ProjectV2SingleSelectFieldOptionInput!]!) {\n      createProjectV2Field(input: {\n        projectId: $projectId\n        dataType: SINGLE_SELECT\n        name: $name\n        singleSelectOptions: $options\n      }) {\n        projectV2Field {\n          ... on ProjectV2SingleSelectField {\n            id\n          }\n        }\n      }\n    }\n  '\n  \n  log \"\U0001F50D DEBUG: project_id=$project_id, field_name=$field_name\"\n  \n  # Build full GraphQL request body with variables\n  local request_body=$(jq -n \\\n    --arg query \"$mutation\" \\\n    --arg projectId \"$project_id\" \\\n    --arg name \"$field_name\" \\\n    --argjson options \"$options_json\" \\\n    '{query: $query, variables: {projectId: $projectId, name: $name, options: $options}}')\n  \n  # Pass complete request via stdin\n  local result=$(echo \"$request_body\" | gh api graphql --input - 2>&1)\n  \n  if echo \"$result\" | jq -e '.errors' >/dev/null 2>&1; then\n    log \"❌ Failed to create field '$field_name':\"\n    echo \"$result\" | jq '.errors' | tee -a \"$SYNC_LOG\" >&2\n    return 1\n  fi\n  \n  local field_id=$(echo \"$result\" | jq -r '.data.createProjectV2Field.projectV2Field.id // \"\"')\n  if [[ -n \"$field_id\" ]] && [[ \"$field_id\" != \"null\" ]]; then\n    log \"✅ Created field '$field_name' (ID: $field_id)\"\n  else\n    log \"⚠️  Field creation returned success but no ID\"\n    echo \"$result\" | jq '.' | tee -a \"$SYNC_LOG\" >&2\n  fi\n}\n\ncreate_text_field() {\n  local project_id=\"$1\"\n  local field_name=\"$2\"\n  \n  # Check if field already exists\n  local existing_field=$(get_project_field \"$project_id\" \"$field_name\")\n  if [[ -n \"$existing_field\" ]] && [[ \"$existing_field\" != \"null\" ]]; then\n    log \"✅ Field '$field_name' already exists, skipping creation\"\n    return 0\n  fi\n  \n  log \"\U0001F527 Creating text field '$field_name'...\"\n  \n  local mutation='\n    mutation($projectId: ID!, $name: String!) {\n      createProjectV2Field(input: {\n        projectId: $projectId\n        dataType: TEXT\n        name: $name\n      }) {\n        projectV2Field {\n          ... on ProjectV2Field {\n            id\n          }\n        }\n      }\n    }\n  '\n  \n  local result=$(gh api graphql \\\n    -f query=\"$mutation\" \\\n    -f projectId=\"$project_id\" \\\n    -f name=\"$field_name\" 2>&1)\n  \n  if echo \"$result\" | jq -e '.errors' >/dev/null 2>&1; then\n    log \"❌ Failed to create text field '$field_name':\"\n    echo \"$result\" | jq '.errors' | tee -a \"$SYNC_LOG\" >&2\n    return 1\n  fi\n  \n  local field_id=$(echo \"$result\" | jq -r '.data.createProjectV2Field.projectV2Field.id // \"\"')\n  if [[ -n \"$field_id\" ]] && [[ \"$field_id\" != \"null\" ]]; then\n    log \"✅ Created text field '$field_name' (ID: $field_id)\"\n  else\n    log \"⚠️  Text field creation returned success but no ID\"\n    echo \"$result\" | jq '.' | tee -a \"$SYNC_LOG\" >&2\n  fi\n}\n\nget_project_field() {\n  local project_id=\"$1\"\n  local field_name=\"$2\"\n  \n  local query='\n    query($projectId: ID!) {\n      node(id: $projectId) {\n        ... on ProjectV2 {\n          fields(first: 20) {\n            nodes {\n              ... on ProjectV2Field {\n                id\n                name\n              }\n              ... on ProjectV2SingleSelectField {\n                id\n                name\n              }\n            }\n          }\n        }\n      }\n    }\n  '\n  \n  gh api graphql \\\n    -f query=\"$query\" \\\n    -f projectId=\"$project_id\" \\\n    | jq -r --arg name \"$field_name\" \\\n      '.data.node.fields.nodes[] | select(.name == $name) | .id'\n}\n\n# ============================================================================\n# ISSUE MANAGEMENT\n# ============================================================================\n\nadd_issue_to_project() {\n  local project_id=\"$1\"\n  local issue_node_id=\"$2\"\n  local issue_number=\"${3:-unknown}\"  # Optional: for better logging\n  \n  local mutation='\n    mutation($projectId: ID!, $contentId: ID!) {\n      addProjectV2ItemById(input: {\n        projectId: $projectId\n        contentId: $contentId\n      }) {\n        item {\n          id\n          project {\n            id\n            title\n          }\n          content {\n            ... on Issue {\n              number\n              projectItems(first: 5) {\n                totalCount\n                nodes {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  '\n  \n  log \"\U0001F517 Linking issue #$issue_number to project $project_id...\"\n  \n  local result=$(gh api graphql \\\n    -f query=\"$mutation\" \\\n    -f projectId=\"$project_id\" \\\n    -f contentId=\"$issue_node_id\" 2>&1)\n  \n  # Save full response for debugging\n  if [[ \"$issue_number\" != \"unknown\" ]]; then\n    echo \"$result\" | jq '.' > \"/tmp/add-project-item-${issue_number}.json\" 2>/dev/null || true\n  fi\n  \n  # Check for errors in the response\n  if echo \"$result\" | jq -e '.errors' >/dev/null 2>&1; then\n    log \"❌ GraphQL ERROR adding issue #$issue_number to project:\"\n    echo \"$result\" | jq '.errors' | tee -a \"$SYNC_LOG\" >&2\n    \n    # Categorize and provide actionable guidance\n    local error_type=$(echo \"$result\" | jq -r '.errors[0].type // \"\"')\n    local error_msg=$(echo \"$result\" | jq -r '.errors[0].message // \"\"')\n    \n    case \"$error_type\" in\n      \"INSUFFICIENT_SCOPES\"|\"FORBIDDEN\")\n        log \"\U0001F510 Permission Error: $error_msg\"\n        log \"\U0001F4A1 Action: Check GitHub App permissions for organization_projects and repository_projects\"\n        log \"\U0001F4A1 Verify: gh auth status and GitHub App installation permissions\"\n        # Track metric\n        echo $(($(cat /tmp/morgan-graphql-permission-errors 2>/dev/null || echo \"0\") + 1)) > /tmp/morgan-graphql-permission-errors\n        ;;\n      \"NOT_FOUND\")\n        log \"\U0001F50D Resource Not Found: $error_msg\"\n        log \"\U0001F4A1 Debug: Project ID=$project_id, Issue Node=$issue_node_id\"\n        log \"\U0001F4A1 Action: Verify project exists and issue is valid\"\n        # Track metric\n        echo $(($(cat /tmp/morgan-graphql-notfound-errors 2>/dev/null || echo \"0\") + 1)) > /tmp/morgan-graphql-notfound-errors\n        ;;\n      \"INTERNAL\"|\"RATE_LIMITED\")\n        log \"⏳ GitHub API Issue: $error_msg\"\n        log \"\U0001F4A1 Action: Will retry automatically with backoff\"\n        # Track metric\n        echo $(($(cat /tmp/morgan-graphql-ratelimit-errors 2>/dev/null || echo \"0\") + 1)) > /tmp/morgan-graphql-ratelimit-errors\n        ;;\n      *)\n        log \"⚠️  Unknown Error Type: $error_type\"\n        log \"\U0001F4CB Message: $error_msg\"\n        # Track metric\n        echo $(($(cat /tmp/morgan-graphql-other-errors 2>/dev/null || echo \"0\") + 1)) > /tmp/morgan-graphql-other-errors\n        ;;\n    esac\n    \n    echo \"null\"\n    return 1\n  fi\n  \n  # Extract item ID\n  local item_id=$(echo \"$result\" | jq -r '.data.addProjectV2ItemById.item.id // \"null\"')\n  \n  if [[ \"$item_id\" == \"null\" ]] || [[ -z \"$item_id\" ]]; then\n    log \"❌ Failed to extract item ID from GraphQL response\"\n    echo \"$result\" | jq '.' | tee -a \"$SYNC_LOG\" >&2\n    echo \"null\"\n    return 1\n  fi\n  \n  # CRITICAL: Verify the link actually persisted\n  local total_count=$(echo \"$result\" | jq -r '.data.addProjectV2ItemById.item.content.projectItems.totalCount // 0' 2>/dev/null)\n  \n  if [[ \"$total_count\" -gt 0 ]]; then\n    log \"✅ Verified: Issue #$issue_number linked to project (${total_count} project links total)\"\n    # Increment success metric\n    echo $(($(cat /tmp/morgan-link-success 2>/dev/null || echo \"0\") + 1)) > /tmp/morgan-link-success\n  else\n    log \"⚠️  WARNING: GraphQL returned item ID but issue has 0 project links!\"\n    log \"\U0001F4A1 This may indicate:\"\n    log \"   - Async operation still in progress (wait 2-5 seconds)\"\n    log \"   - Permission issue after initial validation\"\n    log \"   - Project not properly linked to repository\"\n    log \"\U0001F4CB Item ID returned: $item_id\"\n    # Increment failure metric\n    echo $(($(cat /tmp/morgan-link-failure 2>/dev/null || echo \"0\") + 1)) > /tmp/morgan-link-failure\n  fi\n  \n  echo \"$item_id\"\n}\n\n# ============================================================================\n# FIELD VALUE UPDATES\n# ============================================================================\n\nset_project_item_stage() {\n  local project_id=\"$1\"\n  local item_id=\"$2\"\n  local stage=\"$3\"\n  \n  log \"\U0001F50D Setting Status/Stage fields: item=$item_id, status='$stage'\"\n  \n  local status_updated=false\n  local stage_updated=false\n  local status_field_id=$(get_project_field \"$project_id\" \"Status\")\n  \n  if [[ -n \"$status_field_id\" ]] && [[ \"$status_field_id\" != \"null\" ]]; then\n    local status_option_id=$(get_field_option_id \"$project_id\" \"$status_field_id\" \"$stage\")\n    \n    if [[ -z \"$status_option_id\" ]] || [[ \"$status_option_id\" == \"null\" ]]; then\n      log \"❌ Status option '$stage' not found\"\n    elif update_project_item_field \"$project_id\" \"$item_id\" \"$status_field_id\" \"$status_option_id\"; then\n      log \"✅ Updated Status field to: $stage\"\n      status_updated=true\n    else\n      log \"❌ Failed to update Status field\"\n    fi\n  else\n    log \"⚠️  Status field not found (will rely on legacy Stage field)\"\n  fi\n  \n  local legacy_stage_id=$(get_project_field \"$project_id\" \"Stage\")\n  if [[ -n \"$legacy_stage_id\" ]] && [[ \"$legacy_stage_id\" != \"null\" ]]; then\n    local stage_option_id=$(get_field_option_id \"$project_id\" \"$legacy_stage_id\" \"$stage\")\n    \n    if [[ -z \"$stage_option_id\" ]] || [[ \"$stage_option_id\" == \"null\" ]]; then\n      log \"⚠️  Legacy Stage option '$stage' not found\"\n    elif update_project_item_field \"$project_id\" \"$item_id\" \"$legacy_stage_id\" \"$stage_option_id\"; then\n      log \"✅ Updated legacy Stage field to: $stage\"\n      stage_updated=true\n    else\n      log \"⚠️  Failed to update legacy Stage field\"\n    fi\n  fi\n  \n  if [[ \"$status_updated\" == false ]] && [[ \"$stage_updated\" == false ]]; then\n    log \"❌ Failed to update both Status and Stage fields\"\n    return 1\n  fi\n  \n  if [[ \"$status_updated\" == false ]] && [[ \"$stage_updated\" == true ]]; then\n    log \"⚠️  Status field missing; continuing with legacy Stage updates only\"\n  fi\n  \n  return 0\n}\n\n# Legacy function - now stage and agent are the same thing (agent-based columns)\nset_project_item_agent() {\n  local project_id=\"$1\"\n  local item_id=\"$2\"\n  local agent=\"$3\"\n  \n  # Simply call set_project_item_stage since agent names are now stages\n  set_project_item_stage \"$project_id\" \"$item_id\" \"$agent\"\n}\n\nset_project_item_priority() {\n  local project_id=\"$1\"\n  local item_id=\"$2\"\n  local priority=\"$3\"\n  \n  local field_id=$(get_project_field \"$project_id\" \"Priority\")\n  \n  if [[ -z \"$field_id\" ]] || [[ \"$field_id\" == \"null\" ]]; then\n    return 0\n  fi\n  \n  local priority_value=\"$priority\"\n  case \"$priority\" in\n    \"high\") priority_value=\"High\" ;;\n    \"medium\") priority_value=\"Medium\" ;;\n    \"low\") priority_value=\"Low\" ;;\n  esac\n  \n  local option_id=$(get_field_option_id \"$project_id\" \"$field_id\" \"$priority_value\")\n  \n  if [[ -z \"$option_id\" ]] || [[ \"$option_id\" == \"null\" ]]; then\n    return 0\n  fi\n  \n  update_project_item_field \"$project_id\" \"$item_id\" \"$field_id\" \"$option_id\"\n}\n\nget_field_option_id() {\n  local project_id=\"$1\"\n  local field_id=\"$2\"\n  local option_name=\"$3\"\n  \n  local query='\n    query($projectId: ID!) {\n      node(id: $projectId) {\n        ... on ProjectV2 {\n          fields(first: 20) {\n            nodes {\n              ... on ProjectV2SingleSelectField {\n                id\n                options {\n                  id\n                  name\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  '\n  \n  local result=$(gh api graphql \\\n    -f query=\"$query\" \\\n    -f projectId=\"$project_id\")\n  \n  echo \"$result\" | jq -r \\\n    --arg field_id \"$field_id\" \\\n    --arg option_name \"$option_name\" \\\n    '.data.node.fields.nodes[] | select(.id == $field_id) | .options[] | select(.name == $option_name) | .id'\n}\n\nupdate_project_item_field() {\n  local project_id=\"$1\"\n  local item_id=\"$2\"\n  local field_id=\"$3\"\n  local value=\"$4\"\n  \n  local mutation='\n    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: String!) {\n      updateProjectV2ItemFieldValue(input: {\n        projectId: $projectId\n        itemId: $itemId\n        fieldId: $fieldId\n        value: {\n          singleSelectOptionId: $value\n        }\n      }) {\n        projectV2Item {\n          id\n        }\n      }\n    }\n  '\n  \n  local result=$(gh api graphql \\\n    -f query=\"$mutation\" \\\n    -f projectId=\"$project_id\" \\\n    -f itemId=\"$item_id\" \\\n    -f fieldId=\"$field_id\" \\\n    -f value=\"$value\" 2>&1)\n  \n  # Check for errors\n  if echo \"$result\" | jq -e '.errors' >/dev/null 2>&1; then\n    log \"❌ GraphQL error updating project item field:\"\n    echo \"$result\" | jq '.errors' >&2\n    return 1\n  fi\n  \n  # Verify update succeeded\n  local updated_item_id=$(echo \"$result\" | jq -r '.data.updateProjectV2ItemFieldValue.projectV2Item.id // \"\"')\n  \n  if [[ -z \"$updated_item_id\" ]] || [[ \"$updated_item_id\" == \"null\" ]]; then\n    log \"⚠️  Update returned but no item ID confirmed\"\n    return 1\n  fi\n  \n  return 0\n}\n\n# ============================================================================\n# BRANCH PROTECTION\n# ============================================================================\n\nenable_branch_protection() {\n  local owner=\"$1\"\n  local repo=\"$2\"\n  local branch=\"${3:-main}\"\n  \n  log \"\U0001F512 Enabling branch protection for $owner/$repo:$branch\"\n  \n  # Branch protection configuration\n  # - Require pull request reviews before merging\n  # - Dismiss stale reviews when new commits are pushed\n  # - No direct pushes to protected branch (enforce for admins too)\n  # - Require status checks to pass (if any)\n  local protection_config='{\n    \"required_status_checks\": null,\n    \"enforce_admins\": true,\n    \"required_pull_request_reviews\": {\n      \"dismiss_stale_reviews\": true,\n      \"require_code_owner_reviews\": false,\n      \"required_approving_review_count\": 1\n    },\n    \"restrictions\": null,\n    \"allow_force_pushes\": false,\n    \"allow_deletions\": false,\n    \"required_conversation_resolution\": false\n  }'\n  \n  # Use GitHub CLI to enable branch protection\n  local result=$(echo \"$protection_config\" | gh api \\\n    -X PUT \\\n    -H \"Accept: application/vnd.github+json\" \\\n    \"/repos/$owner/$repo/branches/$branch/protection\" \\\n    --input - 2>&1)\n  \n  local exit_code=$?\n  \n  if [ $exit_code -eq 0 ]; then\n    log \"✅ Branch protection enabled for $branch\"\n    return 0\n  else\n    # Check if branch doesn't exist yet\n    if echo \"$result\" | grep -qi \"not found\"; then\n      log \"⚠️  Branch $branch not found yet, protection will need to be enabled after first push\"\n      return 0\n    fi\n    \n    log \"⚠️  Failed to enable branch protection (may lack permissions)\"\n    log \"Error: $result\"\n    # Don't fail the whole workflow for this\n    return 0\n  fi\n}\n\n# Export functions for use in other scripts\nexport -f graphql_query\nexport -f retry_with_backoff\nexport -f get_repository_id\nexport -f get_or_create_project_smart\nexport -f get_or_create_repo_project\nexport -f get_or_create_org_project\nexport -f ensure_project_linked_to_repository\nexport -f setup_custom_fields\nexport -f create_single_select_field\nexport -f create_text_field\nexport -f get_project_field\nexport -f add_issue_to_project\nexport -f set_project_item_stage\nexport -f set_project_item_agent\nexport -f set_project_item_priority\nexport -f get_field_option_id\nexport -f update_project_item_field\nexport -f enable_branch_protection\n\n"
  morgan-pm.sh.hbs: "#!/bin/bash\nset -euo pipefail\n\n# Morgan Project Manager - GitHub Projects Integration\n# Runs as a daemon throughout the Play workflow lifecycle\n# Manages GitHub Project, Issues, and synchronizes with TaskMaster\n\necho \"\U0001F3AF MORGAN - Project Manager Mode\"\necho \"Repository: {{repository_url}}\"\necho \"Workflow: $WORKFLOW_NAME\"\necho \"Namespace: $NAMESPACE\"\n\n# ============================================================================\n# GITHUB APP AUTHENTICATION\n# ============================================================================\n\necho \"\U0001F510 Authenticating with GitHub App...\"\n\nif [ -n \"${GITHUB_APP_PRIVATE_KEY:-}\" ] && [ -n \"${GITHUB_APP_ID:-}\" ]; then\n    # Create temporary key file\n    TEMP_KEY_FILE=\"/tmp/github-app-key-$$\"\n    echo \"$GITHUB_APP_PRIVATE_KEY\" > \"$TEMP_KEY_FILE\"\n    chmod 600 \"$TEMP_KEY_FILE\"\n\n    # Generate JWT token for GitHub App authentication\n    JWT_TOKEN=$(ruby -r openssl -r json -r base64 -e \"\n    key = OpenSSL::PKey::RSA.new(File.read('$TEMP_KEY_FILE'))\n    payload = {\n        iat: Time.now.to_i - 60,\n        exp: Time.now.to_i + (10 * 60),\n        iss: '$GITHUB_APP_ID'\n    }\n    header = { alg: 'RS256', typ: 'JWT' }\n\n    header_enc = Base64.urlsafe_encode64(header.to_json).gsub('=', '')\n    payload_enc = Base64.urlsafe_encode64(payload.to_json).gsub('=', '')\n    signature = Base64.urlsafe_encode64(key.sign(OpenSSL::Digest::SHA256.new, \\\"#{header_enc}.#{payload_enc}\\\")).gsub('=', '')\n\n    puts \\\"#{header_enc}.#{payload_enc}.#{signature}\\\"\n    \")\n\n    echo \"✓ Generated JWT token\"\n\n    # Parse repository info early\n    REPO_URL=\"{{repository_url}}\"\n    \n    # Handle both full URL and short format (owner/repo)\n    if [[ \"$REPO_URL\" =~ github\\.com[:/]([^/]+)/([^/\\.]+)(\\.git)?$ ]]; then\n        # Full URL format: https://github.com/owner/repo or git@github.com:owner/repo.git\n        REPO_OWNER=\"${BASH_REMATCH[1]}\"\n        REPO_NAME=\"${BASH_REMATCH[2]}\"\n    elif [[ \"$REPO_URL\" =~ ^([^/]+)/([^/]+)$ ]]; then\n        # Short format: owner/repo (allows dots in repo name)\n        REPO_OWNER=\"${BASH_REMATCH[1]}\"\n        REPO_NAME=\"${BASH_REMATCH[2]}\"\n    else\n        echo \"❌ Failed to parse repository URL: $REPO_URL\"\n        echo \"Expected formats: 'owner/repo' or 'https://github.com/owner/repo'\"\n        exit 1\n    fi\n\n    # Get installation ID for the repository\n    INSTALLATION_RESPONSE=$(curl -s -H \"Authorization: Bearer $JWT_TOKEN\" \\\n        -H \"Accept: application/vnd.github+json\" \\\n        \"https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation\")\n\n    INSTALLATION_ID=$(echo \"$INSTALLATION_RESPONSE\" | jq -r '.id')\n\n    # If repo installation failed, try organization installation\n    if [ \"$INSTALLATION_ID\" = \"null\" ] || [ -z \"$INSTALLATION_ID\" ]; then\n        echo \"⚠️  No repo installation, trying organization...\"\n        ORG_INSTALLATION_RESPONSE=$(curl -s -H \"Authorization: Bearer $JWT_TOKEN\" \\\n            -H \"Accept: application/vnd.github+json\" \\\n            \"https://api.github.com/orgs/$REPO_OWNER/installation\")\n        \n        INSTALLATION_ID=$(echo \"$ORG_INSTALLATION_RESPONSE\" | jq -r '.id')\n    fi\n\n    if [ \"$INSTALLATION_ID\" = \"null\" ] || [ -z \"$INSTALLATION_ID\" ]; then\n        echo \"❌ Failed to get installation ID for $REPO_OWNER/$REPO_NAME\"\n        echo \"Response: $INSTALLATION_RESPONSE\"\n        rm -f \"$TEMP_KEY_FILE\"\n        exit 1\n    fi\n\n    echo \"✓ Installation ID: $INSTALLATION_ID\"\n\n    # Get installation access token\n    TOKEN_RESPONSE=$(curl -s -X POST \\\n        -H \"Authorization: Bearer $JWT_TOKEN\" \\\n        -H \"Accept: application/vnd.github+json\" \\\n        \"https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens\")\n\n    GITHUB_TOKEN=$(echo \"$TOKEN_RESPONSE\" | jq -r '.token')\n\n    if [ \"$GITHUB_TOKEN\" = \"null\" ] || [ -z \"$GITHUB_TOKEN\" ]; then\n        echo \"❌ Failed to get installation access token\"\n        echo \"Response: $TOKEN_RESPONSE\"\n        rm -f \"$TEMP_KEY_FILE\"\n        exit 1\n    fi\n\n    # Clean up temporary key file\n    rm -f \"$TEMP_KEY_FILE\"\n\n    # Export the token for git and gh CLI\n    export GITHUB_TOKEN\n\n    # Configure git to use the token\n    git config --global --replace-all credential.helper store\n    echo \"https://x-access-token:${GITHUB_TOKEN}@github.com\" > ~/.git-credentials\n\n    # Note: gh CLI will automatically use GITHUB_TOKEN env var\n    # No explicit auth login needed\n\n    echo \"✅ GitHub App authenticated successfully\"\n\n    # Configure git safe directories\n    git config --global --add safe.directory /workspace\n    git config --global --add safe.directory /tmp/docs-repo\n\nelse\n    echo \"❌ GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found\"\n    exit 1\nfi\n\n# ============================================================================\n# CONFIGURATION\n# ============================================================================\n\necho \"\U0001F50D DEBUG: Configuration\"\necho \"  DOCS_REPOSITORY: ${DOCS_REPOSITORY:-NOT SET}\"\necho \"  DOCS_BRANCH: ${DOCS_BRANCH:-NOT SET}\"\necho \"  DOCS_PROJECT_DIRECTORY: ${DOCS_PROJECT_DIRECTORY:-NOT SET}\"\necho \"  SERVICE_NAME: ${SERVICE_NAME:-NOT SET}\"\n\n# Normalize DOCS_REPOSITORY to full URL if needed\nDOCS_REPO_INPUT=\"${DOCS_REPOSITORY}\"\nif [[ \"$DOCS_REPO_INPUT\" =~ ^https?:// ]] || [[ \"$DOCS_REPO_INPUT\" =~ ^git@ ]]; then\n    # Already a full URL\n    DOCS_REPO=\"$DOCS_REPO_INPUT\"\nelse\n    # Short format (owner/repo) - convert to HTTPS URL\n    DOCS_REPO=\"https://github.com/$DOCS_REPO_INPUT\"\nfi\n\nDOCS_BRANCH=\"${DOCS_BRANCH:-main}\"\nDOCS_DIR=\"${DOCS_PROJECT_DIRECTORY}\"\nSERVICE_NAME=\"${SERVICE_NAME}\"\n\necho \"\U0001F50D DEBUG: Normalized DOCS_REPO to: $DOCS_REPO\"\n\n# Shared state directory\nSHARED_DIR=\"/shared/morgan-pm\"\nmkdir -p \"$SHARED_DIR\"\n\nTASK_ISSUE_MAP=\"$SHARED_DIR/task-issue-map.json\"\nPROJECT_CONFIG=\"$SHARED_DIR/project-config.json\"\nSYNC_LOG=\"$SHARED_DIR/sync.log\"\nTASK_STATE_CACHE=\"$SHARED_DIR/task-state-cache.json\"\n\necho \"\U0001F50D DEBUG: Sourcing helper functions...\"\n# Source helper functions\nsource /shared/github-projects-helpers.sh || {\n  echo \"❌ Failed to source github-projects-helpers.sh\"\n  exit 1\n}\n\necho \"\U0001F4E6 Repository: $REPO_OWNER/$REPO_NAME\"\necho \"\U0001F50D DEBUG: Starting initialization...\"\n\n# ============================================================================\n# HELPER FUNCTIONS\n# ============================================================================\n\nlog() {\n  echo \"[$(date -u +\"%Y-%m-%d %H:%M:%S UTC\")] $*\" | tee -a \"$SYNC_LOG\" >&2\n}\n\npersist_project_config() {\n  local project_id=\"$1\"\n  local project_title=\"${2:-${PROJECT_TITLE:-\"$SERVICE_NAME - TaskMaster Workflow\"}}\"\n  local workflow=\"${3:-$WORKFLOW_NAME}\"\n  local repository=\"${4:-$REPO_OWNER/$REPO_NAME}\"\n\n  if [[ -z \"$project_id\" ]] || [[ \"$project_id\" == \"null\" ]]; then\n    log \"❌ Cannot persist project config - project_id is empty\"\n    return 1\n  fi\n\n  mkdir -p \"$SHARED_DIR\"\n\n  cat > \"$PROJECT_CONFIG\" <<EOF\n{\n  \"project_id\": \"$project_id\",\n  \"project_title\": \"$project_title\",\n  \"workflow_name\": \"$workflow\",\n  \"repository\": \"$repository\",\n  \"created_at\": \"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\"\n}\nEOF\n\n  log \"\U0001F4BE Persisted project configuration to $PROJECT_CONFIG\"\n}\n\nensure_project_config_loaded() {\n  if [[ -f \"$PROJECT_CONFIG\" ]]; then\n    local stored_project_id=$(jq -r '.project_id // empty' \"$PROJECT_CONFIG\" 2>/dev/null || echo \"\")\n    if [[ -n \"$stored_project_id\" ]] && [[ \"$stored_project_id\" != \"null\" ]]; then\n      PROJECT_ID=\"$stored_project_id\"\n      return 0\n    fi\n    log \"⚠️  project-config.json exists but is invalid - attempting to repair\"\n  fi\n\n  if [[ -n \"${PROJECT_ID:-}\" ]] && [[ \"$PROJECT_ID\" != \"null\" ]]; then\n    log \"⚠️  project-config.json missing - recreating from in-memory state\"\n    persist_project_config \"$PROJECT_ID\" \"$PROJECT_TITLE\" \"$WORKFLOW_NAME\" \"$REPO_OWNER/$REPO_NAME\"\n    return 0\n  fi\n\n  log \"❌ Project configuration missing project_id\"\n  return 1\n}\n\n# State tracking helpers to prevent duplicate comments\ninit_state_cache() {\n  if [[ ! -f \"$TASK_STATE_CACHE\" ]]; then\n    echo \"{}\" > \"$TASK_STATE_CACHE\"\n  fi\n}\n\nget_cached_state() {\n  local task_id=\"$1\"\n  jq -r --arg tid \"$task_id\" '.[$tid] // \"{}\"' \"$TASK_STATE_CACHE\" 2>/dev/null || echo \"{}\"\n}\n\nupdate_cached_state() {\n  local task_id=\"$1\"\n  local stage=\"$2\"\n  local agent=\"$3\"\n  local status=\"$4\"\n  local phase=\"$5\"\n  \n  local temp_cache=$(mktemp)\n  jq --arg tid \"$task_id\" \\\n     --arg stage \"$stage\" \\\n     --arg agent \"$agent\" \\\n     --arg status \"$status\" \\\n     --arg phase \"$phase\" \\\n     --arg timestamp \"$(date +%s)\" \\\n     '.[$tid] = {\n       \"stage\": $stage,\n       \"agent\": $agent,\n       \"status\": $status,\n       \"phase\": $phase,\n       \"last_update\": $timestamp\n     }' \"$TASK_STATE_CACHE\" > \"$temp_cache\"\n  mv \"$temp_cache\" \"$TASK_STATE_CACHE\"\n}\n\nhas_state_changed() {\n  local task_id=\"$1\"\n  local new_stage=\"$2\"\n  local new_agent=\"$3\"\n  local new_status=\"$4\"\n  local new_phase=\"$5\"\n  \n  local cached=$(get_cached_state \"$task_id\")\n  \n  # If no cached state, it's a change (first time)\n  if [[ \"$cached\" == \"{}\" ]]; then\n    return 0\n  fi\n  \n  local cached_stage=$(echo \"$cached\" | jq -r '.stage // \"\"')\n  local cached_agent=$(echo \"$cached\" | jq -r '.agent // \"\"')\n  local cached_status=$(echo \"$cached\" | jq -r '.status // \"\"')\n  local cached_phase=$(echo \"$cached\" | jq -r '.phase // \"\"')\n  \n  # Return 0 (true) if anything changed\n  if [[ \"$new_stage\" != \"$cached_stage\" ]] || \\\n     [[ \"$new_agent\" != \"$cached_agent\" ]] || \\\n     [[ \"$new_status\" != \"$cached_status\" ]] || \\\n     [[ \"$new_phase\" != \"$cached_phase\" ]]; then\n    return 0\n  fi\n  \n  return 1\n}\n\n# ============================================================================\n# PHASE 1: INITIALIZATION\n# ============================================================================\n\ninitialize_project() {\n  echo \"\U0001F50D DEBUG: Entered initialize_project()\"\n  log \"\U0001F4CA Phase 1: Project Initialization\"\n  \n  # Clone docs repository to get TaskMaster data\n  log \"\U0001F4E5 Cloning documentation repository...\"\n  echo \"\U0001F50D DEBUG: DOCS_REPO=$DOCS_REPO, DOCS_BRANCH=$DOCS_BRANCH\"\n  TEMP_CLONE=\"/tmp/docs-repo\"\n  rm -rf \"$TEMP_CLONE\"\n  \n  echo \"\U0001F50D DEBUG: About to git clone...\"\n  git clone --depth 1 --branch \"$DOCS_BRANCH\" \"$DOCS_REPO\" \"$TEMP_CLONE\" || {\n    log \"❌ Failed to clone docs repository\"\n    echo \"❌ DEBUG: Git clone failed with exit code $?\"\n    exit 1\n  }\n  echo \"\U0001F50D DEBUG: Git clone succeeded\"\n  \n  cd \"$TEMP_CLONE/$DOCS_DIR\"\n  \n  # Find tasks.json\n  TASKS_JSON_PATH=\"\"\n  if [[ -f \".taskmaster/tasks/tasks.json\" ]]; then\n    TASKS_JSON_PATH=\".taskmaster/tasks/tasks.json\"\n  elif [[ -f \".taskmaster/docs/tasks.json\" ]]; then\n    TASKS_JSON_PATH=\".taskmaster/docs/tasks.json\"\n  else\n    log \"❌ TaskMaster tasks.json not found\"\n    exit 1\n  fi\n  \n  log \"✅ Found tasks.json at: $TASKS_JSON_PATH\"\n  \n  # Read tasks data\n  TASKS_DATA=$(cat \"$TASKS_JSON_PATH\")\n  \n  # Initialize PROJECT_ID (will be set from config or created new)\n  PROJECT_ID=\"\"\n  \n  # Check if FORCE_NEW_PROJECT is set to skip reusing old projects\n  if [[ \"${FORCE_NEW_PROJECT:-false}\" == \"true\" ]]; then\n    log \"\U0001F504 FORCE_NEW_PROJECT=true, will create fresh project\"\n    if [[ -f \"$PROJECT_CONFIG\" ]]; then\n      log \"\U0001F5D1️  Removing old project config: $PROJECT_CONFIG\"\n      rm -f \"$PROJECT_CONFIG\"\n    fi\n  else\n    # Check if we have an existing project configuration\n    if [[ -f \"$PROJECT_CONFIG\" ]]; then\n      PROJECT_ID=$(jq -r '.project_id' \"$PROJECT_CONFIG\" 2>/dev/null || echo \"\")\n      if [[ -n \"$PROJECT_ID\" ]] && [[ \"$PROJECT_ID\" != \"null\" ]]; then\n        log \"♻️  Found existing project ID: $PROJECT_ID\"\n        \n        # Validate the project is still accessible\n        log \"\U0001F50D Validating existing project is accessible...\"\n        if gh api graphql -f query=\"query { node(id: \\\"$PROJECT_ID\\\") { id } }\" > /dev/null 2>&1; then\n          log \"✅ Project is accessible, reusing it\"\n        else\n          log \"⚠️  Existing project is not accessible (may be deleted/closed)\"\n          log \"\U0001F504 Will create a new project instead\"\n          PROJECT_ID=\"\"\n          rm -f \"$PROJECT_CONFIG\"\n        fi\n      else\n        log \"⚠️  Existing project config is invalid, will create new project\"\n        PROJECT_ID=\"\"\n      fi\n    fi\n  fi\n  \n  # Get or create GitHub Project if we don't have one\n  if [[ -z \"$PROJECT_ID\" ]] || [[ \"$PROJECT_ID\" == \"null\" ]]; then\n    log \"\U0001F3D7️  Setting up GitHub Project...\"\n    log \"\U0001F50D DEBUG: REPO_OWNER=$REPO_OWNER, REPO_NAME=$REPO_NAME, SERVICE_NAME=$SERVICE_NAME\"\n    \n    PROJECT_TITLE=\"$SERVICE_NAME - TaskMaster Workflow\"\n    log \"\U0001F50D DEBUG: PROJECT_TITLE=$PROJECT_TITLE\"\n    \n    # Try to create project with smart fallback\n    # Prefers org-level for better visibility, falls back to repo-level if issues\n    # Set PREFER_REPO_LEVEL_PROJECTS=true env var to change behavior\n    local prefer_repo=\"${PREFER_REPO_LEVEL_PROJECTS:-false}\"\n    PROJECT_ID=$(get_or_create_project_smart \"$REPO_OWNER\" \"$REPO_NAME\" \"$PROJECT_TITLE\" \"$prefer_repo\")\n    \n    if [[ -z \"$PROJECT_ID\" ]] || [[ \"$PROJECT_ID\" == \"null\" ]]; then\n      log \"❌ Failed to create or find project\"\n      log \"\U0001F50D DEBUG: PROJECT_ID returned: '$PROJECT_ID'\"\n      exit 1\n    fi\n  fi\n  \n  log \"✅ Project ID: $PROJECT_ID\"\n  \n  # CRITICAL: Verify project is linked to repository\n  # This is essential for issues to be addable to the project\n  if ! ensure_project_linked_to_repository \"$PROJECT_ID\" \"$REPO_OWNER\" \"$REPO_NAME\"; then\n    log \"❌ FATAL: Could not verify project-repository link\"\n    log \"\U0001F4A1 This will prevent issues from being added to the project\"\n    log \"\U0001F4A1 Continuing anyway, but expect linking failures...\"\n  fi\n  \n  # Setup custom fields\n  log \"\U0001F527 Setting up custom fields...\"\n  setup_custom_fields \"$PROJECT_ID\"\n  \n  # Enable branch protection on main branch\n  log \"\U0001F512 Configuring branch protection...\"\n  enable_branch_protection \"$REPO_OWNER\" \"$REPO_NAME\" \"main\"\n  \n  # Store project configuration\n  persist_project_config \"$PROJECT_ID\" \"$PROJECT_TITLE\" \"$WORKFLOW_NAME\" \"$REPO_OWNER/$REPO_NAME\"\n  \n  log \"✅ Project initialization complete\"\n}\n\n# ============================================================================\n# PHASE 2: ISSUE CREATION\n# ============================================================================\n\ncreate_task_issues() {\n  # Check if issue creation should be skipped (PR-only tracking)\n  if [[ \"${SKIP_ISSUE_CREATION:-false}\" == \"true\" ]]; then\n    log \"⏭️  Phase 2: Skipped (SKIP_ISSUE_CREATION=true)\"\n    log \"\U0001F4CB Morgan will track PRs only (no initial issues created)\"\n    echo \"{}\" > \"$TASK_ISSUE_MAP\"\n    return 0\n  fi\n  \n  log \"\U0001F4DD Phase 2: Creating Issues for Tasks\"\n  \n  cd \"$TEMP_CLONE/$DOCS_DIR\"\n  \n  # Clean up old issues from previous workflow runs\n  log \"\U0001F9F9 Checking for old issues from previous workflow runs...\"\n  OLD_ISSUES=$(gh issue list \\\n    --repo \"$REPO_OWNER/$REPO_NAME\" \\\n    --state open \\\n    --label \"taskmaster-task\" \\\n    --json number,labels \\\n    --jq --arg current_workflow \"workflow-$WORKFLOW_NAME\" \\\n      '[.[] | select(.labels | map(.name) | any(. == \"taskmaster-task\")) | \n       select(.labels | map(.name) | any(startswith(\"workflow-\")) and . != $current_workflow) | .number] | .[]' \\\n    2>/dev/null || echo \"\")\n  \n  if [[ -n \"$OLD_ISSUES\" ]]; then\n    OLD_COUNT=$(echo \"$OLD_ISSUES\" | wc -w)\n    log \"\U0001F5D1️  Found $OLD_COUNT old issue(s) from previous runs - closing them...\"\n    for issue_num in $OLD_ISSUES; do\n      log \"  Closing issue #$issue_num\"\n      gh issue close \"$issue_num\" \\\n        --repo \"$REPO_OWNER/$REPO_NAME\" \\\n        --comment \"\U0001F504 Closing this issue as a new workflow run has been initiated. New issues will be created for the latest run.\" \\\n        2>/dev/null || log \"⚠️  Failed to close issue #$issue_num\"\n    done\n    log \"✅ Closed $OLD_COUNT old issue(s)\"\n  else\n    log \"✅ No old issues found to clean up\"\n  fi\n  \n  # Initialize task-issue mapping\n  echo \"{}\" > \"$TASK_ISSUE_MAP\"\n  \n  # Get master/default tag tasks (or all tasks if no tags)\n  TASKS=$(echo \"$TASKS_DATA\" | jq -c '.tasks // .master.tasks // []')\n  \n  if [[ \"$TASKS\" == \"[]\" ]] || [[ \"$TASKS\" == \"null\" ]]; then\n    log \"⚠️  No tasks found in tasks.json\"\n    return 0\n  fi\n  \n  TASK_COUNT=$(echo \"$TASKS\" | jq '. | length')\n  log \"\U0001F4CA Found $TASK_COUNT tasks to create issues for\"\n  \n  echo \"$TASKS\" | jq -c '.[]' | while read -r task; do\n    TASK_ID=$(echo \"$task\" | jq -r '.id')\n    TASK_TITLE=$(echo \"$task\" | jq -r '.title')\n    TASK_STATUS=$(echo \"$task\" | jq -r '.status // \"pending\"')\n    TASK_PRIORITY=$(echo \"$task\" | jq -r '.priority // \"medium\"')\n\n    # Check if issue already exists for this task (prevent duplicates on resume)\n    # Check both open and closed issues to handle cases where issues were closed\n    log \"\U0001F50D Checking for existing issue for task-$TASK_ID...\"\n    EXISTING_ISSUE=$(gh issue list \\\n      --repo \"$REPO_OWNER/$REPO_NAME\" \\\n      --state all \\\n      --label \"task-$TASK_ID\" \\\n      --json number,title,state \\\n      --jq '.[0] | if . then {number: .number, state: .state} else empty end' 2>/dev/null || echo \"\")\n    \n    EXISTING_ISSUE_NUMBER=$(echo \"$EXISTING_ISSUE\" | jq -r '.number // empty' 2>/dev/null || echo \"\")\n    EXISTING_ISSUE_STATE=$(echo \"$EXISTING_ISSUE\" | jq -r '.state // empty' 2>/dev/null || echo \"\")\n\n    if [[ -n \"$EXISTING_ISSUE_NUMBER\" ]]; then\n      if [[ \"$EXISTING_ISSUE_STATE\" == \"CLOSED\" ]]; then\n        log \"\U0001F504 Found closed issue #$EXISTING_ISSUE_NUMBER for task-$TASK_ID - reopening it\"\n        gh issue reopen \"$EXISTING_ISSUE_NUMBER\" \\\n          --repo \"$REPO_OWNER/$REPO_NAME\" \\\n          2>/dev/null || log \"⚠️  Could not reopen issue #$EXISTING_ISSUE_NUMBER\"\n      fi\n      log \"✅ Issue already exists: #$EXISTING_ISSUE_NUMBER (task-$TASK_ID, state: ${EXISTING_ISSUE_STATE:-open})\"\n      ISSUE_NUMBER=\"$EXISTING_ISSUE_NUMBER\"\n      \n      local ISSUE_DATA=$(gh issue view \"$ISSUE_NUMBER\" \\\n        --repo \"$REPO_OWNER/$REPO_NAME\" \\\n        --json id,projectItems 2>/dev/null || echo \"\")\n      \n      ISSUE_NODE_ID=$(echo \"$ISSUE_DATA\" | jq -r '.id // empty')\n      ITEM_ID=$(echo \"$ISSUE_DATA\" | jq -r --arg pid \"$PROJECT_ID\" \\\n        '(.projectItems // []) | map(select(.project.id == $pid)) | .[0].id // \"\"')\n      \n      if [[ -z \"$ITEM_ID\" ]]; then\n        log \"⚠️  Existing issue #$ISSUE_NUMBER not linked to project - linking now\"\n        \n        if [[ -z \"$ISSUE_NODE_ID\" ]]; then\n          ISSUE_NODE_ID=$(gh issue view \"$ISSUE_NUMBER\" \\\n            --repo \"$REPO_OWNER/$REPO_NAME\" \\\n            --json id --jq '.id' 2>/dev/null || echo \"\")\n        fi\n        \n        if [[ -z \"$ISSUE_NODE_ID\" ]]; then\n          log \"❌ Could not determine node ID for issue #$ISSUE_NUMBER\"\n          continue\n        fi\n        \n        if ! ITEM_ID=$(retry_with_backoff 3 \"Link existing issue #$ISSUE_NUMBER to project\" \\\n          add_issue_to_project \"$PROJECT_ID\" \"$ISSUE_NODE_ID\" \"$ISSUE_NUMBER\"); then\n          log \"❌ Failed to link issue #$ISSUE_NUMBER to project\"\n          continue\n        fi\n      fi\n      \n      GITHUB_STAGE=$(map_taskmaster_status_to_stage \"$TASK_STATUS\")\n      retry_with_backoff 3 \"Set stage for task $TASK_ID\" \\\n        set_project_item_stage \"$PROJECT_ID\" \"$ITEM_ID\" \"$GITHUB_STAGE\"\n      \n      retry_with_backoff 3 \"Set priority for task $TASK_ID\" \\\n        set_project_item_priority \"$PROJECT_ID\" \"$ITEM_ID\" \"$TASK_PRIORITY\"\n      \n      TEMP_MAP=$(mktemp)\n      jq --arg task_id \"$TASK_ID\" \\\n         --arg issue_num \"$ISSUE_NUMBER\" \\\n         --arg item_id \"$ITEM_ID\" \\\n         --arg node_id \"${ISSUE_NODE_ID:-}\" \\\n         '.[$task_id] = {\n           \"issue_number\": ($issue_num | tonumber),\n           \"item_id\": $item_id,\n           \"node_id\": $node_id\n         }' \"$TASK_ISSUE_MAP\" > \"$TEMP_MAP\"\n      mv \"$TEMP_MAP\" \"$TASK_ISSUE_MAP\"\n      continue\n    fi\n\n    log \"\U0001F4CC Creating new issue for Task $TASK_ID: $TASK_TITLE\"\n\n    # Generate issue body from task details\n    ISSUE_BODY=$(generate_issue_body \"$task\" \"$TASKS_JSON_PATH\")\n\n    # Debug: Check if body was generated\n    if [[ -z \"$ISSUE_BODY\" ]]; then\n      log \"⚠️  Failed to generate issue body for task $TASK_ID\"\n      continue\n    fi\n\n    log \"\U0001F50D DEBUG: Issue body length: ${#ISSUE_BODY} characters\"\n\n    # Create GitHub issue with workflow-specific labels\n    # First, create issue without labels (labels might not exist)\n    ISSUE_CREATE_OUTPUT=$(gh issue create \\\n      --repo \"$REPO_OWNER/$REPO_NAME\" \\\n      --title \"Task $TASK_ID: $TASK_TITLE\" \\\n      --body \"$ISSUE_BODY\" \\\n      2>&1 || echo \"ERROR\")\n    \n    log \"\U0001F50D DEBUG: Issue create output: $ISSUE_CREATE_OUTPUT\"\n    \n    if [[ \"$ISSUE_CREATE_OUTPUT\" == \"ERROR\" ]] || [[ \"$ISSUE_CREATE_OUTPUT\" == *\"error\"* ]] || [[ \"$ISSUE_CREATE_OUTPUT\" == *\"failed\"* ]]; then\n      log \"⚠️  Failed to create issue for task $TASK_ID\"\n      log \"Error details: $ISSUE_CREATE_OUTPUT\"\n      continue\n    fi\n    \n    # Extract issue number using portable method (Alpine grep doesn't support -P)\n    ISSUE_NUMBER=$(echo \"$ISSUE_CREATE_OUTPUT\" | grep -Eo '[0-9]+$' | tail -1 || echo \"\")\n    \n    if [[ -z \"$ISSUE_NUMBER\" ]]; then\n      log \"⚠️  Could not extract issue number for task $TASK_ID\"\n      log \"Output was: $ISSUE_CREATE_OUTPUT\"\n      continue\n    fi\n    \n    log \"✅ Created issue #$ISSUE_NUMBER for task $TASK_ID\"\n    \n    # Add labels to the issue (create if they don't exist with bright, angelic colors)\n    log \"\U0001F3F7️  Adding labels to issue #$ISSUE_NUMBER...\"\n    gh label create \"taskmaster-task\" --repo \"$REPO_OWNER/$REPO_NAME\" --color \"1d76db\" --description \"TaskMaster managed task\" --force 2>/dev/null || true\n    gh label create \"task-$TASK_ID\" --repo \"$REPO_OWNER/$REPO_NAME\" --color \"0e8a16\" --description \"Task ID correlation\" --force 2>/dev/null || true\n    gh label create \"priority-$TASK_PRIORITY\" --repo \"$REPO_OWNER/$REPO_NAME\" --color \"$(get_priority_color \"$TASK_PRIORITY\")\" --description \"Task priority level\" --force 2>/dev/null || true\n    gh label create \"status-$TASK_STATUS\" --repo \"$REPO_OWNER/$REPO_NAME\" --color \"$(get_status_color \"$TASK_STATUS\")\" --description \"Current task status\" --force 2>/dev/null || true\n    gh label create \"workflow-$WORKFLOW_NAME\" --repo \"$REPO_OWNER/$REPO_NAME\" --color \"5319e7\" --description \"Workflow correlation\" --force 2>/dev/null || true\n    \n    # Apply labels to issue\n    gh issue edit \"$ISSUE_NUMBER\" \\\n      --repo \"$REPO_OWNER/$REPO_NAME\" \\\n      --add-label \"taskmaster-task,task-$TASK_ID,priority-$TASK_PRIORITY,status-$TASK_STATUS,workflow-$WORKFLOW_NAME\" \\\n      2>/dev/null || log \"⚠️  Could not add all labels to issue #$ISSUE_NUMBER\"\n    \n    # Get issue node ID for GraphQL\n    ISSUE_NODE_ID=$(gh issue view \"$ISSUE_NUMBER\" \\\n      --repo \"$REPO_OWNER/$REPO_NAME\" \\\n      --json id --jq '.id')\n    \n    # Add issue to project with retry logic\n    ensure_project_config_loaded || {\n      log \"❌ Cannot link issues without project configuration\"\n      exit 1\n    }\n    PROJECT_ID=$(jq -r '.project_id' \"$PROJECT_CONFIG\")\n    ITEM_ID=\"\"\n    \n    # Retry adding issue to project (handles transient failures)\n    if ! ITEM_ID=$(retry_with_backoff 3 \"Link issue #$ISSUE_NUMBER to project\" \\\n      add_issue_to_project \"$PROJECT_ID\" \"$ISSUE_NODE_ID\" \"$ISSUE_NUMBER\"); then\n      log \"❌ CRITICAL: Failed to add issue #$ISSUE_NUMBER to project after retries\"\n      log \"\U0001F4A1 Continuing with other tasks, but this issue won't appear in project\"\n      continue\n    fi\n    \n    # Verify we got a valid item ID\n    if [[ -z \"$ITEM_ID\" ]] || [[ \"$ITEM_ID\" == \"null\" ]]; then\n      log \"❌ No valid item ID returned for issue #$ISSUE_NUMBER\"\n      continue\n    fi\n    \n    if [[ -n \"$ITEM_ID\" ]]; then\n      log \"✅ Added issue #$ISSUE_NUMBER to project (Item ID: $ITEM_ID)\"\n      \n      # Map TaskMaster status to GitHub Project Stage value (agent-based)\n      GITHUB_STAGE=$(map_taskmaster_status_to_stage \"$TASK_STATUS\")\n      log \"\U0001F50D Mapping TaskMaster status '$TASK_STATUS' → GitHub Stage (Agent) '$GITHUB_STAGE'\"\n      \n      # Set initial field values with retry\n      retry_with_backoff 3 \"Set stage for task $TASK_ID\" \\\n        set_project_item_stage \"$PROJECT_ID\" \"$ITEM_ID\" \"$GITHUB_STAGE\"\n      \n      retry_with_backoff 3 \"Set priority for task $TASK_ID\" \\\n        set_project_item_priority \"$PROJECT_ID\" \"$ITEM_ID\" \"$TASK_PRIORITY\"\n      \n      # Note: No assignee set on creation to keep this public-friendly\n      # Agent assignment comments will be posted when tasks move to active agents\n      \n      # Store mapping\n      TEMP_MAP=$(mktemp)\n      jq --arg task_id \"$TASK_ID\" \\\n         --arg issue_num \"$ISSUE_NUMBER\" \\\n         --arg item_id \"$ITEM_ID\" \\\n         --arg node_id \"$ISSUE_NODE_ID\" \\\n         '.[$task_id] = {\n           \"issue_number\": ($issue_num | tonumber),\n           \"item_id\": $item_id,\n           \"node_id\": $node_id\n         }' \"$TASK_ISSUE_MAP\" > \"$TEMP_MAP\"\n      mv \"$TEMP_MAP\" \"$TASK_ISSUE_MAP\"\n    fi\n  done\n  \n  CREATED_COUNT=$(jq 'length' \"$TASK_ISSUE_MAP\")\n  log \"✅ Created $CREATED_COUNT issues and added to project\"\n}\n\n# ============================================================================\n# PHASE 3: CONTINUOUS MONITORING (EVENT-DRIVEN)\n# ============================================================================\n\nmonitor_and_sync() {\n  # Set monitoring phase flag so ERR trap is lenient\n  export MONITORING_PHASE=true\n  \n  log \"\U0001F440 Phase 3: Event-Driven Monitoring & Synchronization\"\n  log \"\U0001F504 Starting real-time workflow watch...\"\n  \n  ensure_project_config_loaded || {\n    log \"❌ Cannot start monitoring without project configuration\"\n    exit 1\n  }\n  PROJECT_ID=$(jq -r '.project_id' \"$PROJECT_CONFIG\")\n  \n  # Initialize state cache for deduplication\n  init_state_cache\n  \n  # Initial sync of all tasks\n  log \"\U0001F4CA Performing initial sync of all tasks...\"\n  log \"\U0001F50D This will detect any tasks that are already running\"\n  sync_all_tasks \"$PROJECT_ID\" true  # true = is_initial_sync\n  log \"✅ Initial sync complete - GitHub Projects updated with current state\"\n  \n  # Generate initial project summary\n  log \"\U0001F4CA Generating project summary...\"\n  update_project_summary \"$PROJECT_ID\"\n  log \"✅ Project summary complete\"\n  \n  # Background process to watch parent workflow\n  watch_parent_workflow &\n  PARENT_WATCH_PID=$!\n  \n  # Background process to periodically update summary and re-sync (every 2 minutes)\n  (\n    while true; do\n      sleep 120  # 2 minutes\n      log \"\U0001F504 Periodic re-sync (backup to event-driven monitoring)\"\n      sync_all_tasks \"$PROJECT_ID\" false 2>/dev/null || true  # false = not initial sync\n      update_project_summary \"$PROJECT_ID\" 2>/dev/null || true\n    done\n  ) &\n  SUMMARY_UPDATE_PID=$!\n  \n  # Main event loop: Watch all task workflows\n  log \"\U0001F441️  Watching for workflow changes (real-time)...\"\n  \n  # kubectl watch outputs JSON objects, but format varies\n  # We use --watch (not --watch-only) with proper buffering control\n  kubectl get workflows -n \"$NAMESPACE\" \\\n    -l \"parent-workflow=$WORKFLOW_NAME\" \\\n    --watch -o json 2>&1 | \\\n  stdbuf -oL cat | \\\n  while IFS= read -r line; do\n    # Skip empty lines\n    [[ -z \"$line\" ]] && continue\n    \n    # Skip non-JSON lines (kubernetes informational messages)\n    # Check if line starts with '{' or is likely JSON\n    if [[ ! \"$line\" =~ ^\\{ ]]; then\n      continue\n    fi\n    \n    # Validate JSON structure before parsing\n    if ! echo \"$line\" | jq empty 2>/dev/null; then\n      # Not valid JSON - skip silently (don't spam logs)\n      continue\n    fi\n    \n    # Determine if this is a watch event or direct object\n    local has_object=$(echo \"$line\" | jq 'has(\"object\")' 2>/dev/null || echo \"false\")\n    local has_metadata=$(echo \"$line\" | jq 'has(\"metadata\")' 2>/dev/null || echo \"false\")\n    \n    local workflow_obj=\"\"\n    \n    if [[ \"$has_object\" == \"true\" ]]; then\n      # Watch event format: {type: \"ADDED|MODIFIED|DELETED\", object: {...}}\n      EVENT_TYPE=$(echo \"$line\" | jq -r '.type // \"MODIFIED\"')\n      workflow_obj=$(echo \"$line\" | jq -c '.object')\n    elif [[ \"$has_metadata\" == \"true\" ]]; then\n      # Direct workflow object format (from --watch without events)\n      EVENT_TYPE=\"MODIFIED\"\n      workflow_obj=\"$line\"\n    else\n      # Unknown format - skip\n      continue\n    fi\n    \n    # Extract workflow details with robust error handling\n    TASK_ID=$(echo \"$workflow_obj\" | jq -r '.metadata.labels[\"task-id\"] // \"\"' 2>/dev/null)\n    WORKFLOW_NAME_LOCAL=$(echo \"$workflow_obj\" | jq -r '.metadata.name // \"\"' 2>/dev/null)\n    CURRENT_STAGE=$(echo \"$workflow_obj\" | jq -r '.metadata.labels[\"current-stage\"] // \"pending\"' 2>/dev/null)\n    WORKFLOW_PHASE=$(echo \"$workflow_obj\" | jq -r '.status.phase // \"Pending\"' 2>/dev/null)\n    \n    # Validate we got required fields\n    [[ -z \"$TASK_ID\" ]] && continue\n    [[ -z \"$WORKFLOW_NAME_LOCAL\" ]] && continue\n    \n    log \"\U0001F4E1 Workflow event: task-$TASK_ID ($EVENT_TYPE) - stage=$CURRENT_STAGE, phase=$WORKFLOW_PHASE\"\n    log \"\U0001F50D Event details: workflow=$WORKFLOW_NAME_LOCAL, namespace=$NAMESPACE\"\n    \n    # Track event processing metric\n    echo $(($(cat /tmp/morgan-events-processed 2>/dev/null || echo \"0\") + 1)) > /tmp/morgan-events-processed\n    \n    # Update GitHub based on ACTUAL cluster state\n    handle_task_event \"$PROJECT_ID\" \"$TASK_ID\" \"$WORKFLOW_NAME_LOCAL\" \"$CURRENT_STAGE\" \"$WORKFLOW_PHASE\" \"false\"\n  done\n  \n  # Cleanup background processes\n  kill $PARENT_WATCH_PID 2>/dev/null || true\n  kill $SUMMARY_UPDATE_PID 2>/dev/null || true\n  \n  # Final summary update\n  update_project_summary \"$PROJECT_ID\" 2>/dev/null || true\n  \n  log \"\U0001F389 Monitoring complete\"\n}\n\nwatch_parent_workflow() {\n  # Watch parent workflow in background\n  while true; do\n    WORKFLOW_STATUS=$(kubectl get workflow \"$WORKFLOW_NAME\" \\\n      -n \"$NAMESPACE\" \\\n      -o jsonpath='{.status.phase}' 2>/dev/null || echo \"NotFound\")\n    \n    if [[ \"$WORKFLOW_STATUS\" == \"Succeeded\" ]] || [[ \"$WORKFLOW_STATUS\" == \"Failed\" ]] || [[ \"$WORKFLOW_STATUS\" == \"Error\" ]]; then\n      log \"✅ Parent workflow completed with status: $WORKFLOW_STATUS\"\n      \n      # Trigger final sync\n      if ensure_project_config_loaded; then\n        PROJECT_ID=$(jq -r '.project_id' \"$PROJECT_CONFIG\")\n        sync_all_tasks \"$PROJECT_ID\" false  # false = not initial, check for changes\n      else\n        log \"⚠️  Skipping final sync - project configuration unavailable\"\n      fi\n      \n      # Kill main watch process\n      pkill -P $$ kubectl || true\n      exit 0\n    fi\n    \n    sleep 10\n  done\n}\n\nhandle_task_event() {\n  local project_id=\"$1\"\n  local task_id=\"$2\"\n  local workflow_name=\"$3\"\n  local current_stage=\"$4\"\n  local workflow_phase=\"$5\"\n  local is_sync=\"${6:-false}\"  # true for periodic sync, false for real-time events\n  \n  # Get issue details from mapping\n  local entry=$(jq -r --arg tid \"$task_id\" '.[$tid] // empty' \"$TASK_ISSUE_MAP\")\n  [[ -z \"$entry\" ]] && return 0\n  \n  local issue_number=$(echo \"$entry\" | jq -r '.issue_number')\n  local item_id=$(echo \"$entry\" | jq -r '.item_id')\n  \n  # CRITICAL: Check workflow phase FIRST - completed workflows override running agents\n  # This prevents edge case where pod is still running but workflow already succeeded\n  local current_agent=\"\"\n  if [[ \"$workflow_phase\" == \"Succeeded\" ]]; then\n    current_agent=\"Complete ✅\"\n    log \"✅ Workflow succeeded - marking as complete\"\n  elif [[ \"$workflow_phase\" == \"Failed\" ]] || [[ \"$workflow_phase\" == \"Error\" ]]; then\n    # For failed workflows, try to detect which agent failed\n    local failed_agent=$(get_actual_running_agent \"$task_id\" \"$workflow_name\")\n    if [[ -n \"$failed_agent\" ]]; then\n      current_agent=\"$failed_agent\"\n      log \"⚠️  Workflow failed while $current_agent was working\"\n    else\n      # Fall back to stage mapping for failed workflows\n      current_agent=$(map_stage_to_agent \"$current_stage\" \"$workflow_phase\")\n      log \"⚠️  Workflow failed, using stage mapping: $current_agent\"\n    fi\n  else\n    # Workflow still running - detect actual running agent from cluster\n    local actual_agent=$(get_actual_running_agent \"$task_id\" \"$workflow_name\")\n    \n    if [[ -n \"$actual_agent\" ]]; then\n      current_agent=\"$actual_agent\"\n      log \"✅ Using actual running agent from cluster: $current_agent\"\n    else\n      current_agent=$(map_stage_to_agent \"$current_stage\" \"$workflow_phase\")\n      log \"⚠️  No running agent detected, using stage mapping: $current_agent\"\n    fi\n  fi\n  \n  # Agent name IS the status in agent-based columns\n  local task_status=\"$current_agent\"\n  \n  # Check if state actually changed\n  local state_changed=false\n  if has_state_changed \"$task_id\" \"$current_stage\" \"$current_agent\" \"$task_status\" \"$workflow_phase\"; then\n    state_changed=true\n    log \"\U0001F504 State change detected for task-$task_id: $current_agent | $task_status\"\n  else\n    log \"⏭️  No change for task-$task_id (skipping comment posting)\"\n  fi\n  \n  # ═══════════════════════════════════════════════════════════\n  # CRITICAL: ALWAYS update project fields (idempotent, cheap operations)\n  # These GraphQL calls ensure project fields stay in sync\n  # even if deduplication skips comments\n  # ═══════════════════════════════════════════════════════════\n  # Use current_agent as the stage since we now have agent-based columns\n  # task_status and current_agent should be the same (both return agent name from mapping)\n  set_project_item_stage \"$project_id\" \"$item_id\" \"$current_agent\" || \\\n    log \"⚠️  Could not update project stage for item $item_id to $current_agent\"\n  \n  # ALWAYS update issue labels (idempotent)\n  update_issue_labels \"$issue_number\" \"$task_status\" \"$current_agent\"\n  \n  # ═══════════════════════════════════════════════════════════\n  # CONDITIONAL: ONLY post comments if state changed (prevents spam)\n  # ═══════════════════════════════════════════════════════════\n  if [[ \"$state_changed\" == true ]]; then\n    # Update issue assignee to current agent (posts comment)\n    update_issue_assignee \"$issue_number\" \"$current_agent\"\n    \n    # Add structured status history (posts comment)\n    add_status_history \"$issue_number\" \"$task_id\" \"$current_stage\" \"$current_agent\" \"$task_status\" \"$workflow_phase\"\n    \n    # Check for errors/failures (posts comment on errors)\n    check_task_health \"$task_id\" \"$workflow_name\" \"$current_stage\" \"$issue_number\"\n    \n    # Track and report agent progress (posts comment if progress found)\n    update_progress_comment \"$issue_number\" \"$task_id\" \"$workflow_name\" \"$current_stage\"\n    \n    # Stream significant agent activity (posts comment if events found)\n    stream_significant_events \"$task_id\" \"$workflow_name\" \"$issue_number\"\n  fi\n  \n  # ALWAYS update GitHub Checks API (PRs NOT added to project - linked via issue instead)\n  local pr_number=$(find_pr_for_task \"$task_id\")\n  if [[ -n \"$pr_number\" ]]; then\n    # Create/update GitHub check\n    create_or_update_github_check \"$task_id\" \"$pr_number\" \"$current_agent\" \"$current_stage\" \"$workflow_phase\"\n    \n    # NOTE: PRs are NOT added to project board to avoid duplication\n    # PRs are linked to issues via \"Closes #XXX\" in PR description\n    # This keeps one item per task in the project (the issue)\n  fi\n  \n  # ALWAYS update heartbeat (just logs)\n  update_heartbeat \"$issue_number\"\n  \n  # Update state cache after processing\n  update_cached_state \"$task_id\" \"$current_stage\" \"$current_agent\" \"$task_status\" \"$workflow_phase\"\n}\n\nsync_all_tasks() {\n  local project_id=\"$1\"\n  local is_initial_sync=\"${2:-false}\"\n  \n  log \"\U0001F504 Syncing all tasks with GitHub...\"\n  \n  # Iterate through all task mappings - use process substitution to avoid subshell\n  while read -r entry; do\n    TASK_ID=$(echo \"$entry\" | jq -r '.key')\n    \n    # Find workflow for this task\n    TASK_WORKFLOW=$(kubectl get workflows -n \"$NAMESPACE\" \\\n      -l \"task-id=$TASK_ID,parent-workflow=$WORKFLOW_NAME\" \\\n      -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo \"\")\n    \n    if [[ -z \"$TASK_WORKFLOW\" ]]; then\n      log \"⏭️  No workflow found for task-$TASK_ID (not started yet)\"\n      continue\n    fi\n    \n    # Get current stage from workflow labels\n    CURRENT_STAGE=$(kubectl get workflow \"$TASK_WORKFLOW\" \\\n      -n \"$NAMESPACE\" \\\n      -o jsonpath='{.metadata.labels.current-stage}' 2>/dev/null || echo \"pending\")\n    \n    # Get workflow phase\n    WORKFLOW_PHASE=$(kubectl get workflow \"$TASK_WORKFLOW\" \\\n      -n \"$NAMESPACE\" \\\n      -o jsonpath='{.status.phase}' 2>/dev/null || echo \"Pending\")\n    \n    log \"\U0001F50D Syncing task-$TASK_ID: stage=$CURRENT_STAGE, phase=$WORKFLOW_PHASE\"\n    \n    # Use the full event handler for updates\n    # Pass is_sync=true for periodic syncs to enable deduplication\n    local is_sync=\"true\"\n    if [[ \"$is_initial_sync\" == \"true\" ]]; then\n      is_sync=\"false\"  # Initial sync posts all comments (first time state detection)\n    fi\n    handle_task_event \"$project_id\" \"$TASK_ID\" \"$TASK_WORKFLOW\" \"$CURRENT_STAGE\" \"$WORKFLOW_PHASE\" \"$is_sync\"\n  done < <(jq -c 'to_entries[]' \"$TASK_ISSUE_MAP\")\n  \n  log \"✅ Sync complete\"\n}\n\nget_actual_running_agent() {\n  local task_id=\"$1\"\n  local workflow_name=\"$2\"\n  \n  log \"\U0001F50D Detecting actual running agent for task-$task_id from cluster...\"\n  \n  # Strategy 1: Check for RUNNING CodeRun pods (most accurate - shows who's working NOW)\n  # First try label selector (if controller propagates labels)\n  local running_pods=$(kubectl get pods -n \"$NAMESPACE\" \\\n    -l \"task-id=$task_id\" \\\n    --field-selector=status.phase=Running \\\n    -o json 2>/dev/null || echo \"{}\")\n  \n  # If no pods found by label, try by name pattern (coderun-*-t{task-id}-*)\n  if [[ \"$running_pods\" == \"{}\" ]] || [[ $(echo \"$running_pods\" | jq '.items | length') -eq 0 ]]; then\n    log \"\U0001F50D No pods found with task-id label, trying name pattern coderun-*-t${task_id}-*\"\n    running_pods=$(kubectl get pods -n \"$NAMESPACE\" \\\n      --field-selector=status.phase=Running \\\n      -o json 2>/dev/null | jq --arg tid \"$task_id\" \\\n      '{items: [.items[] | select(.metadata.name | test(\"coderun-.*-t\" + $tid + \"-\"))]}' || echo \"{}\")\n  fi  \n  if [[ \"$running_pods\" != \"{}\" ]]; then\n    local pod_count=$(echo \"$running_pods\" | jq -r '.items | length')\n    \n    if [[ \"$pod_count\" -gt 0 ]]; then\n      # Get agent from the most recent running pod\n      local agent=$(echo \"$running_pods\" | jq -r '.items | sort_by(.metadata.creationTimestamp) | last | .metadata.labels.agent // \"\"')\n      \n      # If no agent label, try to extract from pod name (coderun-{service}-t{task-id}-{stage}-*)\n      if [[ -z \"$agent\" ]]; then\n        local pod_name=$(echo \"$running_pods\" | jq -r '.items | sort_by(.metadata.creationTimestamp) | last | .metadata.name // \"\"')\n        log \"\U0001F50D Pod name: $pod_name, checking ownerReferences for CodeRun\"\n        \n        # Get the CodeRun that owns this pod\n        local coderun_name=$(echo \"$running_pods\" | jq -r '.items | sort_by(.metadata.creationTimestamp) | last | .metadata.ownerReferences[] | select(.kind == \"CodeRun\") | .name // \"\"' | head -1)\n        \n        if [[ -n \"$coderun_name\" ]]; then\n          log \"\U0001F50D Found owning CodeRun: $coderun_name\"\n          # Get agent from CodeRun spec\n          agent=$(kubectl get coderun \"$coderun_name\" -n \"$NAMESPACE\" -o jsonpath='{.spec.githubApp}' 2>/dev/null || echo \"\")\n        fi\n      fi\n      \n      if [[ -n \"$agent\" ]]; then\n        log \"✅ Found RUNNING pod with agent: $agent\"\n        format_agent_name \"$agent\"\n        return 0\n      fi\n    fi\n  fi\n  \n  # Strategy 2: Check most recent CodeRun (even if pod completed)\n  local coderun_name=$(kubectl get coderuns -n \"$NAMESPACE\" \\\n    -l \"task-id=$task_id\" \\\n    --sort-by=.metadata.creationTimestamp \\\n    -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo \"\")\n  \n  if [[ -n \"$coderun_name\" ]]; then\n    log \"\U0001F50D Checking CodeRun: $coderun_name\"\n    \n    # Get agent from CodeRun spec\n    local agent=$(kubectl get coderun \"$coderun_name\" -n \"$NAMESPACE\" \\\n      -o jsonpath='{.spec.githubApp}' 2>/dev/null || echo \"\")\n    \n    if [[ -n \"$agent\" ]]; then\n      # Check if CodeRun is still active (not completed)\n      local coderun_phase=$(kubectl get coderun \"$coderun_name\" -n \"$NAMESPACE\" \\\n        -o jsonpath='{.status.phase}' 2>/dev/null || echo \"\")\n      \n      if [[ \"$coderun_phase\" == \"Running\" ]] || [[ \"$coderun_phase\" == \"Pending\" ]]; then\n        log \"✅ Found active CodeRun with agent: $agent (phase: $coderun_phase)\"\n        format_agent_name \"$agent\"\n        return 0\n      else\n        log \"⚠️  CodeRun $coderun_name is not active (phase: $coderun_phase)\"\n      fi\n    fi\n  fi\n  \n  # Strategy 3: Check workflow labels for current stage (fallback)\n  local workflow_stage=$(kubectl get workflow \"$workflow_name\" -n \"$NAMESPACE\" \\\n    -o jsonpath='{.metadata.labels.current-stage}' 2>/dev/null || echo \"\")\n  \n  if [[ -n \"$workflow_stage\" ]] && [[ \"$workflow_stage\" != \"pending\" ]]; then\n    log \"⚠️  No running agent found, using workflow stage: $workflow_stage\"\n  fi\n  \n  # Return empty - will fall back to stage mapping\n  log \"⚠️  Could not detect actual running agent from cluster\"\n  echo \"\"\n}\n\nformat_agent_name() {\n  local agent=\"$1\"\n  \n  # Extract agent name from GitHub App identifier (e.g., \"5DLabs-Blaze\" -> \"blaze\")\n  # This handles formats like: 5DLabs-Rex, 5DLabs-Blaze[bot], rex, Blaze, etc.\n  local agent_name=$(echo \"$agent\" | sed -E 's/^.*[Ll]abs-//; s/\\[bot\\]$//; s/^[0-9]+-//' | tr '[:upper:]' '[:lower:]')\n  \n  # Return full names WITH role descriptions to match Status field options\n  case \"$agent_name\" in\n    \"rex\")\n      echo \"Rex (Implementation)\"\n      ;;\n    \"blaze\")\n      echo \"Blaze (Frontend)\"\n      ;;\n    \"cleo\")\n      echo \"Cleo (Quality)\"\n      ;;\n    \"cipher\")\n      echo \"Cipher (Security)\"\n      ;;\n    \"tess\")\n      echo \"Tess (QA)\"\n      ;;\n    \"atlas\")\n      echo \"Atlas (Integration)\"\n      ;;\n    \"bolt\")\n      echo \"Bolt (Deployment)\"\n      ;;\n    \"morgan\")\n      echo \"Morgan (PM)\"\n      ;;\n    *)\n      echo \"Pending\"\n      ;;\n  esac\n}\n\nmap_stage_to_agent() {\n  # FALLBACK ONLY - actual cluster state should be detected by get_actual_running_agent()\n  # This function provides best-guess mapping when we can't detect actual running agent\n  local stage=\"$1\"\n  local phase=\"$2\"\n  \n  log \"⚠️  Using fallback stage mapping (cluster detection failed)\"\n  \n  # Handle completed workflows first\n  if [[ \"$phase\" == \"Succeeded\" ]]; then\n    echo \"Complete ✅\"\n    return 0\n  fi\n  \n  # Handle failed/error workflows\n  if [[ \"$phase\" == \"Failed\" ]] || [[ \"$phase\" == \"Error\" ]]; then\n    # Failed tasks stay in their current stage for visibility\n    # This requires checking what stage they were in when they failed\n    log \"⚠️  Workflow failed/errored in stage: $stage\"\n  fi\n  \n  case \"$stage\" in\n    \"pending\"|\"waiting-pr-created\")\n      echo \"Pending\"\n      ;;\n    \"implementation\"|\"implementation-in-progress\")\n      echo \"Rex (Implementation)\"\n      ;;\n    \"frontend-in-progress\")\n      echo \"Blaze (Frontend)\"\n      ;;\n    \"quality-in-progress\"|\"waiting-ready-for-qa\")\n      echo \"Cleo (Quality)\"\n      ;;\n    \"security-in-progress\")\n      echo \"Cipher (Security)\"\n      ;;\n    \"testing-in-progress\"|\"qa-in-progress\")\n      echo \"Tess (QA)\"\n      ;;\n    \"integration-in-progress\"|\"merging\")\n      echo \"Atlas (Integration)\"\n      ;;\n    \"deployment-in-progress\"|\"deploying\")\n      echo \"Bolt (Deployment)\"\n      ;;\n    \"completed\"|\"done\")\n      echo \"Complete ✅\"\n      ;;\n    *)\n      # For unknown stages with active workflows, default to Pending\n      if [[ \"$phase\" == \"Running\" ]]; then\n        log \"⚠️  Unknown stage '$stage' with Running phase - defaulting to Pending\"\n        echo \"Pending\"\n      else\n        # For non-running workflows with unknown stage, mark as Pending\"\n        echo \"Pending\"\n      fi\n      ;;\n  esac\n}\n\nget_priority_color() {\n  local priority=\"$1\"\n  \n  case \"$priority\" in\n    \"high\"|\"critical\")\n      echo \"d73a4a\"  # Bright red\n      ;;\n    \"medium\")\n      echo \"fbca04\"  # Bright yellow\n      ;;\n    \"low\")\n      echo \"0e8a16\"  # Bright green\n      ;;\n    *)\n      echo \"1d76db\"  # Bright blue (default)\n      ;;\n  esac\n}\n\nget_status_color() {\n  local status=\"$1\"\n  \n  case \"$status\" in\n    \"pending\"|\"todo\")\n      echo \"bfdadc\"  # Light cyan\n      ;;\n    \"in-progress\"|\"in progress\")\n      echo \"0052cc\"  # Bright blue\n      ;;\n    \"in-review\"|\"in review\")\n      echo \"5319e7\"  # Bright purple\n      ;;\n    \"done\"|\"complete\"|\"completed\")\n      echo \"0e8a16\"  # Bright green\n      ;;\n    \"blocked\"|\"failed\")\n      echo \"d73a4a\"  # Bright red\n      ;;\n    *)\n      echo \"1d76db\"  # Bright blue (default)\n      ;;\n  esac\n}\n\nmap_agent_to_github_username() {\n  local agent=\"$1\"\n  \n  # Map agent display name to GitHub App bot username\n  case \"$agent\" in\n    \"Rex (Implementation)\"|\"Rex\")\n      echo \"rex-5dlabs[bot]\"\n      ;;\n    \"Blaze (Frontend)\"|\"Blaze\")\n      echo \"blaze-5dlabs[bot]\"\n      ;;\n    \"Cleo (Quality)\"|\"Cleo\")\n      echo \"cleo-5dlabs[bot]\"\n      ;;\n    \"Cipher (Security)\"|\"Cipher\")\n      echo \"cipher-5dlabs[bot]\"\n      ;;\n    \"Tess (QA)\"|\"Tess\")\n      echo \"tess-5dlabs[bot]\"\n      ;;\n    \"Morgan (PM)\"|\"Morgan\")\n      echo \"morgan-5dlabs[bot]\"\n      ;;\n    *)\n      echo \"\"\n      ;;\n  esac\n}\n\nupdate_issue_assignee() {\n  local issue_number=\"$1\"\n  local agent=\"$2\"\n  \n  # Post agent assignment as a comment for visibility\n  # Note: We don't assign to a specific user to keep this public-friendly\n  if [[ \"$agent\" != \"Complete ✅\" ]] && [[ \"$agent\" != \"Pending\" ]]; then\n    log \"\U0001F4DD Posting agent assignment comment for $agent on issue #$issue_number\"\n    \n    # Post comment with agent assignment (non-fatal if fails)\n    gh issue comment \"$issue_number\" \\\n      --repo \"$REPO_OWNER/$REPO_NAME\" \\\n      --body \"\U0001F916 **Agent Assignment**\n\n**Current Agent:** $agent\n\n---\n*Auto-assigned by Morgan PM*\" 2>/dev/null || true\n  fi\n}\n\nmap_workflow_to_status() {\n  # This function now returns the agent-based stage (column name)\n  # It's essentially the same as map_stage_to_agent\n  local stage=\"$1\"\n  local phase=\"$2\"\n  \n  # Just call map_stage_to_agent since status and agent are now unified\n  map_stage_to_agent \"$stage\" \"$phase\"\n}\n\nmap_taskmaster_status_to_stage() {\n  # Maps TaskMaster status values (from tasks.json) to GitHub Project \"Stage\" field values\n  # MUST match exact Status field options configured in setup_custom_fields\n  local taskmaster_status=\"$1\"\n  \n  case \"$taskmaster_status\" in\n    \"done\"|\"completed\")\n      echo \"Complete ✅\"\n      ;;\n    \"in-progress\"|\"in_progress\"|\"active\")\n      echo \"Rex (Implementation)\"  # Match exact Status field option\n      ;;\n    \"review\"|\"in-review\"|\"in_review\")\n      echo \"Cleo (Quality)\"  # Match exact Status field option\n      ;;\n    \"testing\"|\"qa\")\n      echo \"Tess (QA)\"  # Match exact Status field option\n      ;;\n    \"blocked\"|\"deferred\"|\"cancelled\")\n      echo \"Pending\"  # Blocked tasks go back to Pending\n      ;;\n    \"pending\"|*)\n      # Default to \"Pending\" for pending or unknown statuses\n      echo \"Pending\"\n      ;;\n  esac\n}\n\nupdate_issue_labels() {\n  local issue_number=\"$1\"\n  local status=\"$2\"\n  local agent=\"$3\"\n  \n  # Remove old status labels\n  gh issue edit \"$issue_number\" \\\n    --repo \"$REPO_OWNER/$REPO_NAME\" \\\n    --remove-label \"status-pending,status-in-progress,status-in-review,status-done,status-blocked\" \\\n    2>/dev/null || true\n  \n  # Add new labels\n  local status_label=\"status-$(echo \"$status\" | tr '[:upper:] ' '[:lower:]-')\"\n  gh issue edit \"$issue_number\" \\\n    --repo \"$REPO_OWNER/$REPO_NAME\" \\\n    --add-label \"$status_label\" \\\n    2>/dev/null || true\n}\n\n# ============================================================================\n# PHASE 1 ENHANCEMENTS: HEALTH CHECKS & STATUS TRACKING\n# ============================================================================\n\nadd_status_history() {\n  local issue_number=\"$1\"\n  local task_id=\"$2\"\n  local stage=\"$3\"\n  local agent=\"$4\"\n  local status=\"$5\"\n  local phase=\"$6\"\n  \n  local timestamp=$(date -u +\"%Y-%m-%d %H:%M:%S UTC\")\n  local argo_url=\"https://argo.5dlabs.com/workflows/cto/$WORKFLOW_NAME\"\n  \n  # Create structured status update comment\n  gh issue comment \"$issue_number\" \\\n    --repo \"$REPO_OWNER/$REPO_NAME\" \\\n    --body \"**\U0001F4CA Status Update**\n\n| Field | Value |\n|-------|-------|\n| ⏰ Time | $timestamp |\n| \U0001F3AF Stage | \\`$stage\\` |\n| \U0001F916 Agent | $agent |\n| \U0001F4CB Status | $status |\n| \U0001F504 Phase | $phase |\n| \U0001F517 Workflow | [View in Argo]($argo_url) |\n\n---\n*Auto-updated by Morgan PM*\" 2>/dev/null || true\n  \n  log \"\U0001F4DD Added status history for task-$task_id\"\n}\n\ncheck_task_health() {\n  local task_id=\"$1\"\n  local workflow_name=\"$2\"\n  local current_stage=\"$3\"\n  local issue_number=\"$4\"\n  \n  # Find CodeRun for this task/stage\n  local coderun_name=$(kubectl get coderuns -n \"$NAMESPACE\" \\\n    -l \"task-id=$task_id,workflow-name=$workflow_name\" \\\n    --sort-by=.metadata.creationTimestamp \\\n    -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo \"\")\n  \n  [[ -z \"$coderun_name\" ]] && return 0\n  \n  # Check CodeRun status\n  local coderun_phase=$(kubectl get coderun \"$coderun_name\" -n \"$NAMESPACE\" \\\n    -o jsonpath='{.status.phase}' 2>/dev/null || echo \"\")\n  \n  local coderun_error=$(kubectl get coderun \"$coderun_name\" -n \"$NAMESPACE\" \\\n    -o jsonpath='{.status.error}' 2>/dev/null || echo \"\")\n  \n  # Check pod status for more details\n  local pod_name=$(kubectl get pods -n \"$NAMESPACE\" \\\n    -l \"coderun=$coderun_name\" \\\n    -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo \"\")\n  \n  local pod_phase=\"\"\n  local pod_reason=\"\"\n  if [[ -n \"$pod_name\" ]]; then\n    pod_phase=$(kubectl get pod \"$pod_name\" -n \"$NAMESPACE\" \\\n      -o jsonpath='{.status.phase}' 2>/dev/null || echo \"\")\n    pod_reason=$(kubectl get pod \"$pod_name\" -n \"$NAMESPACE\" \\\n      -o jsonpath='{.status.containerStatuses[0].state.waiting.reason}' 2>/dev/null || echo \"\")\n  fi\n  \n  # Detect problems\n  local has_error=false\n  local error_message=\"\"\n  \n  if [[ \"$coderun_phase\" == \"Failed\" ]]; then\n    has_error=true\n    error_message=\"CodeRun failed: $coderun_error\"\n  elif [[ \"$pod_reason\" == \"CrashLoopBackOff\" ]] || [[ \"$pod_reason\" == \"Error\" ]]; then\n    has_error=true\n    error_message=\"Agent pod crashed: $pod_reason\"\n  elif [[ \"$pod_phase\" == \"Failed\" ]]; then\n    has_error=true\n    error_message=\"Agent pod failed\"\n  fi\n  \n  # Report errors to GitHub\n  if [[ \"$has_error\" == true ]]; then\n    log \"⚠️  Health check failed for task-$task_id: $error_message\"\n    \n    # Get recent logs for context\n    local error_logs=\"\"\n    if [[ -n \"$pod_name\" ]]; then\n      error_logs=$(kubectl logs \"$pod_name\" -n \"$NAMESPACE\" --tail=20 2>/dev/null || echo \"Logs unavailable\")\n    fi\n    \n    gh issue comment \"$issue_number\" \\\n      --repo \"$REPO_OWNER/$REPO_NAME\" \\\n      --body \"## ⚠️ Agent Error Detected\n\n**CodeRun:** \\`$coderun_name\\`  \n**Error:** $error_message  \n**Time:** $(date -u +\"%Y-%m-%d %H:%M:%S UTC\")\n\n<details>\n<summary>Recent Logs (last 20 lines)</summary>\n\n\\`\\`\\`\n$error_logs\n\\`\\`\\`\n\n</details>\n\n**Next Steps:**\n- Review logs above for root cause\n- Check if this is a transient issue that will auto-retry\n- Manual intervention may be required\n\n---\n*Auto-detected by Morgan PM Health Check*\" 2>/dev/null || true\n  fi\n}\n\nupdate_heartbeat() {\n  local issue_number=\"$1\"\n  local timestamp=$(date -u +\"%Y-%m-%d %H:%M:%S UTC\")\n  \n  # Update or create heartbeat comment\n  # Use a unique marker so we can find and update the same comment\n  local heartbeat_marker=\"<!-- morgan-heartbeat -->\"\n  \n  # For now, just track in sync log (avoid spamming issues)\n  # Could be enhanced to update a single pinned comment\n  echo \"$timestamp - Heartbeat for issue #$issue_number\" >> \"$SYNC_LOG\"\n}\n\n# ============================================================================\n# PHASE 2: SUB-STAGE PROGRESS TRACKING\n# ============================================================================\n\nget_agent_progress() {\n  local task_id=\"$1\"\n  local workflow_name=\"$2\"\n  local current_stage=\"$3\"\n  \n  # Find most recent CodeRun for this task/stage\n  local coderun_name=$(kubectl get coderuns -n \"$NAMESPACE\" \\\n    -l \"task-id=$task_id,workflow-name=$workflow_name\" \\\n    --sort-by=.metadata.creationTimestamp \\\n    -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo \"\")\n  \n  [[ -z \"$coderun_name\" ]] && echo \"\" && return 0\n  \n  # Check for progress annotation (future: agents could set this)\n  local progress=$(kubectl get coderun \"$coderun_name\" -n \"$NAMESPACE\" \\\n    -o jsonpath='{.metadata.annotations.agent-progress}' 2>/dev/null || echo \"\")\n  \n  # If no annotation, try to parse from pod logs\n  if [[ -z \"$progress\" ]]; then\n    local pod_name=$(kubectl get pods -n \"$NAMESPACE\" \\\n      -l \"coderun=$coderun_name\" \\\n      -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo \"\")\n    \n    if [[ -n \"$pod_name\" ]]; then\n      # Look for common progress indicators in logs\n      # Match patterns like \"Progress: 45%\" or \"Step 3/10\" etc\n      local log_progress=$(kubectl logs \"$pod_name\" -n \"$NAMESPACE\" --tail=100 2>/dev/null | \\\n        grep -oiE '(progress:? ?[0-9]+%|[0-9]+%|step [0-9]+/[0-9]+)' | \\\n        tail -1 || echo \"\")\n      \n      if [[ -n \"$log_progress\" ]]; then\n        progress=\"$log_progress\"\n      fi\n    fi\n  fi\n  \n  echo \"$progress\"\n}\n\nupdate_progress_comment() {\n  local issue_number=\"$1\"\n  local task_id=\"$2\"\n  local workflow_name=\"$3\"\n  local current_stage=\"$4\"\n  \n  local progress=$(get_agent_progress \"$task_id\" \"$workflow_name\" \"$current_stage\")\n  \n  [[ -z \"$progress\" ]] && return 0\n  \n  # Post progress update as a comment\n  gh issue comment \"$issue_number\" \\\n    --repo \"$REPO_OWNER/$REPO_NAME\" \\\n    --body \"\U0001F504 **Progress Update** - Stage: \\`$current_stage\\`\n\nCurrent progress: **$progress**\n\n*Updated: $(date -u +\"%Y-%m-%d %H:%M:%S UTC\")*  \n*Auto-updated by Morgan PM*\" 2>/dev/null || true\n  \n  log \"\U0001F4C8 Progress for task-$task_id: $progress\"\n}\n\n# ============================================================================\n# PHASE 3: GITHUB CHECKS API INTEGRATION\n# ============================================================================\n\ncreate_or_update_github_check() {\n  local task_id=\"$1\"\n  local pr_number=\"$2\"\n  local agent_name=\"$3\"\n  local current_stage=\"$4\"\n  local workflow_phase=\"$5\"\n  \n  # Get PR head SHA\n  local pr_head_sha=$(gh pr view \"$pr_number\" \\\n    --repo \"$REPO_OWNER/$REPO_NAME\" \\\n    --json headRefOid \\\n    --jq '.headRefOid' 2>/dev/null || echo \"\")\n  \n  [[ -z \"$pr_head_sha\" ]] && return 0\n  \n  # Map workflow phase to check status\n  local check_status=\"in_progress\"\n  local check_conclusion=\"\"\n  \n  case \"$workflow_phase\" in\n    \"Succeeded\")\n      check_status=\"completed\"\n      check_conclusion=\"success\"\n      ;;\n    \"Failed\"|\"Error\")\n      check_status=\"completed\"\n      check_conclusion=\"failure\"\n      ;;\n    \"Running\")\n      check_status=\"in_progress\"\n      ;;\n    *)\n      check_status=\"queued\"\n      ;;\n  esac\n  \n  # Create/update check run - Include workflow name to scope check per run\n  local check_name=\"$agent_name Quality Gate ($WORKFLOW_NAME)\"\n  local argo_url=\"https://argo.5dlabs.com/workflows/cto/$WORKFLOW_NAME\"\n  \n  # Check if check run already exists\n  local existing_check=$(gh api \\\n    \"/repos/$REPO_OWNER/$REPO_NAME/commits/$pr_head_sha/check-runs\" \\\n    --jq \".check_runs[] | select(.name == \\\"$check_name\\\") | .id\" 2>/dev/null || echo \"\")\n  \n  if [[ -n \"$existing_check\" ]]; then\n    # Update existing check\n    local update_payload=\"{\n      \\\"status\\\": \\\"$check_status\\\",\n      \\\"details_url\\\": \\\"$argo_url\\\",\n      \\\"output\\\": {\n        \\\"title\\\": \\\"$agent_name is reviewing this PR\\\",\n        \\\"summary\\\": \\\"Current stage: $current_stage\\\",\n        \\\"text\\\": \\\"Task ID: $task_id\\\\nWorkflow: $WORKFLOW_NAME\\\\nPhase: $workflow_phase\\\"\n      }\"\n    \n    if [[ -n \"$check_conclusion\" ]]; then\n      update_payload=\"$update_payload,\\\"conclusion\\\": \\\"$check_conclusion\\\"\"\n    fi\n    \n    update_payload=\"$update_payload}\"\n    \n    gh api \\\n      --method PATCH \\\n      -H \"Accept: application/vnd.github+json\" \\\n      \"/repos/$REPO_OWNER/$REPO_NAME/check-runs/$existing_check\" \\\n      --input - <<< \"$update_payload\" 2>/dev/null || true\n    \n    log \"✅ Updated GitHub check for $agent_name on PR #$pr_number\"\n  else\n    # Create new check\n    local create_payload=\"{\n      \\\"name\\\": \\\"$check_name\\\",\n      \\\"head_sha\\\": \\\"$pr_head_sha\\\",\n      \\\"status\\\": \\\"$check_status\\\",\n      \\\"details_url\\\": \\\"$argo_url\\\",\n      \\\"output\\\": {\n        \\\"title\\\": \\\"$agent_name is reviewing this PR\\\",\n        \\\"summary\\\": \\\"Current stage: $current_stage\\\",\n        \\\"text\\\": \\\"Task ID: $task_id\\\\nWorkflow: $WORKFLOW_NAME\\\\nPhase: $workflow_phase\\\"\n      }\"\n    \n    if [[ -n \"$check_conclusion\" ]]; then\n      create_payload=\"$create_payload,\\\"conclusion\\\": \\\"$check_conclusion\\\"\"\n    fi\n    \n    create_payload=\"$create_payload}\"\n    \n    gh api \\\n      --method POST \\\n      -H \"Accept: application/vnd.github+json\" \\\n      \"/repos/$REPO_OWNER/$REPO_NAME/check-runs\" \\\n      --input - <<< \"$create_payload\" 2>/dev/null || true\n    \n    log \"✅ Created GitHub check for $agent_name on PR #$pr_number\"\n  fi\n}\n\nfind_pr_for_task() {\n  local task_id=\"$1\"\n  \n  # Find PR with task label\n  local pr_number=$(gh pr list \\\n    --repo \"$REPO_OWNER/$REPO_NAME\" \\\n    --label \"task-$task_id\" \\\n    --state open \\\n    --json number \\\n    --jq '.[0].number' 2>/dev/null || echo \"\")\n  \n  echo \"$pr_number\"\n}\n\nlink_pr_to_project() {\n  local project_id=\"$1\"\n  local pr_number=\"$2\"\n  local task_id=\"$3\"\n  local current_stage=\"$4\"\n  \n  log \"\U0001F517 Linking PR #$pr_number to project for task-$task_id...\"\n  \n  # Get PR node ID\n  local pr_node_id=$(gh pr view \"$pr_number\" \\\n    --repo \"$REPO_OWNER/$REPO_NAME\" \\\n    --json id --jq '.id' 2>/dev/null || echo \"\")\n  \n  if [[ -z \"$pr_node_id\" ]] || [[ \"$pr_node_id\" == \"null\" ]]; then\n    log \"⚠️  Could not get node ID for PR #$pr_number\"\n    return 1\n  fi\n  \n  log \"✅ Got PR node ID: $pr_node_id\"\n  \n  # Check if PR is already in THIS specific project (not just any project)\n  local pr_in_this_project=$(gh pr view \"$pr_number\" \\\n    --repo \"$REPO_OWNER/$REPO_NAME\" \\\n    --json projectItems --jq --arg pid \"$project_id\" \\\n    '.projectItems[] | select(.project.id == $pid) | .id' 2>/dev/null || echo \"\")\n  \n  if [[ -n \"$pr_in_this_project\" ]]; then\n    log \"✅ PR #$pr_number already linked to this project (item ID: $pr_in_this_project)\"\n    # Update stage even if already linked (PR stage might have changed)\n    set_project_item_stage \"$project_id\" \"$pr_in_this_project\" \"$current_stage\" 2>/dev/null || \\\n      log \"⚠️  Could not update PR #$pr_number stage\"\n    return 0\n  fi\n  \n  # Add PR to project (with retry)\n  local pr_item_id=\"\"\n  if ! pr_item_id=$(retry_with_backoff 3 \"Link PR #$pr_number to project\" \\\n    add_issue_to_project \"$project_id\" \"$pr_node_id\" \"$pr_number\"); then\n    log \"❌ Failed to add PR #$pr_number to project after retries\"\n    return 1\n  fi\n  \n  if [[ -z \"$pr_item_id\" ]] || [[ \"$pr_item_id\" == \"null\" ]]; then\n    log \"⚠️  No item ID returned for PR #$pr_number\"\n    return 1\n  fi\n  \n  log \"✅ Added PR #$pr_number to project (Item ID: $pr_item_id)\"\n  \n  # Set PR stage to match task stage\n  retry_with_backoff 3 \"Set PR #$pr_number stage\" \\\n    set_project_item_stage \"$project_id\" \"$pr_item_id\" \"$current_stage\"\n  \n  log \"✅ Set PR #$pr_number stage to: $current_stage\"\n  \n  return 0\n}\n\n# ============================================================================\n# PHASE 3: AGENT LOG STREAMING\n# ============================================================================\n\nstream_significant_events() {\n  local task_id=\"$1\"\n  local workflow_name=\"$2\"\n  local issue_number=\"$3\"\n  \n  # Find CodeRun pod\n  local coderun_name=$(kubectl get coderuns -n \"$NAMESPACE\" \\\n    -l \"task-id=$task_id,workflow-name=$workflow_name\" \\\n    --sort-by=.metadata.creationTimestamp \\\n    -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo \"\")\n  \n  [[ -z \"$coderun_name\" ]] && return 0\n  \n  local pod_name=$(kubectl get pods -n \"$NAMESPACE\" \\\n    -l \"coderun=$coderun_name\" \\\n    -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo \"\")\n  \n  [[ -z \"$pod_name\" ]] && return 0\n  \n  # Get recent logs and look for significant events\n  local significant_logs=$(kubectl logs \"$pod_name\" -n \"$NAMESPACE\" --tail=50 2>/dev/null | \\\n    grep -iE '(creating pr|running tests?|error|failed|success|completed|starting)' | \\\n    tail -5 || echo \"\")\n  \n  if [[ -n \"$significant_logs\" ]]; then\n    gh issue comment \"$issue_number\" \\\n      --repo \"$REPO_OWNER/$REPO_NAME\" \\\n      --body \"\U0001F916 **Agent Activity** (Last 5 significant events)\n\n\\`\\`\\`\n$significant_logs\n\\`\\`\\`\n\n*Updated: $(date -u +\"%Y-%m-%d %H:%M:%S UTC\")*  \n*Auto-captured by Morgan PM*\" 2>/dev/null || true\n    \n    log \"\U0001F4E1 Posted agent activity for task-$task_id\"\n  fi\n}\n\n# ============================================================================\n# PHASE 3: PROMETHEUS METRICS\n# ============================================================================\n\nexport_prometheus_metrics() {\n  local project_id=\"$1\"\n  \n  # Calculate metrics\n  local total_tasks=$(jq 'length' \"$TASK_ISSUE_MAP\")\n  local completed_tasks=0\n  local in_progress_tasks=0\n  local blocked_tasks=0\n  local pending_tasks=0\n  \n  # Count by stage - use process substitution to avoid subshell variable scope bug\n  while read -r entry; do\n    local task_id=$(echo \"$entry\" | jq -r '.key')\n    \n    # Find workflow for this task\n    local task_workflow=$(kubectl get workflows -n \"$NAMESPACE\" \\\n      -l \"task-id=$task_id,parent-workflow=$WORKFLOW_NAME\" \\\n      -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo \"\")\n    \n    if [[ -z \"$task_workflow\" ]]; then\n      pending_tasks=$((pending_tasks + 1))\n      continue\n    fi\n    \n    local workflow_phase=$(kubectl get workflow \"$task_workflow\" \\\n      -n \"$NAMESPACE\" \\\n      -o jsonpath='{.status.phase}' 2>/dev/null || echo \"Pending\")\n    \n    case \"$workflow_phase\" in\n      \"Succeeded\") completed_tasks=$((completed_tasks + 1)) ;;\n      \"Running\") in_progress_tasks=$((in_progress_tasks + 1)) ;;\n      \"Failed\"|\"Error\") blocked_tasks=$((blocked_tasks + 1)) ;;\n      *) pending_tasks=$((pending_tasks + 1)) ;;\n    esac\n  done < <(jq -c 'to_entries[]' \"$TASK_ISSUE_MAP\")\n  \n  # Calculate average sync lag (time since last update)\n  local sync_timestamp=$(date +%s)\n  \n  # Calculate completion percentage (avoid division by zero)\n  local completion_percentage=0\n  if [[ $total_tasks -gt 0 ]]; then\n    completion_percentage=$((completed_tasks * 100 / total_tasks))\n  fi\n  \n  # Export metrics to file (Prometheus can scrape this)\n  mkdir -p /shared/metrics\n  cat > /shared/metrics/morgan.prom <<EOF\n# HELP morgan_total_tasks Total number of tasks in this project\n# TYPE morgan_total_tasks gauge\nmorgan_total_tasks{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\"} $total_tasks\n\n# HELP morgan_completed_tasks Number of completed tasks\n# TYPE morgan_completed_tasks gauge\nmorgan_completed_tasks{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\"} $completed_tasks\n\n# HELP morgan_in_progress_tasks Number of tasks currently in progress\n# TYPE morgan_in_progress_tasks gauge\nmorgan_in_progress_tasks{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\"} $in_progress_tasks\n\n# HELP morgan_blocked_tasks Number of blocked/failed tasks\n# TYPE morgan_blocked_tasks gauge\nmorgan_blocked_tasks{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\"} $blocked_tasks\n\n# HELP morgan_pending_tasks Number of pending tasks\n# TYPE morgan_pending_tasks gauge\nmorgan_pending_tasks{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\"} $pending_tasks\n\n# HELP morgan_completion_percentage Workflow completion percentage\n# TYPE morgan_completion_percentage gauge\nmorgan_completion_percentage{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\"} $completion_percentage\n\n# HELP morgan_last_sync_timestamp Unix timestamp of last successful sync\n# TYPE morgan_last_sync_timestamp gauge\nmorgan_last_sync_timestamp{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\"} $sync_timestamp\n\n# HELP morgan_event_processing_total Total number of workflow events processed\n# TYPE morgan_event_processing_total counter\nmorgan_event_processing_total{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\"} $(cat /tmp/morgan-events-processed 2>/dev/null || echo \"0\")\n\n# HELP morgan_graphql_errors_total Total number of GraphQL errors encountered\n# TYPE morgan_graphql_errors_total counter\nmorgan_graphql_errors_total{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\",type=\"permission\"} $(cat /tmp/morgan-graphql-permission-errors 2>/dev/null || echo \"0\")\nmorgan_graphql_errors_total{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\",type=\"not_found\"} $(cat /tmp/morgan-graphql-notfound-errors 2>/dev/null || echo \"0\")\nmorgan_graphql_errors_total{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\",type=\"rate_limit\"} $(cat /tmp/morgan-graphql-ratelimit-errors 2>/dev/null || echo \"0\")\nmorgan_graphql_errors_total{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\",type=\"other\"} $(cat /tmp/morgan-graphql-other-errors 2>/dev/null || echo \"0\")\n\n# HELP morgan_issue_link_success_total Successful issue-to-project links\n# TYPE morgan_issue_link_success_total counter\nmorgan_issue_link_success_total{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\"} $(cat /tmp/morgan-link-success 2>/dev/null || echo \"0\")\n\n# HELP morgan_issue_link_failure_total Failed issue-to-project links\n# TYPE morgan_issue_link_failure_total counter\nmorgan_issue_link_failure_total{project=\"$WORKFLOW_NAME\",service=\"$SERVICE_NAME\"} $(cat /tmp/morgan-link-failure 2>/dev/null || echo \"0\")\nEOF\n  \n  log \"\U0001F4CA Exported Prometheus metrics: $completed_tasks/$total_tasks tasks complete\"\n}\n\n# ============================================================================\n# PHASE 3: AI STATUS SUMMARIES\n# ============================================================================\n\ngenerate_ai_summary() {\n  local project_id=\"$1\"\n  \n  # Gather project statistics\n  local total_tasks=$(jq 'length' \"$TASK_ISSUE_MAP\")\n  local project_title=\"\"\n  if ensure_project_config_loaded; then\n    project_title=$(jq -r '.project_title // empty' \"$PROJECT_CONFIG\" 2>/dev/null || echo \"\")\n  fi\n  if [[ -z \"$project_title\" ]]; then\n    project_title=\"${PROJECT_TITLE:-\"$SERVICE_NAME - TaskMaster Workflow\"}\"\n  fi\n  \n  # Get task statuses\n  local tasks_status=$(kubectl get workflows -n \"$NAMESPACE\" \\\n    -l \"parent-workflow=$WORKFLOW_NAME\" \\\n    -o json 2>/dev/null || echo '{\"items\":[]}')\n  \n  local completed_count=$(echo \"$tasks_status\" | jq '[.items[] | select(.status.phase == \"Succeeded\")] | length')\n  local in_progress_count=$(echo \"$tasks_status\" | jq '[.items[] | select(.status.phase == \"Running\")] | length')\n  local failed_count=$(echo \"$tasks_status\" | jq '[.items[] | select(.status.phase == \"Failed\" or .status.phase == \"Error\")] | length')\n  \n  # Create human-readable summary\n  local summary_text=\"\"\n  \n  if [[ $completed_count -eq $total_tasks ]]; then\n    summary_text=\"\U0001F389 **All tasks completed!** The $SERVICE_NAME project workflow has successfully finished all $total_tasks tasks.\"\n  elif [[ $failed_count -gt 0 ]]; then\n    summary_text=\"⚠️ **Attention needed:** $failed_count task(s) have failed. $in_progress_count task(s) in progress, $completed_count/$total_tasks completed.\"\n  elif [[ $in_progress_count -gt 0 ]]; then\n    summary_text=\"\U0001F504 **In progress:** $in_progress_count task(s) actively being worked on. $completed_count/$total_tasks tasks completed so far.\"\n  else\n    summary_text=\"⏸️ **Waiting:** $completed_count/$total_tasks tasks completed. Remaining tasks are pending.\"\n  fi\n  \n  # Update project description with summary\n  # Note: GitHub Projects V2 GraphQL API doesn't support description updates yet\n  # Instead, post summary as a pinned issue comment or use GitHub Project README\n  \n  log \"\U0001F4DD Generated AI summary: $summary_text\"\n  echo \"$summary_text\"\n}\n\nupdate_project_summary() {\n  local project_id=\"$1\"\n  \n  # Generate comprehensive summary with metrics\n  local timestamp=$(date -u +\"%Y-%m-%d %H:%M:%S UTC\")\n  local workflow_url=\"https://argo.5dlabs.com/workflows/cto/$WORKFLOW_NAME\"\n  \n  # Calculate task metrics\n  local total_tasks=$(jq 'length' \"$TASK_ISSUE_MAP\")\n  local completed=0\n  local in_progress=0\n  local pending=0\n  local blocked=0\n  \n  # Count agent distribution\n  declare -A agent_counts\n  \n  while read -r entry; do\n    local task_id=$(echo \"$entry\" | jq -r '.key')\n    local task_workflow=$(kubectl get workflows -n \"$NAMESPACE\" \\\n      -l \"task-id=$task_id,parent-workflow=$WORKFLOW_NAME\" \\\n      -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo \"\")\n    \n    if [[ -z \"$task_workflow\" ]]; then\n      pending=$((pending + 1))\n      continue\n    fi\n    \n    local stage=$(kubectl get workflow \"$task_workflow\" -n \"$NAMESPACE\" \\\n      -o jsonpath='{.metadata.labels.current-stage}' 2>/dev/null || echo \"pending\")\n    local phase=$(kubectl get workflow \"$task_workflow\" -n \"$NAMESPACE\" \\\n      -o jsonpath='{.status.phase}' 2>/dev/null || echo \"Pending\")\n    \n    local agent=$(map_stage_to_agent \"$stage\" \"$phase\")\n    agent_counts[\"$agent\"]=$((${agent_counts[\"$agent\"]:-0} + 1))\n    \n    case \"$phase\" in\n      \"Succeeded\") completed=$((completed + 1)) ;;\n      \"Running\") in_progress=$((in_progress + 1)) ;;\n      \"Failed\"|\"Error\") blocked=$((blocked + 1)) ;;\n      *) pending=$((pending + 1)) ;;\n    esac\n  done < <(jq -c 'to_entries[]' \"$TASK_ISSUE_MAP\")\n  \n  # Calculate completion percentage\n  local completion_pct=0\n  local completed_pct=0\n  local in_progress_pct=0\n  local pending_pct=0\n  local blocked_pct=0\n  \n  if [[ $total_tasks -gt 0 ]]; then\n    completion_pct=$((completed * 100 / total_tasks))\n    completed_pct=$((completed * 100 / total_tasks))\n    in_progress_pct=$((in_progress * 100 / total_tasks))\n    pending_pct=$((pending * 100 / total_tasks))\n    blocked_pct=$((blocked * 100 / total_tasks))\n  fi\n  \n  # Build agent distribution table\n  local agent_table=\"\"\n  for agent in \"${!agent_counts[@]}\"; do\n    local count=${agent_counts[$agent]}\n    agent_table+=\"| $agent | $count |\\n\"\n  done\n  \n  # Generate beautiful README-style summary\n  local summary=$(cat <<EOF\n# \U0001F3AF $SERVICE_NAME - TaskMaster Workflow\n\n**Last Updated**: $timestamp  \n**Workflow**: [\\`$WORKFLOW_NAME\\`]($workflow_url)  \n**Status**: $(get_workflow_status_emoji $in_progress $blocked $completed) | **Completion**: $completion_pct% ($completed/$total_tasks tasks)\n\n---\n\n## \U0001F4CA Progress Overview\n\n| Phase | Count | Percentage |\n|-------|-------|------------|\n| ✅ Complete | $completed | ${completed_pct}% |\n| \U0001F504 In Progress | $in_progress | ${in_progress_pct}% |\n| \U0001F4CB Pending | $pending | ${pending_pct}% |\n| \U0001F6AB Blocked | $blocked | ${blocked_pct}% |\n\n## \U0001F916 Current Agent Distribution\n\n| Agent | Active Tasks |\n|-------|--------------|\n$(echo -e \"$agent_table\")\n\n## ⚡ Real-Time Status\n\nThis project is monitored by **Morgan PM** with real-time synchronization to GitHub Projects.\n\n- **Live Updates**: < 10 second latency\n- **Agent Tracking**: Automatic assignment to current working agent\n- **Quality Gates**: Automated Rex → Cleo → Tess pipeline\n- **Workflow Visibility**: [View in Argo Workflows]($workflow_url)\n\n---\n\n*Auto-generated by Morgan PM at $timestamp*\nEOF\n)\n  \n  # Update project README/description\n  update_project_readme \"$project_id\" \"$summary\"\n  \n  # Also log to console\n  log \"\U0001F4CA Project Summary:\"\n  log \"$summary\"\n  \n  # Export metrics\n  export_prometheus_metrics \"$project_id\"\n}\n\nget_workflow_status_emoji() {\n  local in_progress=\"$1\"\n  local blocked=\"$2\"\n  local completed=\"$3\"\n  \n  if [[ $blocked -gt 0 ]]; then\n    echo \"\U0001F6AB Blocked\"\n  elif [[ $in_progress -gt 0 ]]; then\n    echo \"\U0001F504 In Progress\"\n  elif [[ $completed -gt 0 ]]; then\n    echo \"✅ Active\"\n  else\n    echo \"\U0001F4CB Pending\"\n  fi\n}\n\nupdate_project_readme() {\n  local project_id=\"$1\"\n  local readme_content=\"$2\"\n  \n  # Update project README via GraphQL\n  local update_mutation='\n    mutation($projectId: ID!, $readme: String!) {\n      updateProjectV2(input: {\n        projectId: $projectId\n        readme: $readme\n      }) {\n        projectV2 {\n          id\n          readme\n        }\n      }\n    }\n  '\n  \n  gh api graphql \\\n    -f query=\"$update_mutation\" \\\n    -f projectId=\"$project_id\" \\\n    -f readme=\"$readme_content\" >/dev/null 2>&1 || {\n    log \"⚠️  Could not update project README (not critical)\"\n  }\n}\n\ngenerate_issue_body() {\n  local task=\"$1\"\n  local tasks_json_path=\"$2\"\n  \n  local task_id=$(echo \"$task\" | jq -r '.id')\n  local title=$(echo \"$task\" | jq -r '.title')\n  local description=$(echo \"$task\" | jq -r '.description // \"No description provided\"')\n  local details=$(echo \"$task\" | jq -r '.details // \"No details provided\"')\n  local test_strategy=$(echo \"$task\" | jq -r '.testStrategy // \"No test strategy defined\"')\n  local priority=$(echo \"$task\" | jq -r '.priority // \"medium\"')\n  local dependencies=$(echo \"$task\" | jq -r '.dependencies // [] | join(\", \")')\n  \n  # Try to read full task content from docs directory\n  local task_dir=\"$TEMP_CLONE/$DOCS_DIR/.taskmaster/docs/task-$task_id\"\n  local task_md_content=\"\"\n  local acceptance_criteria=\"\"\n  \n  if [[ -f \"$task_dir/task.md\" ]]; then\n    task_md_content=$(cat \"$task_dir/task.md\" 2>/dev/null || echo \"\")\n  fi\n  \n  if [[ -f \"$task_dir/acceptance-criteria.md\" ]]; then\n    acceptance_criteria=$(cat \"$task_dir/acceptance-criteria.md\" 2>/dev/null || echo \"\")\n  fi\n  \n  cat <<EOF\n# Task $task_id: $title\n\n## \U0001F4CB Quick Summary\n$description\n\n## \U0001F4CA Metadata\n- **Priority**: $priority\n- **Dependencies**: ${dependencies:-None}\n- **Status**: Pending\n- **Workflow Run**: \\`$WORKFLOW_NAME\\`\n- **Started**: $(date -u +\"%Y-%m-%d %H:%M:%S UTC\")\n\n---\n${task_md_content:+\n## \U0001F4D6 Full Task Details\n\n$task_md_content\n\n---\n}${acceptance_criteria:+\n## ✅ Acceptance Criteria\n\n$acceptance_criteria\n\n---\n}\n## \U0001F3AF Implementation Notes (from tasks.json)\n$details\n\n## \U0001F9EA Test Strategy (from tasks.json)\n$test_strategy\n\n---\n\n## \U0001F517 Task Master Integration\n\nThis issue is automatically synchronized with TaskMaster.\n\n**Task File**: \\`$tasks_json_path\\`  \n**Task Details**: \\`.taskmaster/docs/task-$task_id/\\`  \n**Service**: \\`$SERVICE_NAME\\`  \n**Workflow**: \\`$WORKFLOW_NAME\\`\n\n### Agent Pipeline\n1. **Rex** - Implementation\n2. **Cleo** - Code Quality Review\n3. **Cipher** - Security Analysis (if enabled)\n4. **Tess** - QA Testing\n5. **Atlas** - Integration & Merge\n6. **Bolt** - Production Deployment\n\n---\n\n## \U0001F4E1 Live Status\n\nThis issue is monitored by Morgan PM. Status updates are posted automatically as agents progress through the workflow.\n\n**Current Status**: View the Project board for real-time updates  \n**Feedback**: Comment with \\`@morgan\\` to request scope changes or clarifications\n\n---\n\n*This issue is managed by Morgan (Project Manager) for workflow \\`$WORKFLOW_NAME\\`.*\nEOF\n}\n\n# ============================================================================\n# MAIN EXECUTION\n# ============================================================================\n\nmain() {\n  echo \"\U0001F50D DEBUG: Entered main() function\"\n  log \"\U0001F680 Morgan PM starting...\"\n  \n  echo \"\U0001F50D DEBUG: About to call initialize_project()\"\n  # Phase 1: Initialize project\n  initialize_project\n  echo \"\U0001F50D DEBUG: initialize_project() completed\"\n  \n  # Phase 2: Create issues\n  create_task_issues\n  \n  # Phase 3: Monitor and sync\n  echo \"\U0001F50D DEBUG: About to call monitor_and_sync()\"\n  monitor_and_sync\n  \n  log \"✅ Morgan PM completed successfully\"\n  echo \"\U0001F50D DEBUG: main() function completed\"\n}\n\n# Trap errors and cleanup\n# Only log errors - let them propagate so main || { ... } block can handle them\n# The trap should not call exit directly, as that prevents error handling logic from executing\n# Errors will cause exit via 'set -euo pipefail' (line 2), allowing main || { ... } to handle them\ntrap 'echo \"❌ Morgan PM error on line $LINENO: $BASH_COMMAND\" >&2' ERR\n\n# Trap SIGTERM for graceful daemon shutdown (Argo sends SIGTERM when workflow fails/completes)\n# Daemon should exit gracefully with code 0 when terminated\ntrap 'echo \"\U0001F6D1 Received SIGTERM - shutting down Morgan PM daemon gracefully...\"; exit 0' TERM\n\necho \"\U0001F50D DEBUG: About to call main()...\"\n# Run main with error handling - only catch errors during monitoring phase\n# Initialization errors will fail the workflow via 'set -euo pipefail' (line 2)\n# The ERR trap logs errors but doesn't exit - 'set -e' handles the exit\nmain || {\n  EXIT_CODE=$?\n  # Only convert to success if we're in monitoring phase\n  # Initialization failures (before MONITORING_PHASE=true) should fail\n  if [[ \"${MONITORING_PHASE:-false}\" == \"true\" ]]; then\n    echo \"⚠️ Morgan PM encountered an error during monitoring, but continuing as daemon...\"\n    echo \"   Error code: $EXIT_CODE\"\n    # Log the error but don't fail workflow - monitoring errors are non-fatal\n    exit 0\n  else\n    echo \"❌ Morgan PM initialization failed with exit code: $EXIT_CODE\"\n    echo \"   This is a fatal error - workflow should fail\"\n    # Propagate the error - initialization failures should fail the workflow\n    exit $EXIT_CODE\n  fi\n}\n\necho \"✅ DEBUG: main() completed successfully\"\n\n\n\n"
  process-issue-comment.sh.hbs: "#!/bin/bash\nset -euo pipefail\n\n# Morgan Issue Comment Processor\n# Processes human feedback from GitHub issue comments\n# Updates TaskMaster documentation based on comment intent\n\necho \"\U0001F4AC Morgan - Processing Issue Comment\"\necho \"Issue #$ISSUE_NUMBER | Author: $COMMENT_AUTHOR | Intent: $INTENT_TYPE\"\n\n# ============================================================================\n# GITHUB APP AUTHENTICATION\n# ============================================================================\n\necho \"\U0001F510 Authenticating with GitHub App...\"\n\nif [ -n \"${GITHUB_APP_PRIVATE_KEY:-}\" ] && [ -n \"${GITHUB_APP_ID:-}\" ]; then\n    # Parse repository info early\n    # Handle both full URL and short format (owner/repo)\n    if [[ \"$REPOSITORY\" =~ github\\.com[:/]([^/]+)/([^/\\.]+)(\\.git)?$ ]]; then\n        # Full URL format: allows .git suffix\n        REPO_OWNER=\"${BASH_REMATCH[1]}\"\n        REPO_NAME=\"${BASH_REMATCH[2]}\"\n    elif [[ \"$REPOSITORY\" =~ ^([^/]+)/([^/]+)$ ]]; then\n        # Short format: owner/repo (allows dots in repo name)\n        REPO_OWNER=\"${BASH_REMATCH[1]}\"\n        REPO_NAME=\"${BASH_REMATCH[2]}\"\n    else\n        echo \"❌ Failed to parse repository: $REPOSITORY\"\n        echo \"Expected formats: 'owner/repo' or 'https://github.com/owner/repo'\"\n        exit 1\n    fi\n\n    # Create temporary key file\n    TEMP_KEY_FILE=\"/tmp/github-app-key-$$\"\n    echo \"$GITHUB_APP_PRIVATE_KEY\" > \"$TEMP_KEY_FILE\"\n    chmod 600 \"$TEMP_KEY_FILE\"\n\n    # Generate JWT token\n    JWT_TOKEN=$(ruby -r openssl -r json -r base64 -e \"\n    key = OpenSSL::PKey::RSA.new(File.read('$TEMP_KEY_FILE'))\n    payload = {\n        iat: Time.now.to_i - 60,\n        exp: Time.now.to_i + (10 * 60),\n        iss: '$GITHUB_APP_ID'\n    }\n    header = { alg: 'RS256', typ: 'JWT' }\n\n    header_enc = Base64.urlsafe_encode64(header.to_json).gsub('=', '')\n    payload_enc = Base64.urlsafe_encode64(payload.to_json).gsub('=', '')\n    signature = Base64.urlsafe_encode64(key.sign(OpenSSL::Digest::SHA256.new, \\\"#{header_enc}.#{payload_enc}\\\")).gsub('=', '')\n\n    puts \\\"#{header_enc}.#{payload_enc}.#{signature}\\\"\n    \")\n\n    # Get installation ID\n    INSTALLATION_RESPONSE=$(curl -s -H \"Authorization: Bearer $JWT_TOKEN\" \\\n        -H \"Accept: application/vnd.github+json\" \\\n        \"https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation\")\n\n    INSTALLATION_ID=$(echo \"$INSTALLATION_RESPONSE\" | jq -r '.id')\n\n    if [ \"$INSTALLATION_ID\" = \"null\" ] || [ -z \"$INSTALLATION_ID\" ]; then\n        echo \"⚠️  No repo installation, trying organization...\"\n        ORG_INSTALLATION_RESPONSE=$(curl -s -H \"Authorization: Bearer $JWT_TOKEN\" \\\n            -H \"Accept: application/vnd.github+json\" \\\n            \"https://api.github.com/orgs/$REPO_OWNER/installation\")\n        \n        INSTALLATION_ID=$(echo \"$ORG_INSTALLATION_RESPONSE\" | jq -r '.id')\n    fi\n\n    if [ \"$INSTALLATION_ID\" = \"null\" ] || [ -z \"$INSTALLATION_ID\" ]; then\n        echo \"❌ Failed to get installation ID\"\n        rm -f \"$TEMP_KEY_FILE\"\n        exit 1\n    fi\n\n    # Get installation access token\n    TOKEN_RESPONSE=$(curl -s -X POST \\\n        -H \"Authorization: Bearer $JWT_TOKEN\" \\\n        -H \"Accept: application/vnd.github+json\" \\\n        \"https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens\")\n\n    GITHUB_TOKEN=$(echo \"$TOKEN_RESPONSE\" | jq -r '.token')\n\n    if [ \"$GITHUB_TOKEN\" = \"null\" ] || [ -z \"$GITHUB_TOKEN\" ]; then\n        echo \"❌ Failed to get installation access token\"\n        echo \"Response: $TOKEN_RESPONSE\"\n        rm -f \"$TEMP_KEY_FILE\"\n        exit 1\n    fi\n\n    rm -f \"$TEMP_KEY_FILE\"\n\n    # Export and configure authentication\n    export GITHUB_TOKEN\n    git config --global --replace-all credential.helper store\n    echo \"https://x-access-token:${GITHUB_TOKEN}@github.com\" > ~/.git-credentials\n    echo \"$GITHUB_TOKEN\" | gh auth login --with-token\n    git config --global --add safe.directory /tmp/task-docs\n\n    echo \"✅ GitHub App authenticated successfully\"\n\nelse\n    echo \"❌ GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found\"\n    exit 1\nfi\n\n# ============================================================================\n# CONFIGURATION\n# ============================================================================\n\nTASK_DIR=\"/tmp/task-docs\"\n\n# ============================================================================\n# MAIN PROCESSING\n# ============================================================================\n\nprocess_comment() {\n  echo \"\U0001F4E5 Cloning repository...\"\n  git clone --depth 1 \"$REPOSITORY_URL\" \"$TASK_DIR\"\n  cd \"$TASK_DIR\"\n  \n  # Find TaskMaster docs directory\n  DOCS_DIR=\"\"\n  if [[ -d \".taskmaster/docs/task-$TASK_ID\" ]]; then\n    DOCS_DIR=\".taskmaster/docs/task-$TASK_ID\"\n  elif [[ -d \".taskmaster/tasks/task-$TASK_ID\" ]]; then\n    DOCS_DIR=\".taskmaster/tasks/task-$TASK_ID\"\n  else\n    echo \"⚠️  Task directory not found for task $TASK_ID\"\n    post_comment_reply \"I couldn't find the task directory for task $TASK_ID. Please check the task ID.\"\n    exit 0\n  fi\n  \n  echo \"✅ Found task directory: $DOCS_DIR\"\n  \n  # Process based on intent type\n  case \"$INTENT_TYPE\" in\n    \"scope-change\")\n      handle_scope_change\n      ;;\n    \"clarification\")\n      handle_clarification\n      ;;\n    \"priority-change\")\n      handle_priority_change\n      ;;\n    *)\n      echo \"ℹ️  No action required for intent type: $INTENT_TYPE\"\n      ;;\n  esac\n}\n\nhandle_scope_change() {\n  echo \"\U0001F504 Processing scope change request...\"\n  \n  # Add comment to implementation notes\n  TIMESTAMP=$(date -u +\"%Y-%m-%d %H:%M:%S UTC\")\n  echo \"\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"---\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"## Scope Change Request - $TIMESTAMP\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"**Requested by**: @$COMMENT_AUTHOR\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"$COMMENT_BODY\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"\" >> \"$DOCS_DIR/implementation-notes.md\"\n  \n  # Commit changes\n  git config user.name \"Morgan PM Bot\"\n  git config user.email \"morgan@5dlabs.com\"\n  git add \"$DOCS_DIR/implementation-notes.md\"\n  git commit -m \"docs: update task $TASK_ID scope per issue #$ISSUE_NUMBER\n\nRequested by: @$COMMENT_AUTHOR\nType: Scope change\"\n  \n  git push origin HEAD\n  \n  # Reply to comment\n  post_comment_reply \"✅ I've updated the implementation notes for task $TASK_ID to reflect your scope change request. The changes have been committed and will be visible to the implementation team.\"\n}\n\nhandle_clarification() {\n  echo \"❓ Processing clarification request...\"\n  \n  # Add comment to implementation notes\n  TIMESTAMP=$(date -u +\"%Y-%m-%d %H:%M:%S UTC\")\n  echo \"\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"---\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"## Clarification Request - $TIMESTAMP\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"**Asked by**: @$COMMENT_AUTHOR\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"$COMMENT_BODY\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"_Awaiting response from technical lead or stakeholder._\" >> \"$DOCS_DIR/implementation-notes.md\"\n  echo \"\" >> \"$DOCS_DIR/implementation-notes.md\"\n  \n  # Commit changes\n  git config user.name \"Morgan PM Bot\"\n  git config user.email \"morgan@5dlabs.com\"\n  git add \"$DOCS_DIR/implementation-notes.md\"\n  git commit -m \"docs: add clarification request for task $TASK_ID\n\nFrom issue #$ISSUE_NUMBER by @$COMMENT_AUTHOR\"\n  \n  git push origin HEAD\n  \n  # Reply to comment\n  post_comment_reply \"\U0001F4DD I've documented your clarification request in the task notes. A technical lead or stakeholder will respond with the needed information.\"\n}\n\nhandle_priority_change() {\n  echo \"⚡ Processing priority change request...\"\n  \n  # Extract new priority from comment\n  NEW_PRIORITY=\"high\"\n  if echo \"$COMMENT_BODY\" | grep -iE 'medium|normal' >/dev/null; then\n    NEW_PRIORITY=\"medium\"\n  elif echo \"$COMMENT_BODY\" | grep -iE 'low' >/dev/null; then\n    NEW_PRIORITY=\"low\"\n  fi\n  \n  # Update tasks.json\n  TASKS_JSON=\".taskmaster/tasks/tasks.json\"\n  if [[ -f \"$TASKS_JSON\" ]]; then\n    TEMP_JSON=$(mktemp)\n    jq --arg task_id \"$TASK_ID\" \\\n       --arg priority \"$NEW_PRIORITY\" \\\n       '(.tasks // .master.tasks // []) |= map(if .id == ($task_id | tonumber) then .priority = $priority else . end)' \\\n       \"$TASKS_JSON\" > \"$TEMP_JSON\"\n    mv \"$TEMP_JSON\" \"$TASKS_JSON\"\n    \n    # Commit changes\n    git config user.name \"Morgan PM Bot\"\n    git config user.email \"morgan@5dlabs.com\"\n    git add \"$TASKS_JSON\"\n    git commit -m \"chore: update task $TASK_ID priority to $NEW_PRIORITY\n\nRequested in issue #$ISSUE_NUMBER by @$COMMENT_AUTHOR\"\n    \n    git push origin HEAD\n    \n    # Update issue label\n    gh issue edit \"$ISSUE_NUMBER\" \\\n      --repo \"$REPO_OWNER/$REPO_NAME\" \\\n      --remove-label \"priority-high,priority-medium,priority-low\" \\\n      --add-label \"priority-$NEW_PRIORITY\"\n    \n    # Reply to comment\n    post_comment_reply \"✅ Priority updated to **$NEW_PRIORITY** for task $TASK_ID.\"\n  else\n    post_comment_reply \"⚠️  I couldn't update the priority because the tasks.json file wasn't found.\"\n  fi\n}\n\npost_comment_reply() {\n  local message=\"$1\"\n  \n  gh issue comment \"$ISSUE_NUMBER\" \\\n    --repo \"$REPO_OWNER/$REPO_NAME\" \\\n    --body \"## Morgan PM Response\n\n$message\n\n---\n*This is an automated response from Morgan, your AI Project Manager.*\"\n}\n\n# ============================================================================\n# EXECUTION\n# ============================================================================\n\nprocess_comment\necho \"✅ Comment processing complete\"\n\n\n\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: controller-templates-pm
  namespace: cto
  labels:
    app.kubernetes.io/component: templates
    app.kubernetes.io/part-of: cto
