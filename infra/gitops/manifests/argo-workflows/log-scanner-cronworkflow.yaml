---
# CronWorkflow for hourly log scanning
# Scans Loki for errors/warnings across platform namespaces
# and triggers automated remediation CodeRuns when issues are detected.
apiVersion: argoproj.io/v1alpha1
kind: CronWorkflow
metadata:
  name: log-error-scanner
  namespace: cto
  labels:
    app.kubernetes.io/name: healer
    app.kubernetes.io/component: log-scanner
    app.kubernetes.io/managed-by: gitops
spec:
  # Run every hour at minute 0
  schedule: "0 * * * *"

  # Timezone (optional, defaults to UTC)
  timezone: "UTC"

  # Don't run if previous scan is still running
  concurrencyPolicy: "Forbid"

  # Keep last 3 successful and 3 failed workflow runs
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3

  # Start deadline - if scheduler misses window, don't run
  startingDeadlineSeconds: 300

  workflowSpec:
    entrypoint: scan-and-remediate
    serviceAccountName: argo-workflow

    # Workflow-level TTL for cleanup
    ttlStrategy:
      secondsAfterCompletion: 3600  # Keep for 1 hour after completion
      secondsAfterSuccess: 1800     # Keep successful for 30 min
      secondsAfterFailure: 7200     # Keep failed for 2 hours

    # Pod garbage collection
    podGC:
      strategy: OnPodSuccess
      deleteDelayDuration: "60s"

    templates:
      - name: scan-and-remediate
        steps:
          # Step 1: Run the log scan
          - - name: scan-logs
              template: healer-scan

          # Step 2: Report results for visibility
          - - name: report-results
              template: report
              arguments:
                parameters:
                  - name: scan-output
                    value: "{{steps.scan-logs.outputs.result}}"

          # Step 3: Trigger remediation if recommended
          - - name: trigger-remediation
              template: remediate
              arguments:
                parameters:
                  - name: scan-output
                    value: "{{steps.scan-logs.outputs.result}}"
              when: "{{steps.scan-logs.outputs.result}} != ''"

      - name: healer-scan
        container:
          # Use dev registry image until ghcr.io/5dlabs/healer:latest is built
          # TODO: Switch back to ghcr.io/5dlabs/healer:latest after PR #3007 merges
          image: 192.168.1.77:30500/healer:tilt-dev
          imagePullPolicy: Always
          command: ["healer"]
          args:
            - "scan-logs"
            - "--window=1h"
            - "--namespaces=cto,automation,argocd,infra,observability"
            - "--error-threshold=5"
            - "--warn-threshold=20"
            - "--output=json"
            - "--show-candidates"
          env:
            - name: LOKI_URL
              value: "http://loki-gateway.observability.svc.cluster.local:80"
            - name: RUST_LOG
              value: "info"
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"

      - name: report
        inputs:
          parameters:
            - name: scan-output
        script:
          # Use alpine/k8s which has jq pre-installed for JSON parsing
          image: alpine/k8s:1.31.0
          command: ["/bin/sh"]
          source: |
            #!/bin/sh
            set -e

            # Extract JSON from scan output (may contain banner text before JSON)
            SCAN_JSON=$(echo '{{inputs.parameters.scan-output}}' | grep -o '{.*}' | tail -1)

            if [ -z "$SCAN_JSON" ]; then
              echo "Error: No JSON found in scan output"
              exit 1
            fi

            echo "=== Log Scan Results ==="
            echo "$SCAN_JSON" | jq -r '
              "Scan Time: \(.scan_time)",
              "Window: \(.window_minutes) minutes",
              "Total Errors: \(.total_errors)",
              "Total Warnings: \(.total_warnings)",
              "Services with Issues: \(.services_with_issues | length)",
              "",
              "Remediation Recommended: \(.remediation_recommended)",
              if .recommendation_reason then "Reason: \(.recommendation_reason)" else "" end
            '

            # Check if remediation is recommended
            REMEDIATION=$(echo "$SCAN_JSON" | jq -r '.remediation_recommended')

            if [ "$REMEDIATION" = "true" ]; then
              echo ""
              echo "‚ö†Ô∏è  REMEDIATION RECOMMENDED"

              # Extract services needing attention
              echo ""
              echo "Services needing attention:"
              echo "$SCAN_JSON" | jq -r '
                .services_with_issues[] |
                "  - \(.namespace)/\(.service): \(.error_count) errors, \(.warn_count) warnings"
              '
            else
              echo ""
              echo "‚úì No remediation needed at this time"
            fi
          resources:
            requests:
              memory: "64Mi"
              cpu: "50m"
            limits:
              memory: "128Mi"
              cpu: "200m"

      - name: remediate
        inputs:
          parameters:
            - name: scan-output
        script:
          # Use dev registry image - healer binary handles remediation logic internally
          image: 192.168.1.77:30500/healer:tilt-dev
          command: ["/bin/sh"]
          source: |
            #!/bin/sh
            set -e

            # Extract JSON from scan output (may contain banner text before JSON)
            SCAN_JSON=$(echo '{{inputs.parameters.scan-output}}' | grep -o '{.*}' | tail -1)

            # Check if scan output contains remediation_recommended:true
            # Use grep instead of jq since jq isn't available in healer image
            if ! echo "$SCAN_JSON" | grep -q '"remediation_recommended":true'; then
              echo "‚úì No remediation needed, skipping CodeRun creation"
              exit 0
            fi

            echo "üîß Triggering remediation for detected issues..."
            echo ""

            # Pipe scan JSON to healer remediate-from-scan
            # --max-coderuns=3 limits concurrent remediations
            echo "$SCAN_JSON" | healer remediate-from-scan \
              --max-coderuns=3

            echo ""
            echo "‚úÖ Remediation triggered successfully"
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
