---
# CronWorkflow for hourly log scanning
# Scans Loki for errors/warnings across platform namespaces
# and triggers automated remediation CodeRuns when issues are detected.
apiVersion: argoproj.io/v1alpha1
kind: CronWorkflow
metadata:
  name: log-error-scanner
  namespace: cto
  labels:
    app.kubernetes.io/name: healer
    app.kubernetes.io/component: log-scanner
    app.kubernetes.io/managed-by: gitops
spec:
  # Run every hour at minute 0
  schedule: "0 * * * *"

  # Timezone (optional, defaults to UTC)
  timezone: "UTC"

  # Don't run if previous scan is still running
  concurrencyPolicy: "Forbid"

  # Keep last 3 successful and 3 failed workflow runs
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3

  # Start deadline - if scheduler misses window, don't run
  startingDeadlineSeconds: 300

  workflowSpec:
    entrypoint: scan-and-remediate
    serviceAccountName: argo-workflow

    # Workflow-level TTL for cleanup
    ttlStrategy:
      secondsAfterCompletion: 3600  # Keep for 1 hour after completion
      secondsAfterSuccess: 1800     # Keep successful for 30 min
      secondsAfterFailure: 7200     # Keep failed for 2 hours

    # Pod garbage collection
    podGC:
      strategy: OnPodSuccess
      deleteDelayDuration: "60s"

    templates:
      - name: scan-and-remediate
        steps:
          # Step 1: Run the log scan
          - - name: scan-logs
              template: healer-scan

          # Step 2: Report results for visibility
          - - name: report-results
              template: report
              arguments:
                parameters:
                  - name: scan-output
                    value: "{{steps.scan-logs.outputs.parameters.scan-json}}"

          # Step 3: Trigger remediation if recommended
          - - name: trigger-remediation
              template: remediate
              arguments:
                parameters:
                  - name: scan-output
                    value: "{{steps.scan-logs.outputs.parameters.scan-json}}"
              when: "{{steps.scan-logs.outputs.parameters.remediation-needed}} == true"

      - name: healer-scan
        # Use script template to capture output as parameter
        script:
          image: ghcr.io/5dlabs/healer:latest
          imagePullPolicy: Always
          command: ["/bin/sh"]
          source: |
            #!/bin/sh
            # Run healer scan-logs and write JSON to output parameter file
            healer scan-logs \
              --window=1h \
              --namespaces=cto,automation,argocd,infra,observability \
              --error-threshold=5 \
              --warn-threshold=20 \
              --output=json \
              --show-candidates > /tmp/scan-result.json

            # Output JSON to parameter file (Argo reads from this)
            cat /tmp/scan-result.json > /tmp/scan-json

            # Extract remediation_recommended value for conditional step
            # Use grep since jq isn't available in healer image
            if grep -q '"remediation_recommended"[[:space:]]*:[[:space:]]*true' /tmp/scan-result.json; then
              echo "true" > /tmp/remediation-needed
            else
              echo "false" > /tmp/remediation-needed
            fi

            # Also output to stdout for visibility in logs
            cat /tmp/scan-result.json
          env:
            - name: LOKI_URL
              value: "http://loki-gateway.observability.svc.cluster.local:80"
            - name: RUST_LOG
              value: "info"
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
        outputs:
          parameters:
            - name: scan-json
              valueFrom:
                path: /tmp/scan-json
            - name: remediation-needed
              valueFrom:
                path: /tmp/remediation-needed

      - name: report
        inputs:
          parameters:
            - name: scan-output
        script:
          # Use alpine/k8s which has jq pre-installed for JSON parsing
          image: alpine/k8s:1.31.0
          command: ["/bin/sh"]
          source: |
            #!/bin/sh
            set -e

            # The scan output is passed as a parameter - write to file to handle multi-line JSON
            cat > /tmp/scan-result.json << 'SCAN_JSON_EOF'
            {{inputs.parameters.scan-output}}
            SCAN_JSON_EOF

            # Validate JSON
            if ! jq -e . /tmp/scan-result.json > /dev/null 2>&1; then
              echo "Error: Invalid JSON in scan result"
              cat /tmp/scan-result.json
              exit 1
            fi

            echo "=== Log Scan Results ==="
            jq -r '
              "Scan Time: \(.scan_time)",
              "Window: \(.window_minutes) minutes",
              "Total Errors: \(.total_errors)",
              "Total Warnings: \(.total_warnings)",
              "Services with Issues: \(.services_with_issues | length)",
              "",
              "Remediation Recommended: \(.remediation_recommended)",
              if .recommendation_reason then "Reason: \(.recommendation_reason)" else "" end
            ' /tmp/scan-result.json

            # Check if remediation is recommended
            REMEDIATION=$(jq -r '.remediation_recommended' /tmp/scan-result.json)

            if [ "$REMEDIATION" = "true" ]; then
              echo ""
              echo "âš ï¸  REMEDIATION RECOMMENDED"

              # Extract services needing attention
              echo ""
              echo "Services needing attention:"
              jq -r '
                .services_with_issues[] |
                "  - \(.namespace)/\(.service): \(.error_count) errors, \(.warn_count) warnings"
              ' /tmp/scan-result.json
            else
              echo ""
              echo "âœ“ No remediation needed at this time"
            fi
          resources:
            requests:
              memory: "64Mi"
              cpu: "50m"
            limits:
              memory: "128Mi"
              cpu: "200m"

      - name: remediate
        inputs:
          parameters:
            - name: scan-output
        script:
          image: ghcr.io/5dlabs/healer:latest
          command: ["/bin/sh"]
          source: |
            #!/bin/sh
            set -e

            # The scan output is passed as a parameter - write to file to handle multi-line JSON
            cat > /tmp/scan-result.json << 'SCAN_JSON_EOF'
            {{inputs.parameters.scan-output}}
            SCAN_JSON_EOF

            # Check if scan output contains remediation_recommended:true
            # Use grep instead of jq since jq isn't available in healer image
            if ! grep -q '"remediation_recommended"[[:space:]]*:[[:space:]]*true' /tmp/scan-result.json; then
              echo "âœ“ No remediation needed, skipping CodeRun creation"
              exit 0
            fi

            echo "ðŸ”§ Triggering remediation for detected issues..."
            echo ""

            # Pipe scan JSON to healer remediate-from-scan
            # --max-coderuns=3 limits concurrent remediations
            cat /tmp/scan-result.json | healer remediate-from-scan \
              --max-coderuns=3

            echo ""
            echo "âœ… Remediation triggered successfully"
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
