{{- if .Values.webhooks.enabled }}
---
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: tess-label-fallback
  namespace: automation
  labels:
    task: "7"
    type: stage-management
    component: fallback-trigger
spec:
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: approved-label-event
      eventSourceName: github
      eventName: org
      filters:
        data:
          # Filter for pull_request labeled events
          - path: body.X-GitHub-Event
            type: string
            value: ["pull_request"]
          - path: body.action
            type: string
            value: ["labeled"]
          - path: body.label.name
            type: string
            value: ["approved"]
          # Only for our repositories
          - path: body.repository.full_name
            type: string
            value: ["5dlabs/cto", "5dlabs/cto-parallel-test", "5dlabs/cto-play-test"]

  triggers:
    - template:
        name: trigger-atlas-on-label
        conditions: "approved-label-event"
        parameters:
          - src:
              dependencyName: approved-label-event
              dataKey: body.pull_request.number
            dest: spec.arguments.parameters.0.value
          - src:
              dependencyName: approved-label-event
              dataKey: body.repository.full_name
            dest: spec.arguments.parameters.1.value
          - src:
              dependencyName: approved-label-event
              dataTemplate: "{{ .Input.body.pull_request.labels | toJson }}"
            dest: spec.arguments.parameters.2.value
          - src:
              dependencyName: approved-label-event
              dataKey: body.pull_request.head.ref
            dest: spec.arguments.parameters.3.value
        k8s:
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: tess-label-fallback-
                namespace: cto
                labels:
                  type: stage-resume
                  target-stage: waiting-atlas-integration
                  trigger: label-fallback
              spec:
                entrypoint: trigger-atlas-fallback
                serviceAccountName: argo-workflow
                ttlStrategy:
                  secondsAfterCompletion: 300
                  secondsAfterFailure: 3600
                podGC:
                  strategy: OnPodCompletion
                arguments:
                  parameters:
                    - name: pr-number
                      value: ""
                    - name: repo-full
                      value: ""
                    - name: pr-labels
                      value: ""
                    - name: pr-branch
                      value: ""
                templates:
                  - name: trigger-atlas-fallback
                    script:
                      image: alpine/k8s:1.31.0
                      command: [bash]
                      source: |
                        #!/bin/bash
                        set -euo pipefail

                        # Install jq if needed
                        if ! command -v jq >/dev/null 2>&1; then
                          if command -v apk >/dev/null 2>&1; then
                            apk add --no-cache jq >/dev/null 2>&1
                          fi
                        fi

                        # Extract parameters
                        PR_NUMBER='{{workflow.parameters.pr-number}}'
                        REPO_FULL='{{workflow.parameters.repo-full}}'
                        PR_LABELS='{{workflow.parameters.pr-labels}}'
                        PR_BRANCH='{{workflow.parameters.pr-branch}}'

                        echo "=== Tess Label Fallback Trigger ==="
                        echo "PR: #$PR_NUMBER | Repo: $REPO_FULL"
                        echo "Triggered by 'approved' label (fallback for PR review failure)"

                        # Extract task ID from labels or branch
                        TASK_ID=""
                        if [ -n "$PR_LABELS" ] && [ "$PR_LABELS" != "null" ]; then
                          TASK_ID=$(echo "$PR_LABELS" | \
                            jq -r '.[] | select(.name | test("task-[0-9]+")) | .name |
                              capture("task-(?<id>[0-9]+)") | .id' \
                            2>/dev/null | head -n1 || true)
                        fi

                        if [ -z "$TASK_ID" ] && [ -n "$PR_BRANCH" ] && [ "$PR_BRANCH" != "null" ]; then
                          TASK_ID=$(echo "$PR_BRANCH" | grep -oE 'task[-_]*([0-9]+)' | grep -oE '[0-9]+' | head -n1 || true)
                        fi

                        if [ -z "$TASK_ID" ]; then
                          echo "‚ö†Ô∏è Could not extract task ID from PR labels or branch"
                          TASK_ID="0"
                        fi

                        echo "Task ID: $TASK_ID"

                        # Convert repo to label format
                        REPO_LABEL=$(echo "$REPO_FULL" | tr '/' '-')

                        # Find the workflow to resume
                        echo "üîç Looking for workflow with task-id=$TASK_ID and repository=$REPO_LABEL..."
                        WORKFLOW_NAME=$(kubectl get workflows -n cto \
                          -l "task-id=$TASK_ID,repository=$REPO_LABEL" \
                          --field-selector status.phase=Running \
                          -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

                        if [ -z "$WORKFLOW_NAME" ]; then
                          echo "‚ö†Ô∏è No running workflow found for task $TASK_ID in repo $REPO_LABEL"
                          echo "   Checking for any suspended workflow..."

                          # Look for any workflow with suspended nodes
                          WORKFLOW_NAME=$(kubectl get workflows -n cto \
                            -l "task-id=$TASK_ID" \
                            -o json | \
                            jq -r '.items[] |
                              select(.status.nodes | to_entries[] |
                                select(.value.type == "Suspend" and .value.phase == "Running"))
                              | .metadata.name' | \
                            head -n1)

                          if [ -z "$WORKFLOW_NAME" ]; then
                            echo "‚ùå No suspended workflow found to resume"
                            exit 0
                          fi
                        fi

                        echo "‚úÖ Found workflow: $WORKFLOW_NAME"

                        # Get current stage
                        CURRENT_STAGE=$(kubectl get workflow "$WORKFLOW_NAME" -n cto \
                          -o jsonpath='{.metadata.labels.current-stage}' 2>/dev/null || echo "")

                        echo "Current stage: $CURRENT_STAGE"

                        # Check if workflow is at a stage where we should resume
                        if [[ "$CURRENT_STAGE" == "waiting-ready-for-qa" ]] || \
                           [[ "$CURRENT_STAGE" == "testing-in-progress" ]] || \
                           [[ "$CURRENT_STAGE" == "waiting-atlas-integration" ]]; then

                          echo "üìç Workflow is at stage: $CURRENT_STAGE"

                          # Find suspended nodes
                          SUSPEND_NODES=$(kubectl get workflow "$WORKFLOW_NAME" -n cto -o json | \
                            jq -r '.status.nodes | to_entries[] | select(.value.type == "Suspend" and .value.phase == "Running") | .key')

                          if [ -n "$SUSPEND_NODES" ]; then
                            echo "üîÑ Resuming suspended nodes..."
                            for node in $SUSPEND_NODES; do
                              echo "   Resuming node: $node"
                              kubectl patch workflow "$WORKFLOW_NAME" -n cto \
                                --type='json' \
                                -p='[{"op":"replace","path":"/status/nodes/'"$node"'/phase","value":"Succeeded"}]' 2>/dev/null || true
                            done

                            # Also try to resume the workflow itself
                            kubectl patch workflow "$WORKFLOW_NAME" -n cto \
                              --type='json' \
                              -p='[{"op":"replace","path":"/spec/suspend","value":null}]' 2>/dev/null || true

                            echo "‚úÖ Workflow resumed via label fallback trigger"

                            # Update stage if needed
                            if [[ "$CURRENT_STAGE" == "waiting-ready-for-qa" ]] || [[ "$CURRENT_STAGE" == "testing-in-progress" ]]; then
                              echo "üìç Updating stage to waiting-atlas-integration..."
                              kubectl label workflow "$WORKFLOW_NAME" -n cto \
                                current-stage=waiting-atlas-integration \
                                previous-stage="$CURRENT_STAGE" \
                                --overwrite
                            fi
                          else
                            echo "‚ÑπÔ∏è No suspended nodes found - workflow may already be progressing"
                          fi
                        else
                          echo "‚ÑπÔ∏è Workflow not at expected stage for Tess approval, current: $CURRENT_STAGE"
                          echo "   Expected one of: waiting-ready-for-qa, testing-in-progress, waiting-atlas-integration"
                        fi

                        echo "‚úÖ Fallback trigger completed"
{{- end }}
