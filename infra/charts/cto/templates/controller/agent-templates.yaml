{{- if .Values.controller.enabled }}
# =============================================================================
# Agent Templates ConfigMaps
# =============================================================================
# These ConfigMaps contain shell scripts used by Argo Workflows to run
# intake and play workflows with different CLI tools.
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: controller-agents
  namespace: {{ include "cto.namespace" . }}
  labels:
    {{- include "cto.controller.labels" . | nindent 4 }}
    app.kubernetes.io/component: agents
data:
  # Agent configuration for intake and play workflows
  agents.json: |
    {
      "version": "1.0.0",
      "agents": {
        "intake": {
          "name": "intake",
          "type": "intake",
          "description": "PRD analysis and task generation"
        },
        "play": {
          "name": "play",
          "type": "play",
          "description": "Task implementation"
        }
      }
    }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: controller-agent-templates-intake
  namespace: {{ include "cto.namespace" . }}
  labels:
    {{- include "cto.controller.labels" . | nindent 4 }}
    app.kubernetes.io/component: agent-templates
data:
  # GitHub preparation script - creates/clones repository and sets up webhooks
  # This step runs BEFORE the main intake and handles:
  # 1. Creating new repos if no repository_url is provided
  # 2. Cloning existing repos and setting up webhooks
  # 3. Outputting the final repository URL for the intake step
  github_prep.sh: |
    #!/bin/bash
    set -euo pipefail

    # =========================================================================
    # Linear Agent Activity helpers (optional)
    # =========================================================================
    activity_enabled() {
        command -v pm-activity >/dev/null 2>&1 && \
          [ -n "${LINEAR_SESSION_ID:-}" ] && \
          [ -n "${LINEAR_API_TOKEN:-}" ]
    }

    activity_thought() {
        local body="$1"
        if activity_enabled; then
            pm-activity thought --persistent "$body" >/dev/null 2>&1 || true
        fi
    }

    activity_action() {
        local action="$1"
        local parameter="$2"
        if activity_enabled; then
            pm-activity action "$action" "$parameter" >/dev/null 2>&1 || true
        fi
    }

    activity_action_complete() {
        local action="$1"
        local parameter="$2"
        local result="$3"
        if activity_enabled; then
            pm-activity action-complete "$action" "$parameter" "$result" >/dev/null 2>&1 || true
        fi
    }

    activity_error() {
        local body="$1"
        if activity_enabled; then
            pm-activity error "$body" >/dev/null 2>&1 || true
        fi
    }

    # =========================================================================
    # GitHub Repository Preparation Script
    # Runs before intake to ensure repository exists and is configured
    # =========================================================================

    echo "ğŸ”§ GitHub Repository Preparation"
    echo "================================="
    echo "ğŸ“… Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo ""

    activity_thought "GitHub prep started for ${LINEAR_ISSUE_IDENTIFIER:-unknown} (${HOSTNAME:-unknown})"

    # =========================================================================
    # Configuration
    # =========================================================================

    CONFIG_FILE="/intake-files/config.json"

    if [ ! -f "$CONFIG_FILE" ]; then
        echo "âŒ Configuration file not found at $CONFIG_FILE"
        exit 1
    fi

    PROJECT_NAME=$(jq -r '.project_name' "$CONFIG_FILE")
    REPOSITORY_URL=$(jq -r '.repository_url // ""' "$CONFIG_FILE")
    GITHUB_DEFAULT_ORG=$(jq -r '.github_default_org // "5dlabs"' "$CONFIG_FILE")
    GITHUB_VISIBILITY=$(jq -r '.github_visibility // "private"' "$CONFIG_FILE")
    WEBHOOK_CALLBACK_URL=$(jq -r '.webhook_callback_url // ""' "$CONFIG_FILE")

    echo "ğŸ“‹ Configuration:"
    echo "  â†’ Project: $PROJECT_NAME"
    echo "  â†’ Repository URL: ${REPOSITORY_URL:-<not provided>}"
    echo "  â†’ Default Org: $GITHUB_DEFAULT_ORG"
    echo "  â†’ Visibility: $GITHUB_VISIBILITY"
    echo ""

    activity_action "GitHub prep: load config" "$PROJECT_NAME"

    # =========================================================================
    # GitHub Authentication
    # =========================================================================

    echo "ğŸ” Setting up GitHub App authentication..."
    activity_action "GitHub auth" "${GITHUB_DEFAULT_ORG}/${REPO_NAME:-repo}"

    if [ -n "${GITHUB_APP_ID:-}" ] && [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
        # Create JWT
        NOW=$(date +%s)
        IAT=$((NOW - 60))
        EXP=$((NOW + 600))
        
        HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
        PAYLOAD=$(echo -n "{\"iat\":${IAT},\"exp\":${EXP},\"iss\":\"${GITHUB_APP_ID}\"}" | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
        
        SIGNATURE=$(echo -n "${HEADER}.${PAYLOAD}" | openssl dgst -sha256 -sign <(echo "$GITHUB_APP_PRIVATE_KEY") | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
        JWT="${HEADER}.${PAYLOAD}.${SIGNATURE}"
        
        # Get installation token
        INSTALLATIONS=$(curl -s -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github+json" "https://api.github.com/app/installations")
        INSTALLATION_ID=$(echo "$INSTALLATIONS" | jq -r '.[0].id')
        
        if [ -n "$INSTALLATION_ID" ] && [ "$INSTALLATION_ID" != "null" ]; then
            TOKEN_RESPONSE=$(curl -s -X POST -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github+json" "https://api.github.com/app/installations/${INSTALLATION_ID}/access_tokens")
            GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
            
            if [ -n "$GITHUB_TOKEN" ] && [ "$GITHUB_TOKEN" != "null" ]; then
                export GITHUB_TOKEN
                export GH_TOKEN="$GITHUB_TOKEN"
                git config --global credential.helper "!f() { echo \"password=$GITHUB_TOKEN\"; }; f"
                git config --global url."https://x-access-token:${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"
                echo "âœ… GitHub authentication configured"
            else
                echo "âŒ Could not get installation token"
                exit 1
            fi
        else
            echo "âŒ Could not get installation ID"
            exit 1
        fi
    else
        echo "âŒ GitHub App credentials not provided"
        exit 1
    fi
    echo ""

    # =========================================================================
    # Repository Setup
    # =========================================================================

    # Normalize repo name from project name
    REPO_NAME=$(echo "$PROJECT_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' | sed 's/^-*//;s/-*$//')

    if [ -z "$REPOSITORY_URL" ] || [ "$REPOSITORY_URL" = "null" ]; then
        # =====================================================================
        # Create New Repository
        # =====================================================================
        echo "ğŸ†• No repository provided - creating new repository"
        activity_action "Create repository" "$GITHUB_DEFAULT_ORG/$REPO_NAME"
        
        FULL_REPO_NAME="${GITHUB_DEFAULT_ORG}/${REPO_NAME}"
        
        # Check if repo already exists
        if gh repo view "$FULL_REPO_NAME" &>/dev/null; then
            echo "  âš ï¸ Repository $FULL_REPO_NAME already exists"
            REPOSITORY_URL="https://github.com/${FULL_REPO_NAME}"
        else
            echo "  â†’ Creating $GITHUB_VISIBILITY repository: $FULL_REPO_NAME"
            gh repo create "$FULL_REPO_NAME" \
                --"$GITHUB_VISIBILITY" \
                --description "Generated from Linear intake: $PROJECT_NAME" \
                || { echo "âŒ Failed to create repository"; exit 1; }
            
            REPOSITORY_URL="https://github.com/${FULL_REPO_NAME}"
            echo "  âœ… Created repository: $REPOSITORY_URL"
            
            # Initialize with README
            CLONE_DIR="/tmp/repo-init-$(date +%s)"
            git clone "$REPOSITORY_URL" "$CLONE_DIR" 2>/dev/null || {
                # New repo may be empty, init manually
                mkdir -p "$CLONE_DIR"
                cd "$CLONE_DIR"
                git init
                git remote add origin "$REPOSITORY_URL"
            }
            cd "$CLONE_DIR"
            git config user.name "Morgan Intake"
            git config user.email "morgan@5dlabs.com"
            
            if [ ! -f README.md ]; then
                echo "# $PROJECT_NAME" > README.md
                echo "" >> README.md
                echo "Generated by CTO Agent intake workflow." >> README.md
                git add README.md
                git commit -m "chore: initial commit"
                git branch -M main
                git push -u origin main
                echo "  âœ… Initialized repository with README"
            fi
        fi
    else
        # =====================================================================
        # Use Existing Repository
        # =====================================================================
        echo "ğŸ“‚ Using existing repository: $REPOSITORY_URL"
        activity_action "Use existing repository" "$REPOSITORY_URL"
        
        # Verify repo is accessible
        REPO_PATH=$(echo "$REPOSITORY_URL" | sed 's|https://github.com/||' | sed 's|\.git$||')
        if ! gh repo view "$REPO_PATH" &>/dev/null; then
            echo "âŒ Cannot access repository: $REPOSITORY_URL"
            exit 1
        fi
        echo "  âœ… Repository accessible"
    fi

    # Write repository URL early (so Argo can capture it even if later steps fail)
    echo "$REPOSITORY_URL" > /tmp/repository-url

    # =========================================================================
    # Webhook Setup (Optional)
    # =========================================================================

    if [ -n "$WEBHOOK_CALLBACK_URL" ] && [ "$WEBHOOK_CALLBACK_URL" != "null" ]; then
        echo ""
        echo "ğŸ”— Setting up GitHub webhook..."
        activity_action "Setup webhook" "$WEBHOOK_CALLBACK_URL"
        
        REPO_PATH=$(echo "$REPOSITORY_URL" | sed 's|https://github.com/||' | sed 's|\.git$||')
        
        # Check if webhook already exists
        EXISTING_WEBHOOK=$(gh api "repos/${REPO_PATH}/hooks" 2>/dev/null | jq -r ".[] | select(.config.url == \"${WEBHOOK_CALLBACK_URL}\") | .id" || echo "")
        
        if [ -n "$EXISTING_WEBHOOK" ]; then
            echo "  âš ï¸ Webhook already exists (ID: $EXISTING_WEBHOOK)"
            activity_action_complete "Webhook configured" "${REPO_PATH}" "Already exists (id: ${EXISTING_WEBHOOK})"
        else
            # Create webhook using JSON input (ensures correct types for booleans)
            printf '{"name":"web","active":true,"events":["push","pull_request","check_run","check_suite"],"config":{"url":"%s","content_type":"json"}}' "${WEBHOOK_CALLBACK_URL}" > /tmp/webhook-input.json

            if OUT=$(gh api --method POST "repos/${REPO_PATH}/hooks" --input /tmp/webhook-input.json 2>&1); then
                echo "  âœ… Webhook created"
                activity_action_complete "Webhook configured" "${REPO_PATH}" "Created webhook for ${WEBHOOK_CALLBACK_URL}"
            else
                echo "  âŒ Failed to create webhook"
                activity_error "Webhook creation failed for ${REPO_PATH}.\n\nURL: ${WEBHOOK_CALLBACK_URL}\n\n---\n${OUT}\n---"
                # Non-fatal: continue even if webhook fails (permissions issue)
            fi
        fi
    fi

    # =========================================================================
    # Branch Protection (Optional but recommended)
    # =========================================================================

    REPO_PATH=$(echo "$REPOSITORY_URL" | sed 's|https://github.com/||' | sed 's|\.git$||')
    BRANCH_NAME="main"

    echo ""
    echo "ğŸ”’ Ensuring branch protection on ${BRANCH_NAME}..."
    activity_action "Protect branch" "${REPO_PATH}:${BRANCH_NAME}"

    # Check if protection already exists
    if gh api "repos/${REPO_PATH}/branches/${BRANCH_NAME}/protection" >/tmp/branch-protection.json 2>/dev/null; then
        echo "  âœ… Branch protection already enabled"
        SUMMARY=$(jq -r '"- requiredApprovingReviews: \(.required_pull_request_reviews.required_approving_review_count // 0)\n- requireCodeOwnerReviews: \(.required_pull_request_reviews.require_code_owner_reviews // false)\n- allowForcePushes: \(.allow_force_pushes.enabled // false)\n- allowDeletions: \(.allow_deletions.enabled // false)"' /tmp/branch-protection.json 2>/dev/null || echo "- existing protection detected")
        activity_action_complete "Branch protected" "${REPO_PATH}:${BRANCH_NAME}" "Already enabled.\n\n${SUMMARY}"
    else
        # Apply branch protection using JSON input (ensures correct types)
        printf '{"required_status_checks":null,"enforce_admins":false,"required_pull_request_reviews":{"dismiss_stale_reviews":true,"require_code_owner_reviews":false,"required_approving_review_count":1},"restrictions":null,"required_linear_history":true,"allow_force_pushes":false,"allow_deletions":false}' > /tmp/branch-protection-input.json

        if OUT=$(gh api --method PUT "repos/${REPO_PATH}/branches/${BRANCH_NAME}/protection" \
            -H "Accept: application/vnd.github+json" \
            --input /tmp/branch-protection-input.json 2>&1); then
            echo "  âœ… Branch protection applied"
            activity_action_complete "Branch protected" "${REPO_PATH}:${BRANCH_NAME}" "Applied branch protection (1 review required, no force push)"
        else
            echo "  âš ï¸ Could not apply branch protection"
            activity_error "Branch protection failed for ${REPO_PATH}:${BRANCH_NAME}.\n\n---\n${OUT}\n---"
            # Non-fatal: continue even if branch protection fails
        fi
    fi

    # =========================================================================
    # Output
    # =========================================================================

    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "âœ… GitHub preparation complete"
    echo "  Repository URL: $REPOSITORY_URL"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    activity_action_complete "GitHub prep complete" "$REPOSITORY_URL" "Repository ready"

  # Intake workflow script - parses PRD and generates tasks
  # NOTE: This script expects REPOSITORY_URL to be valid (set by github_prep step)
  intake_intake.sh: |
    #!/bin/bash
    set -euo pipefail

    # =========================================================================
    # Linear Agent Activity helpers (optional)
    # =========================================================================
    activity_enabled() {
        command -v pm-activity >/dev/null 2>&1 && \
          [ -n "${LINEAR_SESSION_ID:-}" ] && \
          [ -n "${LINEAR_API_TOKEN:-}" ]
    }

    activity_thought() {
        local body="$1"
        if activity_enabled; then
            pm-activity thought --persistent "$body" >/dev/null 2>&1 || true
        fi
    }

    activity_thought_ephemeral() {
        local body="$1"
        if activity_enabled; then
            pm-activity thought "$body" >/dev/null 2>&1 || true
        fi
    }

    activity_action() {
        local action="$1"
        local parameter="$2"
        if activity_enabled; then
            pm-activity action "$action" "$parameter" >/dev/null 2>&1 || true
        fi
    }

    activity_action_complete() {
        local action="$1"
        local parameter="$2"
        local result="$3"
        if activity_enabled; then
            pm-activity action-complete "$action" "$parameter" "$result" >/dev/null 2>&1 || true
        fi
    }

    activity_error() {
        local body="$1"
        if activity_enabled; then
            pm-activity error "$body" >/dev/null 2>&1 || true
        fi
    }

    # =========================================================================
    # Unified Intake Script
    # This script runs the tasks CLI to parse PRD and generate documentation
    # NOTE: Repository must already exist (created by github_prep step)
    # =========================================================================

    echo "ğŸš€ Starting Unified Intake Process"
    echo "================================="
    echo "ğŸ“ Script version: unified-intake v2.1.0 (tasks CLI)"
    echo "ğŸ“… Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo "ğŸ“¦ Pod: ${HOSTNAME:-unknown}"
    echo ""

    activity_thought "Intake started for ${LINEAR_ISSUE_IDENTIFIER:-unknown} (${HOSTNAME:-unknown})"

    # =========================================================================
    # Phase 1: Configuration and Environment Setup
    # =========================================================================
    echo "ğŸ“‹ Phase 1: Configuration and Environment Setup"
    echo "================================================"

    CONFIG_FILE="/intake-files/config.json"

    # Support both .txt and .md PRD files
    if [ -f "/intake-files/prd.txt" ]; then
        PRD_FILE="/intake-files/prd.txt"
    elif [ -f "/intake-files/prd.md" ]; then
        PRD_FILE="/intake-files/prd.md"
    else
        echo "âŒ No PRD file found (tried prd.txt, prd.md)"
        exit 1
    fi

    ARCH_FILE="/intake-files/architecture.md"

    if [ ! -f "$CONFIG_FILE" ]; then
        echo "âŒ Configuration file not found at $CONFIG_FILE"
        exit 1
    fi

    echo "ğŸ“„ Loading configuration..."
    PROJECT_NAME=$(jq -r '.project_name' "$CONFIG_FILE")
    
    # Get repository URL from:
    # 1. REPOSITORY_URL env var (set by workflow from github-prep output)
    # 2. Fallback to config file
    if [ -n "${REPOSITORY_URL:-}" ] && [ "$REPOSITORY_URL" != "null" ]; then
        echo "  â†’ Using repository URL from workflow parameter"
    else
        REPOSITORY_URL=$(jq -r '.repository_url // ""' "$CONFIG_FILE")
    fi
    
    GITHUB_APP=$(jq -r '.github_app // "5DLabs-Morgan"' "$CONFIG_FILE")
    PRIMARY_MODEL=$(jq -r '.primary_model // "claude-sonnet-4-5-20250929"' "$CONFIG_FILE")
    NUM_TASKS=$(jq -r '.num_tasks // 15' "$CONFIG_FILE")
    EXPAND_TASKS=$(jq -r '.expand_tasks // true' "$CONFIG_FILE")
    ANALYZE_COMPLEXITY=$(jq -r '.analyze_complexity // true' "$CONFIG_FILE")

    echo "  âœ“ Project: $PROJECT_NAME"
    echo "  âœ“ Repository: $REPOSITORY_URL"
    echo "  âœ“ GitHub App: $GITHUB_APP"
    echo "  âœ“ Model: $PRIMARY_MODEL"
    echo "  âœ“ Tasks: ~$NUM_TASKS"
    echo ""

    activity_action "Intake: configure" "$PROJECT_NAME"

    # Validate repository URL
    if [ -z "$REPOSITORY_URL" ] || [ "$REPOSITORY_URL" = "null" ]; then
        echo "âŒ Repository URL not set. Did github_prep step run?"
        exit 1
    fi

    # =========================================================================
    # Phase 2: GitHub Authentication
    # =========================================================================
    echo "ğŸ” Setting up GitHub App authentication..."

    # Generate GitHub token from app credentials
    if [ -n "${GITHUB_APP_ID:-}" ] && [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
        echo "Generating fresh GitHub App token..."
        
        # Create JWT
        NOW=$(date +%s)
        IAT=$((NOW - 60))
        EXP=$((NOW + 600))
        
        HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
        PAYLOAD=$(echo -n "{\"iat\":${IAT},\"exp\":${EXP},\"iss\":\"${GITHUB_APP_ID}\"}" | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
        
        SIGNATURE=$(echo -n "${HEADER}.${PAYLOAD}" | openssl dgst -sha256 -sign <(echo "$GITHUB_APP_PRIVATE_KEY") | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
        JWT="${HEADER}.${PAYLOAD}.${SIGNATURE}"
        
        # Get installation token
        INSTALLATIONS=$(curl -s -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github+json" "https://api.github.com/app/installations")
        INSTALLATION_ID=$(echo "$INSTALLATIONS" | jq -r '.[0].id')
        
        if [ -n "$INSTALLATION_ID" ] && [ "$INSTALLATION_ID" != "null" ]; then
            TOKEN_RESPONSE=$(curl -s -X POST -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github+json" "https://api.github.com/app/installations/${INSTALLATION_ID}/access_tokens")
            GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
            
            if [ -n "$GITHUB_TOKEN" ] && [ "$GITHUB_TOKEN" != "null" ]; then
                export GITHUB_TOKEN
                export GH_TOKEN="$GITHUB_TOKEN"
                git config --global credential.helper "!f() { echo \"password=$GITHUB_TOKEN\"; }; f"
                git config --global url."https://x-access-token:${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"
                echo "âœ… GitHub authentication configured"
            else
                echo "âš ï¸ Could not get installation token, using default auth"
            fi
        else
            echo "âš ï¸ Could not get installation ID, using default auth"
        fi
    else
        echo "âš ï¸ GitHub App credentials not provided, using default auth"
    fi
    echo ""

    # =========================================================================
    # Phase 3: Repository Clone
    # =========================================================================
    echo "ğŸ“¦ Phase 2: Repository Clone and Setup"
    echo "======================================="

    CLONE_DIR="/tmp/repo-$(date +%s)"
    echo "ğŸ“‚ Cloning repository to: $CLONE_DIR"
    activity_action "Clone repository" "$REPOSITORY_URL"

    git clone "$REPOSITORY_URL" "$CLONE_DIR" || exit 1
    cd "$CLONE_DIR" || exit 1
    activity_action_complete "Cloned repository" "$REPOSITORY_URL" "Clone complete"

    git config user.name "Morgan Intake"
    git config user.email "morgan@5dlabs.com"

    # Normalize project directory name
    PROJECT_DIR_NAME=$(echo "$PROJECT_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' | sed 's/^-*//;s/-*$//')
    PROJECT_DIR="$CLONE_DIR/$PROJECT_DIR_NAME"
    mkdir -p "$PROJECT_DIR"
    cd "$PROJECT_DIR" || exit 1

    # =========================================================================
    # Phase 4: Prepare Input Files
    # =========================================================================
    echo ""
    echo "ğŸ“ Setting up input files..."

    mkdir -p .tasks/docs
    cp "$PRD_FILE" ".tasks/docs/prd.txt"
    [ -f "$ARCH_FILE" ] && [ -s "$ARCH_FILE" ] && cp "$ARCH_FILE" ".tasks/docs/architecture.md"

    # =========================================================================
    # Phase 5: Run Tasks CLI Intake
    # =========================================================================
    echo ""
    echo "ğŸš€ Phase 3: Running tasks CLI intake"
    echo "====================================="

    # Verify tasks CLI is available
    if ! command -v tasks &> /dev/null; then
        echo "âŒ tasks CLI not found in PATH"
        exit 1
    fi
    echo "âœ“ tasks CLI found: $(which tasks)"
    tasks --version 2>&1 || true

    # Build intake command
    INTAKE_CMD="tasks intake --prd .tasks/docs/prd.txt --num-tasks $NUM_TASKS"

    # Add architecture if present
    [ -f ".tasks/docs/architecture.md" ] && INTAKE_CMD="$INTAKE_CMD --architecture .tasks/docs/architecture.md"

    # Add model if specified
    [ -n "$PRIMARY_MODEL" ] && [ "$PRIMARY_MODEL" != "null" ] && INTAKE_CMD="$INTAKE_CMD --model $PRIMARY_MODEL"

    # Optionally skip expansion/analysis
    [ "$EXPAND_TASKS" = "false" ] && INTAKE_CMD="$INTAKE_CMD --no-expand"
    [ "$ANALYZE_COMPLEXITY" = "false" ] && INTAKE_CMD="$INTAKE_CMD --no-analyze"

    activity_action "Run tasks intake" "$INTAKE_CMD"

    echo "  â†’ Running: $INTAKE_CMD"
    OUTPUT_FILE="$(mktemp)"
    set +e
    eval "$INTAKE_CMD" 2>&1 | tee "$OUTPUT_FILE"
    INTAKE_EXIT="${PIPESTATUS[0]}"
    set -e
    if [ "$INTAKE_EXIT" -ne 0 ]; then
        SNIPPET="$(tail -n 80 "$OUTPUT_FILE" 2>/dev/null || true)"
        activity_error "tasks intake failed (exit $INTAKE_EXIT)\n\nLast output:\n\n$SNIPPET"
        exit "$INTAKE_EXIT"
    fi
    activity_thought_ephemeral "tasks intake completed successfully"

    # Verify tasks were generated
    TASKS_FILE=".tasks/tasks/tasks.json"
    if [ ! -f "$TASKS_FILE" ]; then
        echo "âŒ tasks.json not found at $TASKS_FILE"
        exit 1
    fi

    TASK_COUNT=$(jq '.tasks | length' "$TASKS_FILE")
    echo "âœ… Generated $TASK_COUNT tasks with documentation"
    SNIPPET="$(tail -n 60 "$OUTPUT_FILE" 2>/dev/null || true)"
    activity_action_complete "Generated tasks" "$TASK_COUNT tasks" "tasks.json created.\n\nLast output:\n\n$SNIPPET"

    # =========================================================================
    # Phase 6: Create Pull Request
    # =========================================================================
    echo ""
    echo "ğŸ”€ Phase 4: Creating Pull Request"
    echo "=================================="

    cd "$CLONE_DIR" || exit 1

    BRANCH_NAME="intake-${PROJECT_DIR_NAME}-$(date +%Y%m%d-%H%M%S)"
    git checkout -b "$BRANCH_NAME"
    git add -A
    git commit -m "feat: intake for $PROJECT_NAME

    - $TASK_COUNT tasks generated
    - XML + Markdown documentation per task
    - Agent routing hints added
    - Complexity analysis: $ANALYZE_COMPLEXITY
    - Task expansion: $EXPAND_TASKS

    ğŸ¤– Generated by Morgan (tasks CLI v2)"

    git push -u origin "$BRANCH_NAME"

    # Build intake metadata JSON for PR body (used by webhook handler on merge)
    INTAKE_METADATA="<!-- intake-metadata: {\"session_id\":\"${LINEAR_SESSION_ID:-}\",\"prd_issue_id\":\"${LINEAR_ISSUE_ID:-}\",\"prd_identifier\":\"${LINEAR_ISSUE_IDENTIFIER:-}\",\"team_id\":\"${LINEAR_TEAM_ID:-}\",\"project_name\":\"${PROJECT_NAME}\",\"project_dir\":\"${PROJECT_DIR_NAME}\"} -->"

    gh pr create \
        --title "ğŸš€ Intake: $PROJECT_NAME" \
        --label "cto-intake" \
        --body "${INTAKE_METADATA}

    ## Intake: $PROJECT_NAME

    ### Generated Structure
    \`\`\`
    $PROJECT_DIR_NAME/
    â”œâ”€â”€ .tasks/
    â”‚   â”œâ”€â”€ docs/
    â”‚   â”‚   â”œâ”€â”€ prd.txt
    â”‚   â”‚   â”œâ”€â”€ architecture.md (if provided)
    â”‚   â”‚   â””â”€â”€ task-*/
    â”‚   â”‚       â”œâ”€â”€ prompt.xml
    â”‚   â”‚       â”œâ”€â”€ prompt.md
    â”‚   â”‚       â””â”€â”€ acceptance.md
    â”‚   â”œâ”€â”€ tasks/
    â”‚   â”‚   â””â”€â”€ tasks.json
    â”‚   â””â”€â”€ reports/
    â”‚       â””â”€â”€ complexity-report.json
    \`\`\`

    ### Stats
    - **Tasks**: $TASK_COUNT
    - **Model**: $PRIMARY_MODEL
    - **Expansion**: $EXPAND_TASKS
    - **Complexity**: $ANALYZE_COMPLEXITY

    ğŸ¤– Generated by Morgan (tasks CLI v2)" \
        --head "$BRANCH_NAME" \
        --base main || echo "âš ï¸ PR creation failed, branch pushed: $BRANCH_NAME"

    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "â•‘ âœ… Intake completed successfully!"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
---
# =============================================================================
# controller-templates-shared - Shared template partials for agent runtime
# =============================================================================
# These templates are mounted at /templates in agent pods for runtime access.
# Used by integration agents (Atlas, Bolt) and healer workflows.
apiVersion: v1
kind: ConfigMap
metadata:
  name: controller-templates-shared
  namespace: {{ include "cto.namespace" . }}
  labels:
    {{- include "cto.controller.labels" . | nindent 4 }}
    app.kubernetes.io/component: templates
data:
  # Placeholder - templates are primarily rendered by controller
  # This ConfigMap provides runtime access to any shared resources
  .keep: |
    # Shared template partials for agent runtime use
    # The controller renders templates into per-job ConfigMaps
    # This ConfigMap provides additional runtime resources if needed
---
# =============================================================================
# controller-templates-integration - Integration templates for Atlas/Bolt
# =============================================================================
# Guardian scripts and integration helpers for infrastructure agents.
apiVersion: v1
kind: ConfigMap
metadata:
  name: controller-templates-integration
  namespace: {{ include "cto.namespace" . }}
  labels:
    {{- include "cto.controller.labels" . | nindent 4 }}
    app.kubernetes.io/component: templates
data:
  # Placeholder for integration templates
  .keep: |
    # Integration templates for infrastructure agents (Atlas, Bolt)
    # Used for guardian scripts and runtime integration helpers
---
# =============================================================================
# controller-templates-healer - Healer templates for remediation workflows
# =============================================================================
# Templates and scripts used by healer/remediation CodeRuns.
apiVersion: v1
kind: ConfigMap
metadata:
  name: controller-templates-healer
  namespace: {{ include "cto.namespace" . }}
  labels:
    {{- include "cto.controller.labels" . | nindent 4 }}
    app.kubernetes.io/component: templates
data:
  # Placeholder for healer templates
  .keep: |
    # Healer templates for remediation workflows
    # Used by Rex-Healer, Blaze-Healer, and other healing agents
{{- end }}






