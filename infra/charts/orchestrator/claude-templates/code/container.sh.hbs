#!/bin/sh

echo '════════════════════════════════════════════════════════════════'
echo '║                 IMPLEMENTATION TASK STARTING                 ║'
echo '════════════════════════════════════════════════════════════════'

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Export GitHub environment for hooks
export GITHUB_USER="{{github_user}}"
export GITHUB_TOKEN="${GITHUB_TOKEN:-}"  # Should be set via secret

# Install GitHub CLI if not present
if ! command -v gh >/dev/null 2>&1; then
    echo "=== Installing GitHub CLI ==="
    if command -v apt-get >/dev/null 2>&1; then
        apt-get update && apt-get install -y gh || echo "⚠️ Failed to install gh CLI"
    elif command -v apk >/dev/null 2>&1; then
        apk add --no-cache github-cli || echo "⚠️ Failed to install gh CLI"
    else
        echo "⚠️ Cannot install gh CLI - package manager not found"
    fi
fi

# Configure SSH authentication (SSH-only system)
echo "=== SSH AUTHENTICATION SETUP ==="

if [ -f "/workspace/.ssh/id_ed25519" ]; then
  echo "✓ SSH private key found at /workspace/.ssh/id_ed25519"
  
  # Create SSH directory in home
  mkdir -p ~/.ssh
  chmod 700 ~/.ssh
  
  # Copy SSH keys from mounted read-only volume to writable location
  if cp /workspace/.ssh/id_ed25519 ~/.ssh/id_ed25519 2>/dev/null; then
    echo "✓ SSH private key copied to ~/.ssh/id_ed25519"
  else
    echo "⚠️  Could not copy SSH key, using mounted location"
    export SSH_KEY_PATH="/workspace/.ssh/id_ed25519"
  fi
  
  # Copy public key if exists
  if [ -f "/workspace/.ssh/id_ed25519.pub" ]; then
    cp /workspace/.ssh/id_ed25519.pub ~/.ssh/id_ed25519.pub 2>/dev/null || echo "⚠️  Could not copy public key"
  fi
  
  # Set proper permissions if we copied the keys
  if [ -f ~/.ssh/id_ed25519 ]; then
    chmod 600 ~/.ssh/id_ed25519
    [ -f ~/.ssh/id_ed25519.pub ] && chmod 644 ~/.ssh/id_ed25519.pub
  fi

  # Configure SSH to use the key
  cat > ~/.ssh/config << EOF
Host github.com
    HostName github.com
    User git
    IdentityFile ${SSH_KEY_PATH:-~/.ssh/id_ed25519}
    IdentitiesOnly yes
    StrictHostKeyChecking no
EOF

  chmod 600 ~/.ssh/config

  # Test SSH connection
  echo "Testing SSH connection to GitHub..."
  ssh -T git@github.com 2>&1 | head -3 || echo "SSH test completed (expected to fail with 'successfully authenticated')"

  echo "✓ SSH authentication configured successfully"
else
  echo "❌ SSH private key not found at /workspace/.ssh/id_ed25519"
  echo "   Expected SSH key secret to be mounted to /workspace/.ssh/"
  echo "   This system is SSH-only - no HTTPS authentication support"
  exit 1
fi

# Configure git user after successful SSH setup
git config --global --add safe.directory /workspace
echo "✓ Added /workspace to safe directories"

git config --global user.name "{{github_user}}"
git config --global user.email "{{github_user}}@users.noreply.github.com"
echo "✓ Configured git user: {{github_user}}"

# =============================================================================
# AUTHENTICATION VERIFICATION
# =============================================================================
echo ""
echo "═══════════════════════════════════════════════════════════════"
echo "🔐 AUTHENTICATION VERIFICATION"
echo "═══════════════════════════════════════════════════════════════"
echo ""

# Test SSH access to repository
echo "Testing SSH repository access..."
REPO_URL="{{repository_url}}"
if git ls-remote "$REPO_URL" HEAD > /dev/null 2>&1; then
  echo "✓ SSH repository access successful"
  echo "  Repository: $REPO_URL"
else
  echo "❌ SSH repository access failed"
  echo "  Repository: $REPO_URL"
  echo ""
  echo "🚫 ABORTING: Cannot access repository via SSH"
  exit 1
fi

# Test platform repository access
DOCS_URL="{{platform_repository_url}}"
echo "Testing docs repository access..."
if git ls-remote "$DOCS_URL" HEAD > /dev/null 2>&1; then
  echo "✓ Docs repository access successful"
  echo "  Repository: $DOCS_URL"
else
  echo "❌ Docs repository access failed"
  echo "  Repository: $DOCS_URL"
  echo ""
  echo "🚫 ABORTING: Cannot access platform repository via SSH"
  exit 1
fi

# Dual Repository Setup - Platform repo for docs, Target repo for implementation
echo ""
echo "═══════════════════════════════════════════════════════════════"
echo "║                 DUAL REPOSITORY SETUP                        ║"
echo "═══════════════════════════════════════════════════════════════"

# Docs Repository Information (for task documentation)
DOCS_URL="{{platform_repository_url}}"
DOCS_BRANCH="{{platform_branch}}"
DOCS_USER="{{github_user}}"

# Docs repository setup
echo "Docs repo: $DOCS_URL"
echo "Docs branch: $DOCS_BRANCH"
echo "Docs user: $DOCS_USER"

# Target Repository Information (for implementation)
REPO_URL="{{repository_url}}"
REPO_BRANCH="{{branch}}"
GITHUB_USER="{{github_user}}"

# Extract repository name from URL for directory naming
REPO_NAME=$(basename "$REPO_URL" .git)
echo "Repository name: $REPO_NAME"

# Target repository setup
echo "Target repo: $REPO_URL"
echo "Target branch: $REPO_BRANCH"
echo "Target user: $GITHUB_USER"

# 1. Clone Docs Repository (for task documentation)
# Handle existing docs repo
if [ -d "docs-repo" ]; then
    echo "Docs repository already exists, updating..."
    cd docs-repo
    git fetch origin
    git checkout "$DOCS_BRANCH"
    git reset --hard "origin/$DOCS_BRANCH"
    cd /workspace
    echo "✓ Docs repository updated successfully"
else
    echo "Cloning docs repository..."
    if ! git clone "$DOCS_URL" docs-repo; then
        echo "❌ Failed to clone docs repository: $DOCS_URL"
        exit 1
    fi
    cd docs-repo && git checkout "$DOCS_BRANCH" && cd /workspace
    echo "✓ Docs repository cloned successfully"
fi

# 2. Copy Current Task Documentation (Clean Previous Task Content)
# Setting up current task

# Task files will be copied to the correct location after repository setup

# 3. MCP Client Configuration (now generated dynamically)
echo "✓ MCP client configuration will be copied from ConfigMap during file setup"

# 4. Destination Repository Setup (Sophisticated Git Workflow)
echo "=== DESTINATION REPOSITORY SETUP ==="

# Check if repository already exists (retry scenario)
if [ -d "$REPO_NAME" ]; then
    echo "Found existing target repository - attempting sophisticated branch management"
    cd "$REPO_NAME"

    # Ensure main branch is current
    echo "Updating main branch..."
    git checkout main 2>/dev/null || git checkout -b main origin/main
    git pull origin main

    # Create or checkout feature branch
    FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
    if git show-ref --verify --quiet refs/heads/$FEATURE_BRANCH; then
        # Feature branch exists - checkout and try to merge main
        echo "Feature branch exists, checking out and merging main..."
        git checkout $FEATURE_BRANCH

        # Attempt to merge main into feature branch
        if git merge main --no-edit; then
            echo "✓ Successfully merged main into feature branch"
        else
            echo "⚠️  Merge conflicts detected during main integration"
            echo "Performing fresh clone fallback to resolve conflicts..."

            # Fallback: delete and fresh clone
            cd ..
            rm -rf "$REPO_NAME"
            if ! git clone "$REPO_URL" "$REPO_NAME"; then
                echo "❌ Failed to clone target repository: $REPO_URL"
                exit 1
            fi
            cd "$REPO_NAME"
            git checkout -b $FEATURE_BRANCH
            echo "✓ Created fresh feature branch after conflict resolution"
        fi
    else
        # Create new feature branch from main
        echo "Creating new feature branch from main..."
        git checkout -b $FEATURE_BRANCH
        echo "✓ Created feature branch: $FEATURE_BRANCH"
    fi
else
    echo "=== CLONING FRESH TARGET REPOSITORY ==="
    if ! git clone "$REPO_URL" "$REPO_NAME"; then
        echo "❌ Failed to clone target repository: $REPO_URL"
        exit 1
    fi
    cd "$REPO_NAME"

    # Ensure we're on main and create feature branch
    git checkout main 2>/dev/null || git checkout -b main origin/main
    FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
    git checkout -b $FEATURE_BRANCH
    echo "✓ Created initial feature branch: $FEATURE_BRANCH"
fi

# 5. Set Working Directory (Critical for Claude Execution)
WORK_DIR="{{working_directory}}"
mkdir -p "$WORK_DIR" && cd "$WORK_DIR"
echo "✓ Set working directory: /workspace/target-repo/$WORK_DIR"
echo "🔑 CRITICAL: Claude will be launched from this directory"

# 6. Working directory will be set up after repository cloning

# Configure git user after successful clone
echo "=== POST-CLONE GIT CONFIGURATION ==="
# Fix dubious ownership issues
git config --global --add safe.directory /workspace/platform-repo
git config --global --add safe.directory /workspace/target-repo
echo "✓ Added repositories to safe directories"

git config --global user.name "$GITHUB_USER"
git config --global user.email "${GITHUB_USER}@users.noreply.github.com"
echo "✓ Configured git user: $GITHUB_USER"

# Copy ConfigMap files to working directory (AFTER repository clone)
echo "=== CONFIGMAP FILE SETUP ==="

# For implementation tasks, Claude works in the target repository service directory
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
  CLAUDE_WORK_DIR="/workspace/$REPO_NAME"
else
  CLAUDE_WORK_DIR="/workspace/$REPO_NAME/$WORK_DIR"
fi

echo "Setting up files in Claude working directory: $CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"

# Copy all files from ConfigMap to working directory
if [ -d "/config" ]; then
  echo "Copying ConfigMap files to working directory..."

  # Copy markdown files (CLAUDE.md memory persistence logic)
  for md_file in /config/*.md; do
    if [ -f "$md_file" ]; then
      basename_file=$(basename "$md_file")
      if [ "$basename_file" = "claude.md" ]; then
        # claude.md -> CLAUDE.md Memory Persistence Logic (controlled by overwriteMemory CRD field)
        OVERWRITE_MEMORY="{{overwrite_memory}}"

        if [ "$OVERWRITE_MEMORY" = "true" ]; then
          # Overwrite mode: Always replace CLAUDE.md with fresh template
          cp "$md_file" "$CLAUDE_WORK_DIR/CLAUDE.md"
          echo "✓ Overwrote CLAUDE.md memory file (fresh start requested)"
        else
          # Preserve mode (default): Only copy if doesn't exist
          if [ ! -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
            cp "$md_file" "$CLAUDE_WORK_DIR/CLAUDE.md"
            echo "✓ Created initial CLAUDE.md memory file"
          else
            echo "✓ Preserved existing CLAUDE.md memory file (maintaining accumulated context)"
          fi
        fi
      else
        # Copy all other markdown files
        cp "$md_file" "$CLAUDE_WORK_DIR/"
        echo "✓ Updated $basename_file"
      fi
    fi
  done

  # Check that the settings are mounted correctly
  if [ -f "/etc/claude-code/managed-settings.json" ]; then
    echo "✓ Enterprise managed settings found at /etc/claude-code/managed-settings.json"
    echo "✓ Mounted directly from ConfigMap (no copying needed)"
    
    # Validate the enterprise settings JSON
    if jq empty /etc/claude-code/managed-settings.json 2>/dev/null; then
      echo "✓ Enterprise settings JSON is valid"
      echo "✓ This will override ALL other Claude Code settings (highest precedence)"
      echo "✓ Model configuration, tools, and permissions are defined"
    else
      echo "❌ Enterprise settings JSON is invalid"
      cat /etc/claude-code/managed-settings.json
      exit 1
    fi
  else
    echo "❌ ERROR: Enterprise managed settings not found!"
    echo "Expected: /etc/claude-code/managed-settings.json (mounted from ConfigMap)"
    exit 1
  fi
  
  # Copy guidelines files to working directory
  if [ -f "/config/coding-guidelines.md" ]; then
    cp /config/coding-guidelines.md "$CLAUDE_WORK_DIR/"
    echo "✓ Copied coding-guidelines.md to working directory"
  fi
  
  if [ -f "/config/github-guidelines.md" ]; then
    cp /config/github-guidelines.md "$CLAUDE_WORK_DIR/"
    echo "✓ Copied github-guidelines.md to working directory"
  fi

  # Copy all hook scripts (now prefixed with hooks- or code_hooks_ to comply with ConfigMap key constraints)
  echo "Copying hook scripts..."
  
  # Copy old-style hooks (hooks- prefix)
  for hook_file in /config/hooks-*.sh; do
    if [ -f "$hook_file" ]; then
      # Extract the hook name (remove hooks- prefix) and copy to workspace
      hook_name=$(basename "$hook_file" | sed 's/^hooks-//')
      cp "$hook_file" "$CLAUDE_WORK_DIR/$hook_name"
      chmod +x "$CLAUDE_WORK_DIR/$hook_name"
      echo "✓ Copied hook: $hook_name"
    fi
  done
  
  # Copy new-style hooks (code_hooks_ prefix)
  for hook_file in /config/code_hooks_*.sh; do
    if [ -f "$hook_file" ]; then
      # Extract the hook name (remove code_hooks_ prefix) and copy to workspace
      hook_name=$(basename "$hook_file" | sed 's/^code_hooks_//')
      cp "$hook_file" "$CLAUDE_WORK_DIR/$hook_name"
      chmod +x "$CLAUDE_WORK_DIR/$hook_name"
      echo "✓ Copied hook: $hook_name"
    fi
  done
  # Check if any hooks were copied
  if ls "$CLAUDE_WORK_DIR"/*.sh >/dev/null 2>&1; then
    echo "✓ Hook scripts copied successfully"
  else
    echo "! No hook scripts found to copy"
  fi

  # Set up MCP configuration files
  echo "Setting up MCP configuration..."
  mkdir -p "$CLAUDE_WORK_DIR/.claude"
  chmod 755 "$CLAUDE_WORK_DIR/.claude"
  
  # Copy MCP configuration files from ConfigMap
  if [ -f "/config/mcp.json" ]; then
    cp /config/mcp.json "$CLAUDE_WORK_DIR/.claude/mcp.json"
    echo "✓ Copied mcp.json to .claude/mcp.json"
  else
    echo "⚠️  mcp.json template not found"
  fi
  
  if [ -f "/config/client-config.json" ]; then
    cp /config/client-config.json "$CLAUDE_WORK_DIR/.claude/client-config.json"
    echo "✓ Copied client-config.json to .claude/client-config.json"
  else
    echo "⚠️  client-config.json template not found"
  fi

  echo "✓ ConfigMap files copied to $CLAUDE_WORK_DIR"
else
  echo "⚠️  Warning: /config directory not found (ConfigMap not mounted?)"
fi

# Copy Current Task Documentation to Working Directory
echo "=== TASK DOCUMENTATION SETUP ==="

# Remove any previous task content to avoid confusion
rm -rf "$CLAUDE_WORK_DIR/task/" 2>/dev/null

# Create clean task directory for current task only
mkdir -p "$CLAUDE_WORK_DIR/task"

# Determine task directory path
{{#if platform_project_directory}}
TASK_DIR="/workspace/docs-repo/{{platform_project_directory}}/.taskmaster/docs/task-{{task_id}}"
{{else}}
# Default to _projects/{service} if not specified
TASK_DIR="/workspace/docs-repo/_projects/{{service_name}}/.taskmaster/docs/task-{{task_id}}"
{{/if}}

if [ -d "$TASK_DIR" ]; then
    cp "$TASK_DIR/task.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || echo "⚠️  task.md not found"
    cp "$TASK_DIR/acceptance-criteria.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || echo "⚠️  acceptance-criteria.md not found"
    cp "$TASK_DIR/prompt.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || echo "⚠️  prompt.md not found"
    echo "✓ Task {{task_id}} documentation copied from $TASK_DIR"
    
    # Copy architecture.md from the root docs directory
    {{#if platform_project_directory}}
    ARCH_FILE="/workspace/docs-repo/{{platform_project_directory}}/.taskmaster/docs/architecture.md"
    {{else}}
    ARCH_FILE="/workspace/docs-repo/_projects/{{service_name}}/.taskmaster/docs/architecture.md"
    {{/if}}
    if [ -f "$ARCH_FILE" ]; then
        cp "$ARCH_FILE" "$CLAUDE_WORK_DIR/task/" 
        echo "✓ Architecture documentation copied from docs root"
    else
        echo "❌ CRITICAL: architecture.md not found at: $ARCH_FILE"
    fi
else
    echo "⚠️  Task {{task_id}} documentation directory not found at: $TASK_DIR"
fi

# Clean up docs repository to avoid Claude confusion
echo "=== DOCS REPOSITORY CLEANUP ==="
if [ -d "/workspace/docs-repo" ]; then
    echo "Removing docs repository to prevent Claude confusion..."
    rm -rf /workspace/docs-repo
    echo "✓ Docs repository cleaned up successfully"
else
    echo "✓ No docs repository cleanup needed"
fi

echo '=== WORKSPACE VALIDATION ==='

# Check for required files in Claude's working directory
MISSING_FILES=""
REQUIRED_FILES="CLAUDE.md"

echo "Checking for required files..."
for file in $REQUIRED_FILES; do
  if [ ! -f "$CLAUDE_WORK_DIR/$file" ]; then
    echo "ERROR: Missing required file: $CLAUDE_WORK_DIR/$file"
    MISSING_FILES="$MISSING_FILES $file"
  else
    echo "✓ Found: $CLAUDE_WORK_DIR/$file"
    # Show file size for verification
    size=$(wc -c < "$CLAUDE_WORK_DIR/$file" 2>/dev/null || echo "0")
    echo "  File size: $size bytes"
  fi
done

# Check git repository (REQUIRED for implementation tasks)
if [ ! -d "/workspace/target-repo/.git" ]; then
  echo "✗ CRITICAL ERROR: No target git repository found!"
  MISSING_FILES="$MISSING_FILES git-repository"
else
  echo "✓ Found: target git repository"
fi

# If any files are missing, abort
if [ -n "$MISSING_FILES" ]; then
  echo ""
  echo "═══════════════════════════════════════════════════════════════"
  echo "║                 WORKSPACE VALIDATION FAILED                  ║"
  echo "═══════════════════════════════════════════════════════════════"
  echo ""
  echo "The following required files are missing:"
  for missing in $MISSING_FILES; do
    case "$missing" in
      "CLAUDE.md")
        echo "  ❌ $missing - Main task instructions for Claude"
        ;;
      "git-repository")
        echo "  ❌ $missing - Required for committing implementation changes"
        ;;
      *)
        echo "  ❌ $missing"
        ;;
    esac
  done
  echo ""
  echo "These files should have been created by the ConfigMap setup process."
  echo "Claude will NOT be started to avoid wasting API credits."
  echo ""
  exit 1
fi

echo "✓ All required files present. Workspace is valid."

echo '=== IMPLEMENTATION TASK DIAGNOSTICS ==='
echo "Project directory: $CLAUDE_WORK_DIR"
echo "Project directory contents:"
ls -la "$CLAUDE_WORK_DIR"
echo ""

# Show git status
echo "Git status:"
git status 2>/dev/null || echo "Git status unavailable"
echo ""

echo '=== CLAUDE EXECUTION ==='

# Export necessary variables
export SERVICE_NAME="{{service}}"
export TASK_ID="{{task_id}}"

# Change to project directory before running Claude
cd "$CLAUDE_WORK_DIR"
echo "Changed to directory: $(pwd)"

# Verify we're in the correct directory and have required files
echo "=== WORKING DIRECTORY VERIFICATION ==="
echo "Current working directory: $(pwd)"
echo "Expected directory: $CLAUDE_WORK_DIR"
if [ "$(pwd)" != "$CLAUDE_WORK_DIR" ]; then
  echo "❌ ERROR: Failed to change to correct working directory!"
  echo "Attempting to change directory again..."
  cd "$CLAUDE_WORK_DIR" || exit 1
  echo "✓ Successfully changed to: $(pwd)"
fi

# Verify setup
echo "✓ Code implementation environment ready"

# Build Claude command
CLAUDE_CMD="claude -p --output-format stream-json --verbose"

# Add model flag if specified via environment variable
if [ -n "$MODEL" ]; then
    CLAUDE_CMD="$CLAUDE_CMD --model $MODEL"
    echo "Using specified model: $MODEL"
fi

# Add retry flag if this is a retry attempt
{{#if is_retry}}
CLAUDE_CMD="$CLAUDE_CMD --continue"
echo 'Adding --continue flag for attempt {{attempts}}'
{{/if}}

# Add resume flag if resuming a previous session
{{#if resume_session}}
CLAUDE_CMD="$CLAUDE_CMD --resume"
echo 'Adding --resume flag to continue previous session'
{{/if}}

echo "════════════════════════════════════════════════════════════════"
echo "║                    STARTING CLAUDE EXECUTION                  ║"
echo "════════════════════════════════════════════════════════════════"
echo "Command: $CLAUDE_CMD"
echo "Note: Claude will automatically read CLAUDE.md from the working directory"
echo "Starting Claude execution..."
echo "=========================="

# Check if prompt.md exists and use it
if [ -f "$CLAUDE_WORK_DIR/task/prompt.md" ]; then
    echo "Using task-specific prompt from prompt.md"
    $CLAUDE_CMD "$(cat $CLAUDE_WORK_DIR/task/prompt.md)"
else
    echo "WARNING: No prompt.md found, using default prompt"
    # Fallback to embedded prompt if needed
    PROMPT="{{prompt_content}}"
    $CLAUDE_CMD "$PROMPT"
fi

echo '════════════════════════════════════════════════════════════════'
echo '║                 IMPLEMENTATION TASK COMPLETE                 ║'
echo '════════════════════════════════════════════════════════════════'

# The Stop hook will run automatically when Claude completes
echo "Claude has completed. Hooks will run if configured."