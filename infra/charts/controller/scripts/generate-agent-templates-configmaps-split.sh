#!/bin/bash
set -euo pipefail

# Script to generate multiple agent-templates ConfigMaps split by CLI type
# This solves both the ArgoCD .Files issue and the 1MB ConfigMap size limit

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CHART_DIR="$(dirname "$SCRIPT_DIR")"
OUTPUT_DIR="$CHART_DIR/templates"

cd "$CHART_DIR"

echo "Generating split ConfigMaps from agent templates..."

# Define CLI types and shared resources
CLI_TYPES=("claude-code" "claude-docs" "codex" "cursor" "factory" "opencode" "integration" "watch")
SHARED_PATTERNS=("coding-guidelines" "github-guidelines" "client-config" "mcp.json" "agents/" "shared/")

generate_configmap() {
  local name=$1
  local filter=$2
  local output_file="$OUTPUT_DIR/agent-templates-${name}.yaml"
  
  echo ""
  echo "Generating ConfigMap: $name"
  
  # Header with metadata
  cat > "$output_file" << HEADER_EOF
# This file is auto-generated by scripts/generate-agent-templates-configmaps-split.sh
# DO NOT EDIT MANUALLY - edit the source files in agent-templates/ instead
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "controller.fullname" . }}-agent-templates-${name}
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "controller.labels" . | nindent 4 }}
    app.kubernetes.io/component: agent-templates
    agent-templates/type: ${name}
  annotations:
    templates-checksum: "CHECKSUM_PLACEHOLDER"
binaryData:
HEADER_EOF

  # Find files matching the filter
  local files_list=""
  if [ "$filter" = "shared" ]; then
    # Shared: collect files matching shared patterns
    for pattern in "${SHARED_PATTERNS[@]}"; do
      files_list+=$(find "agent-templates" -type f -path "*/${pattern}*" \( -name "*.hbs" -o -name "*.sh" -o -name "*.md" \) 2>/dev/null || true)$'\n'
    done
  else
    # CLI-specific: collect files under that CLI directory PLUS shared agent partials
    # Handle split claude ConfigMaps (claude-code and claude-docs)
    if [ "$filter" = "claude-code" ]; then
      files_list=$(find "agent-templates/code/claude" -type f \( -name "*.hbs" -o -name "*.sh" -o -name "*.md" \) 2>/dev/null | LC_ALL=C sort || true)
    elif [ "$filter" = "claude-docs" ]; then
      files_list=$(find "agent-templates/docs/claude" -type f \( -name "*.hbs" -o -name "*.sh" -o -name "*.md" \) 2>/dev/null | LC_ALL=C sort || true)
    elif [ "$filter" = "watch" ]; then
      # Watch templates: include all watch/ subdirectories (factory, claude) and shared acceptance criteria
      files_list=$(find "agent-templates/watch" -type f \( -name "*.hbs" -o -name "*.sh" -o -name "*.md" \) 2>/dev/null | LC_ALL=C sort || true)
    else
      # CLI-specific: collect files under code/, docs/, heal/, review/ directories for this CLI
      files_list=$(find "agent-templates/code/${filter}" "agent-templates/docs/${filter}" "agent-templates/heal/${filter}" "agent-templates/review/${filter}" -type f \( -name "*.hbs" -o -name "*.sh" -o -name "*.md" \) 2>/dev/null | LC_ALL=C sort || true)
    fi
    
    # Also include shared agent partials so templates can resolve {{> agents/...}} references
    agent_partials=$(find "agent-templates/agents" -type f -name "*.hbs" 2>/dev/null | LC_ALL=C sort || true)
    if [ -n "$agent_partials" ]; then
      files_list+=$'\n'
      files_list+="$agent_partials"
    fi

    # Include shared code templates (e.g., hooks prefixed with code_shared_)
    code_shared=$(find "agent-templates" -maxdepth 1 -type f -name "code_shared_*" \( -name "*.hbs" -o -name "*.sh" -o -name "*.md" \) 2>/dev/null | LC_ALL=C sort || true)
    if [ -n "$code_shared" ]; then
      files_list+=$'\n'
      files_list+="$code_shared"
    fi
  fi
  
  # Remove duplicates and empty lines
  files_list=$(echo "$files_list" | LC_ALL=C sort -u | grep -v '^$' || true)
  
  if [ -z "$files_list" ]; then
    echo "  ⚠️  No files found for $name"
    rm "$output_file"
    return
  fi
  
  # Compute checksum
  checksum_tmp=$(mktemp)
  trap 'rm -f "$checksum_tmp"' EXIT
  
  while IFS= read -r f; do
    [ -z "$f" ] && continue
    printf '%s\n' "$f" >> "$checksum_tmp"
    cat "$f" >> "$checksum_tmp"
    printf '\n' >> "$checksum_tmp"
  done <<< "$files_list"
  
  if command -v shasum >/dev/null 2>&1; then
    local checksum=$(shasum -a 256 "$checksum_tmp" | awk '{print $1}')
  else
    local checksum=$(openssl dgst -sha256 -r "$checksum_tmp" | awk '{print $1}')
  fi
  
  # Inject checksum (portable sed for both macOS and Linux)
  if sed --version 2>&1 | grep -q GNU; then
    sed -i "s/CHECKSUM_PLACEHOLDER/${checksum}/" "$output_file"
  else
    sed -i '' "s/CHECKSUM_PLACEHOLDER/${checksum}/" "$output_file"
  fi
  
  # Add files to ConfigMap
  local file_count=0
  while IFS= read -r file; do
    [ -z "$file" ] && continue
    
    # Convert path to ConfigMap key
    key=$(echo "$file" | sed 's|agent-templates/||' | sed 's|/|_|g')
    
    echo "    Processing: $file -> $key"
    
    # Base64 encode
    encoded=$(base64 < "$file" | tr -d '\n')
    
    # Add to ConfigMap
    echo "  $key: $encoded" >> "$output_file"
    file_count=$((file_count + 1))
  done <<< "$files_list"
  
  local size=$(wc -c < "$output_file")
  echo "  ✓ Generated: $output_file"
  echo "  ✓ Checksum: $checksum"
  echo "  ✓ Files: $file_count"
  echo "  ✓ Size: $size bytes ($(numfmt --to=iec-i --suffix=B $size 2>/dev/null || echo "$size bytes"))"
  
  if [ $size -gt 1048576 ]; then
    echo "  ❌ ERROR: ConfigMap exceeds 1MB limit!"
    return 1
  fi
}

# Generate shared resources ConfigMap
generate_configmap "shared" "shared"

# Generate CLI-specific ConfigMaps
for cli in "${CLI_TYPES[@]}"; do
  generate_configmap "$cli" "$cli"
done

echo ""
echo "✅ All ConfigMaps generated successfully!"
echo ""
echo "Generated files:"
ls -lh "$OUTPUT_DIR"/agent-templates-*.yaml
echo ""
echo "Next steps:"
echo "1. Review the generated files"
echo "2. Remove old agent-templates-static.yaml: rm $OUTPUT_DIR/agent-templates-static.yaml"
echo "3. Commit changes: git add $OUTPUT_DIR/agent-templates-*.yaml && git commit -m 'chore: split agent templates into multiple ConfigMaps'"
echo "4. Update controller code to read from multiple ConfigMaps"
echo "5. Push to trigger ArgoCD sync"

