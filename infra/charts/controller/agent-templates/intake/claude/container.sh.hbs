#!/bin/sh
# =============================================================================
# Intake Documentation Template - Claude CLI
# =============================================================================
# This template handles documentation generation phase for unified intake.
# It runs after TaskMaster has parsed the PRD and generated tasks.
#
# Prerequisites:
#   - Repository is already cloned
#   - TaskMaster has generated tasks.json
#   - GitHub App authentication is configured
# =============================================================================

echo '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'
echo '‚ïë        INTAKE DOCUMENTATION GENERATION - CLAUDE CLI          ‚ïë'
echo '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'
echo "üìç Template version: intake-claude v1.0.0"
echo "üìÖ Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
echo "üéØ Agent: {{github_app}}"
echo "üìã Run Type: documentation"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# =============================================================================
# GitHub App Authentication
# =============================================================================
echo ""
echo "üîê Setting up GitHub App authentication..."

generate_github_token() {
    echo "Generating fresh GitHub App token..."
    
    if [ -z "$GITHUB_APP_PRIVATE_KEY" ] || [ -z "$GITHUB_APP_ID" ]; then
        echo "‚ùå GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
        return 1
    fi
    
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"
    
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
    REPO_OWNER=$(echo "$REPO_URL" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
    REPO_NAME=$(echo "$REPO_URL" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    
    INSTALLATION_RESPONSE=$(curl -s -L -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")
    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')
    
    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        ORG_INSTALLATION_RESPONSE=$(curl -s -L -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi
    
    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "‚ùå Failed to get installation ID"
        rm -f "$TEMP_KEY_FILE"
        return 1
    fi
    
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "‚ùå Failed to get installation access token"
        rm -f "$TEMP_KEY_FILE"
        return 1
    fi
    
    rm -f "$TEMP_KEY_FILE"
    export GITHUB_TOKEN
    export TOKEN_GENERATED_AT=$(date +%s)
    
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    echo "$GITHUB_TOKEN" | gh auth login --with-token
    
    echo "‚úì GitHub App authenticated successfully"
}

if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    generate_github_token
else
    echo "‚ùå GitHub App credentials not found"
    exit 1
fi

# =============================================================================
# Git Configuration
# =============================================================================
echo ""
echo "üîß Configuring Git..."

derive_bot_identity() {
    local app_name="$1"
    if [ -z "$app_name" ] || [ "$app_name" = "null" ]; then
        GIT_AUTHOR_NAME="automation[bot]"
        GIT_AUTHOR_EMAIL="automation[bot]@users.noreply.github.com"
        return
    fi
    
    local slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g')
    local bot_login="${slug}[bot]"
    GIT_AUTHOR_NAME="$bot_login"
    GIT_AUTHOR_EMAIL="${bot_login}@users.noreply.github.com"
}

GITHUB_APP="{{github_app}}"
derive_bot_identity "$GITHUB_APP"

git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"
git config --global --add safe.directory /workspace

export GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"

echo "‚úì Git configured as $GIT_AUTHOR_NAME"

# =============================================================================
# Workspace Setup
# =============================================================================
echo ""
echo "üìÅ Setting up workspace..."

WORKING_DIR="{{working_directory}}"
if [ -n "$WORKING_DIR" ] && [ "$WORKING_DIR" != "." ]; then
    CLAUDE_WORK_DIR="/workspace/$WORKING_DIR"
else
    CLAUDE_WORK_DIR="/workspace"
fi

cd "$CLAUDE_WORK_DIR" || exit 1
echo "‚úì Working directory: $CLAUDE_WORK_DIR"

# Copy ConfigMap files
if [ -d "/task-files" ]; then
    for md_file in /task-files/*.md; do
        if [ -f "$md_file" ]; then
            basename_file=$(basename "$md_file")
            if [ "$basename_file" = "claude.md" ]; then
                cp -f "$md_file" "$CLAUDE_WORK_DIR/CLAUDE.md"
            else
                cp -f "$md_file" "$CLAUDE_WORK_DIR/"
            fi
            echo "‚úì Copied $basename_file"
        fi
    done
fi

# =============================================================================
# Validate TaskMaster Setup
# =============================================================================
echo ""
echo "üìã Validating TaskMaster setup..."

if [ ! -d "$CLAUDE_WORK_DIR/.taskmaster" ]; then
    echo "‚ùå .taskmaster directory not found - TaskMaster must be initialized first"
    exit 1
fi

if [ ! -f "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" ]; then
    echo "‚ùå tasks.json not found - TaskMaster must have generated tasks"
    exit 1
fi

TASK_COUNT=$(jq -r '.tasks | length' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" 2>/dev/null || echo "0")
echo "‚úì Found $TASK_COUNT tasks in tasks.json"

# Create docs directory
mkdir -p "$CLAUDE_WORK_DIR/.taskmaster/docs"
echo "‚úì TaskMaster setup validated"

# =============================================================================
# Create PR Branch
# =============================================================================
echo ""
echo "üåø Creating PR branch..."

SOURCE_BRANCH="{{source_branch}}"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
RANDOM_ID=$(date +%s | tail -c 6)
PR_BRANCH="docs/intake-${TIMESTAMP}-${RANDOM_ID}"

if ! git checkout -b "$PR_BRANCH" "origin/$SOURCE_BRANCH" 2>/dev/null; then
    echo "‚ùå Failed to create PR branch from origin/$SOURCE_BRANCH"
    exit 1
fi

export DOCS_AUTO_SAVE_BRANCH="$PR_BRANCH"
export SOURCE_BRANCH
echo "‚úì Created PR branch: $PR_BRANCH (from origin/$SOURCE_BRANCH)"

# =============================================================================
# Claude Execution
# =============================================================================
echo ""
echo "ü§ñ Starting Claude documentation generation..."

cd "$CLAUDE_WORK_DIR"

CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Add MCP configuration if available
if [ -f "/workspace/.mcp.json" ]; then
    CLAUDE_CMD="$CLAUDE_CMD --mcp-config /workspace/.mcp.json"
    echo "‚úì Added MCP configuration"
fi

# Build the documentation prompt
INITIAL_TEXT=$(jq -Rs . << 'DOC_PROMPT_EOF'
# Documentation Generation Task

## Overview
Generate comprehensive documentation for all tasks in the TaskMaster project.

## Required Process

### Step 1: Analyze Tasks
1. Read `.taskmaster/tasks/tasks.json` to understand all tasks
2. Review any PRD, architecture, or context files
3. Note task dependencies and implementation order

### Step 2: Generate Documentation
For EACH task, create the following files in `.taskmaster/docs/task-{id}/`:

- `task.md` - Comprehensive task overview and implementation guide
- `prompt.md` - Autonomous prompt for AI agents to implement the task
- `acceptance-criteria.md` - Clear acceptance criteria and test cases
- `task.xml` - XML-structured prompt optimized for LLM consumption

### Step 3: Add Agent Hints
For each task, add appropriate agent hints based on content:
- Tasks involving React/Vue/frontend ‚Üí add "frontend" hint
- Tasks involving API/database/backend ‚Üí add "backend" hint
- Tasks involving multiple systems ‚Üí add "integration" hint

## Completion
When finished, output a summary of all documentation generated.
DOC_PROMPT_EOF
)

echo "Starting Claude with documentation prompt..."
(printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}\n' "$INITIAL_TEXT"; exec 0<&-) | $CLAUDE_CMD &
CLAUDE_PID=$!

wait "$CLAUDE_PID"
CLAUDE_EXIT_CODE=$?
echo "Claude completed with exit code: $CLAUDE_EXIT_CODE"

# =============================================================================
# PR Creation
# =============================================================================
echo ""
echo "üìù Creating pull request..."

cd "$CLAUDE_WORK_DIR"

# Stage and commit changes
git add .taskmaster/
STAGED_FILES=$(git status --porcelain | grep "^[AM]" | wc -l)

if [ "$STAGED_FILES" -gt 0 ]; then
    git commit -m "docs: generate TaskMaster documentation

- Auto-generated comprehensive task documentation
- Created task.md, prompt.md, acceptance-criteria.md for each task
- Added agent routing hints

ü§ñ Auto-generated by Unified Intake"

    git push -u origin "$PR_BRANCH"
    
    PR_TITLE="docs: TaskMaster documentation for project intake"
    PR_BODY="Auto-generated TaskMaster documentation by unified intake.

**Branch:** \`$PR_BRANCH\` ‚Üí \`$SOURCE_BRANCH\`
**Tasks Documented:** $TASK_COUNT

ü§ñ Auto-generated by Unified Intake"

    if gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base "$SOURCE_BRANCH" --head "$PR_BRANCH"; then
        echo "‚úì Pull request created successfully"
    else
        echo "‚ö†Ô∏è Failed to create PR - branch pushed, create PR manually"
    fi
else
    echo "‚ö†Ô∏è No documentation changes to commit"
fi

echo ""
echo "‚úÖ Intake documentation generation complete!"






