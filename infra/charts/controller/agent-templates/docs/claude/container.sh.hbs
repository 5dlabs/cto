#!/bin/sh

echo 'Starting documentation generation...'
echo "üìç Docs container template version: $(date -u +%Y-%m-%d) - jq-only processing (no base64 decode)"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication (SSH not required)"

# Function to generate fresh GitHub App token (defined globally for reuse)
generate_github_token() {
    echo "Generating fresh GitHub App token..."

    # Check if credentials are available
    if [ -z "$GITHUB_APP_PRIVATE_KEY" ] || [ -z "$GITHUB_APP_ID" ]; then
        echo "‚ùå GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
        return 1
    fi

    # Create temporary private key file from environment variable
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    echo "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"

    echo "Using private key from environment variable"

    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

    if [ -z "$JWT_TOKEN" ]; then
        echo "‚ùå Failed to generate JWT token"
        exit 1
    fi

    # Get installation ID for the repository
    REPO_OWNER=$(echo "{{repository_url}}" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
    REPO_NAME=$(echo "{{repository_url}}" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')

    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."

    # Try repository installation first (follow redirects)
    INSTALLATION_RESPONSE=$(curl -s -L -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    # Fallback: try organization installation if repo lookup failed
    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "‚ö†Ô∏è Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "‚ùå Failed to get installation ID for repository"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    echo "Installation ID: $INSTALLATION_ID"

    # Export for use by hooks
    export INSTALLATION_ID

    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "‚ùå Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"

    # Export the token for git to use
    export GITHUB_TOKEN

    # Store token generation time for refresh checks
    export TOKEN_GENERATED_AT=$(date +%s)

    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials

    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token

    echo "‚úì GitHub App authenticated successfully"
}

# Function to check if token needs refresh (call before git operations)
refresh_token_if_needed() {
    if [ -z "$TOKEN_GENERATED_AT" ]; then
        echo "‚ö†Ô∏è No token timestamp found, refreshing token..."
        generate_github_token
        return
    fi

    NOW=$(date +%s)
    TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))
    # Refresh if token is older than 50 minutes (GitHub tokens last 1 hour, refresh at 50 min to be safe)
    if [ $TOKEN_AGE -gt 3000 ]; then
        echo "üîÑ Token is $(($TOKEN_AGE / 60)) minutes old, refreshing..."
        generate_github_token
    fi
}

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    # Initial authentication
    generate_github_token

    # Validate authentication by testing actual GitHub operations we'll need
    echo "üîç Validating GitHub authentication with actual operations..."
    REPO_OWNER=$(echo "$REPO_URL" | sed 's|https://github.com/||' | sed 's|/.*||')
    REPO_NAME=$(echo "$REPO_URL" | sed 's|.*/||')

    # Test 1: Can we access the repository?
    if gh api "repos/$REPO_OWNER/$REPO_NAME" > /tmp/repo_test.json 2>&1; then
        echo "‚úÖ Repository access confirmed"
    else
        echo "‚ùå Cannot access repository $REPO_OWNER/$REPO_NAME"
        echo "Error: $(cat /tmp/repo_test.json)"
        exit 1
    fi

    # Test 2: Can we list branches (needed for PR creation)?
    if gh api "repos/$REPO_OWNER/$REPO_NAME/branches" > /tmp/branches_test.json 2>&1; then
        echo "‚úÖ Can list branches"
    else
        echo "‚ùå Cannot list branches"
        echo "Error: $(cat /tmp/branches_test.json)"
        exit 1
    fi

    # Test 3: Can we get app info (GitHub Apps can't access user endpoint)?
    if gh api app > /tmp/app_test.json 2>&1; then
        APP_NAME=$(jq -r '.name' /tmp/app_test.json 2>/dev/null || echo "unknown")
        echo "‚úÖ GitHub App API access confirmed: $APP_NAME"
    else
        echo "‚úÖ App endpoint not accessible (normal for GitHub Apps) - using repo access as confirmation"
    fi

    echo "‚úÖ All GitHub authentication tests passed - proceeding with confidence"

else
    echo "‚ùå GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
    exit 1
fi


# Git configuration with proper GitHub App attribution
git config --global --add safe.directory "$TASK_WORKSPACE"

# Set GitHub App attribution - use generic format for all agents
derive_bot_identity() {
    local app_name="$1"

    if [ -z "$app_name" ] || [ "$app_name" = "null" ]; then
        GIT_AUTHOR_NAME="automation[bot]"
        GIT_AUTHOR_EMAIL="automation[bot]@users.noreply.github.com"
        return
    fi

    local slug
    slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-+|-+$//g')
    if [ -z "$slug" ]; then
        slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]')
    fi

    local bot_login="${slug}[bot]"
    local bot_email="${bot_login}@users.noreply.github.com"

    if [ -n "${GITHUB_TOKEN:-}" ]; then
        local encoded_login
        encoded_login=$(printf '%s' "$bot_login" | sed 's/\[/%5B/g; s/\]/%5D/g')
        local bot_response
        bot_response=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/users/${encoded_login}" 2>/dev/null || true)
        local bot_id
        bot_id=$(printf '%s' "$bot_response" | jq -r '.id // empty' 2>/dev/null || echo '')
        if [ -n "$bot_id" ]; then
            bot_email="${bot_id}+${bot_login}@users.noreply.github.com"
        fi
    fi

    GIT_AUTHOR_NAME="$bot_login"
    GIT_AUTHOR_EMAIL="$bot_email"
}

GITHUB_APP="{{github_app}}"
derive_bot_identity "$GITHUB_APP"

# Configure git with proper GitHub App attribution
git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

# Set environment variables for Claude Code to use
export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"

echo "‚úì Git configured"

# Repository setup
REPO_BRANCH="{{source_branch}}"
echo "Repository: $REPO_URL"
echo "Branch: $REPO_BRANCH"

if [ -d "/workspace/.git" ]; then
  echo "Repository exists, updating..."
  cd "$TASK_WORKSPACE"
  git remote set-url origin "$REPO_URL"
  git fetch origin
  git checkout "$REPO_BRANCH"
  git pull origin "$REPO_BRANCH"
else
  echo "Setting up repository..."
  # Clone to temp directory first, then move contents
  TEMP_CLONE_DIR="/tmp/repo-clone"
  rm -rf "$TEMP_CLONE_DIR"

  if ! git clone --depth 1 --branch "$REPO_BRANCH" "$REPO_URL" "$TEMP_CLONE_DIR"; then
    echo "‚ùå Failed to clone repository"
    exit 1
  fi

  # Move repository contents to workspace
  mv "$TEMP_CLONE_DIR"/* /workspace/ 2>/dev/null || true
  mv "$TEMP_CLONE_DIR"/.[^.]* /workspace/ 2>/dev/null || true
  rm -rf "$TEMP_CLONE_DIR"
  cd "$TASK_WORKSPACE"
fi

echo "‚úì Repository ready"

# Working directory setup
WORKING_DIR="{{working_directory}}"
if [ -n "$WORKING_DIR" ] && [ "$WORKING_DIR" != "." ]; then
  CLAUDE_WORK_DIR="/workspace/$WORKING_DIR"
  cd "$CLAUDE_WORK_DIR" || exit 1
  echo "‚úì Working directory: $CLAUDE_WORK_DIR"
else
  CLAUDE_WORK_DIR="/workspace"
  echo "‚úì Working directory: $CLAUDE_WORK_DIR"
fi

# Copy ConfigMap files
echo "Setting up ConfigMap files..."
if [ -d "/task-files" ]; then
  # Copy markdown files
  for md_file in /task-files/*.md; do
    if [ -f "$md_file" ]; then
      basename_file=$(basename "$md_file")
      if [ "$basename_file" = "claude.md" ]; then
        cp -f "$md_file" "$CLAUDE_WORK_DIR/CLAUDE.md"
      else
        cp -f "$md_file" "$CLAUDE_WORK_DIR/"
      fi
      echo "‚úì Copied $basename_file"
    fi
  done

  # Verify enterprise settings
  if [ -f "/etc/claude-code/managed-settings.json" ]; then
    echo "‚úì Enterprise settings verified"
    if ! jq empty /etc/claude-code/managed-settings.json 2>/dev/null; then
      echo "‚ùå Invalid enterprise settings JSON"
      exit 1
    fi
  else
    echo "‚ùå Enterprise settings not found"
    exit 1
  fi

  # Copy hook scripts (controller automatically includes any docs_hooks_* files)
  for hook_file in /task-files/hooks-*.sh; do
    if [ -f "$hook_file" ]; then
      hook_name=$(basename "$hook_file" | sed 's/^hooks-//')
      cp "$hook_file" "$CLAUDE_WORK_DIR/$hook_name"
      chmod +x "$CLAUDE_WORK_DIR/$hook_name"
  echo "‚úì Copied hook: $hook_name"
    fi
  done

else
  echo "‚ùå ConfigMap not mounted at /task-files"
  exit 1
fi

# Validate workspace
echo "Validating workspace..."
REQUIRED_FILES="CLAUDE.md"
for file in $REQUIRED_FILES; do
  if [ ! -f "$CLAUDE_WORK_DIR/$file" ]; then
    echo "‚ùå Missing required file: $file"
    exit 1
  fi
done

# Check for .taskmaster directory - create if missing for resilient setup
if [ ! -d "$CLAUDE_WORK_DIR/.taskmaster" ]; then
  echo "‚ö†Ô∏è  .taskmaster directory not found, initializing structure..."
  mkdir -p "$CLAUDE_WORK_DIR/.taskmaster/tasks"
  mkdir -p "$CLAUDE_WORK_DIR/.taskmaster/docs"
  echo "‚úì Created .taskmaster structure"
else
  echo "‚úì .taskmaster directory exists"
fi

# Ensure docs directory exists and clean old data to prevent contamination
mkdir -p "$CLAUDE_WORK_DIR/.taskmaster/docs"

# TEMPORARY: Clean any existing documentation to prevent cross-project contamination
echo "üßπ Cleaning existing documentation to prevent cross-project contamination..."
rm -rf "$CLAUDE_WORK_DIR/.taskmaster/docs/task-"* 2>/dev/null || true
echo "‚úì Cleaned existing task documentation"

## Handle task files - support both JSON and individual file formats
echo "Setting up task files..."
if [ -f "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" ]; then
  echo "üìã Found tasks.json, generating individual task files..."

  # Robust extraction: handle different possible tasks.json structures
  echo "üîç Analyzing tasks.json structure..."

  # Debug: Show the actual structure of tasks.json
  echo "üìÑ Raw tasks.json structure preview:"
  head -20 "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" 2>/dev/null || echo "Could not read tasks.json"
  echo "üìä JSON structure analysis:"
  jq -r '"Type: " + (type | tostring) + ", Length: " + (if type == "array" then length else (keys | length) end | tostring)' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" 2>/dev/null || echo "Could not analyze JSON structure"

  gen_count=0

  # Use jq directly to process tasks without base64 encoding/decoding
  # This avoids the base64 invalid input errors

  # First, check the actual structure of tasks.json
  if jq -e '.master.tasks and (.master.tasks | type == "array")' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" >/dev/null 2>&1; then
    echo "üìã Detected TaskMaster structure with master.tasks array"
    jq -c '.master.tasks[] | select(.id != null)' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json"
  elif jq -e 'type == "array" and length > 0' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" >/dev/null 2>&1; then
    echo "üìã Detected array structure, checking if it contains task objects directly..."
    # Check if it's an array of task objects directly
    if jq -e '.[0] | has("id")' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" >/dev/null 2>&1; then
      echo "üìã Processing as direct array of task objects"
      jq -c '.[] | select(.id != null)' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json"
    elif jq -e '.[0] | has("tasks")' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" >/dev/null 2>&1; then
      echo "üìã Processing as array with nested tasks arrays"
      jq -c '.[].tasks[]? | select(.id != null)' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json"
    else
      echo "üìã Processing as generic array structure"
      jq -c '.[] | select(.id != null)' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json"
    fi
  elif jq -e '.tasks and (.tasks | type == "array")' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" >/dev/null 2>&1; then
    echo "üìã Processing as object with tasks array"
    jq -c '.tasks[] | select(.id != null)' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json"
  else
    echo "‚ö†Ô∏è Unexpected tasks.json structure, attempting generic extraction..."
    # Fallback: try to extract any objects with id field
    jq -c '.. | objects | select(.id != null)' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" 2>/dev/null || {
      echo "‚ùå Failed to parse tasks.json structure"
      echo "Showing raw tasks.json content for debugging:"
      cat "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" 2>/dev/null || echo "Could not read tasks.json"
      exit 1
    }
  fi \
    | while IFS= read -r task_json; do
      if [ -z "$task_json" ]; then
        continue
      fi

      # Direct JSON extraction with error handling (no base64 decoding needed)
      _decode() {
        printf '%s' "$task_json" | jq -r "$1" 2>/dev/null || echo ""
      }

      task_id=$(_decode '.id')
      if [ -z "$task_id" ] || [ "$task_id" = "null" ]; then
        echo "‚ö†Ô∏è Skipping task without valid id: $task_id"
        continue
      fi
      title=$(_decode '.title // "No Title"')
      description=$(_decode '.description // ""')
      details=$(_decode '.details // ""')
      test_strategy=$(_decode '.testStrategy // ""')

      task_dir="$CLAUDE_WORK_DIR/.taskmaster/docs/task-$task_id"
      mkdir -p "$task_dir"
      cat > "$task_dir/task.txt" << EOF
# Task $task_id: $title

## Description
$description

## Implementation Details
$details

## Test Strategy
$test_strategy
EOF

      # Generate XML format optimized for LLM consumption with enhanced structure
      # Extract additional fields for XML structure
      priority=$(_decode '.priority // "medium"')
      dependencies=$(_decode '.dependencies // []' | jq -r 'if type == "array" then . else [] end | join(", ")')
      status=$(_decode '.status // "pending"')

      # Determine technology stack from task content for role definition
      if echo "$details" | grep -qi "rust\|cargo\|tokio\|serde"; then
        tech_role="senior Rust developer specializing in Kubernetes controllers and cloud-native applications"
      elif echo "$details" | grep -qi "kubernetes\|k8s\|argo\|helm"; then
        tech_role="senior Kubernetes engineer specializing in GitOps workflows and Argo Events"
      elif echo "$details" | grep -qi "argo\|workflow\|events"; then
        tech_role="senior DevOps engineer specializing in Argo Workflows and event-driven automation"
      else
        tech_role="senior software engineer and coding agent specializing in the project's technology stack"
      fi

      # Extract technical specifications from task details
      specs=""
      if echo "$details" | grep -A 10 -i "technical\|requirements\|specifications" >/dev/null 2>&1; then
        specs_section=$(echo "$details" | sed -n '/technical\|requirements\|specifications/I,/^$/p' | head -10)
        while IFS= read -r line; do
          # Case-insensitive check to exclude section headers
          if [[ -n "$line" ]] && ! echo "$line" | grep -qi "^[[:space:]]*\(technical\|requirements\|specifications\)[[:space:]]*$"; then
            # XML escape the content
            escaped_line=$(echo "$line" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/"/\&quot;/g; s/'\''/\&#39;/g')
            specs="${specs}<spec>$escaped_line</spec>
        "
          fi
        done <<< "$specs_section"
      fi

      # Fallback specs if none found
      if [ -z "$specs" ]; then
        specs="<spec>Follow the project&apos;s existing architecture and coding patterns</spec>
        <spec>Ensure compatibility with the current technology stack</spec>
        <spec>Implement proper error handling and logging</spec>
        <spec>Follow established security best practices</spec>"
      fi

      # Extract acceptance criteria from test strategy
      criteria=""
      if [ -n "$test_strategy" ]; then
        # Split test strategy into individual criteria on numbered items (1., 2., etc.)
        # Use word boundaries to avoid splitting on version numbers or decimals
        IFS=$'\n' read -rd '' -a test_parts <<< "$(echo "$test_strategy" | grep -E '^[[:space:]]*[0-9]+[[:space:]]*\.[[:space:]]*[A-Z]')"
        for part in "${test_parts[@]}"; do
          part=$(echo "$part" | sed 's/^[[:space:]]*[0-9]\+\.[[:space:]]*//;s/[[:space:]]*$//')
          if [ -n "$part" ] && [ ${#part} -gt 10 ]; then
            # XML escape the content
            escaped_part=$(echo "$part" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/"/\&quot;/g; s/'\''/\&#39;/g')
            criteria="${criteria}<criterion>$escaped_part</criterion>
        "
          fi
        done
      fi

      # Fallback criteria if none extracted
      if [ -z "$criteria" ]; then
        criteria="<criterion>Implementation must be complete and functional</criterion>
        <criterion>Code must follow the project&apos;s style guidelines and conventions</criterion>
        <criterion>All edge cases should be properly handled</criterion>
        <criterion>Implementation should be well-documented with clear comments</criterion>"
      fi

      gen_count=$((gen_count+1))
      echo "‚úì Generated docs/task-$task_id/task.txt"
    done
  echo "Generated $gen_count task directories with txt files from tasks.json"
elif [ -d "$CLAUDE_WORK_DIR/.taskmaster/tasks" ] && [ "$(ls -A "$CLAUDE_WORK_DIR/.taskmaster/tasks" 2>/dev/null)" ]; then
  echo "üìã Found individual task files, copying to docs directory..."

  # Copy individual task files from tasks/ to docs/ directory
  for task_dir in "$CLAUDE_WORK_DIR/.taskmaster/tasks"/task-*; do
    if [ -d "$task_dir" ]; then
      task_name=$(basename "$task_dir")
      target_dir="$CLAUDE_WORK_DIR/.taskmaster/docs/$task_name"
      mkdir -p "$target_dir"
      cp -r "$task_dir"/* "$target_dir/"
      echo "‚úì Copied $task_name to docs directory"
    fi
  done
else
  echo "‚ùå No task files found - expected either:"
  echo "  - tasks.json at .taskmaster/tasks/tasks.json"
  echo "  - Individual task directories at .taskmaster/tasks/task-*/"
  exit 1
fi

# Verify we have task files to work with
if [ ! -d "$CLAUDE_WORK_DIR/.taskmaster/docs" ] || [ -z "$(ls -A "$CLAUDE_WORK_DIR/.taskmaster/docs" 2>/dev/null)" ]; then
  echo "‚ùå No task files available in .taskmaster/docs directory"
  exit 1
fi

echo "‚úì Workspace validated"

# Copy MCP servers config for Tools if provided
if [ -f "/task-files/mcp.json" ]; then
  # Copy to both working directory (project scope) and workspace root (local scope)
  cp "/task-files/mcp.json" "$CLAUDE_WORK_DIR/.mcp.json" && echo "‚úì Copied mcp.json to $CLAUDE_WORK_DIR/.mcp.json (project scope)" || echo "‚ö†Ô∏è mcp.json copy to working dir failed"
  cp "/task-files/mcp.json" "/workspace/.mcp.json" && echo "‚úì Copied mcp.json to /workspace/.mcp.json (local scope)" || echo "‚ö†Ô∏è mcp.json copy to workspace root failed"

  # Fix MCP configuration for container environment in both locations
  for mcp_file in "$CLAUDE_WORK_DIR/.mcp.json" "/workspace/.mcp.json"; do
    if [ -f "$mcp_file" ]; then
      echo "üîß Updating MCP configuration for container environment: $mcp_file"
      # Update TASK_MASTER_PROJECT_ROOT to container path (generic replacement)
      sed -i 's|"TASK_MASTER_PROJECT_ROOT"[[:space:]]*:[[:space:]]*"[^"]*"|"TASK_MASTER_PROJECT_ROOT": "/workspace/docs"|g' "$mcp_file"
      echo "‚úì Updated MCP configuration paths in $mcp_file"
    fi
  done
else
  echo "‚ÑπÔ∏è No mcp.json provided; Tools MCP may not be configured"
fi

# Environment setup
export SERVICE_NAME="{{service_name}}"
export SOURCE_BRANCH="{{source_branch}}"
export WORKING_DIR="{{working_directory}}"
export GITHUB_USER="{{github_app}}"
export GITHUB_APP="{{github_app}}"

# Optional: copy agent-centric Tools client config (base from Helm/controller)
if [ -f "/task-files/client-config.json" ]; then
  echo "üîç DEBUG: Source /task-files/client-config.json summary (pre-copy):"
  (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' \
     "/task-files/client-config.json" 2>/dev/null \
   || { echo -n "raw="; head -c 200 "/task-files/client-config.json"; echo; })

  cp "/task-files/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" \
    && echo "‚úì client-config.json copied to Claude working directory" \
    || echo "‚ùå client-config.json copy failed"
  cp \$FACTORY_WORK_DIR/client-config.json "$TASK_WORKSPACE/client-config.json" 2>/dev/null || true \
    && echo "‚úì client-config.json copied to workspace root" \
    || echo "‚ùå client-config.json copy to workspace failed"

  if [ -f "$CLAUDE_WORK_DIR/client-config.json" ]; then
    echo "üîç DEBUG: Dest $CLAUDE_WORK_DIR/client-config.json summary (post-copy):"
    (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' \
       "$CLAUDE_WORK_DIR/client-config.json" 2>/dev/null \
     || { echo -n "raw="; head -c 200 "$CLAUDE_WORK_DIR/client-config.json"; echo; })
    # Harden file to catch unexpected overwrites (diagnostic)
    chmod a-w "$CLAUDE_WORK_DIR/client-config.json" 2>/dev/null || true
    echo "üîí DEBUG: Made $CLAUDE_WORK_DIR/client-config.json read-only to detect overwrites"
  fi
else
  echo "‚ö†Ô∏è client-config.json not found - MCP client may not be configured"
fi

# MCP configuration already handled above with path fixes

# Enterprise managed settings are mounted directly from ConfigMap
echo "=== ENTERPRISE MANAGED SETTINGS ==="
echo "‚úì Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
echo "‚úì No copying needed - mount automatically reflects latest ConfigMap changes"

echo "‚úì ConfigMap files copied to $CLAUDE_WORK_DIR"

# Append repo-level clientConfig from cto-config.json if present (append-only, generic)
CTO_CANDIDATES=("$CLAUDE_WORK_DIR/cto-config.json" "/workspace/cto-config.json")
for CFG_PATH in "${CTO_CANDIDATES[@]}"; do
  if [ -f "$CFG_PATH" ] && [ -f "$CLAUDE_WORK_DIR/client-config.json" ]; then
    echo "üîß Merging repo cto-config.json clientConfig into client-config.json (append-only)"
    AGENT_KEY=$(echo "{{github_app}}" | sed 's/^5DLabs-//' | tr 'A-Z' 'a-z')
    TMP_MERGE="/tmp/client-config.merged.json"
    if jq --arg ak "$AGENT_KEY" -s '
      def append_only_merge(b; e):
        if (b|type)=="object" and (e|type)=="object" then
          (b + e | to_entries
            | map({key: .key, value:
                ( (b[.key] // empty) as $bv | (e[.key] // empty) as $ev
                  | if ($bv|type)=="object" and ($ev|type)=="object" then append_only_merge($bv;$ev)
                    elif ($bv|type)=="array" and ($ev|type)=="array" then ($bv + $ev | unique)
                    elif ($bv|type)==($ev|type) then $bv
                    else ($bv // $ev) end) })
            | from_entries)
        elif (b|type)=="array" and (e|type)=="array" then (b + e | unique)
        else b end;
      (.[0] as $base | .[1] as $repo |
       ($repo.agents[$ak].clientConfig // {}) as $extra |
       append_only_merge($base; $extra)
      )' "$CLAUDE_WORK_DIR/client-config.json" "$CFG_PATH" > "$TMP_MERGE"; then
      mv "$TMP_MERGE" "$CLAUDE_WORK_DIR/client-config.json"
      cp \$FACTORY_WORK_DIR/client-config.json "$TASK_WORKSPACE/client-config.json" 2>/dev/null || true 2>/dev/null || true
      echo "‚úì Appended repo clientConfig for agent: $AGENT_KEY"
      echo "üîç DEBUG: Dest $CLAUDE_WORK_DIR/client-config.json summary (post-merge):"
      (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' \
         "$CLAUDE_WORK_DIR/client-config.json" 2>/dev/null \
       || { echo -n "raw="; head -c 200 "$CLAUDE_WORK_DIR/client-config.json"; echo; })
    else
      echo "‚ö†Ô∏è Failed to merge repo cto-config.json clientConfig into client-config.json"
    fi
    break
  fi
done

# Start background token refresh process (every 45 minutes to stay ahead of 1-hour expiry)
(
    while true; do
        sleep 2700  # 45 minutes
        echo "[Background] Checking if token needs refresh..."
        if [ -n "$TOKEN_GENERATED_AT" ]; then
            NOW=$(date +%s)
            TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))
            echo "[Background] Token age: $(($TOKEN_AGE / 60)) minutes"
            if [ $TOKEN_AGE -gt 2700 ]; then
                echo "[Background] Refreshing GitHub token proactively..."
                if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
                    generate_github_token
                fi
            fi
        fi
    done
) &
TOKEN_REFRESH_PID=$!
echo "‚úì Started background token refresh process (PID: $TOKEN_REFRESH_PID)"

# Ensure we kill the background process on exit
trap "kill $TOKEN_REFRESH_PID 2>/dev/null || true" EXIT

# Config diagnostics (visibility for MCP + client config)
echo '=== CONFIG DIAGNOSTICS ==='
echo "Working directory: $CLAUDE_WORK_DIR"
echo "Listing /task-files (ConfigMap mount):"
ls -la /task-files | sed 's/^/[task-files] /'
echo "MCP_CLIENT_CONFIG: ${MCP_CLIENT_CONFIG:-<unset>}"
if [ -f "$CLAUDE_WORK_DIR/client-config.json" ]; then
  echo "[client-config] path: $CLAUDE_WORK_DIR/client-config.json"
  echo "[client-config] summary:"; jq -r '"remoteTools=" + ((.remoteTools // []) | length | tostring) + ", localServers.keys=" + ((.localServers // {} | keys) | join(","))' "$CLAUDE_WORK_DIR/client-config.json" 2>/dev/null || echo "  (not valid JSON)"
else
  echo "[client-config] MISSING at $CLAUDE_WORK_DIR/client-config.json"
fi
# Check MCP files in both locations
echo "[mcp] Checking MCP configuration files..."
for mcp_location in "/workspace/.mcp.json" "$CLAUDE_WORK_DIR/.mcp.json"; do
  if [ -f "$mcp_location" ]; then
    echo "[mcp] ‚úì FOUND: $mcp_location"
    echo "[mcp] File size: $(wc -c < "$mcp_location") bytes"
    echo "[mcp] First 10 lines:"; head -n 10 "$mcp_location" | sed 's/^/[mcp]   /'
    echo "[mcp] Permissions: $(ls -la "$mcp_location")"
  else
    echo "[mcp] ‚úó MISSING: $mcp_location"
  fi
done

# Check current working directory for Claude execution
echo "[mcp] Current working directory: $(pwd)"
echo "[mcp] Claude will be launched from: $(pwd)"
echo "[mcp] According to MCP scope hierarchy:"
echo "[mcp]   1. Local scope (current dir): $(pwd)/.mcp.json"
echo "[mcp]   2. Project scope (working dir): $CLAUDE_WORK_DIR/.mcp.json"
echo "[mcp]   3. User scope: ~/.config/claude-code/.mcp.json"
echo '=== END CONFIG DIAGNOSTICS ==='

# Verify/Select client-config.json for runtime
echo "=== TOOLS CONFIG SETUP ==="
WORKSPACE_CFG="$CLAUDE_WORK_DIR/client-config.json"
SOURCE_CFG="/task-files/client-config.json"

# Helper to check non-empty JSON object
is_valid_cfg() {
  local p="$1"
  [ -f "$p" ] || return 1
  jq -e 'type=="object" and length>0' "$p" >/dev/null 2>&1
}

SRC_OK=false
WS_OK=false
if is_valid_cfg "$SOURCE_CFG"; then SRC_OK=true; fi
if is_valid_cfg "$WORKSPACE_CFG"; then WS_OK=true; fi

if $SRC_OK; then
  export MCP_CLIENT_CONFIG="$SOURCE_CFG"
  echo "‚úì Selected MCP_CLIENT_CONFIG from source ConfigMap: $MCP_CLIENT_CONFIG"
elif $WS_OK; then
  export MCP_CLIENT_CONFIG="$WORKSPACE_CFG"
  echo "‚úì Selected MCP_CLIENT_CONFIG from workspace copy: $MCP_CLIENT_CONFIG"
else
  echo "‚ùå No valid client-config.json found (both source and workspace empty/invalid). Aborting."
  if [ -f "$SOURCE_CFG" ]; then
    echo "   Source summary:"; (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' "$SOURCE_CFG" 2>/dev/null || { echo -n "   raw="; head -c 200 "$SOURCE_CFG"; echo; })
  else
    echo "   Source missing: $SOURCE_CFG"
  fi
  if [ -f "$WORKSPACE_CFG" ]; then
    echo "   Workspace summary:"; (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' "$WORKSPACE_CFG" 2>/dev/null || { echo -n "   raw="; head -c 200 "$WORKSPACE_CFG"; echo; })
  else
    echo "   Workspace missing: $WORKSPACE_CFG"
  fi
  exit 1
fi

# Pre-flight MCP tool checks (fail-fast)
echo "=== PRE-FLIGHT MCP TOOL CHECKS ==="

# 1) Ensure tools client is available when mcpServers includes it
MCP_FILE_PROJECT="$CLAUDE_WORK_DIR/.mcp.json"
MCP_FILE_WORKSPACE="/workspace/.mcp.json"
if [ -f "$MCP_FILE_WORKSPACE" ] || [ -f "$MCP_FILE_PROJECT" ]; then
  if ! command -v tools >/dev/null 2>&1; then
    echo "‚ùå 'tools' CLI not found in PATH but required by .mcp.json. Aborting."
    exit 1
  fi
  # If TOOLS_SERVER_URL present, attempt quick connectivity check
  TM_URL=$(jq -r '.mcpServers.tools.env.TOOLS_SERVER_URL // empty' "$MCP_FILE_WORKSPACE" 2>/dev/null || true)
  if [ -z "$TM_URL" ] && [ -f "$MCP_FILE_PROJECT" ]; then
    TM_URL=$(jq -r '.mcpServers.tools.env.TOOLS_SERVER_URL // empty' "$MCP_FILE_PROJECT" 2>/dev/null || true)
  fi
  if [ -n "$TM_URL" ]; then
    echo "üîç Checking Tools endpoint: $TM_URL"
    # Treat any HTTP response as connectivity; only fail on DNS/connect/timeout errors
    HTTP_CODE=$(curl -sS -o /dev/null -w "%{http_code}" --connect-timeout 2 --max-time 3 "$TM_URL" 2>/dev/null)
    CURL_RC=$?
    if [ "$CURL_RC" -ne 0 ]; then
      echo "‚ùå Network error reaching Tools MCP endpoint (curl rc=$CURL_RC): $TM_URL. Aborting."
      exit 1
    fi
    echo "‚úì Tools endpoint reachable (HTTP ${HTTP_CODE:-unknown})"
  fi
else
  echo "‚ÑπÔ∏è No .mcp.json found; skipping tools connectivity check"
fi

# 2) Validate local server commands defined in MCP client config
if [ -f "$MCP_CLIENT_CONFIG" ]; then
  # Iterate known local servers and ensure their commands exist (if specified)
  for srv in filesystem git; do
    CMD=$(jq -r --arg s "$srv" '.localServers[$s].command // empty' "$MCP_CLIENT_CONFIG" 2>/dev/null || true)
    if [ -n "$CMD" ]; then
      if ! command -v "$CMD" >/dev/null 2>&1; then
        echo "‚ùå Local MCP server '$srv' requires command '$CMD' not found in PATH. Aborting."
        exit 1
      fi
      echo "‚úì Local server '$srv' command '$CMD' found"
    fi
  done
else
  echo "‚ö†Ô∏è MCP_CLIENT_CONFIG not found for local server validation"
fi

# 3) Announce remote tools list for visibility
if [ -f "$MCP_CLIENT_CONFIG" ]; then
  echo -n "üîß Remote tools configured: "
  jq -r '(.remoteTools // []) | join(", ")' "$MCP_CLIENT_CONFIG" 2>/dev/null | sed 's/^$/<none>/'
fi

echo '=== WORKSPACE VALIDATION ==='

# Check for required files in Claude's working directory
MISSING_FILES=""
REQUIRED_FILES="CLAUDE.md"

echo "Checking for required files..."
for file in $REQUIRED_FILES; do
  if [ ! -f "$CLAUDE_WORK_DIR/$file" ]; then
    echo "ERROR: Missing required file: $CLAUDE_WORK_DIR/$file"
    MISSING_FILES="$MISSING_FILES $file"
  else
    echo "‚úì Found: $CLAUDE_WORK_DIR/$file"
    # Show file size for verification
    size=$(wc -c < "$CLAUDE_WORK_DIR/$file" 2>/dev/null || echo "0")
    echo "  File size: $size bytes"
  fi
done

# Check git repository (REQUIRED for implementation tasks)
if [ ! -d "/workspace/.git" ]; then
  echo "‚úó CRITICAL ERROR: No target git repository found!"
  MISSING_FILES="$MISSING_FILES git-repository"
else
  echo "‚úì Found: target git repository"
fi

# If any files are missing, abort
if [ -n "$MISSING_FILES" ]; then
  echo ""
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo "‚ïë                 WORKSPACE VALIDATION FAILED                  ‚ïë"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo ""
  echo "The following required files are missing:"
  for missing in $MISSING_FILES; do
    case "$missing" in
      "CLAUDE.md")
        echo "  ‚ùå $missing - Main task instructions for Claude"
        ;;
      "git-repository")
        echo "  ‚ùå $missing - Required for committing documentation changes"
        ;;
      *)
        echo "  ‚ùå $missing"
        ;;
    esac
  done
  echo ""
  echo "These files should have been created by the ConfigMap setup process."
  echo "Claude will NOT be started to avoid wasting API credits."
  echo ""
  exit 1
fi

echo "‚úì All required files present. Workspace is valid."

# Create PR branch BEFORE Claude runs (like code jobs)
# This ensures all commits go to the PR branch, not the base branch
# Note: SOURCE_BRANCH is already set from template at line 551
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
RANDOM_ID=$(date +%s | tail -c 6)
PR_BRANCH="docs/{{#if task_id}}task-{{task_id}}{{else}}auto-gen{{/if}}-${TIMESTAMP}-${RANDOM_ID}"

echo "Creating PR branch: $PR_BRANCH"
echo "Target base branch: $SOURCE_BRANCH"
# Create branch from the correct source branch (not current HEAD)
if ! git checkout -b "$PR_BRANCH" "origin/$SOURCE_BRANCH" 2>/dev/null; then
    echo "‚ùå Failed to create PR branch from origin/$SOURCE_BRANCH"
    exit 1
fi
echo "‚úì Created PR branch: $PR_BRANCH (from origin/$SOURCE_BRANCH)"

# Export for use by auto-save hook and later PR creation
export DOCS_AUTO_SAVE_BRANCH="$PR_BRANCH"
export SOURCE_BRANCH

# Claude execution
echo "Starting Claude execution (stream-json)..."

# Ensure Claude runs from workspace root for proper MCP scope resolution
cd "$TASK_WORKSPACE"
echo "üîç DEBUG: Launching Claude from directory: $(pwd)"

# Check if system prompt file exists and add to command if available
CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Add MCP configuration if available
if [ -f "/workspace/.mcp.json" ]; then
    echo "‚úì Adding MCP configuration from /workspace/.mcp.json to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --mcp-config /workspace/.mcp.json"
    echo "üîç DEBUG: MCP file check: FOUND at $(pwd)/.mcp.json"
elif [ -f "/workspace/docs/.mcp.json" ]; then
    echo "‚úì Adding MCP configuration from /workspace/docs/.mcp.json to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --mcp-config /workspace/docs/.mcp.json"
else
    echo "‚ö†Ô∏è No MCP configuration file found, MCP servers will not be available"
    echo "üîç DEBUG: MCP file check: MISSING at $(pwd)/.mcp.json"
fi

# DEBUG: Print MCP_CLIENT_CONFIG for troubleshooting client config issues
echo "üîç DEBUG: MCP_CLIENT_CONFIG is set to: '$MCP_CLIENT_CONFIG'"
if [ -f "$MCP_CLIENT_CONFIG" ]; then
    echo "üîç DEBUG: MCP_CLIENT_CONFIG file exists and is readable"
    echo "üîç DEBUG: First few lines of client config:"
    head -10 "$MCP_CLIENT_CONFIG" 2>/dev/null || echo "Could not read client config file"
else
    echo "üîç DEBUG: MCP_CLIENT_CONFIG file does NOT exist or is not readable"
fi
echo ""

# Look for agent-specific system prompt file from agents ConfigMap
# The system prompt should be in the agents ConfigMap if configured
if [ -f "/config/agents/{{github_app}}_system-prompt.md" ]; then
    echo "‚úì Found system prompt file for {{github_app}}, adding to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /config/agents/{{github_app}}_system-prompt.md"
    if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
        echo "[DEBUG] System prompt path: /config/agents/{{github_app}}_system-prompt.md"
        echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "/config/agents/{{github_app}}_system-prompt.md" | sed 's/^/[DEBUG] /'
        echo "[DEBUG] ----"
    fi
elif [ -f "/task-files/{{github_app}}_system-prompt.md" ]; then
    # Fallback to task-files if included inline
    echo "‚úì Found system prompt in task ConfigMap for {{github_app}}"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /task-files/{{github_app}}_system-prompt.md"
    if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
        echo "[DEBUG] System prompt path: /task-files/{{github_app}}_system-prompt.md"
        echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "/task-files/{{github_app}}_system-prompt.md" | sed 's/^/[DEBUG] /'
        echo "[DEBUG] ----"
    fi
else
    echo "‚ÑπÔ∏è No system prompt file found for agent {{github_app}}, using defaults"
fi

# Model is set via settings.json template, not CLI flag

# Change to CLAUDE_WORK_DIR to find prompt.md
cd "$CLAUDE_WORK_DIR"

# Get the initial prompt text (from prompt.md if available, fallback to default)
if [ -f "prompt.md" ]; then
    echo "‚úì Found prompt.md, using as initial prompt"
    INITIAL_TEXT=$(jq -Rs . < "prompt.md")
else
    echo "‚ÑπÔ∏è No prompt.md found, using default documentation generation prompt"
    INITIAL_TEXT=$(jq -Rs . << 'DEFAULT_PROMPT_EOF'
# CRITICAL: Complete Documentation Generation Task

**üö® MANDATORY COMPLETION REQUIREMENT üö®**
You MUST complete ALL steps in this process. Partial completion is not acceptable. This is especially critical for large projects with many tasks.

## Task Overview
Generate comprehensive documentation for **ALL Task Master tasks**.

**If this is a large project with many tasks (10+ tasks), you MUST:**
- Process ALL tasks without stopping
- Show progress updates as you work through each task
- Complete the ENTIRE git workflow including PR creation
- Do NOT stop partway through - finish everything

## Required Process

### Step 1: Context Analysis (REQUIRED)
1. Read CLAUDE.md for project context and standards
2. **Use individual task files:**
   - Individual task files have been pre-copied to `.taskmaster/docs/task-{id}/task.txt`
   - Each `task.txt` contains complete task information including subtasks and implementation details
3. Review architecture.md and prd.txt for context
4. **For large projects: Announce total task count and confirm you will process ALL of them**

**üéØ IMPORTANT: Use individual `task.txt` files for each task**
- Individual task files are available at: `.taskmaster/docs/task-{id}/task.txt`

### Step 2: Documentation Generation (MANDATORY FOR ALL TASKS)
**YOU MUST CREATE DOCUMENTATION FOR EVERY TASK THAT NEEDS IT. DO NOT SKIP ANY INCOMPLETE TASKS.**

For each task that needs documentation (process ALL incomplete tasks, no exceptions):
- `task.md` - Comprehensive task overview and implementation guide
- `prompt.md` - Autonomous prompt for AI agents
- `acceptance-criteria.md` - Clear acceptance criteria and test cases
- `task.xml` - XML-structured prompt optimized for LLM consumption (agent-generated)

## Final Confirmation Required
**YOU MUST END WITH THIS EXACT MESSAGE:**
```
üéâ DOCUMENTATION GENERATION COMPLETE üéâ
‚úÖ Generated documentation for ALL tasks
‚úÖ Created all required documentation files (task.md, prompt.md, acceptance-criteria.md, task.xml)
üìã Total files created: [COUNT]
üîß Generated comprehensive markdown documentation
üîó Git workflow and pull request will be handled automatically by orchestrator hook
```
DEFAULT_PROMPT_EOF
    )
fi

# Return to workspace root for proper MCP resolution
cd "$TASK_WORKSPACE"

# Start Claude with prompt piped directly to stdin (no sidecar, no FIFO)
# Use a subshell to ensure stdin closes after the prompt is sent
echo "‚úì Starting Claude with docs prompt..."
(printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}\n' "$INITIAL_TEXT"; exec 0<&-) | $CLAUDE_CMD &
CLAUDE_PID=$!
echo "‚úì Started Claude (PID: $CLAUDE_PID), stdin will close after prompt"

# Start background token refresh for long-running jobs
(
    while kill -0 $CLAUDE_PID 2>/dev/null; do
        sleep 2700  # Check every 45 minutes

        if [ -n "$TOKEN_GENERATED_AT" ] && [ -n "$GITHUB_APP_PRIVATE_KEY" ]; then
            NOW=$(date +%s)
            TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))

            if [ $TOKEN_AGE -gt 2700 ]; then
                echo "[Background] Token is $(($TOKEN_AGE / 60)) minutes old, refreshing..."
                generate_github_token
            fi
        fi
    done
) &
TOKEN_REFRESH_PID=$!
echo "‚úì Started background token refresh (PID: $TOKEN_REFRESH_PID)"

# Wait for Claude process to complete
wait "$CLAUDE_PID"
CLAUDE_EXIT_CODE=$?
echo "Claude completed with exit code: $CLAUDE_EXIT_CODE"

# Stop token refresh background process
if [ -n "$TOKEN_REFRESH_PID" ]; then
    kill $TOKEN_REFRESH_PID 2>/dev/null || true
    echo "‚úì Stopped token refresh process"
fi

# PR creation
echo "Creating pull request..."

# Ensure we're in the correct working directory for git operations
cd /workspace/{{working_directory}}

# Check for documentation changes (including untracked files)
echo "Checking for documentation changes..."
echo "Current directory: $(pwd)"

# Check for any changes in .taskmaster directory
MODIFIED_DOCS=$(git diff HEAD -- .taskmaster/ 2>/dev/null | wc -l)
STAGED_DOCS=$(git diff --cached HEAD -- .taskmaster/ 2>/dev/null | wc -l)
UNTRACKED_DOCS=$(git ls-files --others --exclude-standard .taskmaster/ 2>/dev/null | wc -l)

echo "Modified files: $MODIFIED_DOCS lines of diff"
echo "Staged files: $STAGED_DOCS lines of diff"
echo "Untracked files: $UNTRACKED_DOCS files"

if [ "$MODIFIED_DOCS" -eq 0 ] && [ "$STAGED_DOCS" -eq 0 ] && [ "$UNTRACKED_DOCS" -eq 0 ]; then
    echo "No documentation changes found in .taskmaster/"
    echo "Checking if .taskmaster exists:"
    ls -la .taskmaster/ 2>/dev/null || echo ".taskmaster directory not found"
    exit 0
fi

echo "‚úì Documentation changes detected, proceeding with PR creation..."

# Verify we're on the PR branch created at the start
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ "$CURRENT_BRANCH" != "$PR_BRANCH" ]; then
    echo "‚ö†Ô∏è Warning: Current branch ($CURRENT_BRANCH) differs from expected PR branch ($PR_BRANCH)"
    echo "Switching back to PR branch..."
    if ! git checkout "$PR_BRANCH"; then
        echo "‚ùå Failed to checkout PR branch"
        exit 1
    fi
fi
echo "‚úì On PR branch: $PR_BRANCH (target: $SOURCE_BRANCH)"

echo "Staging all .taskmaster changes..."
git add .taskmaster/

echo "Checking for uncommitted changes..."
STAGED_FILES=$(git status --porcelain | grep "^[AM]" | wc -l)

if [ "$STAGED_FILES" -gt 0 ]; then
    echo "Showing what will be committed:"
    git status --porcelain

    echo "Committing changes..."
    if ! git commit -m "docs: generate Task Master documentation{{#if task_id}} (task {{task_id}}){{/if}}

- Auto-generated comprehensive task documentation
- Updated task breakdowns and implementation details
- Added acceptance criteria and workflow prompts
- Generated by orchestrator docs agent

ü§ñ Auto-generated by Claude docs agent"; then
        echo "‚ùå Failed to commit changes"
        echo "Git status:"
        git status
        exit 1
    fi
else
    echo "‚úì All changes already committed by auto-save hook"
fi

# Check if we need to push (there might be unpushed commits from hook)
if git rev-list --count origin/"$PR_BRANCH"..HEAD 2>/dev/null | grep -q '^0$'; then
    echo "‚úì Branch already up to date with origin"
else
    echo "Pushing branch..."
    if ! git push -u origin "$PR_BRANCH"; then
        echo "‚ùå Failed to push branch"
        echo "Retrying with verbose output..."
        GIT_CURL_VERBOSE=1 git push -u origin "$PR_BRANCH" 2>&1
        exit 1
    fi
fi

echo "‚úì Branch pushed successfully"

# Create PR
if command -v gh >/dev/null 2>&1; then
    # GitHub CLI should already be authenticated from the beginning of the script

    PR_TITLE="docs: auto-generate Task Master documentation{{#if task_id}} for task {{task_id}}{{/if}}"
    PR_BODY="Auto-generated Task Master documentation by orchestrator container script.

**Working Directory:** {{working_dir}}
**Branch:** \`$PR_BRANCH\` ‚Üí \`$SOURCE_BRANCH\`
**Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
{{#if task_id}}**Target Task:** {{task_id}}{{/if}}

ü§ñ Auto-generated by Container Script"

    # Refresh GitHub token if needed before PR creation
    refresh_token_if_needed

    # Retry PR creation up to 3 times for transient failures
    PR_CREATED=false
    for attempt in 1 2 3; do
        echo "Creating PR (attempt $attempt/3)..."
        if gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base "$SOURCE_BRANCH" --head "$PR_BRANCH"; then
            echo "‚úì Pull request created successfully"
            PR_CREATED=true
            break
        else
            echo "‚ùå PR creation attempt $attempt failed"
            if [ $attempt -lt 3 ]; then
                echo "‚è≥ Waiting 5 seconds before retry..."
                sleep 5
            fi
        fi
    done

    if [ "$PR_CREATED" = false ]; then
        echo "‚ùå Failed to create pull request after 3 attempts"
        echo "‚ö†Ô∏è Branch has been pushed, but PR creation failed"
        # Extract owner/repo from repository URL
        REPO_PATH=$(echo "{{repository_url}}" | sed -E 's|https://github.com/||' | sed 's|\.git$||')
        echo "üí° You can manually create a PR at: https://github.com/$REPO_PATH/pull/new/$PR_BRANCH"
        exit 1
    fi
else
    echo "‚ö†Ô∏è GitHub CLI not available - create PR manually"
fi

echo "Documentation generation completed successfully!"
