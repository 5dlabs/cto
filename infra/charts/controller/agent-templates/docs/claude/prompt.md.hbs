# CRITICAL: Complete Documentation Generation Task

{{!-- Safety toggle: set to false to run safe test mode --}}
{{#unless (eq "false" "true")}}

**üö® MANDATORY COMPLETION REQUIREMENT üö®**
You must finish every step below for each task that still needs documentation. Partial completion is not acceptable.

## Task Overview
Generate complete documentation for {{#if task_id}}task {{task_id}}{{else}}every Task Master task that is missing required files{{/if}}. For large projects (10+ tasks) announce total scope, provide progress updates after every 5 tasks, and keep working until all incomplete tasks are covered.

## Step 0: MCP Tool Discovery and Usage Plan (Required)
- List the available MCP tools/servers (for example via `tools/list`).
- Draft a short plan mapping tools to actions during documentation:
  - `filesystem`: open precise source files, capture accurate APIs, note file paths.
  - `git`: gather commit history or rationale when it clarifies intent.
  - `rustdocs_query_rust_docs`: quote authoritative Rust API snippets with identifiers.
  - `brave_web_search`: pull external standards/examples only when local sources are insufficient.
- Execute this plan throughout all later steps.

## Step 1: Context Analysis
1. Read `CLAUDE.md` for project conventions.
2. Use individual task files at `.taskmaster/docs/task-{id}/task.txt`; each contains the full task brief.
3. Review `.taskmaster/docs/architecture.md` and `.taskmaster/docs/prd.txt` for system context.
{{#if include_codebase}}
4. Read `.taskmaster/docs/codebase.md` to understand the current implementation, reuse patterns, and note deltas required by upcoming tasks.
{{/if}}

## Step 2: Determine Workload
Before starting any task, check whether all four required artifacts already exist with substantial content:
- `task.md`
- `prompt.md`
- `acceptance-criteria.md`
- `task.xml`

If every file is present and meaningful, skip that task. Otherwise, process it fully. Announce each task when you begin ("üìù Processing Task [ID]: [Title]") and confirm when done ("‚úÖ Completed Task [ID]").

## Step 3: Produce Documentation (Per Task)
Create or update all four deliverables inside `.taskmaster/docs/task-{id}/`:

### 3.1 `task.md`
- Summarize objectives, context, dependencies, and implementation plan.
- Reference specific source files or modules (‚â§30 line excerpts) discovered via MCP tools.
- Highlight architectural considerations and risks.

### 3.2 `prompt.md`
- Craft a standalone agent prompt that captures task intent, constraints, available tools, and success definition.
- Keep instructions concise and action-oriented so future agents can execute autonomously.

### 3.3 `acceptance-criteria.md`
- List clear, testable criteria (bulleted).
- Include manual/automated validation steps and relevant commands.

### 3.4 `task.xml`
- Generate the XML prompt using the structure below. Populate every element with task-specific information.
```xml
<prompt>
    <role>You are a senior coding agent specializing in [technology stack from task].</role>
    <task>
        <id>[Task ID]</id>
        <title>[Task Title]</title>
        <description>[Complete task description]</description>
        <priority>[high|medium|low]</priority>
        <status>[pending|in-progress|done]</status>
        <dependencies>[comma-separated dependency IDs]</dependencies>
    </task>
    <technical_specifications>
        <spec>[Technical requirement]</spec>
    </technical_specifications>
    <implementation_details>
        [Detailed implementation guidance from task.txt and analysis]
    </implementation_details>
    <acceptance_criteria>
        <criterion>[Acceptance criterion]</criterion>
    </acceptance_criteria>
    <test_strategy>
        [Testing approach and required commands]
    </test_strategy>
    <instructions>
        Think step-by-step, follow existing patterns, include necessary imports, error handling, and tests. Apply insights gathered via MCP tools to ensure correctness.
    </instructions>
</prompt>
```

### 3.5 Diagrams (When Helpful)
- If a task benefits from visualisation, create `.taskmaster/docs/task-{id}/diagrams.mmd` with Mermaid definitions (one file per task).
- Optionally render assets alongside the source, e.g. `mmdc -i diagrams.mmd -o diagrams.svg` or `.png`.
- Keep diagram notes concise and reference them from `task.md` where appropriate.

### 3.6 Reflection Checkpoint (After Each Task)
Immediately after finishing the required outputs (including diagrams if created):
1. Review the artifacts you just produced.
2. Note at least one improvement or insight to apply on the next task (e.g., missing code reference, unclear criteria).
3. State how you will adjust before beginning the next task and follow through.

## Step 4: Create Integration Tasks for Parallel Execution Levels

**Purpose:** When tasks can run in parallel, we need integration validation between levels to ensure they work together.

### 4.1 Analyze Dependency Graph
1. Read `.taskmaster/tasks/tasks.json`
2. Build dependency graph to identify execution levels:
   - **Level 0:** Tasks with no dependencies
   - **Level 1:** Tasks depending only on Level 0 tasks
   - **Level 2:** Tasks depending on Level 0 or 1 tasks
   - Etc.

3. Identify levels needing integration tasks:
   - **Rule:** If a level has 2+ tasks, create an integration task after it
   - **Single task levels:** Skip integration (nothing to integrate)

**Example Analysis:**
```
Given tasks.json:
- Task 1 (deps: []) ‚Üí Level 0
- Task 2 (deps: []) ‚Üí Level 0
- Task 3 (deps: []) ‚Üí Level 0
- Task 4 (deps: [1,2,3]) ‚Üí Level 1

Result:
- Level 0: [1,2,3] ‚Üê 3 parallel tasks, CREATE integration task
- Level 1: [4] ‚Üê 1 task, SKIP integration
```

### 4.2 Create Integration Tasks

For EACH level with 2+ tasks:

**Step A: Determine Integration Task ID**
- Use next available ID after the level's tasks
- Example: If level has tasks 1,2,3, integration task is 4

**Step B: Copy and customize templates**
```bash
INTEGRATION_ID=[next_available_id]
LEVEL_INDEX=[level_number]
LEVEL_TASKS=[comma_separated_task_ids]

# Copy templates
cp -r /agent-templates/docs/templates/integration-task .taskmaster/docs/task-$INTEGRATION_ID/

# Update placeholders in all files
sed -i "s/LEVEL_INDEX/$LEVEL_INDEX/g" .taskmaster/docs/task-$INTEGRATION_ID/*.md
sed -i "s/TASK_LIST_PLACEHOLDER/$LEVEL_TASKS/g" .taskmaster/docs/task-$INTEGRATION_ID/*.md
```

**Step C: Add to tasks.json**
Insert integration task into tasks.json at appropriate position:
```json
{
  "id": INTEGRATION_ID,
  "title": "Integration - Level LEVEL_INDEX",
  "description": "Validate that tasks LEVEL_TASKS integrate correctly before proceeding to next level",
  "status": "pending",
  "dependencies": [LEVEL_TASKS],
  "priority": "high",
  "agentHint": "integration",
  "details": "Integration validation for execution level LEVEL_INDEX",
  "testStrategy": "Run full test suite with integrated code, verify no conflicts, validate build succeeds"
}
```

**Step D: Update dependent tasks**
- Tasks in the NEXT level should now depend on the integration task
- Example: If Task 4 depended on [1,2,3], update to depend on [integration_task_id]

### 4.3 Create Final Integration Task (Always)
After all levels and their integration tasks, create ONE final integration task:
- ID: highest task ID + 1
- Depends on: ALL previous tasks (including level integration tasks)
- Purpose: End-to-end system validation

```json
{
  "id": FINAL_ID,
  "title": "Final Integration & Deployment Verification",
  "description": "End-to-end system validation and deployment readiness verification",
  "status": "pending",
  "dependencies": [ALL_TASK_IDS],
  "priority": "critical",
  "agentHint": "integration",
  "details": "Final integration validation - see .taskmaster/docs/task-[FINAL_ID]/",
  "testStrategy": "Complete system integration tests, deployment validation, smoke tests"
}
```

### 4.4 Verify All Integration Tasks
- [ ] Integration task created for each level with 2+ tasks
- [ ] Final integration task created depending on ALL tasks
- [ ] Dependencies updated correctly
- [ ] All template files exist and are customized
- [ ] `agentHint` set to "integration" for all integration tasks

## Step 5: Completion and Handoff
- Do **not** run git commands; the orchestrator handles branch, commit, push, and PR creation (`docs-gen-{{source_branch}}`).
- When all tasks (including integration task) are complete, confirm: "‚úÖ DOCUMENTATION FILES GENERATED - Hook will handle git workflow and PR creation".

## Quality and Error Handling
- Ensure documents are technically accurate, well-formatted, and consistent.
- Include targeted code snippets, links, and references derived from MCP tools.
- If any step fails, report the issue, fix it, and continue until resolved.

## Final Confirmation (Mandatory)
End with exactly:
```
üéâ DOCUMENTATION GENERATION COMPLETE üéâ
‚úÖ Generated documentation for {{#if task_id}}task {{task_id}}{{else}}ALL tasks{{/if}}
‚úÖ Created all required documentation files (task.md, prompt.md, acceptance-criteria.md, task.xml)
‚úÖ Created [X] integration tasks for parallel execution levels
‚úÖ Created final integration & deployment verification task
üìã Total tasks documented: [COUNT] (including integration tasks)
üìã Integration tasks created for levels with 2+ parallel tasks
üìã Total files created: [FILE_COUNT]
üîß Generated comprehensive markdown documentation
üîó Git workflow and pull request will be handled automatically by orchestrator hook
```

If you cannot provide this message, continue working until you can.

{{else}}

## Safe Test Mode

What time is it? Please answer this simple question and exit immediately.

{{/unless}}
