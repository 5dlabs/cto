#!/bin/sh
# Factory PR Remediation - Rex
# Executes PR remediation tasks triggered by review findings
# Spawned via CodeRun CRD when users click "remediate" or when Rex is triggered to fix issues

set -e

echo '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'
echo '‚ïë           REX PR REMEDIATION (FACTORY) STARTING              ‚ïë'
echo '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'
echo "üéØ Agent: {{github_app}}"
echo "üî¢ PR Number: {{pr_number}}"
echo "üìÇ Repository: {{repository_url}}"
echo "üìù Head SHA: {{head_sha}}"
{{#if task_id}}
echo "üìã Task ID: {{task_id}}"
{{/if}}

# Source common utilities if available
if [ -f /workspace/scripts/lib/common.sh ]; then
    . /workspace/scripts/lib/common.sh
fi

# Set up environment
export REPOSITORY_URL="{{repository_url}}"
export PR_NUMBER="{{pr_number}}"
export HEAD_SHA="{{head_sha}}"
export REPO_SLUG="{{repo_slug}}"

echo "üì¶ Repository: $REPO_SLUG"

# Pre-flight: Check for required tools
# jq is critical for parsing CI alerts and review findings
if ! command -v jq >/dev/null 2>&1; then
    echo "‚ö†Ô∏è Warning: jq not found - CI alert parsing will be limited"
    echo "   Remediation will proceed but may miss exact file:line context"
fi

# Always fetch CI alerts for remediation context
echo ""
echo "üìä Fetching CI alerts for remediation context..."
if command -v utils >/dev/null 2>&1; then
    utils alerts --repo "$REPO_SLUG" --pr "$PR_NUMBER" --format json > /tmp/ci-alerts.json 2>/dev/null || echo "[]" > /tmp/ci-alerts.json
    
    # Count and analyze alerts
    if command -v jq >/dev/null 2>&1 && [ -s /tmp/ci-alerts.json ]; then
        FAILURE_COUNT=$(jq '[.[] | select(.annotation_level == "failure")] | length' /tmp/ci-alerts.json 2>/dev/null || echo "0")
        WARNING_COUNT=$(jq '[.[] | select(.annotation_level == "warning")] | length' /tmp/ci-alerts.json 2>/dev/null || echo "0")
        export CI_ALERTS_FILE="/tmp/ci-alerts.json"
        export CI_FAILURE_COUNT="$FAILURE_COUNT"
        export CI_WARNING_COUNT="$WARNING_COUNT"
        
        if [ "$FAILURE_COUNT" -gt 0 ]; then
            echo "üî¥ Found $FAILURE_COUNT CI error(s), $WARNING_COUNT warning(s)"
            echo "   ‚Üí These will be included in remediation targets"
            
            # Show a preview of what needs to be fixed
            echo ""
            echo "üìç Files requiring fixes:"
            jq -r '.[] | select(.annotation_level == "failure") | "   - \(.path):\(.start_line) - \(.message | split("\n")[0])"' /tmp/ci-alerts.json 2>/dev/null | head -10
        elif [ "$WARNING_COUNT" -gt 0 ]; then
            echo "üü° Found $WARNING_COUNT CI warning(s)"
        else
            echo "‚úÖ No CI failures detected"
        fi
    else
        echo "‚ö†Ô∏è Could not parse CI alerts (jq not available)"
    fi
else
    echo "‚ö†Ô∏è utils binary not available, skipping CI alert fetch"
fi

# Check for review findings to remediate (from Stitch)
{{#if findings_path}}
echo ""
echo "üìã Remediating findings from: {{findings_path}}"
if [ -f "{{findings_path}}" ]; then
    export FINDINGS_FILE="{{findings_path}}"
    echo "‚úÖ Findings file found"
else
    echo "‚ö†Ô∏è Findings file not found at {{findings_path}}"
fi
{{/if}}

# If no findings file but we have CI alerts, use those as findings
if [ -z "$FINDINGS_FILE" ] && [ -f "$CI_ALERTS_FILE" ] && [ "$CI_FAILURE_COUNT" -gt 0 ]; then
    # Convert CI alerts to findings format for Rex
    echo ""
    echo "üîÑ Converting CI alerts to findings format..."
    jq '[.[] | select(.annotation_level == "failure" or .annotation_level == "warning") | {
        severity: (if .annotation_level == "failure" then "critical" else "suggestion" end),
        file: .path,
        start_line: .start_line,
        end_line: .end_line,
        title: ("CI: " + (.message | split("\n")[0] | .[0:80])),
        description: .message
    }]' /tmp/ci-alerts.json > /tmp/findings.json 2>/dev/null || echo "[]" > /tmp/findings.json
    export FINDINGS_FILE="/tmp/findings.json"
    echo "‚úÖ Created findings file with $CI_FAILURE_COUNT CI failures"
fi

# Check for review comment context
{{#if review_comment_id}}
echo ""
echo "üí¨ Triggered by review comment: {{review_comment_id}}"
export REVIEW_COMMENT_ID="{{review_comment_id}}"
{{/if}}

# Load agent prompt
AGENT_PROMPT="/task-files/agents.md"
if [ ! -f "${AGENT_PROMPT}" ]; then
    echo "‚ùå Agent prompt not found at ${AGENT_PROMPT}"
    echo ""
    echo "This usually means the agent-templates ConfigMap is not properly mounted."
    echo "Please verify:"
    echo "  1. The cto-controller-agent-templates-factory ConfigMap exists"
    echo "  2. The ConfigMap contains remediate_factory_agents.md.hbs"
    echo "  3. The volume mount is configured correctly in the CodeRun spec"
    exit 1
fi

echo ""
echo "üöÄ Starting Factory CLI (droid exec)..."
echo ""

# Run Factory with the remediation agent prompt
exec droid exec \
    --auto high \
    --model "{{model}}" \
    --output-format stream-json \
    "$(cat ${AGENT_PROMPT})"
