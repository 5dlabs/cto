#!/bin/bash
set -euo pipefail

# Morgan Project Manager - GitHub Projects Integration
# Runs as a daemon throughout the Play workflow lifecycle
# Manages GitHub Project, Issues, and synchronizes with TaskMaster

echo "üéØ MORGAN - Project Manager Mode"
echo "Repository: {{repository_url}}"
echo "Workflow: $WORKFLOW_NAME"
echo "Namespace: $NAMESPACE"

# ============================================================================
# GITHUB APP AUTHENTICATION
# ============================================================================

echo "üîê Authenticating with GitHub App..."

if [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ] && [ -n "${GITHUB_APP_ID:-}" ]; then
    # Create temporary key file
    TEMP_KEY_FILE="/tmp/github-app-key-$$"
    echo "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"

    # Generate JWT token for GitHub App authentication
    JWT_TOKEN=$(ruby -r openssl -r json -r base64 -e "
    key = OpenSSL::PKey::RSA.new(File.read('$TEMP_KEY_FILE'))
    payload = {
        iat: Time.now.to_i - 60,
        exp: Time.now.to_i + (10 * 60),
        iss: '$GITHUB_APP_ID'
    }
    header = { alg: 'RS256', typ: 'JWT' }

    header_enc = Base64.urlsafe_encode64(header.to_json).gsub('=', '')
    payload_enc = Base64.urlsafe_encode64(payload.to_json).gsub('=', '')
    signature = Base64.urlsafe_encode64(key.sign(OpenSSL::Digest::SHA256.new, \"#{header_enc}.#{payload_enc}\")).gsub('=', '')

    puts \"#{header_enc}.#{payload_enc}.#{signature}\"
    ")

    echo "‚úì Generated JWT token"

    # Parse repository info early
    REPO_URL="{{repository_url}}"
    
    # Handle both full URL and short format (owner/repo)
    if [[ "$REPO_URL" =~ github\.com[:/]([^/]+)/([^/\.]+)(\.git)?$ ]]; then
        # Full URL format: https://github.com/owner/repo or git@github.com:owner/repo.git
        REPO_OWNER="${BASH_REMATCH[1]}"
        REPO_NAME="${BASH_REMATCH[2]}"
    elif [[ "$REPO_URL" =~ ^([^/]+)/([^/]+)$ ]]; then
        # Short format: owner/repo (allows dots in repo name)
        REPO_OWNER="${BASH_REMATCH[1]}"
        REPO_NAME="${BASH_REMATCH[2]}"
    else
        echo "‚ùå Failed to parse repository URL: $REPO_URL"
        echo "Expected formats: 'owner/repo' or 'https://github.com/owner/repo'"
        exit 1
    fi

    # Get installation ID for the repository
    INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    # If repo installation failed, try organization installation
    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "‚ö†Ô∏è  No repo installation, trying organization..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "‚ùå Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response: $INSTALLATION_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    echo "‚úì Installation ID: $INSTALLATION_ID"

    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "‚ùå Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"

    # Export the token for git and gh CLI
    export GITHUB_TOKEN

    # Configure git to use the token
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials

    # Note: gh CLI will automatically use GITHUB_TOKEN env var
    # No explicit auth login needed

    echo "‚úÖ GitHub App authenticated successfully"

    # Configure git safe directories
    git config --global --add safe.directory /workspace
    git config --global --add safe.directory /tmp/docs-repo

else
    echo "‚ùå GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
    exit 1
fi

# ============================================================================
# CONFIGURATION
# ============================================================================

echo "üîç DEBUG: Configuration"
echo "  DOCS_REPOSITORY: ${DOCS_REPOSITORY:-NOT SET}"
echo "  DOCS_BRANCH: ${DOCS_BRANCH:-NOT SET}"
echo "  DOCS_PROJECT_DIRECTORY: ${DOCS_PROJECT_DIRECTORY:-NOT SET}"
echo "  SERVICE_NAME: ${SERVICE_NAME:-NOT SET}"

# Normalize DOCS_REPOSITORY to full URL if needed
DOCS_REPO_INPUT="${DOCS_REPOSITORY}"
if [[ "$DOCS_REPO_INPUT" =~ ^https?:// ]] || [[ "$DOCS_REPO_INPUT" =~ ^git@ ]]; then
    # Already a full URL
    DOCS_REPO="$DOCS_REPO_INPUT"
else
    # Short format (owner/repo) - convert to HTTPS URL
    DOCS_REPO="https://github.com/$DOCS_REPO_INPUT"
fi

DOCS_BRANCH="${DOCS_BRANCH:-main}"
DOCS_DIR="${DOCS_PROJECT_DIRECTORY}"
SERVICE_NAME="${SERVICE_NAME}"

echo "üîç DEBUG: Normalized DOCS_REPO to: $DOCS_REPO"

# Shared state directory
SHARED_DIR="/shared/morgan-pm"
mkdir -p "$SHARED_DIR"

TASK_ISSUE_MAP="$SHARED_DIR/task-issue-map.json"
PROJECT_CONFIG="$SHARED_DIR/project-config.json"
SYNC_LOG="$SHARED_DIR/sync.log"

echo "üîç DEBUG: Sourcing helper functions..."
# Source helper functions
source /workspace/github-projects-helpers.sh || {
  echo "‚ùå Failed to source github-projects-helpers.sh"
  exit 1
}

echo "üì¶ Repository: $REPO_OWNER/$REPO_NAME"
echo "üîç DEBUG: Starting initialization..."

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

log() {
  echo "[$(date -u +"%Y-%m-%d %H:%M:%S UTC")] $*" | tee -a "$SYNC_LOG"
}

# ============================================================================
# PHASE 1: INITIALIZATION
# ============================================================================

initialize_project() {
  echo "üîç DEBUG: Entered initialize_project()"
  log "üìä Phase 1: Project Initialization"
  
  # Clone docs repository to get TaskMaster data
  log "üì• Cloning documentation repository..."
  echo "üîç DEBUG: DOCS_REPO=$DOCS_REPO, DOCS_BRANCH=$DOCS_BRANCH"
  TEMP_CLONE="/tmp/docs-repo"
  rm -rf "$TEMP_CLONE"
  
  echo "üîç DEBUG: About to git clone..."
  git clone --depth 1 --branch "$DOCS_BRANCH" "$DOCS_REPO" "$TEMP_CLONE" || {
    log "‚ùå Failed to clone docs repository"
    echo "‚ùå DEBUG: Git clone failed with exit code $?"
    exit 1
  }
  echo "üîç DEBUG: Git clone succeeded"
  
  cd "$TEMP_CLONE/$DOCS_DIR"
  
  # Find tasks.json
  TASKS_JSON_PATH=""
  if [[ -f ".taskmaster/tasks/tasks.json" ]]; then
    TASKS_JSON_PATH=".taskmaster/tasks/tasks.json"
  elif [[ -f ".taskmaster/docs/tasks.json" ]]; then
    TASKS_JSON_PATH=".taskmaster/docs/tasks.json"
  else
    log "‚ùå TaskMaster tasks.json not found"
    exit 1
  fi
  
  log "‚úÖ Found tasks.json at: $TASKS_JSON_PATH"
  
  # Read tasks data
  TASKS_DATA=$(cat "$TASKS_JSON_PATH")
  
  # Get or create GitHub Project
  log "üèóÔ∏è  Setting up GitHub Project..."
  
  PROJECT_TITLE="$SERVICE_NAME - TaskMaster Workflow"
  PROJECT_ID=$(get_or_create_project "$REPO_OWNER" "$PROJECT_TITLE")
  
  if [[ -z "$PROJECT_ID" ]]; then
    log "‚ùå Failed to create or find project"
    exit 1
  fi
  
  log "‚úÖ Project ID: $PROJECT_ID"
  
  # Setup custom fields
  log "üîß Setting up custom fields..."
  setup_custom_fields "$PROJECT_ID"
  
  # Store project configuration
  cat > "$PROJECT_CONFIG" <<EOF
{
  "project_id": "$PROJECT_ID",
  "project_title": "$PROJECT_TITLE",
  "workflow_name": "$WORKFLOW_NAME",
  "repository": "$REPO_OWNER/$REPO_NAME",
  "created_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
}
EOF
  
  log "‚úÖ Project initialization complete"
}

# ============================================================================
# PHASE 2: ISSUE CREATION
# ============================================================================

create_task_issues() {
  log "üìù Phase 2: Creating Issues for Tasks"
  
  cd "$TEMP_CLONE/$DOCS_DIR"
  
  # Initialize task-issue mapping
  echo "{}" > "$TASK_ISSUE_MAP"
  
  # Get master/default tag tasks (or all tasks if no tags)
  TASKS=$(echo "$TASKS_DATA" | jq -c '.tasks // .master.tasks // []')
  
  if [[ "$TASKS" == "[]" ]] || [[ "$TASKS" == "null" ]]; then
    log "‚ö†Ô∏è  No tasks found in tasks.json"
    return 0
  fi
  
  TASK_COUNT=$(echo "$TASKS" | jq '. | length')
  log "üìä Found $TASK_COUNT tasks to create issues for"
  
  echo "$TASKS" | jq -c '.[]' | while read -r task; do
    TASK_ID=$(echo "$task" | jq -r '.id')
    TASK_TITLE=$(echo "$task" | jq -r '.title')
    TASK_STATUS=$(echo "$task" | jq -r '.status // "pending"')
    TASK_PRIORITY=$(echo "$task" | jq -r '.priority // "medium"')
    
    log "üìå Creating issue for Task $TASK_ID: $TASK_TITLE"
    
    # Generate issue body from task details
    ISSUE_BODY=$(generate_issue_body "$task" "$TASKS_JSON_PATH")
    
    # Create GitHub issue with workflow-specific labels
    ISSUE_NUMBER=$(gh issue create \
      --repo "$REPO_OWNER/$REPO_NAME" \
      --title "Task $TASK_ID: $TASK_TITLE" \
      --body "$ISSUE_BODY" \
      --label "taskmaster-task,task-$TASK_ID,priority-$TASK_PRIORITY,status-$TASK_STATUS,workflow-$WORKFLOW_NAME" \
      2>/dev/null | grep -oP '\d+$' || echo "")
    
    if [[ -z "$ISSUE_NUMBER" ]]; then
      log "‚ö†Ô∏è  Failed to create issue for task $TASK_ID, skipping..."
      continue
    fi
    
    log "‚úÖ Created issue #$ISSUE_NUMBER for task $TASK_ID"
    
    # Get issue node ID for GraphQL
    ISSUE_NODE_ID=$(gh issue view "$ISSUE_NUMBER" \
      --repo "$REPO_OWNER/$REPO_NAME" \
      --json id --jq '.id')
    
    # Add issue to project
    PROJECT_ID=$(jq -r '.project_id' "$PROJECT_CONFIG")
    ITEM_ID=$(add_issue_to_project "$PROJECT_ID" "$ISSUE_NODE_ID")
    
    if [[ -n "$ITEM_ID" ]]; then
      log "‚úÖ Added issue #$ISSUE_NUMBER to project (Item ID: $ITEM_ID)"
      
      # Set initial field values
      set_project_item_status "$PROJECT_ID" "$ITEM_ID" "$TASK_STATUS"
      set_project_item_priority "$PROJECT_ID" "$ITEM_ID" "$TASK_PRIORITY"
      set_project_item_agent "$PROJECT_ID" "$ITEM_ID" "Pending"
      
      # Store mapping
      TEMP_MAP=$(mktemp)
      jq --arg task_id "$TASK_ID" \
         --arg issue_num "$ISSUE_NUMBER" \
         --arg item_id "$ITEM_ID" \
         --arg node_id "$ISSUE_NODE_ID" \
         '.[$task_id] = {
           "issue_number": ($issue_num | tonumber),
           "item_id": $item_id,
           "node_id": $node_id
         }' "$TASK_ISSUE_MAP" > "$TEMP_MAP"
      mv "$TEMP_MAP" "$TASK_ISSUE_MAP"
    fi
  done
  
  CREATED_COUNT=$(jq 'length' "$TASK_ISSUE_MAP")
  log "‚úÖ Created $CREATED_COUNT issues and added to project"
}

# ============================================================================
# PHASE 3: CONTINUOUS MONITORING (EVENT-DRIVEN)
# ============================================================================

monitor_and_sync() {
  log "üëÄ Phase 3: Event-Driven Monitoring & Synchronization"
  log "üîÑ Starting real-time workflow watch..."
  
  PROJECT_ID=$(jq -r '.project_id' "$PROJECT_CONFIG")
  
  # Initial sync of all tasks
  log "üìä Performing initial sync..."
  sync_all_tasks "$PROJECT_ID"
  
  # Background process to watch parent workflow
  watch_parent_workflow &
  PARENT_WATCH_PID=$!
  
  # Main event loop: Watch all task workflows
  log "üëÅÔ∏è  Watching for workflow changes (real-time)..."
  kubectl get workflows -n "$NAMESPACE" \
    -l "parent-workflow=$WORKFLOW_NAME" \
    --watch -o json 2>/dev/null | \
  while read -r event_line; do
    # Skip empty lines
    [[ -z "$event_line" ]] && continue
    
    # Parse event
    EVENT_TYPE=$(echo "$event_line" | jq -r '.type // "UNKNOWN"')
    WORKFLOW_OBJ=$(echo "$event_line" | jq -r '.object // {}')
    
    # Extract workflow details
    TASK_ID=$(echo "$WORKFLOW_OBJ" | jq -r '.metadata.labels["task-id"] // ""')
    WORKFLOW_NAME_LOCAL=$(echo "$WORKFLOW_OBJ" | jq -r '.metadata.name // ""')
    CURRENT_STAGE=$(echo "$WORKFLOW_OBJ" | jq -r '.metadata.labels["current-stage"] // "pending"')
    WORKFLOW_PHASE=$(echo "$WORKFLOW_OBJ" | jq -r '.status.phase // "Pending"')
    
    [[ -z "$TASK_ID" ]] && continue
    
    log "üì° Event: $EVENT_TYPE for task-$TASK_ID (stage=$CURRENT_STAGE, phase=$WORKFLOW_PHASE)"
    
    # Update GitHub for this specific task
    handle_task_event "$PROJECT_ID" "$TASK_ID" "$WORKFLOW_NAME_LOCAL" "$CURRENT_STAGE" "$WORKFLOW_PHASE"
  done
  
  # Cleanup
  kill $PARENT_WATCH_PID 2>/dev/null || true
  
  log "üéâ Monitoring complete"
}

watch_parent_workflow() {
  # Watch parent workflow in background
  while true; do
    WORKFLOW_STATUS=$(kubectl get workflow "$WORKFLOW_NAME" \
      -n "$NAMESPACE" \
      -o jsonpath='{.status.phase}' 2>/dev/null || echo "NotFound")
    
    if [[ "$WORKFLOW_STATUS" == "Succeeded" ]] || [[ "$WORKFLOW_STATUS" == "Failed" ]] || [[ "$WORKFLOW_STATUS" == "Error" ]]; then
      log "‚úÖ Parent workflow completed with status: $WORKFLOW_STATUS"
      
      # Trigger final sync
      PROJECT_ID=$(jq -r '.project_id' "$PROJECT_CONFIG")
      sync_all_tasks "$PROJECT_ID"
      
      # Kill main watch process
      pkill -P $$ kubectl || true
      exit 0
    fi
    
    sleep 10
  done
}

handle_task_event() {
  local project_id="$1"
  local task_id="$2"
  local workflow_name="$3"
  local current_stage="$4"
  local workflow_phase="$5"
  
  # Get issue details from mapping
  local entry=$(jq -r --arg tid "$task_id" '.[$tid] // empty' "$TASK_ISSUE_MAP")
  [[ -z "$entry" ]] && return 0
  
  local issue_number=$(echo "$entry" | jq -r '.issue_number')
  local item_id=$(echo "$entry" | jq -r '.item_id')
  
  # Map stage to agent and status
  local current_agent=$(map_stage_to_agent "$current_stage" "$workflow_phase")
  local task_status=$(map_workflow_to_status "$current_stage" "$workflow_phase")
  
  log "üîÑ Updating task-$task_id: $current_agent | $task_status"
  
  # Update project item
  set_project_item_status "$project_id" "$item_id" "$task_status"
  set_project_item_agent "$project_id" "$item_id" "$current_agent"
  
  # Update issue labels
  update_issue_labels "$issue_number" "$task_status" "$current_agent"
  
  # NEW: Add structured status history
  add_status_history "$issue_number" "$task_id" "$current_stage" "$current_agent" "$task_status" "$workflow_phase"
  
  # NEW: Check for errors/failures
  check_task_health "$task_id" "$workflow_name" "$current_stage" "$issue_number"
  
  # NEW: Update heartbeat timestamp
  update_heartbeat "$issue_number"
}

sync_all_tasks() {
  local project_id="$1"
  
  # Iterate through all task mappings
  jq -c 'to_entries[]' "$TASK_ISSUE_MAP" | while read -r entry; do
    TASK_ID=$(echo "$entry" | jq -r '.key')
    ISSUE_NUMBER=$(echo "$entry" | jq -r '.value.issue_number')
    ITEM_ID=$(echo "$entry" | jq -r '.value.item_id')
    
    # Find workflow for this task
    TASK_WORKFLOW=$(kubectl get workflows -n "$NAMESPACE" \
      -l "task-id=$TASK_ID,parent-workflow=$WORKFLOW_NAME" \
      -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
    
    if [[ -z "$TASK_WORKFLOW" ]]; then
      continue
    fi
    
    # Get current stage from workflow labels
    CURRENT_STAGE=$(kubectl get workflow "$TASK_WORKFLOW" \
      -n "$NAMESPACE" \
      -o jsonpath='{.metadata.labels.current-stage}' 2>/dev/null || echo "pending")
    
    # Get workflow phase
    WORKFLOW_PHASE=$(kubectl get workflow "$TASK_WORKFLOW" \
      -n "$NAMESPACE" \
      -o jsonpath='{.status.phase}' 2>/dev/null || echo "Pending")
    
    # Map stage to agent and status
    CURRENT_AGENT=$(map_stage_to_agent "$CURRENT_STAGE" "$WORKFLOW_PHASE")
    TASK_STATUS=$(map_workflow_to_status "$CURRENT_STAGE" "$WORKFLOW_PHASE")
    
    # Update project item
    set_project_item_status "$project_id" "$ITEM_ID" "$TASK_STATUS"
    set_project_item_agent "$project_id" "$ITEM_ID" "$CURRENT_AGENT"
    
    # Update issue labels to reflect current state
    update_issue_labels "$ISSUE_NUMBER" "$TASK_STATUS" "$CURRENT_AGENT"
  done
}

map_stage_to_agent() {
  local stage="$1"
  local phase="$2"
  
  case "$stage" in
    "pending"|"waiting-pr-created")
      echo "Rex (Implementation)"
      ;;
    "implementation"|"implementation-in-progress")
      echo "Rex (Implementation)"
      ;;
    "quality-in-progress"|"waiting-ready-for-qa")
      echo "Cleo (Quality)"
      ;;
    "security-in-progress")
      echo "Cipher (Security)"
      ;;
    "testing-in-progress"|"qa-in-progress")
      echo "Tess (QA)"
      ;;
    "integration-in-progress"|"merging")
      echo "Atlas (Integration)"
      ;;
    "deployment-in-progress"|"deploying")
      echo "Bolt (Deployment)"
      ;;
    "completed"|"done")
      echo "Complete ‚úÖ"
      ;;
    *)
      if [[ "$phase" == "Succeeded" ]]; then
        echo "Complete ‚úÖ"
      else
        echo "In Progress"
      fi
      ;;
  esac
}

map_workflow_to_status() {
  local stage="$1"
  local phase="$2"
  
  case "$phase" in
    "Succeeded")
      echo "Done"
      ;;
    "Failed"|"Error")
      echo "Blocked"
      ;;
    "Running")
      case "$stage" in
        "implementation"*|"pending")
          echo "In Progress"
          ;;
        "quality"*|"security"*|"testing"*)
          echo "In Review"
          ;;
        *)
          echo "In Progress"
          ;;
      esac
      ;;
    *)
      echo "Todo"
      ;;
  esac
}

update_issue_labels() {
  local issue_number="$1"
  local status="$2"
  local agent="$3"
  
  # Remove old status labels
  gh issue edit "$issue_number" \
    --repo "$REPO_OWNER/$REPO_NAME" \
    --remove-label "status-pending,status-in-progress,status-in-review,status-done,status-blocked" \
    2>/dev/null || true
  
  # Add new labels
  local status_label="status-$(echo "$status" | tr '[:upper:] ' '[:lower:]-')"
  gh issue edit "$issue_number" \
    --repo "$REPO_OWNER/$REPO_NAME" \
    --add-label "$status_label" \
    2>/dev/null || true
}

# ============================================================================
# PHASE 1 ENHANCEMENTS: HEALTH CHECKS & STATUS TRACKING
# ============================================================================

add_status_history() {
  local issue_number="$1"
  local task_id="$2"
  local stage="$3"
  local agent="$4"
  local status="$5"
  local phase="$6"
  
  local timestamp=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
  local argo_url="https://argo.5dlabs.com/workflows/agent-platform/$WORKFLOW_NAME"
  
  # Create structured status update comment
  gh issue comment "$issue_number" \
    --repo "$REPO_OWNER/$REPO_NAME" \
    --body "**üìä Status Update**

| Field | Value |
|-------|-------|
| ‚è∞ Time | $timestamp |
| üéØ Stage | \`$stage\` |
| ü§ñ Agent | $agent |
| üìã Status | $status |
| üîÑ Phase | $phase |
| üîó Workflow | [View in Argo]($argo_url) |

---
*Auto-updated by Morgan PM*" 2>/dev/null || true
  
  log "üìù Added status history for task-$task_id"
}

check_task_health() {
  local task_id="$1"
  local workflow_name="$2"
  local current_stage="$3"
  local issue_number="$4"
  
  # Find CodeRun for this task/stage
  local coderun_name=$(kubectl get coderuns -n "$NAMESPACE" \
    -l "task-id=$task_id,workflow-name=$workflow_name" \
    --sort-by=.metadata.creationTimestamp \
    -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo "")
  
  [[ -z "$coderun_name" ]] && return 0
  
  # Check CodeRun status
  local coderun_phase=$(kubectl get coderun "$coderun_name" -n "$NAMESPACE" \
    -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
  
  local coderun_error=$(kubectl get coderun "$coderun_name" -n "$NAMESPACE" \
    -o jsonpath='{.status.error}' 2>/dev/null || echo "")
  
  # Check pod status for more details
  local pod_name=$(kubectl get pods -n "$NAMESPACE" \
    -l "coderun=$coderun_name" \
    -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
  
  local pod_phase=""
  local pod_reason=""
  if [[ -n "$pod_name" ]]; then
    pod_phase=$(kubectl get pod "$pod_name" -n "$NAMESPACE" \
      -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
    pod_reason=$(kubectl get pod "$pod_name" -n "$NAMESPACE" \
      -o jsonpath='{.status.containerStatuses[0].state.waiting.reason}' 2>/dev/null || echo "")
  fi
  
  # Detect problems
  local has_error=false
  local error_message=""
  
  if [[ "$coderun_phase" == "Failed" ]]; then
    has_error=true
    error_message="CodeRun failed: $coderun_error"
  elif [[ "$pod_reason" == "CrashLoopBackOff" ]] || [[ "$pod_reason" == "Error" ]]; then
    has_error=true
    error_message="Agent pod crashed: $pod_reason"
  elif [[ "$pod_phase" == "Failed" ]]; then
    has_error=true
    error_message="Agent pod failed"
  fi
  
  # Report errors to GitHub
  if [[ "$has_error" == true ]]; then
    log "‚ö†Ô∏è  Health check failed for task-$task_id: $error_message"
    
    # Get recent logs for context
    local error_logs=""
    if [[ -n "$pod_name" ]]; then
      error_logs=$(kubectl logs "$pod_name" -n "$NAMESPACE" --tail=20 2>/dev/null || echo "Logs unavailable")
    fi
    
    gh issue comment "$issue_number" \
      --repo "$REPO_OWNER/$REPO_NAME" \
      --body "## ‚ö†Ô∏è Agent Error Detected

**CodeRun:** \`$coderun_name\`  
**Error:** $error_message  
**Time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")

<details>
<summary>Recent Logs (last 20 lines)</summary>

\`\`\`
$error_logs
\`\`\`

</details>

**Next Steps:**
- Review logs above for root cause
- Check if this is a transient issue that will auto-retry
- Manual intervention may be required

---
*Auto-detected by Morgan PM Health Check*" 2>/dev/null || true
  fi
}

update_heartbeat() {
  local issue_number="$1"
  local timestamp=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
  
  # Update or create heartbeat comment
  # Use a unique marker so we can find and update the same comment
  local heartbeat_marker="<!-- morgan-heartbeat -->"
  
  # For now, just track in sync log (avoid spamming issues)
  # Could be enhanced to update a single pinned comment
  echo "$timestamp - Heartbeat for issue #$issue_number" >> "$SYNC_LOG"
}

generate_issue_body() {
  local task="$1"
  local tasks_json_path="$2"
  
  local task_id=$(echo "$task" | jq -r '.id')
  local title=$(echo "$task" | jq -r '.title')
  local description=$(echo "$task" | jq -r '.description // "No description provided"')
  local details=$(echo "$task" | jq -r '.details // "No details provided"')
  local test_strategy=$(echo "$task" | jq -r '.testStrategy // "No test strategy defined"')
  local priority=$(echo "$task" | jq -r '.priority // "medium"')
  local dependencies=$(echo "$task" | jq -r '.dependencies // [] | join(", ")')
  
  cat <<EOF
# Task $task_id: $title

## üìã Description
$description

## üéØ Implementation Details
$details

## üß™ Test Strategy
$test_strategy

## üìä Metadata
- **Priority**: $priority
- **Dependencies**: ${dependencies:-None}
- **Status**: Pending
- **Workflow Run**: \`$WORKFLOW_NAME\`
- **Started**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

---

## üîó Task Master Integration

This issue is automatically synchronized with TaskMaster.

**Task File**: \`$tasks_json_path\`  
**Service**: \`$SERVICE_NAME\`  
**Workflow**: \`$WORKFLOW_NAME\`

### Agent Pipeline
1. **Rex** - Implementation
2. **Cleo** - Code Quality Review
3. **Cipher** - Security Analysis (if enabled)
4. **Tess** - QA Testing
5. **Atlas** - Integration & Merge
6. **Bolt** - Production Deployment

---

## üì° Live Status

This issue is monitored by Morgan PM. Status updates are posted automatically as agents progress through the workflow.

**Current Status**: View the Project board for real-time updates  
**Feedback**: Comment with \`@morgan\` to request scope changes or clarifications

---

*This issue is managed by Morgan (Project Manager) for workflow \`$WORKFLOW_NAME\`.*
EOF
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

main() {
  echo "üîç DEBUG: Entered main() function"
  log "üöÄ Morgan PM starting..."
  
  echo "üîç DEBUG: About to call initialize_project()"
  # Phase 1: Initialize project
  initialize_project
  echo "üîç DEBUG: initialize_project() completed"
  
  # Phase 2: Create issues
  create_task_issues
  
  # Phase 3: Monitor and sync
  echo "üîç DEBUG: About to call monitor_and_sync()"
  monitor_and_sync
  
  log "‚úÖ Morgan PM completed successfully"
  echo "üîç DEBUG: main() function completed"
}

# Trap errors and cleanup
trap 'echo "‚ùå Morgan PM error on line $LINENO: $BASH_COMMAND" >&2; exit 1' ERR

echo "üîç DEBUG: About to call main()..."
# Run main
main

echo "‚úÖ DEBUG: main() completed successfully"



