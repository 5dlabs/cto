#!/bin/bash
set -euo pipefail

# Morgan Project Manager - GitHub Projects Integration
# Runs as a daemon throughout the Play workflow lifecycle
# Manages GitHub Project, Issues, and synchronizes with TaskMaster

echo "üéØ MORGAN - Project Manager Mode"
echo "Repository: {{repository_url}}"
echo "Workflow: $WORKFLOW_NAME"
echo "Namespace: $NAMESPACE"

# ============================================================================
# GITHUB APP AUTHENTICATION
# ============================================================================

echo "üîê Authenticating with GitHub App..."

if [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ] && [ -n "${GITHUB_APP_ID:-}" ]; then
    # Create temporary key file
    TEMP_KEY_FILE="/tmp/github-app-key-$$"
    echo "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"

    # Generate JWT token for GitHub App authentication
    JWT_TOKEN=$(ruby -r openssl -r json -r base64 -e "
    key = OpenSSL::PKey::RSA.new(File.read('$TEMP_KEY_FILE'))
    payload = {
        iat: Time.now.to_i - 60,
        exp: Time.now.to_i + (10 * 60),
        iss: '$GITHUB_APP_ID'
    }
    header = { alg: 'RS256', typ: 'JWT' }

    header_enc = Base64.urlsafe_encode64(header.to_json).gsub('=', '')
    payload_enc = Base64.urlsafe_encode64(payload.to_json).gsub('=', '')
    signature = Base64.urlsafe_encode64(key.sign(OpenSSL::Digest::SHA256.new, \"#{header_enc}.#{payload_enc}\")).gsub('=', '')

    puts \"#{header_enc}.#{payload_enc}.#{signature}\"
    ")

    echo "‚úì Generated JWT token"

    # Parse repository info early
    REPO_URL="{{repository_url}}"
    
    # Handle both full URL and short format (owner/repo)
    if [[ "$REPO_URL" =~ github\.com[:/]([^/]+)/([^/\.]+)(\.git)?$ ]]; then
        # Full URL format: https://github.com/owner/repo or git@github.com:owner/repo.git
        REPO_OWNER="${BASH_REMATCH[1]}"
        REPO_NAME="${BASH_REMATCH[2]}"
    elif [[ "$REPO_URL" =~ ^([^/]+)/([^/]+)$ ]]; then
        # Short format: owner/repo (allows dots in repo name)
        REPO_OWNER="${BASH_REMATCH[1]}"
        REPO_NAME="${BASH_REMATCH[2]}"
    else
        echo "‚ùå Failed to parse repository URL: $REPO_URL"
        echo "Expected formats: 'owner/repo' or 'https://github.com/owner/repo'"
        exit 1
    fi

    # Get installation ID for the repository
    INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    # If repo installation failed, try organization installation
    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "‚ö†Ô∏è  No repo installation, trying organization..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "‚ùå Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response: $INSTALLATION_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    echo "‚úì Installation ID: $INSTALLATION_ID"

    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "‚ùå Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"

    # Export the token for git and gh CLI
    export GITHUB_TOKEN

    # Configure git to use the token
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials

    # Note: gh CLI will automatically use GITHUB_TOKEN env var
    # No explicit auth login needed

    echo "‚úÖ GitHub App authenticated successfully"

    # Configure git safe directories
    git config --global --add safe.directory /workspace
    git config --global --add safe.directory /tmp/docs-repo

else
    echo "‚ùå GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
    exit 1
fi

# ============================================================================
# CONFIGURATION
# ============================================================================

echo "üîç DEBUG: Configuration"
echo "  DOCS_REPOSITORY: ${DOCS_REPOSITORY:-NOT SET}"
echo "  DOCS_BRANCH: ${DOCS_BRANCH:-NOT SET}"
echo "  DOCS_PROJECT_DIRECTORY: ${DOCS_PROJECT_DIRECTORY:-NOT SET}"
echo "  SERVICE_NAME: ${SERVICE_NAME:-NOT SET}"

# Normalize DOCS_REPOSITORY to full URL if needed
DOCS_REPO_INPUT="${DOCS_REPOSITORY}"
if [[ "$DOCS_REPO_INPUT" =~ ^https?:// ]] || [[ "$DOCS_REPO_INPUT" =~ ^git@ ]]; then
    # Already a full URL
    DOCS_REPO="$DOCS_REPO_INPUT"
else
    # Short format (owner/repo) - convert to HTTPS URL
    DOCS_REPO="https://github.com/$DOCS_REPO_INPUT"
fi

DOCS_BRANCH="${DOCS_BRANCH:-main}"
DOCS_DIR="${DOCS_PROJECT_DIRECTORY}"
SERVICE_NAME="${SERVICE_NAME}"

echo "üîç DEBUG: Normalized DOCS_REPO to: $DOCS_REPO"

# Shared state directory
SHARED_DIR="/shared/morgan-pm"
mkdir -p "$SHARED_DIR"

TASK_ISSUE_MAP="$SHARED_DIR/task-issue-map.json"
PROJECT_CONFIG="$SHARED_DIR/project-config.json"
SYNC_LOG="$SHARED_DIR/sync.log"

echo "üîç DEBUG: Sourcing helper functions..."
# Source helper functions
source /workspace/github-projects-helpers.sh || {
  echo "‚ùå Failed to source github-projects-helpers.sh"
  exit 1
}

echo "üì¶ Repository: $REPO_OWNER/$REPO_NAME"
echo "üîç DEBUG: Starting initialization..."

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

log() {
  echo "[$(date -u +"%Y-%m-%d %H:%M:%S UTC")] $*" | tee -a "$SYNC_LOG"
}

# ============================================================================
# PHASE 1: INITIALIZATION
# ============================================================================

initialize_project() {
  echo "üîç DEBUG: Entered initialize_project()"
  log "üìä Phase 1: Project Initialization"
  
  # Clone docs repository to get TaskMaster data
  log "üì• Cloning documentation repository..."
  echo "üîç DEBUG: DOCS_REPO=$DOCS_REPO, DOCS_BRANCH=$DOCS_BRANCH"
  TEMP_CLONE="/tmp/docs-repo"
  rm -rf "$TEMP_CLONE"
  
  echo "üîç DEBUG: About to git clone..."
  git clone --depth 1 --branch "$DOCS_BRANCH" "$DOCS_REPO" "$TEMP_CLONE" || {
    log "‚ùå Failed to clone docs repository"
    echo "‚ùå DEBUG: Git clone failed with exit code $?"
    exit 1
  }
  echo "üîç DEBUG: Git clone succeeded"
  
  cd "$TEMP_CLONE/$DOCS_DIR"
  
  # Find tasks.json
  TASKS_JSON_PATH=""
  if [[ -f ".taskmaster/tasks/tasks.json" ]]; then
    TASKS_JSON_PATH=".taskmaster/tasks/tasks.json"
  elif [[ -f ".taskmaster/docs/tasks.json" ]]; then
    TASKS_JSON_PATH=".taskmaster/docs/tasks.json"
  else
    log "‚ùå TaskMaster tasks.json not found"
    exit 1
  fi
  
  log "‚úÖ Found tasks.json at: $TASKS_JSON_PATH"
  
  # Read tasks data
  TASKS_DATA=$(cat "$TASKS_JSON_PATH")
  
  # Get or create GitHub Project
  log "üèóÔ∏è  Setting up GitHub Project..."
  log "üîç DEBUG: REPO_OWNER=$REPO_OWNER, SERVICE_NAME=$SERVICE_NAME"
  
  PROJECT_TITLE="$SERVICE_NAME - TaskMaster Workflow"
  log "üîç DEBUG: PROJECT_TITLE=$PROJECT_TITLE"
  
  PROJECT_ID=$(get_or_create_project "$REPO_OWNER" "$PROJECT_TITLE")
  
  if [[ -z "$PROJECT_ID" ]] || [[ "$PROJECT_ID" == "null" ]]; then
    log "‚ùå Failed to create or find project"
    log "üîç DEBUG: PROJECT_ID returned: '$PROJECT_ID'"
    exit 1
  fi
  
  log "‚úÖ Project ID: $PROJECT_ID"
  
  # Setup custom fields
  log "üîß Setting up custom fields..."
  setup_custom_fields "$PROJECT_ID"
  
  # Store project configuration
  cat > "$PROJECT_CONFIG" <<EOF
{
  "project_id": "$PROJECT_ID",
  "project_title": "$PROJECT_TITLE",
  "workflow_name": "$WORKFLOW_NAME",
  "repository": "$REPO_OWNER/$REPO_NAME",
  "created_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
}
EOF
  
  log "‚úÖ Project initialization complete"
}

# ============================================================================
# PHASE 2: ISSUE CREATION
# ============================================================================

create_task_issues() {
  log "üìù Phase 2: Creating Issues for Tasks"
  
  cd "$TEMP_CLONE/$DOCS_DIR"
  
  # Initialize task-issue mapping
  echo "{}" > "$TASK_ISSUE_MAP"
  
  # Get master/default tag tasks (or all tasks if no tags)
  TASKS=$(echo "$TASKS_DATA" | jq -c '.tasks // .master.tasks // []')
  
  if [[ "$TASKS" == "[]" ]] || [[ "$TASKS" == "null" ]]; then
    log "‚ö†Ô∏è  No tasks found in tasks.json"
    return 0
  fi
  
  TASK_COUNT=$(echo "$TASKS" | jq '. | length')
  log "üìä Found $TASK_COUNT tasks to create issues for"
  
  echo "$TASKS" | jq -c '.[]' | while read -r task; do
    TASK_ID=$(echo "$task" | jq -r '.id')
    TASK_TITLE=$(echo "$task" | jq -r '.title')
    TASK_STATUS=$(echo "$task" | jq -r '.status // "pending"')
    TASK_PRIORITY=$(echo "$task" | jq -r '.priority // "medium"')
    
    log "üìå Creating issue for Task $TASK_ID: $TASK_TITLE"
    
    # Generate issue body from task details
    ISSUE_BODY=$(generate_issue_body "$task" "$TASKS_JSON_PATH")
    
    # Debug: Check if body was generated
    if [[ -z "$ISSUE_BODY" ]]; then
      log "‚ö†Ô∏è  Failed to generate issue body for task $TASK_ID"
      continue
    fi
    
    log "üîç DEBUG: Issue body length: ${#ISSUE_BODY} characters"
    
    # Create GitHub issue with workflow-specific labels
    # First, create issue without labels (labels might not exist)
    ISSUE_CREATE_OUTPUT=$(gh issue create \
      --repo "$REPO_OWNER/$REPO_NAME" \
      --title "Task $TASK_ID: $TASK_TITLE" \
      --body "$ISSUE_BODY" \
      2>&1 || echo "ERROR")
    
    log "üîç DEBUG: Issue create output: $ISSUE_CREATE_OUTPUT"
    
    if [[ "$ISSUE_CREATE_OUTPUT" == "ERROR" ]] || [[ "$ISSUE_CREATE_OUTPUT" == *"error"* ]] || [[ "$ISSUE_CREATE_OUTPUT" == *"failed"* ]]; then
      log "‚ö†Ô∏è  Failed to create issue for task $TASK_ID"
      log "Error details: $ISSUE_CREATE_OUTPUT"
      continue
    fi
    
    # Extract issue number using portable method (Alpine grep doesn't support -P)
    ISSUE_NUMBER=$(echo "$ISSUE_CREATE_OUTPUT" | grep -Eo '[0-9]+$' | tail -1 || echo "")
    
    if [[ -z "$ISSUE_NUMBER" ]]; then
      log "‚ö†Ô∏è  Could not extract issue number for task $TASK_ID"
      log "Output was: $ISSUE_CREATE_OUTPUT"
      continue
    fi
    
    log "‚úÖ Created issue #$ISSUE_NUMBER for task $TASK_ID"
    
    # Add labels to the issue (create if they don't exist)
    log "üè∑Ô∏è  Adding labels to issue #$ISSUE_NUMBER..."
    gh label create "taskmaster-task" --repo "$REPO_OWNER/$REPO_NAME" --force 2>/dev/null || true
    gh label create "task-$TASK_ID" --repo "$REPO_OWNER/$REPO_NAME" --force 2>/dev/null || true
    gh label create "priority-$TASK_PRIORITY" --repo "$REPO_OWNER/$REPO_NAME" --force 2>/dev/null || true
    gh label create "status-$TASK_STATUS" --repo "$REPO_OWNER/$REPO_NAME" --force 2>/dev/null || true
    gh label create "workflow-$WORKFLOW_NAME" --repo "$REPO_OWNER/$REPO_NAME" --force 2>/dev/null || true
    
    # Apply labels to issue
    gh issue edit "$ISSUE_NUMBER" \
      --repo "$REPO_OWNER/$REPO_NAME" \
      --add-label "taskmaster-task,task-$TASK_ID,priority-$TASK_PRIORITY,status-$TASK_STATUS,workflow-$WORKFLOW_NAME" \
      2>/dev/null || log "‚ö†Ô∏è  Could not add all labels to issue #$ISSUE_NUMBER"
    
    # Get issue node ID for GraphQL
    ISSUE_NODE_ID=$(gh issue view "$ISSUE_NUMBER" \
      --repo "$REPO_OWNER/$REPO_NAME" \
      --json id --jq '.id')
    
    # Add issue to project
    PROJECT_ID=$(jq -r '.project_id' "$PROJECT_CONFIG")
    ITEM_ID=$(add_issue_to_project "$PROJECT_ID" "$ISSUE_NODE_ID")
    
    if [[ -n "$ITEM_ID" ]]; then
      log "‚úÖ Added issue #$ISSUE_NUMBER to project (Item ID: $ITEM_ID)"
      
      # Set initial field values
      set_project_item_status "$PROJECT_ID" "$ITEM_ID" "$TASK_STATUS"
      set_project_item_priority "$PROJECT_ID" "$ITEM_ID" "$TASK_PRIORITY"
      set_project_item_agent "$PROJECT_ID" "$ITEM_ID" "Pending"
      
      # Store mapping
      TEMP_MAP=$(mktemp)
      jq --arg task_id "$TASK_ID" \
         --arg issue_num "$ISSUE_NUMBER" \
         --arg item_id "$ITEM_ID" \
         --arg node_id "$ISSUE_NODE_ID" \
         '.[$task_id] = {
           "issue_number": ($issue_num | tonumber),
           "item_id": $item_id,
           "node_id": $node_id
         }' "$TASK_ISSUE_MAP" > "$TEMP_MAP"
      mv "$TEMP_MAP" "$TASK_ISSUE_MAP"
    fi
  done
  
  CREATED_COUNT=$(jq 'length' "$TASK_ISSUE_MAP")
  log "‚úÖ Created $CREATED_COUNT issues and added to project"
}

# ============================================================================
# PHASE 3: CONTINUOUS MONITORING (EVENT-DRIVEN)
# ============================================================================

monitor_and_sync() {
  log "üëÄ Phase 3: Event-Driven Monitoring & Synchronization"
  log "üîÑ Starting real-time workflow watch..."
  
  PROJECT_ID=$(jq -r '.project_id' "$PROJECT_CONFIG")
  
  # Initial sync of all tasks
  log "üìä Performing initial sync..."
  sync_all_tasks "$PROJECT_ID"
  
  # Generate initial project summary
  update_project_summary "$PROJECT_ID"
  
  # Background process to watch parent workflow
  watch_parent_workflow &
  PARENT_WATCH_PID=$!
  
  # Background process to periodically update summary (every 5 minutes)
  (
    while true; do
      sleep 300  # 5 minutes
      update_project_summary "$PROJECT_ID" 2>/dev/null || true
    done
  ) &
  SUMMARY_UPDATE_PID=$!
  
  # Main event loop: Watch all task workflows
  log "üëÅÔ∏è  Watching for workflow changes (real-time)..."
  
  # kubectl watch outputs JSON objects one per line, not a JSON array
  # Use --watch-only to get only changes (not initial list)
  kubectl get workflows -n "$NAMESPACE" \
    -l "parent-workflow=$WORKFLOW_NAME" \
    --watch-only -o json 2>/dev/null | \
  while IFS= read -r event_line; do
    # Skip empty lines
    [[ -z "$event_line" ]] && continue
    
    # Validate JSON before parsing
    if ! echo "$event_line" | jq empty 2>/dev/null; then
      log "‚ö†Ô∏è  Skipping invalid JSON line"
      continue
    fi
    
    # Parse event - kubectl watch outputs {type, object} format
    EVENT_TYPE=$(echo "$event_line" | jq -r '.type // "MODIFIED"' 2>/dev/null || echo "MODIFIED")
    
    # Handle different watch formats
    if echo "$event_line" | jq -e '.object' >/dev/null 2>&1; then
      # Standard watch format: {type: "MODIFIED", object: {...}}
      WORKFLOW_OBJ=$(echo "$event_line" | jq -r '.object')
    else
      # Direct object format
      WORKFLOW_OBJ="$event_line"
    fi
    
    # Extract workflow details
    TASK_ID=$(echo "$WORKFLOW_OBJ" | jq -r '.metadata.labels["task-id"] // ""' 2>/dev/null || echo "")
    WORKFLOW_NAME_LOCAL=$(echo "$WORKFLOW_OBJ" | jq -r '.metadata.name // ""' 2>/dev/null || echo "")
    CURRENT_STAGE=$(echo "$WORKFLOW_OBJ" | jq -r '.metadata.labels["current-stage"] // "pending"' 2>/dev/null || echo "pending")
    WORKFLOW_PHASE=$(echo "$WORKFLOW_OBJ" | jq -r '.status.phase // "Pending"' 2>/dev/null || echo "Pending")
    
    [[ -z "$TASK_ID" ]] && continue
    
    log "üì° Event: $EVENT_TYPE for task-$TASK_ID (stage=$CURRENT_STAGE, phase=$WORKFLOW_PHASE)"
    
    # Update GitHub for this specific task
    handle_task_event "$PROJECT_ID" "$TASK_ID" "$WORKFLOW_NAME_LOCAL" "$CURRENT_STAGE" "$WORKFLOW_PHASE"
  done
  
  # Cleanup background processes
  kill $PARENT_WATCH_PID 2>/dev/null || true
  kill $SUMMARY_UPDATE_PID 2>/dev/null || true
  
  # Final summary update
  update_project_summary "$PROJECT_ID" 2>/dev/null || true
  
  log "üéâ Monitoring complete"
}

watch_parent_workflow() {
  # Watch parent workflow in background
  while true; do
    WORKFLOW_STATUS=$(kubectl get workflow "$WORKFLOW_NAME" \
      -n "$NAMESPACE" \
      -o jsonpath='{.status.phase}' 2>/dev/null || echo "NotFound")
    
    if [[ "$WORKFLOW_STATUS" == "Succeeded" ]] || [[ "$WORKFLOW_STATUS" == "Failed" ]] || [[ "$WORKFLOW_STATUS" == "Error" ]]; then
      log "‚úÖ Parent workflow completed with status: $WORKFLOW_STATUS"
      
      # Trigger final sync
      PROJECT_ID=$(jq -r '.project_id' "$PROJECT_CONFIG")
      sync_all_tasks "$PROJECT_ID"
      
      # Kill main watch process
      pkill -P $$ kubectl || true
      exit 0
    fi
    
    sleep 10
  done
}

handle_task_event() {
  local project_id="$1"
  local task_id="$2"
  local workflow_name="$3"
  local current_stage="$4"
  local workflow_phase="$5"
  
  # Get issue details from mapping
  local entry=$(jq -r --arg tid "$task_id" '.[$tid] // empty' "$TASK_ISSUE_MAP")
  [[ -z "$entry" ]] && return 0
  
  local issue_number=$(echo "$entry" | jq -r '.issue_number')
  local item_id=$(echo "$entry" | jq -r '.item_id')
  
  # Map stage to agent and status
  local current_agent=$(map_stage_to_agent "$current_stage" "$workflow_phase")
  local task_status=$(map_workflow_to_status "$current_stage" "$workflow_phase")
  
  log "üîÑ Updating task-$task_id: $current_agent | $task_status"
  
  # Update project item
  set_project_item_status "$project_id" "$item_id" "$task_status"
  set_project_item_agent "$project_id" "$item_id" "$current_agent"
  
  # Update issue labels
  update_issue_labels "$issue_number" "$task_status" "$current_agent"
  
  # NEW: Add structured status history
  add_status_history "$issue_number" "$task_id" "$current_stage" "$current_agent" "$task_status" "$workflow_phase"
  
  # NEW: Check for errors/failures
  check_task_health "$task_id" "$workflow_name" "$current_stage" "$issue_number"
  
  # NEW: Track and report agent progress
  update_progress_comment "$issue_number" "$task_id" "$workflow_name" "$current_stage"
  
  # NEW: GitHub Checks API integration (if PR exists)
  local pr_number=$(find_pr_for_task "$task_id")
  if [[ -n "$pr_number" ]]; then
    create_or_update_github_check "$task_id" "$pr_number" "$current_agent" "$current_stage" "$workflow_phase"
  fi
  
  # NEW: Stream significant agent activity
  stream_significant_events "$task_id" "$workflow_name" "$issue_number"
  
  # NEW: Update heartbeat timestamp
  update_heartbeat "$issue_number"
}

sync_all_tasks() {
  local project_id="$1"
  
  # Iterate through all task mappings
  jq -c 'to_entries[]' "$TASK_ISSUE_MAP" | while read -r entry; do
    TASK_ID=$(echo "$entry" | jq -r '.key')
    ISSUE_NUMBER=$(echo "$entry" | jq -r '.value.issue_number')
    ITEM_ID=$(echo "$entry" | jq -r '.value.item_id')
    
    # Find workflow for this task
    TASK_WORKFLOW=$(kubectl get workflows -n "$NAMESPACE" \
      -l "task-id=$TASK_ID,parent-workflow=$WORKFLOW_NAME" \
      -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
    
    if [[ -z "$TASK_WORKFLOW" ]]; then
      continue
    fi
    
    # Get current stage from workflow labels
    CURRENT_STAGE=$(kubectl get workflow "$TASK_WORKFLOW" \
      -n "$NAMESPACE" \
      -o jsonpath='{.metadata.labels.current-stage}' 2>/dev/null || echo "pending")
    
    # Get workflow phase
    WORKFLOW_PHASE=$(kubectl get workflow "$TASK_WORKFLOW" \
      -n "$NAMESPACE" \
      -o jsonpath='{.status.phase}' 2>/dev/null || echo "Pending")
    
    # Map stage to agent and status
    CURRENT_AGENT=$(map_stage_to_agent "$CURRENT_STAGE" "$WORKFLOW_PHASE")
    TASK_STATUS=$(map_workflow_to_status "$CURRENT_STAGE" "$WORKFLOW_PHASE")
    
    # Update project item
    set_project_item_status "$project_id" "$ITEM_ID" "$TASK_STATUS"
    set_project_item_agent "$project_id" "$ITEM_ID" "$CURRENT_AGENT"
    
    # Update issue labels to reflect current state
    update_issue_labels "$ISSUE_NUMBER" "$TASK_STATUS" "$CURRENT_AGENT"
  done
}

map_stage_to_agent() {
  local stage="$1"
  local phase="$2"
  
  case "$stage" in
    "pending"|"waiting-pr-created")
      echo "Rex (Implementation)"
      ;;
    "implementation"|"implementation-in-progress")
      echo "Rex (Implementation)"
      ;;
    "quality-in-progress"|"waiting-ready-for-qa")
      echo "Cleo (Quality)"
      ;;
    "security-in-progress")
      echo "Cipher (Security)"
      ;;
    "testing-in-progress"|"qa-in-progress")
      echo "Tess (QA)"
      ;;
    "integration-in-progress"|"merging")
      echo "Atlas (Integration)"
      ;;
    "deployment-in-progress"|"deploying")
      echo "Bolt (Deployment)"
      ;;
    "completed"|"done")
      echo "Complete ‚úÖ"
      ;;
    *)
      if [[ "$phase" == "Succeeded" ]]; then
        echo "Complete ‚úÖ"
      else
        echo "In Progress"
      fi
      ;;
  esac
}

map_workflow_to_status() {
  local stage="$1"
  local phase="$2"
  
  case "$phase" in
    "Succeeded")
      echo "Done"
      ;;
    "Failed"|"Error")
      echo "Blocked"
      ;;
    "Running")
      case "$stage" in
        "implementation"*|"pending")
          echo "In Progress"
          ;;
        "quality"*|"security"*|"testing"*)
          echo "In Review"
          ;;
        *)
          echo "In Progress"
          ;;
      esac
      ;;
    *)
      echo "Todo"
      ;;
  esac
}

update_issue_labels() {
  local issue_number="$1"
  local status="$2"
  local agent="$3"
  
  # Remove old status labels
  gh issue edit "$issue_number" \
    --repo "$REPO_OWNER/$REPO_NAME" \
    --remove-label "status-pending,status-in-progress,status-in-review,status-done,status-blocked" \
    2>/dev/null || true
  
  # Add new labels
  local status_label="status-$(echo "$status" | tr '[:upper:] ' '[:lower:]-')"
  gh issue edit "$issue_number" \
    --repo "$REPO_OWNER/$REPO_NAME" \
    --add-label "$status_label" \
    2>/dev/null || true
}

# ============================================================================
# PHASE 1 ENHANCEMENTS: HEALTH CHECKS & STATUS TRACKING
# ============================================================================

add_status_history() {
  local issue_number="$1"
  local task_id="$2"
  local stage="$3"
  local agent="$4"
  local status="$5"
  local phase="$6"
  
  local timestamp=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
  local argo_url="https://argo.5dlabs.com/workflows/agent-platform/$WORKFLOW_NAME"
  
  # Create structured status update comment
  gh issue comment "$issue_number" \
    --repo "$REPO_OWNER/$REPO_NAME" \
    --body "**üìä Status Update**

| Field | Value |
|-------|-------|
| ‚è∞ Time | $timestamp |
| üéØ Stage | \`$stage\` |
| ü§ñ Agent | $agent |
| üìã Status | $status |
| üîÑ Phase | $phase |
| üîó Workflow | [View in Argo]($argo_url) |

---
*Auto-updated by Morgan PM*" 2>/dev/null || true
  
  log "üìù Added status history for task-$task_id"
}

check_task_health() {
  local task_id="$1"
  local workflow_name="$2"
  local current_stage="$3"
  local issue_number="$4"
  
  # Find CodeRun for this task/stage
  local coderun_name=$(kubectl get coderuns -n "$NAMESPACE" \
    -l "task-id=$task_id,workflow-name=$workflow_name" \
    --sort-by=.metadata.creationTimestamp \
    -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo "")
  
  [[ -z "$coderun_name" ]] && return 0
  
  # Check CodeRun status
  local coderun_phase=$(kubectl get coderun "$coderun_name" -n "$NAMESPACE" \
    -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
  
  local coderun_error=$(kubectl get coderun "$coderun_name" -n "$NAMESPACE" \
    -o jsonpath='{.status.error}' 2>/dev/null || echo "")
  
  # Check pod status for more details
  local pod_name=$(kubectl get pods -n "$NAMESPACE" \
    -l "coderun=$coderun_name" \
    -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
  
  local pod_phase=""
  local pod_reason=""
  if [[ -n "$pod_name" ]]; then
    pod_phase=$(kubectl get pod "$pod_name" -n "$NAMESPACE" \
      -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
    pod_reason=$(kubectl get pod "$pod_name" -n "$NAMESPACE" \
      -o jsonpath='{.status.containerStatuses[0].state.waiting.reason}' 2>/dev/null || echo "")
  fi
  
  # Detect problems
  local has_error=false
  local error_message=""
  
  if [[ "$coderun_phase" == "Failed" ]]; then
    has_error=true
    error_message="CodeRun failed: $coderun_error"
  elif [[ "$pod_reason" == "CrashLoopBackOff" ]] || [[ "$pod_reason" == "Error" ]]; then
    has_error=true
    error_message="Agent pod crashed: $pod_reason"
  elif [[ "$pod_phase" == "Failed" ]]; then
    has_error=true
    error_message="Agent pod failed"
  fi
  
  # Report errors to GitHub
  if [[ "$has_error" == true ]]; then
    log "‚ö†Ô∏è  Health check failed for task-$task_id: $error_message"
    
    # Get recent logs for context
    local error_logs=""
    if [[ -n "$pod_name" ]]; then
      error_logs=$(kubectl logs "$pod_name" -n "$NAMESPACE" --tail=20 2>/dev/null || echo "Logs unavailable")
    fi
    
    gh issue comment "$issue_number" \
      --repo "$REPO_OWNER/$REPO_NAME" \
      --body "## ‚ö†Ô∏è Agent Error Detected

**CodeRun:** \`$coderun_name\`  
**Error:** $error_message  
**Time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")

<details>
<summary>Recent Logs (last 20 lines)</summary>

\`\`\`
$error_logs
\`\`\`

</details>

**Next Steps:**
- Review logs above for root cause
- Check if this is a transient issue that will auto-retry
- Manual intervention may be required

---
*Auto-detected by Morgan PM Health Check*" 2>/dev/null || true
  fi
}

update_heartbeat() {
  local issue_number="$1"
  local timestamp=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
  
  # Update or create heartbeat comment
  # Use a unique marker so we can find and update the same comment
  local heartbeat_marker="<!-- morgan-heartbeat -->"
  
  # For now, just track in sync log (avoid spamming issues)
  # Could be enhanced to update a single pinned comment
  echo "$timestamp - Heartbeat for issue #$issue_number" >> "$SYNC_LOG"
}

# ============================================================================
# PHASE 2: SUB-STAGE PROGRESS TRACKING
# ============================================================================

get_agent_progress() {
  local task_id="$1"
  local workflow_name="$2"
  local current_stage="$3"
  
  # Find most recent CodeRun for this task/stage
  local coderun_name=$(kubectl get coderuns -n "$NAMESPACE" \
    -l "task-id=$task_id,workflow-name=$workflow_name" \
    --sort-by=.metadata.creationTimestamp \
    -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo "")
  
  [[ -z "$coderun_name" ]] && echo "" && return 0
  
  # Check for progress annotation (future: agents could set this)
  local progress=$(kubectl get coderun "$coderun_name" -n "$NAMESPACE" \
    -o jsonpath='{.metadata.annotations.agent-progress}' 2>/dev/null || echo "")
  
  # If no annotation, try to parse from pod logs
  if [[ -z "$progress" ]]; then
    local pod_name=$(kubectl get pods -n "$NAMESPACE" \
      -l "coderun=$coderun_name" \
      -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
    
    if [[ -n "$pod_name" ]]; then
      # Look for common progress indicators in logs
      # Match patterns like "Progress: 45%" or "Step 3/10" etc
      local log_progress=$(kubectl logs "$pod_name" -n "$NAMESPACE" --tail=100 2>/dev/null | \
        grep -oiE '(progress:? ?[0-9]+%|[0-9]+%|step [0-9]+/[0-9]+)' | \
        tail -1 || echo "")
      
      if [[ -n "$log_progress" ]]; then
        progress="$log_progress"
      fi
    fi
  fi
  
  echo "$progress"
}

update_progress_comment() {
  local issue_number="$1"
  local task_id="$2"
  local workflow_name="$3"
  local current_stage="$4"
  
  local progress=$(get_agent_progress "$task_id" "$workflow_name" "$current_stage")
  
  [[ -z "$progress" ]] && return 0
  
  # Post progress update as a comment
  gh issue comment "$issue_number" \
    --repo "$REPO_OWNER/$REPO_NAME" \
    --body "üîÑ **Progress Update** - Stage: \`$current_stage\`

Current progress: **$progress**

*Updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")*  
*Auto-updated by Morgan PM*" 2>/dev/null || true
  
  log "üìà Progress for task-$task_id: $progress"
}

# ============================================================================
# PHASE 3: GITHUB CHECKS API INTEGRATION
# ============================================================================

create_or_update_github_check() {
  local task_id="$1"
  local pr_number="$2"
  local agent_name="$3"
  local current_stage="$4"
  local workflow_phase="$5"
  
  # Get PR head SHA
  local pr_head_sha=$(gh pr view "$pr_number" \
    --repo "$REPO_OWNER/$REPO_NAME" \
    --json headRefOid \
    --jq '.headRefOid' 2>/dev/null || echo "")
  
  [[ -z "$pr_head_sha" ]] && return 0
  
  # Map workflow phase to check status
  local check_status="in_progress"
  local check_conclusion=""
  
  case "$workflow_phase" in
    "Succeeded")
      check_status="completed"
      check_conclusion="success"
      ;;
    "Failed"|"Error")
      check_status="completed"
      check_conclusion="failure"
      ;;
    "Running")
      check_status="in_progress"
      ;;
    *)
      check_status="queued"
      ;;
  esac
  
  # Create/update check run
  local check_name="$agent_name Quality Gate"
  local argo_url="https://argo.5dlabs.com/workflows/agent-platform/$WORKFLOW_NAME"
  
  # Check if check run already exists
  local existing_check=$(gh api \
    "/repos/$REPO_OWNER/$REPO_NAME/commits/$pr_head_sha/check-runs" \
    --jq ".check_runs[] | select(.name == \"$check_name\") | .id" 2>/dev/null || echo "")
  
  if [[ -n "$existing_check" ]]; then
    # Update existing check
    local update_payload="{
      \"status\": \"$check_status\",
      \"details_url\": \"$argo_url\",
      \"output\": {
        \"title\": \"$agent_name is reviewing this PR\",
        \"summary\": \"Current stage: $current_stage\",
        \"text\": \"Task ID: $task_id\\nWorkflow: $WORKFLOW_NAME\\nPhase: $workflow_phase\"
      }"
    
    if [[ -n "$check_conclusion" ]]; then
      update_payload="$update_payload,\"conclusion\": \"$check_conclusion\""
    fi
    
    update_payload="$update_payload}"
    
    gh api \
      --method PATCH \
      -H "Accept: application/vnd.github+json" \
      "/repos/$REPO_OWNER/$REPO_NAME/check-runs/$existing_check" \
      --input - <<< "$update_payload" 2>/dev/null || true
    
    log "‚úÖ Updated GitHub check for $agent_name on PR #$pr_number"
  else
    # Create new check
    local create_payload="{
      \"name\": \"$check_name\",
      \"head_sha\": \"$pr_head_sha\",
      \"status\": \"$check_status\",
      \"details_url\": \"$argo_url\",
      \"output\": {
        \"title\": \"$agent_name is reviewing this PR\",
        \"summary\": \"Current stage: $current_stage\",
        \"text\": \"Task ID: $task_id\\nWorkflow: $WORKFLOW_NAME\\nPhase: $workflow_phase\"
      }"
    
    if [[ -n "$check_conclusion" ]]; then
      create_payload="$create_payload,\"conclusion\": \"$check_conclusion\""
    fi
    
    create_payload="$create_payload}"
    
    gh api \
      --method POST \
      -H "Accept: application/vnd.github+json" \
      "/repos/$REPO_OWNER/$REPO_NAME/check-runs" \
      --input - <<< "$create_payload" 2>/dev/null || true
    
    log "‚úÖ Created GitHub check for $agent_name on PR #$pr_number"
  fi
}

find_pr_for_task() {
  local task_id="$1"
  
  # Find PR with task label
  local pr_number=$(gh pr list \
    --repo "$REPO_OWNER/$REPO_NAME" \
    --label "task-$task_id" \
    --state open \
    --json number \
    --jq '.[0].number' 2>/dev/null || echo "")
  
  echo "$pr_number"
}

# ============================================================================
# PHASE 3: AGENT LOG STREAMING
# ============================================================================

stream_significant_events() {
  local task_id="$1"
  local workflow_name="$2"
  local issue_number="$3"
  
  # Find CodeRun pod
  local coderun_name=$(kubectl get coderuns -n "$NAMESPACE" \
    -l "task-id=$task_id,workflow-name=$workflow_name" \
    --sort-by=.metadata.creationTimestamp \
    -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo "")
  
  [[ -z "$coderun_name" ]] && return 0
  
  local pod_name=$(kubectl get pods -n "$NAMESPACE" \
    -l "coderun=$coderun_name" \
    -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
  
  [[ -z "$pod_name" ]] && return 0
  
  # Get recent logs and look for significant events
  local significant_logs=$(kubectl logs "$pod_name" -n "$NAMESPACE" --tail=50 2>/dev/null | \
    grep -iE '(creating pr|running tests?|error|failed|success|completed|starting)' | \
    tail -5 || echo "")
  
  if [[ -n "$significant_logs" ]]; then
    gh issue comment "$issue_number" \
      --repo "$REPO_OWNER/$REPO_NAME" \
      --body "ü§ñ **Agent Activity** (Last 5 significant events)

\`\`\`
$significant_logs
\`\`\`

*Updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")*  
*Auto-captured by Morgan PM*" 2>/dev/null || true
    
    log "üì° Posted agent activity for task-$task_id"
  fi
}

# ============================================================================
# PHASE 3: PROMETHEUS METRICS
# ============================================================================

export_prometheus_metrics() {
  local project_id="$1"
  
  # Calculate metrics
  local total_tasks=$(jq 'length' "$TASK_ISSUE_MAP")
  local completed_tasks=0
  local in_progress_tasks=0
  local blocked_tasks=0
  local pending_tasks=0
  
  # Count by stage
  jq -c 'to_entries[]' "$TASK_ISSUE_MAP" | while read -r entry; do
    local task_id=$(echo "$entry" | jq -r '.key')
    
    # Find workflow for this task
    local task_workflow=$(kubectl get workflows -n "$NAMESPACE" \
      -l "task-id=$task_id,parent-workflow=$WORKFLOW_NAME" \
      -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
    
    if [[ -z "$task_workflow" ]]; then
      pending_tasks=$((pending_tasks + 1))
      continue
    fi
    
    local workflow_phase=$(kubectl get workflow "$task_workflow" \
      -n "$NAMESPACE" \
      -o jsonpath='{.status.phase}' 2>/dev/null || echo "Pending")
    
    case "$workflow_phase" in
      "Succeeded") completed_tasks=$((completed_tasks + 1)) ;;
      "Running") in_progress_tasks=$((in_progress_tasks + 1)) ;;
      "Failed"|"Error") blocked_tasks=$((blocked_tasks + 1)) ;;
      *) pending_tasks=$((pending_tasks + 1)) ;;
    esac
  done
  
  # Calculate average sync lag (time since last update)
  local sync_timestamp=$(date +%s)
  
  # Export metrics to file (Prometheus can scrape this)
  mkdir -p /shared/metrics
  cat > /shared/metrics/morgan.prom <<EOF
# HELP morgan_total_tasks Total number of tasks in this project
# TYPE morgan_total_tasks gauge
morgan_total_tasks{project="$WORKFLOW_NAME",service="$SERVICE_NAME"} $total_tasks

# HELP morgan_completed_tasks Number of completed tasks
# TYPE morgan_completed_tasks gauge
morgan_completed_tasks{project="$WORKFLOW_NAME",service="$SERVICE_NAME"} $completed_tasks

# HELP morgan_in_progress_tasks Number of tasks currently in progress
# TYPE morgan_in_progress_tasks gauge
morgan_in_progress_tasks{project="$WORKFLOW_NAME",service="$SERVICE_NAME"} $in_progress_tasks

# HELP morgan_blocked_tasks Number of blocked/failed tasks
# TYPE morgan_blocked_tasks gauge
morgan_blocked_tasks{project="$WORKFLOW_NAME",service="$SERVICE_NAME"} $blocked_tasks

# HELP morgan_pending_tasks Number of pending tasks
# TYPE morgan_pending_tasks gauge
morgan_pending_tasks{project="$WORKFLOW_NAME",service="$SERVICE_NAME"} $pending_tasks

# HELP morgan_last_sync_timestamp Unix timestamp of last sync
# TYPE morgan_last_sync_timestamp gauge
morgan_last_sync_timestamp{project="$WORKFLOW_NAME",service="$SERVICE_NAME"} $sync_timestamp

# HELP morgan_project_completion_percentage Project completion percentage
# TYPE morgan_project_completion_percentage gauge
morgan_project_completion_percentage{project="$WORKFLOW_NAME",service="$SERVICE_NAME"} $(( total_tasks > 0 ? (completed_tasks * 100) / total_tasks : 0 ))
EOF
  
  log "üìä Exported Prometheus metrics: $completed_tasks/$total_tasks tasks complete"
}

# ============================================================================
# PHASE 3: AI STATUS SUMMARIES
# ============================================================================

generate_ai_summary() {
  local project_id="$1"
  
  # Gather project statistics
  local total_tasks=$(jq 'length' "$TASK_ISSUE_MAP")
  local project_title=$(jq -r '.project_title' "$PROJECT_CONFIG")
  
  # Get task statuses
  local tasks_status=$(kubectl get workflows -n "$NAMESPACE" \
    -l "parent-workflow=$WORKFLOW_NAME" \
    -o json 2>/dev/null || echo '{"items":[]}')
  
  local completed_count=$(echo "$tasks_status" | jq '[.items[] | select(.status.phase == "Succeeded")] | length')
  local in_progress_count=$(echo "$tasks_status" | jq '[.items[] | select(.status.phase == "Running")] | length')
  local failed_count=$(echo "$tasks_status" | jq '[.items[] | select(.status.phase == "Failed" or .status.phase == "Error")] | length')
  
  # Create human-readable summary
  local summary_text=""
  
  if [[ $completed_count -eq $total_tasks ]]; then
    summary_text="üéâ **All tasks completed!** The $SERVICE_NAME project workflow has successfully finished all $total_tasks tasks."
  elif [[ $failed_count -gt 0 ]]; then
    summary_text="‚ö†Ô∏è **Attention needed:** $failed_count task(s) have failed. $in_progress_count task(s) in progress, $completed_count/$total_tasks completed."
  elif [[ $in_progress_count -gt 0 ]]; then
    summary_text="üîÑ **In progress:** $in_progress_count task(s) actively being worked on. $completed_count/$total_tasks tasks completed so far."
  else
    summary_text="‚è∏Ô∏è **Waiting:** $completed_count/$total_tasks tasks completed. Remaining tasks are pending."
  fi
  
  # Update project description with summary
  # Note: GitHub Projects V2 GraphQL API doesn't support description updates yet
  # Instead, post summary as a pinned issue comment or use GitHub Project README
  
  log "üìù Generated AI summary: $summary_text"
  echo "$summary_text"
}

update_project_summary() {
  local project_id="$1"
  
  local summary=$(generate_ai_summary "$project_id")
  
  # Find the first issue to pin the summary
  local first_issue=$(jq -r 'to_entries[0].value.issue_number' "$TASK_ISSUE_MAP" 2>/dev/null || echo "")
  
  if [[ -n "$first_issue" ]]; then
    # Check if summary comment exists
    local summary_marker="<!-- morgan-project-summary -->"
    
    # For now, just log the summary
    # Future: Could create a dedicated "Project Status" issue
    log "üìä Project Summary: $summary"
  fi
  
  # Export metrics along with summary
  export_prometheus_metrics "$project_id"
}

generate_issue_body() {
  local task="$1"
  local tasks_json_path="$2"
  
  local task_id=$(echo "$task" | jq -r '.id')
  local title=$(echo "$task" | jq -r '.title')
  local description=$(echo "$task" | jq -r '.description // "No description provided"')
  local details=$(echo "$task" | jq -r '.details // "No details provided"')
  local test_strategy=$(echo "$task" | jq -r '.testStrategy // "No test strategy defined"')
  local priority=$(echo "$task" | jq -r '.priority // "medium"')
  local dependencies=$(echo "$task" | jq -r '.dependencies // [] | join(", ")')
  
  cat <<EOF
# Task $task_id: $title

## üìã Description
$description

## üéØ Implementation Details
$details

## üß™ Test Strategy
$test_strategy

## üìä Metadata
- **Priority**: $priority
- **Dependencies**: ${dependencies:-None}
- **Status**: Pending
- **Workflow Run**: \`$WORKFLOW_NAME\`
- **Started**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

---

## üîó Task Master Integration

This issue is automatically synchronized with TaskMaster.

**Task File**: \`$tasks_json_path\`  
**Service**: \`$SERVICE_NAME\`  
**Workflow**: \`$WORKFLOW_NAME\`

### Agent Pipeline
1. **Rex** - Implementation
2. **Cleo** - Code Quality Review
3. **Cipher** - Security Analysis (if enabled)
4. **Tess** - QA Testing
5. **Atlas** - Integration & Merge
6. **Bolt** - Production Deployment

---

## üì° Live Status

This issue is monitored by Morgan PM. Status updates are posted automatically as agents progress through the workflow.

**Current Status**: View the Project board for real-time updates  
**Feedback**: Comment with \`@morgan\` to request scope changes or clarifications

---

*This issue is managed by Morgan (Project Manager) for workflow \`$WORKFLOW_NAME\`.*
EOF
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

main() {
  echo "üîç DEBUG: Entered main() function"
  log "üöÄ Morgan PM starting..."
  
  echo "üîç DEBUG: About to call initialize_project()"
  # Phase 1: Initialize project
  initialize_project
  echo "üîç DEBUG: initialize_project() completed"
  
  # Phase 2: Create issues
  create_task_issues
  
  # Phase 3: Monitor and sync
  echo "üîç DEBUG: About to call monitor_and_sync()"
  monitor_and_sync
  
  log "‚úÖ Morgan PM completed successfully"
  echo "üîç DEBUG: main() function completed"
}

# Trap errors and cleanup
trap 'echo "‚ùå Morgan PM error on line $LINENO: $BASH_COMMAND" >&2; exit 1' ERR

echo "üîç DEBUG: About to call main()..."
# Run main
main

echo "‚úÖ DEBUG: main() completed successfully"



