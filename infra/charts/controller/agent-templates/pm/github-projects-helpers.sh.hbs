#!/bin/bash
# GitHub Projects V2 API Helper Functions
# GraphQL-based operations for managing GitHub Projects
# These functions are sourced by Morgan PM scripts
# Patterns adapted from 5dlabs/tasks reference implementation

# ============================================================================
# GraphQL QUERY HELPERS WITH RETRY LOGIC
# ============================================================================

retry_with_backoff() {
  local max_attempts="$1"
  shift
  local operation_name="$1"
  shift
  # Remaining args are the command to execute
  
  local attempt=1
  local delay=2
  
  while [[ $attempt -le $max_attempts ]]; do
    log "üîÑ Attempt $attempt/$max_attempts: $operation_name"
    
    # Execute the command
    if "$@"; then
      log "‚úÖ $operation_name succeeded on attempt $attempt"
      return 0
    fi
    
    local exit_code=$?
    
    if [[ $attempt -lt $max_attempts ]]; then
      log "‚è≥ Attempt $attempt failed (exit $exit_code), retrying in ${delay}s..."
      sleep $delay
      delay=$((delay * 2))  # Exponential backoff: 2s, 4s, 8s, 16s...
      attempt=$((attempt + 1))
    else
      log "‚ùå All $max_attempts attempts failed for: $operation_name"
      return $exit_code
    fi
  done
}

graphql_query() {
  local query="$1"
  local variables="${2:-{}}"
  local max_retries=3
  local retry_count=0
  
  while [ $retry_count -lt $max_retries ]; do
    local result=$(gh api graphql -f query="$query" -F variables="$variables" 2>&1)
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
      echo "$result"
      return 0
    fi
    
    # Check if rate limited
    if echo "$result" | grep -q "rate limit"; then
      retry_count=$((retry_count + 1))
      local backoff=$((2 ** retry_count))
      echo "‚ö†Ô∏è  Rate limited, retrying in ${backoff}s..." >&2
      sleep "$backoff"
    else
      echo "{}" 
      return 1
    fi
  done
  
  echo "{}"
  return 1
}

# ============================================================================
# PROJECT MANAGEMENT
# ============================================================================

get_repository_id() {
  local owner="$1"
  local repo_name="$2"
  
  local query='
    query($owner: String!, $repo: String!) {
      repository(owner: $owner, name: $repo) {
        id
      }
    }
  '
  
  local result=$(gh api graphql -f query="$query" -f owner="$owner" -f repo="$repo_name" 2>&1)
  
  local repo_id=$(echo "$result" | jq -r '.data.repository.id // ""')
  
  if [[ -z "$repo_id" ]] || [[ "$repo_id" == "null" ]]; then
    log "‚ùå Could not get repository ID for $owner/$repo_name" >&2
    echo "$result" >&2
    echo ""
    return 1
  fi
  
  echo "$repo_id"
}

get_or_create_project_smart() {
  local owner="$1"
  local repo_name="$2"
  local title="$3"
  local prefer_repo_level="${4:-false}"  # Can be set via env var or param
  
  local project_id=""
  
  # Try repo-level first if preferred (simpler permissions, auto-linked)
  if [[ "$prefer_repo_level" == "true" ]]; then
    log "üìä Attempting repo-level project (preferred mode)..."
    project_id=$(get_or_create_repo_project "$owner" "$repo_name" "$title")
    
    if [[ -n "$project_id" ]] && [[ "$project_id" != "null" ]]; then
      log "‚úÖ Using repo-level project: $project_id"
      echo "$project_id"
      return 0
    else
      log "‚ö†Ô∏è  Repo-level project creation failed, falling back to org-level..."
    fi
  fi
  
  # Try org-level (default or fallback)
  log "üìä Attempting org-level project..."
  project_id=$(get_or_create_org_project "$owner" "$repo_name" "$title")
  
  if [[ -n "$project_id" ]] && [[ "$project_id" != "null" ]]; then
    log "‚úÖ Using org-level project: $project_id"
    echo "$project_id"
    return 0
  fi
  
  # If org-level failed and we haven't tried repo-level yet
  if [[ "$prefer_repo_level" != "true" ]]; then
    log "‚ö†Ô∏è  Org-level project failed, trying repo-level as fallback..."
    project_id=$(get_or_create_repo_project "$owner" "$repo_name" "$title")
    
    if [[ -n "$project_id" ]] && [[ "$project_id" != "null" ]]; then
      log "‚úÖ Using repo-level project (fallback): $project_id"
      echo "$project_id"
      return 0
    fi
  fi
  
  log "‚ùå Failed to create project at any level"
  echo "null"
  return 1
}

get_or_create_repo_project() {
  local owner="$1"
  local repo_name="$2"
  local title="$3"
  
  # Get repository ID
  local repo_id=$(get_repository_id "$owner" "$repo_name")
  
  if [[ -z "$repo_id" ]] || [[ "$repo_id" == "null" ]]; then
    return 1
  fi
  
  # Try to find existing repo-level project
  local find_query='
    query($owner: String!, $repo: String!) {
      repository(owner: $owner, name: $repo) {
        projectsV2(first: 20) {
          nodes {
            id
            title
            owner {
              __typename
            }
          }
        }
      }
    }
  '
  
  local result=$(gh api graphql -f query="$find_query" -f owner="$owner" -f repo="$repo_name")
  
  # Find repo-level project (owner type is Repository, not Organization)
  local existing_id=$(echo "$result" | jq -r --arg title "$title" \
    '.data.repository.projectsV2.nodes[] | select(.title == $title and .owner.__typename == "Repository") | .id' | head -1)
  
  if [[ -n "$existing_id" ]] && [[ "$existing_id" != "null" ]]; then
    echo "$existing_id"
    return 0
  fi
  
  # Create new repo-level project
  local create_mutation='
    mutation($repositoryId: ID!, $title: String!) {
      createProjectV2(input: {
        repositoryId: $repositoryId
        title: $title
      }) {
        projectV2 {
          id
          title
        }
      }
    }
  '
  
  local create_result=$(gh api graphql \
    -f query="$create_mutation" \
    -f repositoryId="$repo_id" \
    -f title="$title")
  
  if echo "$create_result" | jq -e '.errors' >/dev/null 2>&1; then
    echo "$create_result" | jq '.errors' >&2
    echo "null"
    return 1
  fi
  
  local project_id=$(echo "$create_result" | jq -r '.data.createProjectV2.projectV2.id // "null"')
  
  # CRITICAL FIX: Create board view for repo-level projects too
  # This was missing and caused board columns not to be configured
  if [[ -n "$project_id" ]] && [[ "$project_id" != "null" ]]; then
    create_default_board_view "$project_id"
  fi
  
  echo "$project_id"
}

get_or_create_org_project() {
  local owner="$1"
  local repo_name="$2"
  local title="$3"
  
  # Get repository node ID - needed for linking project to repo
  local repo_result=$(gh api graphql -f query='
    query($owner: String!, $repo: String!) {
      repository(owner: $owner, name: $repo) {
        id
      }
    }
  ' -f owner="$owner" -f repo="$repo_name" 2>&1)
  
  local repo_id=$(echo "$repo_result" | jq -r '.data.repository.id // ""')
  
  if [[ -z "$repo_id" ]] || [[ "$repo_id" == "null" ]]; then
    echo "ERROR: Could not get repository ID for $owner/$repo_name" >&2
    echo "$repo_result" >&2
    echo ""
    return 1
  fi
  
  # Try to find existing project (check both org and linked projects)
  local query='
    query($owner: String!, $repo: String!) {
      repository(owner: $owner, name: $repo) {
        projectsV2(first: 20) {
          nodes {
            id
            title
          }
        }
      }
    }
  '
  
  local result=$(gh api graphql -f query="$query" -f owner="$owner" -f repo="$repo_name")
  
  # Check if project exists
  local project_id=$(echo "$result" | jq -r \
    --arg title "$title" \
    '.data.repository.projectsV2.nodes[] | select(.title == $title) | .id')
  
  if [[ -n "$project_id" ]] && [[ "$project_id" != "null" ]]; then
    echo "$project_id"
    return 0
  fi
  
  # GitHub Projects V2 are created at org/user level, then linked to repos
  # Get owner ID for project creation
  echo "Creating org-level project and linking to repository $owner/$repo_name" >&2
  
  local owner_result=$(gh api graphql -f query='
    query($owner: String!) {
      repositoryOwner(login: $owner) {
        id
      }
    }
  ' -f owner="$owner" 2>&1)
  
  local owner_id=$(echo "$owner_result" | jq -r '.data.repositoryOwner.id // ""')
  
  if [[ -z "$owner_id" ]] || [[ "$owner_id" == "null" ]]; then
    echo "ERROR: Could not get owner ID for $owner" >&2
    echo "$owner_result" >&2
    echo ""
    return 1
  fi
  
  echo "Owner ID: $owner_id" >&2
  
  local create_mutation='
    mutation($ownerId: ID!, $title: String!) {
      createProjectV2(input: {
        ownerId: $ownerId
        title: $title
      }) {
        projectV2 {
          id
        }
      }
    }
  '
  
  local create_result=$(gh api graphql \
    -f query="$create_mutation" \
    -f ownerId="$owner_id" \
    -f title="$title" 2>&1)
  
  # Check for errors in response
  if echo "$create_result" | jq -e '.errors' >/dev/null 2>&1; then
    echo "ERROR: Failed to create project" >&2
    echo "$create_result" | jq -r '.errors[0].message' >&2
    echo ""
    return 1
  fi
  
  local project_id=$(echo "$create_result" | jq -r '.data.createProjectV2.projectV2.id // ""')
  
  if [[ -z "$project_id" ]] || [[ "$project_id" == "null" ]]; then
    echo "ERROR: No project ID returned" >&2
    echo "$create_result" >&2
    echo ""
    return 1
  fi
  
  # Link the project to the repository so it appears on repo page
  echo "Linking project $project_id to repository $repo_id" >&2
  
  local link_mutation='
    mutation($projectId: ID!, $repositoryId: ID!) {
      linkProjectV2ToRepository(input: {
        projectId: $projectId
        repositoryId: $repositoryId
      }) {
        repository {
          id
        }
      }
    }
  '
  
  # Redirect both stdout and stderr to avoid contaminating the return value
  gh api graphql \
    -f query="$link_mutation" \
    -f projectId="$project_id" \
    -f repositoryId="$repo_id" >/dev/null 2>&1 || {
      echo "WARNING: Could not link project to repository (project still works)" >&2
    }
  
  # Create board view and set as default
  create_default_board_view "$project_id"
  
  # Return only the project ID (not mutation output)
  echo "$project_id"
}

ensure_project_linked_to_repository() {
  local project_id="$1"
  local repo_owner="$2"
  local repo_name="$3"
  
  log "üîó Verifying project is linked to repository $repo_owner/$repo_name..."
  
  # Check if already linked
  local check_query='
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          repositories(first: 20) {
            nodes {
              owner {
                login
              }
              name
            }
          }
        }
      }
    }
  '
  
  local result=$(gh api graphql -f query="$check_query" -f projectId="$project_id")
  
  # Check if our repo is in the list
  local is_linked=$(echo "$result" | jq -r --arg owner "$repo_owner" --arg name "$repo_name" \
    '.data.node.repositories.nodes[] | select(.owner.login == $owner and .name == $name) | .name' | head -1)
  
  if [[ -n "$is_linked" ]]; then
    log "‚úÖ Project already linked to repository"
    return 0
  fi
  
  log "üìé Linking project to repository..."
  
  # Get repository ID
  local repo_id=$(get_repository_id "$repo_owner" "$repo_name")
  
  if [[ -z "$repo_id" ]] || [[ "$repo_id" == "null" ]]; then
    log "‚ùå Could not get repository ID"
    return 1
  fi
  
  # Link project to repository
  local link_mutation='
    mutation($projectId: ID!, $repositoryId: ID!) {
      linkProjectV2ToRepository(input: {
        projectId: $projectId
        repositoryId: $repositoryId
      }) {
        repository {
          id
          nameWithOwner
        }
      }
    }
  '
  
  local link_result=$(gh api graphql \
    -f query="$link_mutation" \
    -f projectId="$project_id" \
    -f repositoryId="$repo_id")
  
  # Check for errors
  if echo "$link_result" | jq -e '.errors' >/dev/null 2>&1; then
    log "‚ùå Failed to link project to repository:"
    echo "$link_result" | jq '.errors'
    return 1
  fi
  
  local linked_repo=$(echo "$link_result" | jq -r '.data.linkProjectV2ToRepository.repository.nameWithOwner // ""')
  
  if [[ "$linked_repo" == "$repo_owner/$repo_name" ]]; then
    log "‚úÖ Successfully verified project link to: $linked_repo"
    return 0
  else
    log "‚ùå Link verification failed - expected $repo_owner/$repo_name, got $linked_repo"
    return 1
  fi
}

create_default_board_view() {
  local project_id="$1"
  
  echo "Setting up agent-based board view as default..." >&2
  
  # Using built-in Status field - board columns auto-create!
  echo "‚úÖ Board will use Status field for automatic column creation" >&2
  
  # First, get existing views (GitHub auto-creates a default table view)
  local views_query='
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          views(first: 10) {
            nodes {
              id
              name
              layout
            }
          }
        }
      }
    }
  '
  
  local views_result
  views_result=$(gh api graphql \
    -f query="$views_query" \
    -f projectId="$project_id" 2>/dev/null) || {
    echo "‚ö†Ô∏è  Could not query existing views" >&2
    return 1
  }
  
  # Create board view with agent-based columns
  local view_mutation='
    mutation($projectId: ID!) {
      createProjectV2View(input: {
        projectId: $projectId
        name: "Agent Workflow Board"
        layout: BOARD_LAYOUT
      }) {
        projectV2View {
          id
          number
        }
      }
    }
  '
  
  local view_result
  view_result=$(gh api graphql \
    -f query="$view_mutation" \
    -f projectId="$project_id" 2>/dev/null) || {
    echo "‚ö†Ô∏è  Could not create board view" >&2
    return 1
  }
  
  local view_id=$(echo "$view_result" | jq -r '.data.createProjectV2View.projectV2View.id // ""' 2>/dev/null)
  local view_number=$(echo "$view_result" | jq -r '.data.createProjectV2View.projectV2View.number // ""' 2>/dev/null)
  
  if [[ -n "$view_id" ]] && [[ "$view_id" != "null" ]]; then
    echo "‚úÖ Created agent workflow board view (ID: $view_id, Number: $view_number)" >&2
    
    # Note: GitHub Projects V2 API doesn't support setting groupByFieldId during creation via GraphQL
    # The board will use default grouping (by Status typically)
    # Users can manually configure grouping by "Stage" field in the UI
    # The Stage field contains agent names: Pending, Rex (Implementation), Cleo (Quality), etc.
    
    echo "üí° To group by agents in the UI:" >&2
    echo "   1. Open the project board" >&2
    echo "   2. Click 'Group by' ‚Üí Select 'Stage'" >&2
    echo "   3. Columns will show: Pending | Rex | Cleo | Cipher | Tess | Atlas | Bolt | Complete ‚úÖ" >&2
    
    # Delete ALL table views - GitHub Projects V2 API doesn't support configuring field visibility
    # Table views will show default columns (Assignees, Sub-issues progress) which we don't want
    # Users can manually create a table view and configure columns if needed
    # For now, we only use the board view which shows agent-based columns correctly
    local all_table_views=$(echo "$views_result" | jq -r '.data.node.views.nodes[]? | select(.layout == "TABLE_LAYOUT") | .id' 2>/dev/null)
    
    if [[ -n "$all_table_views" ]]; then
      echo "Removing all table views (board view will be the default)..." >&2
      
      while IFS= read -r table_view_id; do
        if [[ -n "$table_view_id" ]] && [[ "$table_view_id" != "null" ]]; then
          local delete_mutation='
            mutation($viewId: ID!) {
              deleteProjectV2View(input: {
                viewId: $viewId
              }) {
                projectV2View {
                  id
                }
              }
            }
          '
          
          if gh api graphql \
            -f query="$delete_mutation" \
            -f viewId="$table_view_id" >/dev/null 2>&1; then
            echo "‚úÖ Deleted table view (ID: $table_view_id)" >&2
          else
            echo "‚ö†Ô∏è  Could not delete table view (ID: $table_view_id)" >&2
          fi
        fi
      done <<< "$all_table_views"
      
      echo "‚úÖ All table views removed - board view is now the default!" >&2
      echo "üí° If you need a table view, create it manually and hide 'Assignees' and 'Sub-issues progress' columns" >&2
    else
      echo "‚úÖ No table views found - board view will be the default" >&2
    fi
  else
    echo "‚ö†Ô∏è  Could not create board view (project still works)" >&2
  fi
}

# ============================================================================
# CUSTOM FIELDS SETUP
# ============================================================================

setup_custom_fields() {
  local project_id="$1"
  
  # CRITICAL: Use GitHub's BUILT-IN "Status" field with agent names and roles
  # This causes board columns to AUTO-CREATE without manual configuration!
  # Pattern from 5dlabs/tasks - Status field triggers automatic column creation
  create_single_select_field "$project_id" "Status" \
    "Pending" "Rex (Implementation)" "Blaze (Frontend)" "Cleo (Quality)" "Cipher (Security)" "Tess (QA)" "Atlas (Integration)" "Bolt (Deployment)" "Complete ‚úÖ"
  
  # Create "Task ID" field (text)
  create_text_field "$project_id" "Task ID" || true
  
  # Create "Priority" field for filtering
  create_single_select_field "$project_id" "Priority" \
    "High" "Medium" "Low" || true
  
  echo "‚úÖ Custom fields setup completed" >&2
}

create_single_select_field() {
  local project_id="$1"
  local field_name="$2"
  shift 2
  local options=("$@")
  
  # Check if field already exists
  local existing_field=$(get_project_field "$project_id" "$field_name")
  if [[ -n "$existing_field" ]] && [[ "$existing_field" != "null" ]]; then
    log "‚úÖ Field '$field_name' already exists"
    
    # CRITICAL: Status field may exist but have NO options - add them!
    if [[ "$field_name" == "Status" ]]; then
      log "üîß Ensuring Status field has agent options..."
      local colors=("GRAY" "RED" "ORANGE" "YELLOW" "GREEN" "BLUE" "PURPLE" "PINK")
      local opts_json="[]"
      for i in "${!options[@]}"; do
        local color="${colors[$((i % ${#colors[@]}))]}"
        opts_json=$(echo "$opts_json" | jq --arg n "${options[$i]}" --arg c "$color" '. += [{"name": $n, "color": $c, "description": $n}]')
      done
      
      local upd=$(jq -n --arg q 'mutation($fieldId: ID!, $options: [ProjectV2SingleSelectFieldOptionInput!]!) { updateProjectV2Field(input: {fieldId: $fieldId, singleSelectOptions: $options}) { projectV2Field { ... on ProjectV2SingleSelectField { id options { name } } } } }' --arg fieldId "$existing_field" --argjson options "$opts_json" '{query: $q, variables: {fieldId: $fieldId, options: $options}}')
      
      log "üîç DEBUG: Updating Status field with options: $(echo "$opts_json" | jq -c '[.[] | .name]')"
      
      local result=$(echo "$upd" | gh api graphql --input - 2>&1)
      
      if echo "$result" | jq -e '.errors' >/dev/null 2>&1; then
        log "‚ùå GraphQL ERROR updating Status field options:"
        echo "$result" | jq '.errors' | tee -a "$SYNC_LOG" >&2
      elif echo "$result" | jq -e '.data.updateProjectV2Field.projectV2Field.options' >/dev/null 2>&1; then
        local added_opts=$(echo "$result" | jq -r '.data.updateProjectV2Field.projectV2Field.options[].name' | tr '\n' ', ')
        log "‚úÖ Added agent options to Status field: $added_opts"
      else
        log "‚ö†Ô∏è  Status field update returned but no confirmation"
        echo "$result" | jq '.' | tee -a "$SYNC_LOG" >&2
      fi
    fi
    
    return 0
  fi
  
  log "üîß Creating field '$field_name' with ${#options[@]} options..."
  
  # Build options JSON using jq for proper formatting
  # Note: GitHub's ProjectV2SingleSelectFieldOptionInput requires name, color, AND description (all NON_NULL)
  local options_json="[]"
  local colors=("RED" "BLUE" "GREEN" "YELLOW" "ORANGE" "PURPLE" "PINK" "GRAY")
  for i in "${!options[@]}"; do
    local color="${colors[$((i % ${#colors[@]}))]}"
    local option_name="${options[$i]}"
    # Use option name as description for simplicity
    options_json=$(echo "$options_json" | jq --arg name "$option_name" --arg color "$color" --arg desc "$option_name" \
      '. += [{"name": $name, "color": $color, "description": $desc}]')
  done
  
  log "üîç DEBUG: options_json = $options_json"
  
  # Validate that all options have required fields (name, color, description)
  local validation_errors=$(echo "$options_json" | jq -r '
    map(
      select(
        (.name == null or .name == "") or 
        (.color == null or .color == "") or 
        (.description == null)
      )
    ) | 
    if length > 0 then 
      "Missing required fields in options: " + (map(.name // "unnamed") | join(", "))
    else 
      ""
    end
  ')
  
  if [[ -n "$validation_errors" ]]; then
    log "‚ùå Validation error: $validation_errors"
    return 1
  fi
  
  local mutation='
    mutation($projectId: ID!, $name: String!, $options: [ProjectV2SingleSelectFieldOptionInput!]!) {
      createProjectV2Field(input: {
        projectId: $projectId
        dataType: SINGLE_SELECT
        name: $name
        singleSelectOptions: $options
      }) {
        projectV2Field {
          ... on ProjectV2SingleSelectField {
            id
          }
        }
      }
    }
  '
  
  log "üîç DEBUG: project_id=$project_id, field_name=$field_name"
  
  # Build full GraphQL request body with variables
  local request_body=$(jq -n \
    --arg query "$mutation" \
    --arg projectId "$project_id" \
    --arg name "$field_name" \
    --argjson options "$options_json" \
    '{query: $query, variables: {projectId: $projectId, name: $name, options: $options}}')
  
  # Pass complete request via stdin
  local result=$(echo "$request_body" | gh api graphql --input - 2>&1)
  
  if echo "$result" | jq -e '.errors' >/dev/null 2>&1; then
    log "‚ùå Failed to create field '$field_name':"
    echo "$result" | jq '.errors' | tee -a "$SYNC_LOG" >&2
    return 1
  fi
  
  local field_id=$(echo "$result" | jq -r '.data.createProjectV2Field.projectV2Field.id // ""')
  if [[ -n "$field_id" ]] && [[ "$field_id" != "null" ]]; then
    log "‚úÖ Created field '$field_name' (ID: $field_id)"
  else
    log "‚ö†Ô∏è  Field creation returned success but no ID"
    echo "$result" | jq '.' | tee -a "$SYNC_LOG" >&2
  fi
}

create_text_field() {
  local project_id="$1"
  local field_name="$2"
  
  # Check if field already exists
  local existing_field=$(get_project_field "$project_id" "$field_name")
  if [[ -n "$existing_field" ]] && [[ "$existing_field" != "null" ]]; then
    log "‚úÖ Field '$field_name' already exists, skipping creation"
    return 0
  fi
  
  log "üîß Creating text field '$field_name'..."
  
  local mutation='
    mutation($projectId: ID!, $name: String!) {
      createProjectV2Field(input: {
        projectId: $projectId
        dataType: TEXT
        name: $name
      }) {
        projectV2Field {
          ... on ProjectV2Field {
            id
          }
        }
      }
    }
  '
  
  local result=$(gh api graphql \
    -f query="$mutation" \
    -f projectId="$project_id" \
    -f name="$field_name" 2>&1)
  
  if echo "$result" | jq -e '.errors' >/dev/null 2>&1; then
    log "‚ùå Failed to create text field '$field_name':"
    echo "$result" | jq '.errors' | tee -a "$SYNC_LOG" >&2
    return 1
  fi
  
  local field_id=$(echo "$result" | jq -r '.data.createProjectV2Field.projectV2Field.id // ""')
  if [[ -n "$field_id" ]] && [[ "$field_id" != "null" ]]; then
    log "‚úÖ Created text field '$field_name' (ID: $field_id)"
  else
    log "‚ö†Ô∏è  Text field creation returned success but no ID"
    echo "$result" | jq '.' | tee -a "$SYNC_LOG" >&2
  fi
}

get_project_field() {
  local project_id="$1"
  local field_name="$2"
  
  local query='
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          fields(first: 20) {
            nodes {
              ... on ProjectV2Field {
                id
                name
              }
              ... on ProjectV2SingleSelectField {
                id
                name
              }
            }
          }
        }
      }
    }
  '
  
  gh api graphql \
    -f query="$query" \
    -f projectId="$project_id" \
    | jq -r --arg name "$field_name" \
      '.data.node.fields.nodes[] | select(.name == $name) | .id'
}

# ============================================================================
# ISSUE MANAGEMENT
# ============================================================================

add_issue_to_project() {
  local project_id="$1"
  local issue_node_id="$2"
  local issue_number="${3:-unknown}"  # Optional: for better logging
  
  local mutation='
    mutation($projectId: ID!, $contentId: ID!) {
      addProjectV2ItemById(input: {
        projectId: $projectId
        contentId: $contentId
      }) {
        item {
          id
          project {
            id
            title
          }
          content {
            ... on Issue {
              number
              projectItems(first: 5) {
                totalCount
                nodes {
                  id
                }
              }
            }
          }
        }
      }
    }
  '
  
  log "üîó Linking issue #$issue_number to project $project_id..."
  
  local result=$(gh api graphql \
    -f query="$mutation" \
    -f projectId="$project_id" \
    -f contentId="$issue_node_id" 2>&1)
  
  # Save full response for debugging
  if [[ "$issue_number" != "unknown" ]]; then
    echo "$result" | jq '.' > "/tmp/add-project-item-${issue_number}.json" 2>/dev/null || true
  fi
  
  # Check for errors in the response
  if echo "$result" | jq -e '.errors' >/dev/null 2>&1; then
    log "‚ùå GraphQL ERROR adding issue #$issue_number to project:"
    echo "$result" | jq '.errors' | tee -a "$SYNC_LOG" >&2
    
    # Categorize and provide actionable guidance
    local error_type=$(echo "$result" | jq -r '.errors[0].type // ""')
    local error_msg=$(echo "$result" | jq -r '.errors[0].message // ""')
    
    case "$error_type" in
      "INSUFFICIENT_SCOPES"|"FORBIDDEN")
        log "üîê Permission Error: $error_msg"
        log "üí° Action: Check GitHub App permissions for organization_projects and repository_projects"
        log "üí° Verify: gh auth status and GitHub App installation permissions"
        # Track metric
        echo $(($(cat /tmp/morgan-graphql-permission-errors 2>/dev/null || echo "0") + 1)) > /tmp/morgan-graphql-permission-errors
        ;;
      "NOT_FOUND")
        log "üîç Resource Not Found: $error_msg"
        log "üí° Debug: Project ID=$project_id, Issue Node=$issue_node_id"
        log "üí° Action: Verify project exists and issue is valid"
        # Track metric
        echo $(($(cat /tmp/morgan-graphql-notfound-errors 2>/dev/null || echo "0") + 1)) > /tmp/morgan-graphql-notfound-errors
        ;;
      "INTERNAL"|"RATE_LIMITED")
        log "‚è≥ GitHub API Issue: $error_msg"
        log "üí° Action: Will retry automatically with backoff"
        # Track metric
        echo $(($(cat /tmp/morgan-graphql-ratelimit-errors 2>/dev/null || echo "0") + 1)) > /tmp/morgan-graphql-ratelimit-errors
        ;;
      *)
        log "‚ö†Ô∏è  Unknown Error Type: $error_type"
        log "üìã Message: $error_msg"
        # Track metric
        echo $(($(cat /tmp/morgan-graphql-other-errors 2>/dev/null || echo "0") + 1)) > /tmp/morgan-graphql-other-errors
        ;;
    esac
    
    echo "null"
    return 1
  fi
  
  # Extract item ID
  local item_id=$(echo "$result" | jq -r '.data.addProjectV2ItemById.item.id // "null"')
  
  if [[ "$item_id" == "null" ]] || [[ -z "$item_id" ]]; then
    log "‚ùå Failed to extract item ID from GraphQL response"
    echo "$result" | jq '.' | tee -a "$SYNC_LOG" >&2
    echo "null"
    return 1
  fi
  
  # CRITICAL: Verify the link actually persisted
  local total_count=$(echo "$result" | jq -r '.data.addProjectV2ItemById.item.content.projectItems.totalCount // 0' 2>/dev/null)
  
  if [[ "$total_count" -gt 0 ]]; then
    log "‚úÖ Verified: Issue #$issue_number linked to project (${total_count} project links total)"
    # Increment success metric
    echo $(($(cat /tmp/morgan-link-success 2>/dev/null || echo "0") + 1)) > /tmp/morgan-link-success
  else
    log "‚ö†Ô∏è  WARNING: GraphQL returned item ID but issue has 0 project links!"
    log "üí° This may indicate:"
    log "   - Async operation still in progress (wait 2-5 seconds)"
    log "   - Permission issue after initial validation"
    log "   - Project not properly linked to repository"
    log "üìã Item ID returned: $item_id"
    # Increment failure metric
    echo $(($(cat /tmp/morgan-link-failure 2>/dev/null || echo "0") + 1)) > /tmp/morgan-link-failure
  fi
  
  echo "$item_id"
}

# ============================================================================
# FIELD VALUE UPDATES
# ============================================================================

set_project_item_stage() {
  local project_id="$1"
  local item_id="$2"
  local stage="$3"
  
  log "üîç Setting Status field: item=$item_id, status='$stage'"
  
  # Use built-in "Status" field - enables AUTO-COLUMN CREATION!
  local field_id=$(get_project_field "$project_id" "Status")
  
  if [[ -z "$field_id" ]] || [[ "$field_id" == "null" ]]; then
    log "‚ùå Status field not found"
    return 1
  fi
  
  local option_id=$(get_field_option_id "$project_id" "$field_id" "$stage")
  
  if [[ -z "$option_id" ]] || [[ "$option_id" == "null" ]]; then
    log "‚ùå Status option '$stage' not found"
    return 1
  fi
  
  if update_project_item_field "$project_id" "$item_id" "$field_id" "$option_id"; then
    log "‚úÖ Updated status to: $stage"
    return 0
  else
    log "‚ùå Failed to update status"
    return 1
  fi
}

# Legacy function - now stage and agent are the same thing (agent-based columns)
set_project_item_agent() {
  local project_id="$1"
  local item_id="$2"
  local agent="$3"
  
  # Simply call set_project_item_stage since agent names are now stages
  set_project_item_stage "$project_id" "$item_id" "$agent"
}

set_project_item_priority() {
  local project_id="$1"
  local item_id="$2"
  local priority="$3"
  
  local field_id=$(get_project_field "$project_id" "Priority")
  
  if [[ -z "$field_id" ]] || [[ "$field_id" == "null" ]]; then
    return 0
  fi
  
  local priority_value="$priority"
  case "$priority" in
    "high") priority_value="High" ;;
    "medium") priority_value="Medium" ;;
    "low") priority_value="Low" ;;
  esac
  
  local option_id=$(get_field_option_id "$project_id" "$field_id" "$priority_value")
  
  if [[ -z "$option_id" ]] || [[ "$option_id" == "null" ]]; then
    return 0
  fi
  
  update_project_item_field "$project_id" "$item_id" "$field_id" "$option_id"
}

get_field_option_id() {
  local project_id="$1"
  local field_id="$2"
  local option_name="$3"
  
  local query='
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          fields(first: 20) {
            nodes {
              ... on ProjectV2SingleSelectField {
                id
                options {
                  id
                  name
                }
              }
            }
          }
        }
      }
    }
  '
  
  local result=$(gh api graphql \
    -f query="$query" \
    -f projectId="$project_id")
  
  echo "$result" | jq -r \
    --arg field_id "$field_id" \
    --arg option_name "$option_name" \
    '.data.node.fields.nodes[] | select(.id == $field_id) | .options[] | select(.name == $option_name) | .id'
}

update_project_item_field() {
  local project_id="$1"
  local item_id="$2"
  local field_id="$3"
  local value="$4"
  
  local mutation='
    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: String!) {
      updateProjectV2ItemFieldValue(input: {
        projectId: $projectId
        itemId: $itemId
        fieldId: $fieldId
        value: {
          singleSelectOptionId: $value
        }
      }) {
        projectV2Item {
          id
        }
      }
    }
  '
  
  local result=$(gh api graphql \
    -f query="$mutation" \
    -f projectId="$project_id" \
    -f itemId="$item_id" \
    -f fieldId="$field_id" \
    -f value="$value" 2>&1)
  
  # Check for errors
  if echo "$result" | jq -e '.errors' >/dev/null 2>&1; then
    log "‚ùå GraphQL error updating project item field:"
    echo "$result" | jq '.errors' >&2
    return 1
  fi
  
  # Verify update succeeded
  local updated_item_id=$(echo "$result" | jq -r '.data.updateProjectV2ItemFieldValue.projectV2Item.id // ""')
  
  if [[ -z "$updated_item_id" ]] || [[ "$updated_item_id" == "null" ]]; then
    log "‚ö†Ô∏è  Update returned but no item ID confirmed"
    return 1
  fi
  
  return 0
}

# Export functions for use in other scripts
export -f graphql_query
export -f retry_with_backoff
export -f get_repository_id
export -f get_or_create_project_smart
export -f get_or_create_repo_project
export -f get_or_create_org_project
export -f ensure_project_linked_to_repository
export -f setup_custom_fields
export -f create_single_select_field
export -f create_text_field
export -f get_project_field
export -f add_issue_to_project
export -f set_project_item_stage
export -f set_project_item_agent
export -f set_project_item_priority
export -f get_field_option_id
export -f update_project_item_field

