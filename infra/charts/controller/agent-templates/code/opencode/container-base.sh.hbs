#!/bin/bash
set -euo pipefail

# =========================================================================
# Environment bootstrapping
# =========================================================================

{{#if agent_banner}}
echo "{{agent_banner}}"
{{else}}
echo "üîß Initialising OpenCode environment"
{{/if}}

if [ -f "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi

if [ -f "/root/.cargo/env" ]; then
  . "/root/.cargo/env"
fi

if command -v rustup >/dev/null 2>&1; then
  rustup default stable 2>/dev/null || true
fi

# Preemptively prune stale Rustup downloads to avoid bulk cleanup commands later
if [ -d "$HOME/.rustup/downloads" ]; then
  find "$HOME/.rustup/downloads" -mindepth 1 -delete 2>/dev/null || true
fi

echo "PATH: $PATH"

# =========================================================================
# RETRY CONFIGURATION
# =========================================================================
MAX_RETRIES_CONFIG=${OPENCODE_MAX_RETRIES:-${EXECUTION_MAX_RETRIES:-10}}
echo ""
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "‚ïë                    RETRY CONFIGURATION                        ‚ïë"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "ü§ñ CLI: {{cli_type}}"
echo "üéØ Model: {{model}}"
if [ "$MAX_RETRIES_CONFIG" = "0" ]; then
  echo "üîÑ Maximum Iterations: UNLIMITED (will retry until complete)"
else
  echo "üîÑ Maximum Iterations: $MAX_RETRIES_CONFIG"
fi
if [ -n "${OPENCODE_MAX_RETRIES:-}" ]; then
  echo "üìç Source: OPENCODE_MAX_RETRIES environment variable"
elif [ -n "${EXECUTION_MAX_RETRIES:-}" ]; then
  echo "üìç Source: EXECUTION_MAX_RETRIES environment variable"
else
  echo "üìç Source: Default configuration"
fi
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo ""

# =========================================================================
# GitHub App authentication
# =========================================================================

REPO_URL="{{repository_url}}"

if [ -z "${GITHUB_APP_PRIVATE_KEY:-}" ] || [ -z "${GITHUB_APP_ID:-}" ]; then
  echo "‚ùå Missing GitHub App credentials"
  exit 1
fi

echo "üîê Authenticating with GitHub App"
TEMP_KEY_FILE="/tmp/github-app-key.pem"
printf '%b' "$GITHUB_APP_PRIVATE_KEY" >"$TEMP_KEY_FILE"
chmod 600 "$TEMP_KEY_FILE"

JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
NOW=$(date +%s)
EXP=$((NOW + 600))
JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
rm -f "$TEMP_KEY_FILE"

parse_repo() {
  local input="$1"
  if echo "$input" | grep -qE '^https://github.com/'; then
    echo "$input" | sed -E 's|https://github.com/([^/]+)/([^/]+?)(\.git)?$|\1 \2|'
  elif echo "$input" | grep -qE '^git@github.com:'; then
    echo "$input" | sed -E 's|git@github.com:([^/]+)/([^/]+?)(\.git)?$|\1 \2|'
  else
    echo "$input" | sed -E 's|\.git$||' | sed -E 's|([^/]+)/([^/]+)|\1 \2|'
  fi
}

read REPO_OWNER REPO_NAME <<<"$(parse_repo "$REPO_URL")"
REPO_HTTP_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}.git"

INSTALLATION_ID=$(curl -s -L \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
  INSTALLATION_ID=$(curl -s -L \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
fi

if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
  echo "‚ùå Unable to resolve installation ID for $REPO_OWNER/$REPO_NAME"
  exit 1
fi

GITHUB_TOKEN=$(curl -s -X POST \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')

if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
  echo "‚ùå Unable to obtain installation token"
  exit 1
fi

export GITHUB_TOKEN
export GH_TOKEN="$GITHUB_TOKEN"
export GH_HOST="github.com"

# Task-specific workspace for parallel execution isolation
TASK_WORKSPACE="/workspace/task-{{task_id}}"
mkdir -p /workspace
mkdir -p "$TASK_WORKSPACE"
echo "üìÅ Using task-specific workspace: $TASK_WORKSPACE"

export GIT_CONFIG_GLOBAL="$TASK_WORKSPACE/.gitconfig"
CREDENTIALS_FILE="$TASK_WORKSPACE/.git-credentials"

git config --global --replace-all credential.helper "store --file=$CREDENTIALS_FILE"

write_git_credentials() {
  if [ -z "${GITHUB_TOKEN:-}" ]; then
    return
  fi
  printf 'https://x-access-token:%s@github.com\n' "$GITHUB_TOKEN" >"$CREDENTIALS_FILE"
  chmod 600 "$CREDENTIALS_FILE" 2>/dev/null || true
}

write_git_credentials

TOKEN_GENERATED_AT=$(date +%s)

refresh_github_token() {
  echo "üîÑ Refreshing GitHub App token..."

  TEMP_KEY_FILE="/tmp/github-app-key-$$"
  printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
  chmod 600 "$TEMP_KEY_FILE"

  JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  NOW=$(date +%s)
  EXP=$((NOW + 600))
  JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

  rm -f "$TEMP_KEY_FILE"

  NEW_INSTALLATION_ID=$(curl -s -L \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

  if [ "$NEW_INSTALLATION_ID" = "null" ] || [ -z "$NEW_INSTALLATION_ID" ]; then
    NEW_INSTALLATION_ID=$(curl -s -L \
      -H "Authorization: Bearer $JWT_TOKEN" \
      -H "Accept: application/vnd.github+json" \
      "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
  fi

  TOKEN_RESPONSE=$(curl -s -X POST \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/app/installations/$NEW_INSTALLATION_ID/access_tokens")

  NEW_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

  if [ "$NEW_TOKEN" != "null" ] && [ -n "$NEW_TOKEN" ]; then
    export GITHUB_TOKEN="$NEW_TOKEN"
    export GH_TOKEN="$NEW_TOKEN"
    TOKEN_GENERATED_AT=$(date +%s)
    write_git_credentials

    if command -v gh >/dev/null 2>&1; then
      printf '%s\n' "$NEW_TOKEN" | timeout 10 gh auth login --with-token --hostname "$GH_HOST" >/dev/null 2>&1 || true
      gh auth setup-git >/dev/null 2>&1 || true
    fi

    echo "‚úÖ Token refreshed"
    return 0
  fi

  echo "‚ùå Failed to refresh token: $TOKEN_RESPONSE"
  return 1
}

refresh_token_if_needed() {
  if [ -z "$TOKEN_GENERATED_AT" ]; then
    refresh_github_token || true
    return
  fi

  NOW=$(date +%s)
  TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))

  if [ $TOKEN_AGE -gt 3000 ]; then
    echo "üîÑ Token age: $((TOKEN_AGE / 60)) minutes ‚Äî refreshing"
    refresh_github_token || true
  fi
}

sanitize_status_message() {
  printf '%s' "$1" | tr '\n' ' ' | tr '\r' ' '
}

resolve_pr_url() {
  if [ -n "${PR_URL:-}" ]; then
    printf '%s' "$PR_URL"
    return
  fi

  if [ -n "${PR_NUMBER:-}" ] && [ -n "${REPO_OWNER:-}" ] && [ -n "${REPO_NAME:-}" ]; then
    printf 'https://github.com/%s/%s/pull/%s' "$REPO_OWNER" "$REPO_NAME" "$PR_NUMBER"
    return
  fi

  if command -v gh >/dev/null 2>&1; then
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || printf '')
    if [ -n "$current_branch" ]; then
      local pr_url
      pr_url=$(gh pr list --state all --head "$current_branch" --json url --jq '.[0].url' 2>/dev/null || printf '')
      if [ -n "$pr_url" ]; then
        printf '%s' "$pr_url"
        return
      fi
    fi
  fi

  printf ''
}

patch_coderun_status() {
  local phase="$1"
  local message="$2"
  local remediation_status="${3:-}"
  local qa_status="${4:-}"
  local pr_url="${5:-}"
  local work_completed_flag="${6:-false}"

  if [ -z "${CODERUN_NAME:-}" ] || [ -z "${NAMESPACE:-}" ]; then
    return
  fi

  local token_path="/var/run/secrets/kubernetes.io/serviceaccount/token"
  local ca_path="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"

  if [ ! -f "$token_path" ] || [ ! -f "$ca_path" ]; then
    echo "‚ÑπÔ∏è Service account credentials unavailable; skipping CodeRun status update"
    return
  fi

  if ! command -v jq >/dev/null 2>&1; then
    echo "‚ÑπÔ∏è jq not available; skipping CodeRun status update"
    return
  fi

  local work_completed="false"
  if [ "$work_completed_flag" = "true" ]; then
    work_completed="true"
  fi

  local payload
  payload=$(jq -n \
    --arg phase "$phase" \
    --arg message "$(sanitize_status_message "$message")" \
    --arg remediation "$remediation_status" \
    --arg qa "$qa_status" \
    --arg pr "$pr_url" \
    --arg workCompleted "$work_completed" \
    '{
      status: (
        {
          phase: $phase,
          message: $message,
          workCompleted: ($workCompleted == "true")
        }
        + (if $remediation != "" then {remediationStatus: $remediation} else {} end)
        + (if $qa != "" then {qaStatus: $qa} else {} end)
        + (if $pr != "" then {pullRequestUrl: $pr} else {} end)
      )
    }'
  ) || return

  local api_host="${KUBERNETES_SERVICE_HOST:-}"
  local api_port="${KUBERNETES_SERVICE_PORT_HTTPS:-${KUBERNETES_SERVICE_PORT:-443}}"

  if [ -z "$api_host" ]; then
    echo "‚ÑπÔ∏è Kubernetes API host unavailable; skipping CodeRun status update"
    return
  fi

  local token
  token=$(cat "$token_path")

  curl -sS -X PATCH \
    -H "Authorization: Bearer $token" \
    -H "Content-Type: application/merge-patch+json" \
    --cacert "$ca_path" \
    --data "$payload" \
    "https://${api_host}:${api_port}/apis/agents.platform/v1/namespaces/${NAMESPACE}/coderuns/${CODERUN_NAME}/status" >/dev/null 2>&1 || \
    echo "‚ö†Ô∏è Failed to patch CodeRun status"
}

stop_docker_sidecar() {
  if [ ! -S /var/run/docker.sock ]; then
    return
  fi

  echo "üõë Stopping Docker sidecar"

  if command -v pkill >/dev/null 2>&1; then
    pkill dockerd >/dev/null 2>&1 || true
  elif command -v killall >/dev/null 2>&1; then
    killall dockerd >/dev/null 2>&1 || true
  else
    PID=$(pidof dockerd 2>/dev/null || true)
    if [ -n "$PID" ]; then
      kill "$PID" >/dev/null 2>&1 || true
    fi
  fi
}

trap 'stop_docker_sidecar || true' EXIT

ensure_gh_authenticated() {
  if ! command -v gh >/dev/null 2>&1; then
    echo "‚ö†Ô∏è GitHub CLI (gh) not found; skipping authentication"
    return 0
  fi

  if ! gh auth status -h "$GH_HOST" >/dev/null 2>&1; then
    echo "üîê Logging in to GitHub CLI for host $GH_HOST"
    refresh_github_token || true
    if ! printf '%s\n' "$GITHUB_TOKEN" | timeout 10 gh auth login --with-token --hostname "$GH_HOST" >/dev/null 2>&1; then
      echo "‚ö†Ô∏è gh auth login returned non-zero or timed out; continuing with GH_TOKEN env"
    fi
  fi

  refresh_token_if_needed || true
  gh auth setup-git >/dev/null 2>&1 || true

  if gh auth status -h "$GH_HOST" >/dev/null 2>&1; then
    echo "‚úÖ GitHub CLI authenticated for $GH_HOST"
  else
    echo "‚ö†Ô∏è Unable to confirm GitHub CLI auth; GH_TOKEN will still be used for git operations"
  fi
}

ensure_gh_authenticated

ensure_pr_created() {
  if [ "${SKIP_AUTO_PR:-0}" = "1" ]; then
    echo "‚è≠Ô∏è  Auto PR creation disabled via SKIP_AUTO_PR=1"
    return
  fi

  # CRITICAL GUARD #1: Check if orchestrator already provided PR_NUMBER
  # This must be checked BEFORE any other logic to prevent duplicate PRs
  if [ -n "${PR_NUMBER:-}" ]; then
    echo "‚ÑπÔ∏è PR_NUMBER=${PR_NUMBER} provided by orchestrator; skipping fallback PR creation"
    return
  fi

  # CRITICAL GUARD #2: Only auto-create PRs during implementation stage
  # Quality/security/testing agents should NEVER create PRs
  if [ "${WORKFLOW_STAGE:-}" != "implementation" ]; then
    echo "‚ÑπÔ∏è Not in implementation stage (${WORKFLOW_STAGE:-unknown}); skipping fallback PR creation"
    return
  fi

  if [ ! -d .git ]; then
    echo "‚ö†Ô∏è Repository not initialised; skipping auto PR creation"
    return
  fi

  if ! command -v gh >/dev/null 2>&1; then
    echo "‚ö†Ô∏è GitHub CLI not available; skipping auto PR creation"
    return
  fi

  if ! command -v jq >/dev/null 2>&1; then
    echo "‚ö†Ô∏è jq not available; skipping auto PR creation"
    return
  fi

  if [ -z "${GITHUB_TOKEN:-}" ]; then
    echo "‚ö†Ô∏è GITHUB_TOKEN not set; skipping auto PR creation"
    return
  fi

  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || printf '')
  if [ -z "$CURRENT_BRANCH" ]; then
    echo "‚ö†Ô∏è Unable to determine current branch; skipping auto PR creation"
    return
  fi

  # Ensure we have repo context for PR checks
  REPO_SLUG="${REPO_OWNER:-}/${REPO_NAME:-}"
  if [ "$REPO_SLUG" = "/" ] || [ -z "$REPO_OWNER" ] || [ -z "$REPO_NAME" ]; then
    echo "‚ö†Ô∏è REPO_OWNER/REPO_NAME not set; checking for PRs without explicit repo context"
    REPO_SLUG=""
  fi

  # Check if PR already exists for this branch (with explicit repo context)
  refresh_token_if_needed || true
  if [ -n "$REPO_SLUG" ]; then
    PR_OUTPUT=$(gh pr list -R "$REPO_SLUG" --state open --head "$CURRENT_BRANCH" --json number --limit 1 2>&1)
  else
  PR_OUTPUT=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number --limit 1 2>&1)
  fi
  PR_EXIT_CODE=$?

  if [ $PR_EXIT_CODE -ne 0 ] && printf '%s' "$PR_OUTPUT" | grep -qi "HTTP 401"; then
    echo "‚ö†Ô∏è gh pr list returned HTTP 401; refreshing GitHub credentials"
    refresh_github_token || true
    ensure_gh_authenticated
    if [ -n "$REPO_SLUG" ]; then
      PR_OUTPUT=$(gh pr list -R "$REPO_SLUG" --state open --head "$CURRENT_BRANCH" --json number --limit 1 2>&1)
    else
    PR_OUTPUT=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number --limit 1 2>&1)
    fi
    PR_EXIT_CODE=$?
  fi

  if [ $PR_EXIT_CODE -ne 0 ]; then
    printf '%s\n' "$PR_OUTPUT" >&2
    PR_DATA="[]"
  else
    PR_DATA="$PR_OUTPUT"
  fi

  if [ -z "$PR_DATA" ]; then
    PR_DATA="[]"
  fi

  if [ "$(printf '%s' "$PR_DATA" | jq 'length' 2>/dev/null || echo 0)" -gt 0 ]; then
    echo "‚úÖ Pull request already exists for branch $CURRENT_BRANCH"
    return
  fi

  BASE_BRANCH="${PR_BASE_BRANCH:-main}"
  REMOTE_BASE="origin/$BASE_BRANCH"
  if ! git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
    if git show-ref --verify --quiet "refs/remotes/origin/master"; then
      BASE_BRANCH="master"
      REMOTE_BASE="origin/$BASE_BRANCH"
    else
      DEFAULT_REMOTE=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
      if [ -n "$DEFAULT_REMOTE" ]; then
        BASE_BRANCH="$DEFAULT_REMOTE"
        REMOTE_BASE="origin/$BASE_BRANCH"
      else
        REMOTE_BASE=""
      fi
    fi
  fi

  refresh_token_if_needed || true
  if [ -n "$BASE_BRANCH" ]; then
    git fetch origin "$BASE_BRANCH" >/dev/null 2>&1 || true
  fi

  if [ "$CURRENT_BRANCH" = "HEAD" ] || [ "$CURRENT_BRANCH" = "$BASE_BRANCH" ]; then
    AUTO_BRANCH="task-{{task_id}}-{{service}}-$(date +%Y%m%d-%H%M%S)"
    echo "‚ö†Ô∏è Branch $CURRENT_BRANCH unsuitable for PR; creating $AUTO_BRANCH"
    if ! git checkout -B "$AUTO_BRANCH" >/dev/null 2>&1; then
      echo "‚ùå Failed to create fallback branch $AUTO_BRANCH"
      return
    fi
    CURRENT_BRANCH="$AUTO_BRANCH"
  fi

  git add .
  if git diff --cached --quiet --exit-code; then
    echo "‚ÑπÔ∏è No staged changes detected after auto-staging"
  else
    COMMIT_MSG="chore({{service}}): auto-commit for task {{task_id}}"
    if ! git commit -m "$COMMIT_MSG" >/dev/null 2>&1; then
      echo "‚ö†Ô∏è Failed to commit staged changes automatically"
    else
      echo "‚úÖ Auto-committed staged changes"
    fi
  fi

  if git rev-parse --verify --quiet "$CURRENT_BRANCH" >/dev/null 2>&1; then
    refresh_token_if_needed || true
    if ! git push -u origin "$CURRENT_BRANCH" >/dev/null 2>&1; then
      echo "‚ö†Ô∏è Failed to push branch $CURRENT_BRANCH; skipping auto PR creation"
      return
    fi
  else
    echo "‚ö†Ô∏è Unable to verify branch $CURRENT_BRANCH; skipping auto PR creation"
    return
  fi

  git fetch origin "$CURRENT_BRANCH" >/dev/null 2>&1 || true
  if [ -n "$REMOTE_BASE" ]; then
    AHEAD_COUNT=$(git rev-list --left-right "$REMOTE_BASE...$CURRENT_BRANCH" 2>/dev/null | awk '/^>/{c++} END{print c+0}')
  else
    AHEAD_COUNT=1
  fi
  if [ "${AHEAD_COUNT:-0}" -eq 0 ]; then
    echo "‚ö†Ô∏è Branch $CURRENT_BRANCH has no commits ahead of $BASE_BRANCH; skipping PR creation"
    return
  fi

  RUN_LABEL="run-{{workflow_name}}"
  if [ "${RUN_LABEL#run-}" = "" ]; then
    RUN_LABEL="run-unknown"
  fi

  TASK_LABEL="task-{{task_id}}"
  SERVICE_LABEL="service-{{service}}"
  REPO_SLUG="${REPO_OWNER}/${REPO_NAME}"

  echo "üîç Ensuring PR correlation labels exist"
  for label in "$TASK_LABEL" "$SERVICE_LABEL" "$RUN_LABEL"; do
    if [ -z "$label" ]; then
      continue
    fi

    if gh label view "$label" -R "$REPO_SLUG" >/dev/null 2>&1; then
      echo "   ‚úì Label '$label' already exists"
      continue
    fi

    case "$label" in
      task-*) COLOR="28a745"; DESC="Task correlation" ;;
      service-*) COLOR="0e8a16"; DESC="Service correlation" ;;
      run-*) COLOR="0366d6"; DESC="Workflow correlation" ;;
      *) COLOR="ededed"; DESC="Automation label" ;;
    esac

    if gh label create "$label" --force -R "$REPO_SLUG" --color "$COLOR" --description "$DESC" >/tmp/gh-label-create.log 2>&1; then
      echo "   ‚úÖ Created label '$label'"
    else
      echo "   ‚ùå Failed to create label '$label'"
      cat /tmp/gh-label-create.log >&2 || true
    fi
    rm -f /tmp/gh-label-create.log
  done

  # VALIDATION: Check for problematic commits before creating PR
  echo "üîç Validating changes before PR creation..."
  
  # Check total diff size
  TOTAL_ADDITIONS=$(git diff --numstat "$BASE_BRANCH"..."$CURRENT_BRANCH" | awk '{sum+=$1} END {print sum+0}')
  TOTAL_DELETIONS=$(git diff --numstat "$BASE_BRANCH"..."$CURRENT_BRANCH" | awk '{sum+=$2} END {print sum+0}')
  TOTAL_CHANGES=$((TOTAL_ADDITIONS + TOTAL_DELETIONS))
  
  echo "   üìä Total changes: +$TOTAL_ADDITIONS -$TOTAL_DELETIONS (total: $TOTAL_CHANGES lines)"
  
  # Warn if commit is suspiciously large
  if [[ $TOTAL_CHANGES -gt 100000 ]]; then
    echo "   ‚ö†Ô∏è  WARNING: Very large commit detected ($TOTAL_CHANGES lines)!"
    echo "   This may include unwanted files like node_modules or build artifacts"
  fi
  
  # Check for commonly ignored files that shouldn't be committed
  PROBLEMATIC_FILES=$(git diff --name-only "$BASE_BRANCH"..."$CURRENT_BRANCH" | grep -E "(node_modules/|\.next/|dist/|build/|target/debug/|\.pyc$|__pycache__/)" || echo "")
  
  if [[ -n "$PROBLEMATIC_FILES" ]]; then
    echo "   ‚ùå ERROR: Detected files that should be gitignored!"
    echo "$PROBLEMATIC_FILES" | head -10 | sed 's/^/      /'
    if [[ $(echo "$PROBLEMATIC_FILES" | wc -l) -gt 10 ]]; then
      echo "      ... and $(($(echo "$PROBLEMATIC_FILES" | wc -l) - 10)) more"
    fi
    echo ""
    echo "   üõë BLOCKING PR CREATION"
    echo "   Please add a .gitignore file and remove these files from git"
    echo "   Suggested .gitignore entries:"
    echo "      node_modules/"
    echo "      dist/"
    echo "      build/"
    echo "      target/debug/"
    echo "      __pycache__/"
    return 1
  fi
  
  # Check file count
  FILE_COUNT=$(git diff --name-only "$BASE_BRANCH"..."$CURRENT_BRANCH" | wc -l)
  echo "   üìÅ Files changed: $FILE_COUNT"
  
  if [[ $FILE_COUNT -gt 100 ]]; then
    echo "   ‚ö†Ô∏è  WARNING: Large number of files changed ($FILE_COUNT)"
    echo "   Verify this is intentional and not due to dependency/build commits"
  fi
  
  echo "   ‚úÖ Validation passed"
  
  # Find the GitHub issue for this task (created by Morgan PM)
  ISSUE_NUMBER=$(gh issue list -R "$REPO_SLUG" --label "task-{{task_id}}" --json number --jq '.[0].number' 2>/dev/null || echo "")
  
  ISSUE_LINK=""
  if [[ -n "$ISSUE_NUMBER" ]]; then
    echo "üîó Found GitHub issue #$ISSUE_NUMBER for task {{task_id}}"
    ISSUE_LINK="Closes #$ISSUE_NUMBER"
  fi

  PR_TITLE="feat({{service}}): complete task {{task_id}}"
  read -r -d '' PR_BODY <<EOF || true
## Summary
- Auto-generated fallback PR because the OpenCode agent finished without opening one
- Task {{task_id}} for service {{service}} is ready for review

## Metadata
- Agent: {{github_app}}
- Workflow: {{workflow_name}}
- Branch: \`$CURRENT_BRANCH\` ‚Üí \`$BASE_BRANCH\`
${ISSUE_LINK:+
## Links
$ISSUE_LINK
}
_This PR was created automatically by the OpenCode container._
EOF

  LABEL_ARGS=("--title" "$PR_TITLE" "--body" "$PR_BODY" "--base" "$BASE_BRANCH" "--head" "$CURRENT_BRANCH")

  # Create PR first without labels, then add labels separately
  # This prevents the entire PR creation from failing if a label doesn't exist
  if PR_URL=$(gh pr create "${LABEL_ARGS[@]}" 2>&1); then
    echo "‚úÖ Auto-created pull request: $PR_URL"
    
    # Now add labels one by one (non-critical if they fail)
    for label in "$TASK_LABEL" "$SERVICE_LABEL" "$RUN_LABEL"; do
      if [ -z "$label" ]; then
        continue
      fi
      
      # Try to create label if it doesn't exist
      if ! gh label view "$label" -R "$REPO_SLUG" >/dev/null 2>&1; then
        case "$label" in
          task-*) COLOR="28a745"; DESC="Task correlation" ;;
          service-*) COLOR="0e8a16"; DESC="Service correlation" ;;
          run-*) COLOR="0366d6"; DESC="Workflow correlation" ;;
          *) COLOR="ededed"; DESC="Automation label" ;;
        esac
        gh label create "$label" --force -R "$REPO_SLUG" --color "$COLOR" --description "$DESC" >/dev/null 2>&1 || true
      fi
      
      # Add label to PR (continue even if it fails)
      if gh pr edit "$CURRENT_BRANCH" --add-label "$label" >/dev/null 2>&1; then
        echo "   ‚úì Added label: $label"
      else
        echo "   ‚ö†Ô∏è Could not add label: $label (PR still created)"
      fi
    done
  else
    echo "‚ö†Ô∏è Failed to create pull request: $PR_URL"
    echo "   This may be because a PR already exists or there's an authentication issue"
  fi
}

git config --global --add safe.directory "$TASK_WORKSPACE"
GITHUB_APP="{{github_app}}"

derive_bot_identity() {
  local app_name="$1"

  if [ -z "$app_name" ] || [ "$app_name" = "null" ]; then
    GIT_AUTHOR_NAME="automation[bot]"
    GIT_AUTHOR_EMAIL="automation[bot]@users.noreply.github.com"
    return
  fi

  local slug
  slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-+|-+$//g')
  if [ -z "$slug" ]; then
    slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]')
  fi

  local bot_login="${slug}[bot]"
  local bot_email="${bot_login}@users.noreply.github.com"

  if [ -n "${GITHUB_TOKEN:-}" ]; then
    local encoded_login
    encoded_login=$(printf '%s' "$bot_login" | sed 's/\[/%5B/g; s/\]/%5D/g')
    local bot_response
    bot_response=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/users/${encoded_login}" 2>/dev/null || true)
    local bot_id
    bot_id=$(printf '%s' "$bot_response" | jq -r '.id // empty' 2>/dev/null || echo '')
    if [ -n "$bot_id" ]; then
      bot_email="${bot_id}+${bot_login}@users.noreply.github.com"
    fi
  fi

  GIT_AUTHOR_NAME="$bot_login"
  GIT_AUTHOR_EMAIL="$bot_email"
}

GITHUB_APP="{{github_app}}"
derive_bot_identity "$GITHUB_APP"

git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

export GIT_AUTHOR_NAME
export GIT_AUTHOR_EMAIL
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true
# Repository checkout
# =========================================================================

WORK_DIR="{{working_directory}}"
cd "$TASK_WORKSPACE"

REPO_ROOT="$TASK_WORKSPACE/$REPO_NAME"
git config --global --add safe.directory "$REPO_ROOT"

if [ -d "$REPO_NAME/.git" ]; then
  echo "üîÅ Repository already cloned, fetching latest"
  cd "$REPO_NAME"
  refresh_token_if_needed
  git fetch --all --prune
else
  echo "‚¨áÔ∏è  Cloning repository"
  refresh_token_if_needed
  git clone "$REPO_HTTP_URL"
  cd "$REPO_NAME"
fi

cd "$REPO_ROOT"

# Remove stale automation-managed files that block branch checkout when rerunning
MANAGED_PATHS=(
  ".mcp.json"
  "AGENTS.md"
  "client-config.json"
  "coding-guidelines.md"
  "github-guidelines.md"
  "task"
)

for managed_path in "${MANAGED_PATHS[@]}"; do
  if git ls-files --error-unmatch -- "$managed_path" >/dev/null 2>&1; then
    status_output=$(git status --short -- "$managed_path" 2>/dev/null || true)
    untracked=false
    while IFS= read -r line; do
      case "$line" in
        "?? "*)
          untracked=true
          break
          ;;
      esac
    done <<EOF
$status_output
EOF

    if [ "$untracked" = true ]; then
      echo "üßπ Removing stale untracked files to allow checkout: $managed_path"
      git clean -fd -- "$managed_path" >/dev/null 2>&1 || rm -rf "$managed_path"
    fi
    continue
  fi

  if [ -e "$managed_path" ]; then
    echo "üßπ Removing stale file to allow checkout: $managed_path"
    rm -rf "$managed_path"
  fi
done

BASE_BRANCH="${PR_BASE_BRANCH:-main}"
REMOTE_BASE="origin/$BASE_BRANCH"

if ! git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
  if git show-ref --verify --quiet "refs/remotes/origin/master"; then
    BASE_BRANCH="master"
    REMOTE_BASE="origin/$BASE_BRANCH"
  else
    DEFAULT_REMOTE=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    if [ -n "$DEFAULT_REMOTE" ]; then
      BASE_BRANCH="$DEFAULT_REMOTE"
      REMOTE_BASE="origin/$BASE_BRANCH"
    else
      REMOTE_BASE=""
    fi
  fi
fi

if [ -n "$BASE_BRANCH" ]; then
  git fetch origin "$BASE_BRANCH" >/dev/null 2>&1 || true
fi

FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
if git show-ref --verify --quiet "refs/heads/$FEATURE_BRANCH"; then
  echo "Feature branch '$FEATURE_BRANCH' exists, checking out..."
  # Clean up any local changes from previous runs to avoid checkout conflicts
  # Preserve task/ directory since it was just copied
  if ! git diff-index --quiet HEAD -- || [ -n "$(git ls-files --others --exclude-standard)" ]; then
    echo "üîÑ Cleaning workspace before checkout (preserving task/ directory)"
    
    # Save task/ directory if it exists
    if [ -d "task" ]; then
      echo "üì¶ Temporarily saving task/ directory"
      cp -r task /tmp/task-backup-$$ 2>/dev/null || true
    fi
    
    # Reset all changes aggressively
    git reset --hard HEAD 2>/dev/null || true
    git clean -fdx -e task/ 2>/dev/null || true
    
    # Restore task/ directory
    if [ -d "/tmp/task-backup-$$" ]; then
      echo "üì¶ Restoring task/ directory"
      rm -rf task 2>/dev/null || true
      cp -r /tmp/task-backup-$$ task 2>/dev/null || true
      rm -rf /tmp/task-backup-$$ 2>/dev/null || true
    fi
    
    echo "‚úÖ Workspace cleaned"
  fi
  
  # Now checkout should work
  git checkout "$FEATURE_BRANCH"
  if [ -n "$REMOTE_BASE" ]; then
    echo "üì• Fast-forwarding $FEATURE_BRANCH with $REMOTE_BASE"
    if ! git merge "$REMOTE_BASE" --ff-only >/dev/null 2>&1; then
      # Check if PR exists for this branch before creating timestamped fallback
      echo "‚ö†Ô∏è Unable to fast-forward $FEATURE_BRANCH; checking for existing PR"
      refresh_token_if_needed || true
      EXISTING_PR=$(gh pr list --state open --head "$FEATURE_BRANCH" --json number --limit 1 2>/dev/null | jq -r '.[0].number // empty')
      
      if [ -n "$EXISTING_PR" ]; then
        echo "‚úÖ Found existing PR #$EXISTING_PR for branch $FEATURE_BRANCH"
        echo "‚ÑπÔ∏è Continuing with this branch despite merge conflict (will be resolved in PR)"
        # Stay on the current branch and let the PR handle conflicts
      else
        echo "‚ÑπÔ∏è No existing PR found; recreating branch from $REMOTE_BASE"
        # Delete local branch and recreate fresh from base
        # Force discard all local changes since we're recreating from scratch
        git reset --hard HEAD 2>/dev/null || true
        git clean -fd 2>/dev/null || true
        git checkout -f "$REMOTE_BASE" 2>/dev/null || git checkout -b temp-branch "$REMOTE_BASE"
        git branch -D "$FEATURE_BRANCH" 2>/dev/null || true
        git checkout -b "$FEATURE_BRANCH" "$REMOTE_BASE"
        echo "‚úÖ Recreated $FEATURE_BRANCH from $REMOTE_BASE"
      fi
    fi
  fi
else
  echo "Creating new feature branch '$FEATURE_BRANCH'"
  
  # Check for and abort any in-progress merge conflicts before checkout
  if git status --porcelain 2>/dev/null | grep -q "^UU\|^AA\|^DD\|^..U\|^U..\|^DD\|^AU\|^UA\|^DU\|^UD"; then
    echo "‚ö†Ô∏è Detecting unresolved merge conflicts, aborting merge..."
    git merge --abort 2>/dev/null || true
    echo "‚úì Merge conflicts aborted"
  fi
  
  # Check for and reset any incomplete merge (rebase, cherry-pick, etc.)
  if [ -f ".git/REBASE_HEAD" ] || [ -f ".git/CHERRY_PICK_HEAD" ] || [ -f ".git/MERGE_HEAD" ]; then
    echo "‚ö†Ô∏è Detecting incomplete git operation, resetting..."
    git rebase --abort 2>/dev/null || true
    git cherry-pick --abort 2>/dev/null || true  
    git merge --abort 2>/dev/null || true
    if ! git diff-index --quiet HEAD; then
      git reset --hard HEAD 2>/dev/null || true
    fi
    echo "‚úì Git operations reset"
  fi
  
  # Clean up any local changes from previous runs to avoid checkout conflicts
  # Preserve task/ directory since it was just copied
  if ! git diff-index --quiet HEAD -- || [ -n "$(git ls-files --others --exclude-standard)" ]; then
    echo "üîÑ Cleaning workspace before creating new branch (preserving task/ directory)"
    
    # Save task/ directory if it exists
    if [ -d "task" ]; then
      echo "üì¶ Temporarily saving task/ directory"
      cp -r task /tmp/task-backup-$$ 2>/dev/null || true
    fi
    
    # Reset all changes aggressively
    git reset --hard HEAD 2>/dev/null || true
    git clean -fdx -e task/ 2>/dev/null || true
    
    # Restore task/ directory
    if [ -d "/tmp/task-backup-$$" ]; then
      echo "üì¶ Restoring task/ directory"
      rm -rf task 2>/dev/null || true
      cp -r /tmp/task-backup-$$ task 2>/dev/null || true
      rm -rf /tmp/task-backup-$$ 2>/dev/null || true
    fi
    
    echo "‚úÖ Workspace cleaned"
  fi
  
  if [ -n "$REMOTE_BASE" ] && git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
    git checkout -b "$FEATURE_BRANCH" "$REMOTE_BASE"
  else
    git checkout -b "$FEATURE_BRANCH"
  fi
fi

git config --local user.name "$GIT_AUTHOR_NAME"
git config --local user.email "$GIT_AUTHOR_EMAIL"
git config --local push.autoSetupRemote true
export IMPLEMENTATION_BRANCH="$FEATURE_BRANCH"
echo "‚úì Using feature branch: $FEATURE_BRANCH (base: ${BASE_BRANCH:-unknown})"

# Set working directory: use repo root if working_directory is "." or empty
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ] || [ "$WORK_DIR" = "null" ]; then
  OPENCODE_WORK_DIR="$REPO_ROOT"
else
  OPENCODE_WORK_DIR="$REPO_ROOT/$WORK_DIR"
  mkdir -p "$OPENCODE_WORK_DIR"
fi

cd "$OPENCODE_WORK_DIR"
echo "‚úì Working directory: $OPENCODE_WORK_DIR"

echo "üì¶ git status"
refresh_token_if_needed
git status --short || true

# Load resilient task setup functions (mounted from shared ConfigMap)
source /agent-templates/shared_task-setup-functions.sh || {
    echo "‚ö†Ô∏è Warning: Resilient task functions not available, using basic operations"
    # Define minimal fallback functions
    safe_copy_file() { cp "$1" "$2" && echo "‚úì $3 copied" || echo "‚ùå $3 copy failed"; }
    safe_copy_directory() { cp -r "$1" "$2" && echo "‚úì $3 copied" || echo "‚ùå $3 copy failed"; }
    safe_ensure_directory() { mkdir -p "$1"; }
    verify_task_files() { 
        if [ -f "$1/prompt.md" ]; then
            echo "‚úÖ Task files verified"
            return 0
        else
            echo "‚ùå Task files missing"
            return 1
        fi
    }
    create_error_report() { echo "‚ùå ERROR: $3"; }
    attempt_task_recovery() { echo "‚ùå Recovery not available"; return 1; }
}

# =========================================================================
# Materialise task context (RESILIENT MODE)
# =========================================================================

echo "üß± Syncing task assets (RESILIENT MODE)"
# Use safe directory creation to avoid overwriting files
if ! safe_ensure_directory "$OPENCODE_WORK_DIR/task" "OpenCode task directory"; then
    echo "‚ùå CRITICAL: Cannot create OpenCode task directory"
    exit 1
fi

# Safely copy task files from ConfigMap
if [ -d "/task-files/task" ]; then
    echo "üìÇ Copying task files from ConfigMap..."
    if ! safe_copy_directory "/task-files/task" "$OPENCODE_WORK_DIR/task" "ConfigMap task files"; then
        echo "‚ö†Ô∏è Warning: Could not copy all task files from ConfigMap"
    fi
else
    echo "‚ÑπÔ∏è No task files in ConfigMap - will rely on docs repository"
fi

DOCS_REPO_URL="{{docs_repository_url}}"
DOCS_BRANCH="{{docs_branch}}"
DOCS_PROJECT_DIRECTORY="{{docs_project_directory}}"

if [ -n "$DOCS_REPO_URL" ] && [ "$DOCS_REPO_URL" != "null" ]; then
  refresh_token_if_needed
  if [ -z "$DOCS_BRANCH" ] || [ "$DOCS_BRANCH" = "null" ]; then
    DOCS_BRANCH="main"
  fi

  echo "üìö Syncing docs repository: $DOCS_REPO_URL (branch: $DOCS_BRANCH)"
  DOCS_CLONE_DIR="/tmp/docs-repo"
  rm -rf "$DOCS_CLONE_DIR"

  read DOCS_OWNER DOCS_NAME <<<"$(parse_repo "$DOCS_REPO_URL")"
  DOCS_HTTP_URL="https://github.com/${DOCS_OWNER}/${DOCS_NAME}.git"

  if git clone --quiet --branch "$DOCS_BRANCH" --single-branch "$DOCS_HTTP_URL" "$DOCS_CLONE_DIR"; then
    echo "‚úì Docs repository cloned"
    DOCS_BASE_PATH="$DOCS_CLONE_DIR/.taskmaster"
    if [ -n "$DOCS_PROJECT_DIRECTORY" ] && [ "$DOCS_PROJECT_DIRECTORY" != "null" ]; then
      DOCS_BASE_PATH="$DOCS_CLONE_DIR/$DOCS_PROJECT_DIRECTORY/.taskmaster"
    fi

    echo "üîç Docs base path: $DOCS_BASE_PATH"
    
    # Resilient task directory discovery - check regular, tasks/, and .completed locations
    # Check both regular location and .completed location (tasks moved after completion)
    TASK_DIR=""
    if [ -d "$DOCS_BASE_PATH/docs/task-{{task_id}}" ]; then
      TASK_DIR="$DOCS_BASE_PATH/docs/task-{{task_id}}"
      echo "‚úì Found task files in docs/ directory"
    elif [ -d "$DOCS_BASE_PATH/docs/.completed/task-{{task_id}}" ]; then
      TASK_DIR="$DOCS_BASE_PATH/docs/.completed/task-{{task_id}}"
      echo "‚úì Found task files in docs/.completed/ directory"
      echo "‚ÑπÔ∏è Task appears to be completed - using files from .completed folder"
    elif [ -d "$DOCS_BASE_PATH/tasks/task-{{task_id}}" ]; then
      TASK_DIR="$DOCS_BASE_PATH/tasks/task-{{task_id}}"
      echo "‚úì Found task files in tasks/ directory"
    fi

    if [ -n "$TASK_DIR" ] && [ -d "$TASK_DIR" ]; then
      echo "‚úì Copying task definition from $TASK_DIR (RESILIENT MODE)"
      refresh_token_if_needed
      if safe_copy_directory "$TASK_DIR" "$OPENCODE_WORK_DIR/task" "docs task files"; then
          echo "‚úÖ Task files copied successfully from docs repository"
      else
          echo "‚ùå CRITICAL: Failed to copy task files from docs repository"
          create_error_report "$OPENCODE_WORK_DIR/task" "{{task_id}}" "Failed to copy from docs repository"
      fi
    else
      echo "‚ùå CRITICAL: Task directory not found. Checked:"
      echo "   - $DOCS_BASE_PATH/docs/task-{{task_id}}"
      echo "   - $DOCS_BASE_PATH/docs/.completed/task-{{task_id}}"
      echo "   - $DOCS_BASE_PATH/tasks/task-{{task_id}}"
      create_error_report "$OPENCODE_WORK_DIR/task" "{{task_id}}" "Task directory not found in docs repository"
    fi

    if [ -f "$DOCS_BASE_PATH/tasks.json" ]; then
      refresh_token_if_needed
      safe_copy_file "$DOCS_BASE_PATH/tasks.json" "$OPENCODE_WORK_DIR/task/tasks.json" "tasks.json"
    fi
  fi
fi
if [ -f /task-files/coding-guidelines.md ]; then
  cp /task-files/coding-guidelines.md "$OPENCODE_WORK_DIR/"
  echo "‚úì Copied coding-guidelines.md to working directory"
fi

if [ -f /task-files/github-guidelines.md ]; then
  cp /task-files/github-guidelines.md "$OPENCODE_WORK_DIR/"
  echo "‚úì Copied github-guidelines.md to working directory"
fi

# AGENTS.md Memory Persistence Logic (controlled by overwriteMemory CRD field)
OVERWRITE_MEMORY="{{overwrite_memory}}"

# Handle AGENTS.md based on overwriteMemory setting
if [ "$OVERWRITE_MEMORY" = "true" ]; then
  # Overwrite mode: Always replace AGENTS.md with fresh template
  if [ -f /task-files/AGENTS.md ]; then
    cp /task-files/AGENTS.md "$OPENCODE_WORK_DIR/AGENTS.md"
    echo "‚úì Overwrote AGENTS.md memory file (fresh start requested)"
  fi
else
  # Preserve mode (default): Only copy if doesn't exist
  if [ ! -f "$OPENCODE_WORK_DIR/AGENTS.md" ]; then
    # Initial creation - copy from ConfigMap
    if [ -f /task-files/AGENTS.md ]; then
      cp /task-files/AGENTS.md "$OPENCODE_WORK_DIR/AGENTS.md"
      echo "‚úì Created initial AGENTS.md memory file"
    fi
  else
    echo "‚úì Preserved existing AGENTS.md memory file (maintaining accumulated context)"
  fi
fi

if [ -f /task-files/client-config.json ]; then
  cp /task-files/client-config.json "$OPENCODE_WORK_DIR/"
  echo "‚úì Copied client-config.json to working directory"
fi

if [ -f /task-files/mcp.json ]; then
  cp /task-files/mcp.json "$OPENCODE_WORK_DIR/.mcp.json"
fi

export OPENCODE_PERMISSION='{"bash":{"*":"allow"},"edit":"allow","webfetch":"allow"}'

# Guard against destructive workspace cleanup
guard_rm() {
  if [ "$#" -ge 2 ]; then
    local flags=()
    local targets=()
    for arg in "$@"; do
      case "$arg" in
        -*) flags+=("$arg") ;;
        *) targets+=("$arg") ;;
      esac
    done

    local has_recursive=0
    local has_force=0
    for flag in "${flags[@]}"; do
      case "$flag" in
        -*)
          [[ "$flag" == *r* || "$flag" == *R* ]] && has_recursive=1
          [[ "$flag" == *f* || "$flag" == *F* ]] && has_force=1
          ;;
      esac
    done

    if ((has_recursive && has_force)); then
      for target in "${targets[@]}"; do
        [ -z "$target" ] && continue
        local expanded="$target"
        case "$target" in
          ~*) expanded="${target/#\~/$HOME}" ;;
        esac
        local resolved
        resolved=$(realpath -m "$expanded" 2>/dev/null || printf '%s' "$expanded")
        if [ "$resolved" = "$OPENCODE_WORK_DIR" ] || [ "$resolved" = "$TASK_WORKSPACE" ] ||
           [ "$resolved" = "$HOME" ] || [[ "$resolved" == "$HOME/.rustup"* ]]; then
          echo "‚ùå Guard: destructive rm blocked (target=$target)" >&2
          return 1
        fi
      done
    fi
  fi

  return 0
}

rm() {
  if guard_rm "$@"; then
    command rm "$@"
  else
    return 1
  fi
}

export -f guard_rm rm

if [ ! -f "$OPENCODE_WORK_DIR/client-config.json" ]; then
  echo "‚ùå client-config.json missing from workspace; required for MCP/toolman"
  exit 1
fi

echo "=== MCP CLIENT CONFIG ==="
WORKSPACE_CFG="$OPENCODE_WORK_DIR/client-config.json"
SOURCE_CFG="/task-files/client-config.json"
TARGET_CFG="${MCP_CLIENT_CONFIG:-$TASK_WORKSPACE/client-config.json}"

is_valid_cfg() {
  local path="$1"
  [ -f "$path" ] || return 1
  if command -v jq >/dev/null 2>&1; then
    jq -e 'type=="object" and length>=0' "$path" >/dev/null 2>&1
  else
    [ -s "$path" ]
  fi
}

if is_valid_cfg "$WORKSPACE_CFG"; then
  cp "$WORKSPACE_CFG" "$TARGET_CFG"
  echo "‚úì Using MCP client config from workspace: $TARGET_CFG"
elif is_valid_cfg "$SOURCE_CFG"; then
  cp "$SOURCE_CFG" "$WORKSPACE_CFG"
  cp "$SOURCE_CFG" "$TARGET_CFG"
  echo "‚úì Restored MCP client config from source: $TARGET_CFG"
else
  echo "‚ùå No valid MCP client config available (checked $WORKSPACE_CFG and $SOURCE_CFG)"
  if [ -f "$WORKSPACE_CFG" ]; then
    echo "   Workspace contents preview:"; head -c 200 "$WORKSPACE_CFG" 2>/dev/null || echo "   <unreadable>"
  fi
  if [ -f "$SOURCE_CFG" ]; then
    echo "   Source contents preview:"; head -c 200 "$SOURCE_CFG" 2>/dev/null || echo "   <unreadable>"
  fi
  exit 1
fi

MCP_CLIENT_CONFIG="$TARGET_CFG"
export MCP_CLIENT_CONFIG

if [ -f "$MCP_CLIENT_CONFIG" ]; then
  if command -v jq >/dev/null 2>&1; then
    echo "[client-config] summary:"
    if ! jq -r '"remoteTools=" + ((.remoteTools // []) | length | tostring) + ", localServers=" + ((.localServers // {} | keys) | join(","))' "$MCP_CLIENT_CONFIG" 2>/dev/null; then
      echo "  (not valid JSON)"
    fi
  fi
fi

echo "=== client-config.json ==="
if command -v jq >/dev/null 2>&1; then
  jq '.' "$MCP_CLIENT_CONFIG" 2>/dev/null || cat "$MCP_CLIENT_CONFIG"
else
  cat "$MCP_CLIENT_CONFIG"
fi
echo "=========================="

# Configure OpenCode config directory
mkdir -p "$HOME/.opencode"
if [ -f /task-files/opencode-config.json ]; then
  cp /task-files/opencode-config.json "$HOME/.opencode/config.json"
  echo "‚úì Installed opencode-config.json"
else
  echo "‚ö†Ô∏è opencode-config.json not provided; falling back to defaults"
fi

echo "=== MCP PRECHECKS ==="
if ! command -v toolman >/dev/null 2>&1; then
  echo "‚ùå 'toolman' CLI not found in PATH; required for MCP"
  exit 1
fi

TOOLMAN_URL=${TOOLMAN_SERVER_URL:-"http://toolman.agent-platform.svc.cluster.local:3000/mcp"}
TOOLMAN_URL="${TOOLMAN_URL%/}"
echo "üîç Checking Toolman endpoint: $TOOLMAN_URL"
TOOLMAN_RETRIES=3
TOOLMAN_WAIT=2
TOOLMAN_SUCCESS=false
for i in $(seq 1 $TOOLMAN_RETRIES); do
  if curl -sSf --connect-timeout 5 --max-time 10 \
    -X POST "$TOOLMAN_URL" \
    -H 'Content-Type: application/json' \
    -d '{"jsonrpc":"2.0","id":"health","method":"tools/list","params":{}}' >/tmp/toolman-ping.log 2>&1; then
    TOOLMAN_SUCCESS=true
    rm -f /tmp/toolman-ping.log
    break
  fi
  if [ $i -lt $TOOLMAN_RETRIES ]; then
    echo "‚ö†Ô∏è Toolman connectivity check failed (attempt $i/$TOOLMAN_RETRIES), retrying in ${TOOLMAN_WAIT}s..."
    cat /tmp/toolman-ping.log >&2 || true
    rm -f /tmp/toolman-ping.log
    sleep $TOOLMAN_WAIT
    TOOLMAN_WAIT=$((TOOLMAN_WAIT * 2))  # Exponential backoff
  fi
done

if [ "$TOOLMAN_SUCCESS" != "true" ]; then
  echo "‚ùå Unable to reach Toolman server at $TOOLMAN_URL after $TOOLMAN_RETRIES attempts"
  cat /tmp/toolman-ping.log >&2 || true
  rm -f /tmp/toolman-ping.log
  echo "‚ö†Ô∏è This may be an intermittent DNS/network issue. Proceeding anyway, but MCP tools may not work."
  echo "‚ö†Ô∏è If OpenCode execution fails, check Toolman service health and DNS resolution."
  # Don't exit - allow OpenCode to proceed in case Toolman comes back online
  # The MCP client will handle connection failures gracefully
fi
echo "‚úì Toolman endpoint check completed"

# Verify OpenCode provider API key is set based on config
OPENCODE_CONFIG_PATH="$HOME/.opencode/config.json"
if [ -f "$OPENCODE_CONFIG_PATH" ]; then
  PROVIDER_ENV_KEY=$(jq -r '.provider.envKey // "OPENAI_API_KEY"' "$OPENCODE_CONFIG_PATH")
else
  PROVIDER_ENV_KEY="OPENAI_API_KEY"
fi

if [ -z "${!PROVIDER_ENV_KEY:-}" ]; then
  echo "‚ùå $PROVIDER_ENV_KEY is not set; OpenCode cannot authenticate with its provider"
  exit 1
fi

echo "üîë Configuring OpenCode authentication (provider key: $PROVIDER_ENV_KEY)"

if [ ! -f "$OPENCODE_WORK_DIR/AGENTS.md" ]; then
  echo "‚ö†Ô∏è No AGENTS.md guidance file detected; creating placeholder"
  cat <<'PLACEHOLDER' > "$OPENCODE_WORK_DIR/AGENTS.md"
# Project Guidance

This OpenCode run was triggered without AGENTS.md content. Provide project context in AGENTS.md to give OpenCode richer instructions.
PLACEHOLDER
fi

# =========================================================================
# Prompt assembly and OpenCode execution
# =========================================================================

PROMPT_PREFIX=""

# Simple, focused context - let @ references do the heavy lifting
PROMPT_PREFIX="${PROMPT_PREFIX}## Task Context\n\n"
PROMPT_PREFIX="${PROMPT_PREFIX}You're working on **Task {{task_id}}** for service **{{service}}**.\n\n"
PROMPT_PREFIX="${PROMPT_PREFIX}**Required Reading:**\n"
PROMPT_PREFIX="${PROMPT_PREFIX}- @task/acceptance-criteria.md ‚Äî Your success criteria (complete ALL of these)\n"
PROMPT_PREFIX="${PROMPT_PREFIX}- @AGENTS.md ‚Äî Repository guidelines and workflow\n"
if [ -f "$OPENCODE_WORK_DIR/task/toolman-guide.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}- @task/toolman-guide.md ‚Äî Tool usage reference\n"
fi
if [ -f "$OPENCODE_WORK_DIR/coding-guidelines.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}- @coding-guidelines.md ‚Äî Coding standards\n"
fi
if [ -f "$OPENCODE_WORK_DIR/github-guidelines.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}- @github-guidelines.md ‚Äî Git workflow\n"
fi

PROMPT_PREFIX="${PROMPT_PREFIX}\n**Key Requirements:**\n"
PROMPT_PREFIX="${PROMPT_PREFIX}- Implement ALL acceptance criteria before completing\n"
PROMPT_PREFIX="${PROMPT_PREFIX}- Write production code (no TODOs or placeholders)\n"
PROMPT_PREFIX="${PROMPT_PREFIX}- Commit frequently and create a PR when done\n"
PROMPT_PREFIX="${PROMPT_PREFIX}- Run quality gates (cargo fmt, clippy, test) before finishing\n"
PROMPT_PREFIX="${PROMPT_PREFIX}- You're on branch \`feature/task-{{task_id}}-implementation\`\n"
PROMPT_PREFIX="${PROMPT_PREFIX}- GitHub auth is pre-configured (GH_TOKEN is set)\n\n"
PROMPT_PREFIX="${PROMPT_PREFIX}---\n\n"

# Resilient verification of task files
echo "üîç RESILIENT VERIFICATION: Checking task files at: $OPENCODE_WORK_DIR/task/"
if verify_task_files "$OPENCODE_WORK_DIR/task" "{{task_id}}"; then
    echo "‚úÖ Task files verification: PASSED"
else
    echo "‚ùå CRITICAL: Task files verification: FAILED"
    create_error_report "$OPENCODE_WORK_DIR/task" "{{task_id}}" "Task files missing before agent execution"
    
    # Attempt recovery
    if attempt_task_recovery "/tmp/docs-repo" "$OPENCODE_WORK_DIR/task" "{{task_id}}"; then
        echo "‚úÖ Recovery successful - continuing with execution"
    else
        echo "‚ùå Recovery failed - cannot proceed without prompt.md"
        exit 1
    fi
fi

PROMPT_FILE="$OPENCODE_WORK_DIR/task/prompt.md"
echo "üìÑ Using prompt file: $PROMPT_FILE"

echo "startingTask:{{task_id}}"
echo ""

PROMPT_CONTENT="${PROMPT_PREFIX}$(cat "$PROMPT_FILE")"

# Print prompt preview (similar to Factory/Claude CLIs)
echo "üì§ Sending prompt to OpenCode/Grok (truncated to 2000 chars for log safety):"
echo "=================================================================================="
PROMPT_PREVIEW=$(printf '%s' "$PROMPT_CONTENT" | head -c 2000)
printf '%s\n' "$PROMPT_PREVIEW"
echo "..."
echo "=================================================================================="
PROMPT_BYTES=$(printf '%s' "$PROMPT_CONTENT" | wc -c | tr -d '[:space:]')
echo "üìè Total prompt size: $PROMPT_BYTES bytes"
echo ""

ORIGINAL_PROMPT="$PROMPT_CONTENT"
PREVIOUS_MESSAGE_FILE=""

# Grok Code Fast 1 has 256k context window - MAX IT OUT
TOKEN_LIMIT=${OPENCODE_TOKEN_LIMIT:-256000}

# Grok is fast (190 tokens/sec) so can handle longer timeouts
OPENCODE_TIMEOUT=${OPENCODE_EXEC_TIMEOUT:-2400}  # 40 minutes (was 30)

RESET_SESSION_ON_RETRY=${OPENCODE_RESET_SESSION_ON_RETRY:-1}
CONTINUE_SESSION=${OPENCODE_CONTINUE_SESSION:-1}

# Reasonable retries for Grok - not too many to waste tokens
# Special case: 0 means unlimited (keep going until acceptance criteria met)
MAX_RETRIES=${OPENCODE_MAX_RETRIES:-${EXECUTION_MAX_RETRIES:-10}}
if [ "$MAX_RETRIES" = "0" ]; then
  echo "üîÑ Unlimited retries enabled - will continue until acceptance criteria met"
  UNLIMITED_RETRIES=1
else
  UNLIMITED_RETRIES=0
fi

# Output format: json (structured, parseable) or markdown (human-readable)
# JSON is better for automated parsing (session IDs, circuit breaker, token tracking)
# MARKDOWN is better for human observation during development/debugging
# Set OPENCODE_VERBOSE=1 to use markdown format for readability
if [ "${OPENCODE_VERBOSE:-0}" = "1" ]; then
  OPENCODE_FORMAT="markdown"
  # Only set log level if not explicitly provided by user
  if [ -z "${OPENCODE_LOG_LEVEL:-}" ]; then
    OPENCODE_LOG_LEVEL="INFO"
  fi
  echo "üì¢ Verbose mode enabled - using markdown format with ${OPENCODE_LOG_LEVEL} log level for readability"
  if [ "${OPENCODE_LOG_LEVEL}" != "DEBUG" ]; then
    echo "   To see even more detail, set OPENCODE_LOG_LEVEL=DEBUG"
  fi
else
  OPENCODE_FORMAT=${OPENCODE_FORMAT:-json}
  # Only set log level if not explicitly provided by user
  if [ -z "${OPENCODE_LOG_LEVEL:-}" ]; then
    OPENCODE_LOG_LEVEL="DEBUG"
  fi
fi

ATTEMPT=1
SUCCESS=0
OPENCODE_EXIT=1
LAST_MESSAGE_FILE=""
RUN_LOG=""
COMPLETION_REASON=""
LAST_COMPLETION_REASON=""
NEXT_ITERATION_GUIDANCE=""

SESSION_DIR="$HOME/.opencode/sessions"
LATEST_SESSION_ID=""

# Circuit breaker: track repeated command failures
declare -A FAILED_COMMANDS
MAX_SAME_COMMAND_FAILURES=3

# Session continuation: retry within same session when no tools used
MAX_CONTINUATION_RETRIES=5

# Helper: Check if response had any tool calls
has_tool_calls() {
  local log_file="$1"
  if [ ! -f "$log_file" ]; then
    return 1
  fi
  
  # Check for tool_use events in the JSON log
  if grep -q '"type":"tool_use"' "$log_file" 2>/dev/null; then
    return 0
  fi
  return 1
}

has_existing_sessions() {
  local session_dir="$1"
  if [ ! -d "$session_dir" ]; then
    return 1
  fi

  for session_file in "$session_dir"/*.json; do
    if [ -f "$session_file" ]; then
      return 0
    fi
  done

  return 1
}

extract_session_id() {
  local log_file="$1"
  [ -f "$log_file" ] || return 1
  if command -v jq >/dev/null 2>&1; then
    jq -r 'select(.sessionID != null) | .sessionID' "$log_file" 2>/dev/null | tail -n1 | tr -d '\r' | tr -d '\n'
  else
    awk '
      {
        gsub(/\033\[[0-9;]*[mK]/, "");
        if ($0 ~ /sessionID"[[:space:]]*:[[:space:]]*"[0-9a-fA-F-]{4,}/) {
          match($0, /sessionID"[[:space:]]*:[[:space:]]*"([0-9a-fA-F-]+)/, a);
          if (a[1] != "") last=a[1];
        } else if ($0 ~ /opencode session[[:space:]]+[0-9a-fA-F-]{4,}/) {
          match($0, /opencode session[[:space:]]+([0-9a-fA-F-]+)/, a);
          if (a[1] != "") last=a[1];
        }
      }
      END {
        if (last != "") print last;
      }
    ' "$log_file" 2>/dev/null
  fi
}

print_attempt_banner() {
  local attempt="$1"
  local max="$2"
  local unlimited="$3"
  local border="‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  local label

  if [ "$unlimited" = "1" ]; then
    label="‚ïë üöÄ EXECUTION ATTEMPT #${attempt} (UNLIMITED MODE)"
  elif [ -n "$max" ] && [ "$max" -gt 0 ]; then
    label="‚ïë üöÄ EXECUTION ATTEMPT ${attempt} / ${max}"
  else
    label="‚ïë üöÄ EXECUTION ATTEMPT #${attempt}"
  fi

  local base_padding=$(( ${#border} - ${#label} - 1 ))
  local extra_width=0

  if [[ "$label" == *"üöÄ"* ]]; then
    extra_width=$((extra_width + 1))
  fi

  local padding=$((base_padding - extra_width))
  if [ $padding -lt 0 ]; then
    padding=0
  fi

  echo ""
  echo "$border"
  printf '%s%*s‚ïë\n' "$label" "$padding" ""
  echo "$border"
  echo ""
}

if [ "$CONTINUE_SESSION" = "1" ]; then
  if ! has_existing_sessions "$SESSION_DIR"; then
    echo "‚ÑπÔ∏è No existing OpenCode sessions detected; starting new session"
    CONTINUE_SESSION=0
  fi
fi

write_last_message() {
  local log_file="$1"
  local dest_file="$2"
  [ -f "$log_file" ] || return 1

  if command -v jq >/dev/null 2>&1; then
    local last_text
    last_text=$(jq -r '
      select(.type == "text")
      | (if (.text | type) == "object" then .text.text
         else if (.part | type) == "object" then .part.text
         else .text end)
      | select(. != null and . != "")
    ' "$log_file" 2>/dev/null | tail -n1)

    if [ -n "$last_text" ]; then
      printf '%s\n' "$last_text" > "$dest_file"
      return 0
    fi
  fi

  tail -n 100 "$log_file" 2>/dev/null > "$dest_file"
  return 0
}

if [ "$CONTINUE_SESSION" = "1" ]; then
  echo "‚ÑπÔ∏è OpenCode will attempt to continue the most recent session when available."
else
  if [ -d "$SESSION_DIR" ]; then
    find "$SESSION_DIR" -maxdepth 1 -type f -name '*.json' -delete 2>/dev/null || true
  fi
fi

# =========================================================================
# Model rotation configuration
# =========================================================================
DEFAULT_MODEL="{{model}}"
MODEL_ROTATION=()
MODEL_ROTATION_COUNT=0
{{#if model_rotation}}
MODEL_ROTATION=(
{{#each model_rotation}}
"{{this}}"
{{/each}}
)
MODEL_ROTATION_COUNT=${#MODEL_ROTATION[@]}
if [ $MODEL_ROTATION_COUNT -gt 0 ]; then
  echo "üéØ Model rotation enabled (${MODEL_ROTATION_COUNT} models): ${MODEL_ROTATION[*]}"
fi
{{/if}}
if [ -z "$DEFAULT_MODEL" ] && [ $MODEL_ROTATION_COUNT -gt 0 ]; then
  DEFAULT_MODEL="${MODEL_ROTATION[0]}"
fi
if [ -n "$DEFAULT_MODEL" ]; then
  echo "üéØ Default model: $DEFAULT_MODEL"
fi

COMPLETED_ATTEMPTS=0
while [ "$UNLIMITED_RETRIES" = "1" ] || [ $ATTEMPT -le $MAX_RETRIES ]; do
  print_attempt_banner "$ATTEMPT" "$MAX_RETRIES" "$UNLIMITED_RETRIES"

  # Calculate which model to use for this attempt
  CURRENT_MODEL="$DEFAULT_MODEL"
  if [ $MODEL_ROTATION_COUNT -gt 0 ]; then
    MODEL_INDEX=$(((ATTEMPT - 1) % MODEL_ROTATION_COUNT))
    CURRENT_MODEL="${MODEL_ROTATION[$MODEL_INDEX]}"
  fi
  if [ -n "$CURRENT_MODEL" ]; then
    echo "üéØ Attempt $ATTEMPT will use model: $CURRENT_MODEL"
    
    # Update opencode config with current model (format: provider/model)
    if [ -f "$HOME/.opencode/config.json" ]; then
      jq --arg model "$CURRENT_MODEL" '.model = $model' "$HOME/.opencode/config.json" > /tmp/opencode-config-rotated.json && \
      mv /tmp/opencode-config-rotated.json "$HOME/.opencode/config.json"
    fi
  fi

  # Always refresh the GitHub token before starting a new iteration to avoid credential expiry
  refresh_github_token || true

  CURRENT_ATTEMPT=$ATTEMPT
  LAST_MESSAGE_FILE="/tmp/opencode-last-message-${ATTEMPT}.txt"
  RUN_LOG="/tmp/opencode-run-${ATTEMPT}.jsonl"

  if [ "$RESET_SESSION_ON_RETRY" = "1" ] && [ "$CONTINUE_SESSION" != "1" ] && [ $ATTEMPT -gt 1 ] && [ -d "$SESSION_DIR" ]; then
    find "$SESSION_DIR" -maxdepth 1 -type f -name '*.json' -delete 2>/dev/null || true
  fi

  # Inner continuation loop counter
  CONTINUATION_ATTEMPT=0

  if [ $ATTEMPT -eq 1 ]; then
    PROMPT_PAYLOAD="$ORIGINAL_PROMPT"
  else
    if [ -n "$PREVIOUS_MESSAGE_FILE" ] && [ -s "$PREVIOUS_MESSAGE_FILE" ]; then
      PREVIOUS_SNIPPET=$(tail -n 40 "$PREVIOUS_MESSAGE_FILE" 2>/dev/null | sed 's/^/    /')
    else
      PREVIOUS_SNIPPET="    <no previous output available>"
    fi
    PROMPT_PAYLOAD="## Continuation - Attempt $ATTEMPT/$MAX_RETRIES

The task isn't complete yet. Here's what you said last time:

$PREVIOUS_SNIPPET

**Next steps:**
1. Review @task/acceptance-criteria.md to see what's still missing
2. Implement the remaining requirements
3. Commit your changes and push
4. Verify all acceptance criteria are met

Continue working on the incomplete items."
    if [ -n "$NEXT_ITERATION_GUIDANCE" ]; then
      PROMPT_PAYLOAD="${PROMPT_PAYLOAD}

${NEXT_ITERATION_GUIDANCE}"
    fi
  fi

  # Inner loop: keep session alive when model returns text-only (no tools)
  while [ $CONTINUATION_ATTEMPT -le $MAX_CONTINUATION_RETRIES ]; do
    if [ $CONTINUATION_ATTEMPT -gt 0 ]; then
      echo "üîÑ Continuation $CONTINUATION_ATTEMPT/$MAX_CONTINUATION_RETRIES (keeping session alive)"
      PROMPT_PAYLOAD="The task is not complete yet. **Use tools** to continue working on the remaining requirements.

Remaining work:
- Review acceptance criteria: \`cat task/acceptance-criteria.md\`  
- Check what's been done: \`git status\` and \`git log\`
- Fix any errors or incomplete implementations
- Run quality gates (cargo fmt, cargo clippy, cargo test)
- Commit and push changes
- Create or update PR

**Important:** Do not just explain - take action with tools to complete the task."
      if [ -n "$NEXT_ITERATION_GUIDANCE" ]; then
        PROMPT_PAYLOAD="${PROMPT_PAYLOAD}

${NEXT_ITERATION_GUIDANCE}"
      fi
      RUN_LOG="/tmp/opencode-run-${ATTEMPT}-cont${CONTINUATION_ATTEMPT}.jsonl"
    fi
    
    set +e
    set -o pipefail
    # Write prompt to temp file to avoid "Argument list too long" error
    PROMPT_FILE="/tmp/opencode-prompt-${ATTEMPT}-${CONTINUATION_ATTEMPT}.txt"
    printf '%s' "$PROMPT_PAYLOAD" > "$PROMPT_FILE"
    
    OPENCODE_CMD=(
      "opencode"
      "run"
      "--format"
      "$OPENCODE_FORMAT"
      "--log-level"
      "$OPENCODE_LOG_LEVEL"
    )
    if [ "$CONTINUE_SESSION" = "1" ]; then
      if [ -n "$LATEST_SESSION_ID" ]; then
        OPENCODE_CMD+=("--session" "$LATEST_SESSION_ID")
      else
        OPENCODE_CMD+=("--continue")
      fi
    fi
    
    # Pass prompt via stdin to handle large prompts
    if command -v timeout >/dev/null 2>&1; then
      timeout "$OPENCODE_TIMEOUT" "${OPENCODE_CMD[@]}" < "$PROMPT_FILE" | tee "$RUN_LOG"
    else
      "${OPENCODE_CMD[@]}" < "$PROMPT_FILE" | tee "$RUN_LOG"
    fi
    OPENCODE_EXIT=${PIPESTATUS[0]}
    set +o pipefail
    set -e
    
    # Clean up prompt file
    rm -f "$PROMPT_FILE"
    
    # Check if this run had tool calls
    if has_tool_calls "$RUN_LOG"; then
      echo "‚úÖ Session produced tool calls - good progress"
      break
    else
      echo "‚ö†Ô∏è No tool calls detected - model stuck in explanation mode"
      if [ $CONTINUATION_ATTEMPT -ge $MAX_CONTINUATION_RETRIES ]; then
        echo "‚ùå Max continuation retries reached - moving to next attempt"
        break
      fi
    fi
    
    CONTINUATION_ATTEMPT=$((CONTINUATION_ATTEMPT + 1))
  done

  if [ $OPENCODE_EXIT -eq 124 ]; then
    echo "‚è±Ô∏è OpenCode command exceeded ${OPENCODE_TIMEOUT}s timeout; terminating session"
    pkill -f "opencode" 2>/dev/null || true
    PREVIOUS_MESSAGE_FILE="$LAST_MESSAGE_FILE"
    COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
    ATTEMPT=$((ATTEMPT + 1))
    continue
  fi

  echo "[opencode-debug] Attempt $ATTEMPT finished with exit code $OPENCODE_EXIT"

  if [ $OPENCODE_EXIT -ne 0 ]; then
    echo "‚ö†Ô∏è OpenCode exited with status $OPENCODE_EXIT on attempt $ATTEMPT"
  fi

  # Circuit breaker: detect repeated failing bash commands
  if [ -f "$RUN_LOG" ]; then
    # Extract failed bash commands from the log
    FAILED_CMD=$(jq -r 'select(.type=="tool_use" and .part.tool=="bash" and .part.state.status=="completed" and .part.state.metadata.exit!=0) | .part.state.input.command' "$RUN_LOG" 2>/dev/null | tail -n1 | head -c 100)
    
    if [ -n "$FAILED_CMD" ]; then
      # Track how many times this command has failed
      FAILED_COMMANDS["$FAILED_CMD"]=$((${FAILED_COMMANDS["$FAILED_CMD"]:-0} + 1))
      FAIL_COUNT=${FAILED_COMMANDS["$FAILED_CMD"]}
      
      if [ $FAIL_COUNT -ge $MAX_SAME_COMMAND_FAILURES ]; then
        echo "üî¥ CIRCUIT BREAKER TRIGGERED: Command has failed $FAIL_COUNT times in a row:"
        echo "   Command: $FAILED_CMD"
        echo "   This indicates the agent is stuck in a loop. Adding explicit guidance..."
        
        # Force a stronger prompt for next retry
        PROMPT_PAYLOAD="‚ö†Ô∏è **LOOP DETECTED**: You have tried this command $FAIL_COUNT times:
\`\`\`bash
$FAILED_CMD
\`\`\`

It keeps failing with the same error. **STOP REPEATING THIS COMMAND.**

Instead:
1. Check your working directory with \`pwd\`
2. List files with \`ls -la\`
3. Try a completely different approach (create files one at a time, use different syntax, etc.)
4. If directories don't exist, create them step-by-step and verify each step

Continuing Task {{task_id}} - focus on solving the underlying issue, not repeating the same failed command."
        
        # Reset the counter to give it a fresh chance with new guidance
        FAILED_COMMANDS["$FAILED_CMD"]=0
      fi
    fi
  fi

  write_last_message "$RUN_LOG" "$LAST_MESSAGE_FILE" || true

  if [ -s "$LAST_MESSAGE_FILE" ]; then
    echo "üìù OpenCode summary (attempt $ATTEMPT):"
    sed 's/^/    /' "$LAST_MESSAGE_FILE"
  else
    echo "‚ÑπÔ∏è No textual summary captured from OpenCode on attempt $ATTEMPT"
  fi

  NEW_SESSION_ID=""
  if [ -n "$RUN_LOG" ] && [ -f "$RUN_LOG" ]; then
    NEW_SESSION_ID=$(extract_session_id "$RUN_LOG" || true)
  fi
  if [ -n "$NEW_SESSION_ID" ]; then
    if [ "$LATEST_SESSION_ID" != "$NEW_SESSION_ID" ]; then
      echo "‚ÑπÔ∏è  Captured OpenCode session ID: $NEW_SESSION_ID"
      LATEST_SESSION_ID="$NEW_SESSION_ID"
    fi
    CONTINUE_SESSION=1
  fi

  PREVIOUS_MESSAGE_FILE="$LAST_MESSAGE_FILE"

  if [ "${TOKEN_LIMIT:-0}" -gt 0 ] && [ -f "$RUN_LOG" ]; then
    LAST_TOKENS=$(grep -Eo 'tokens used: [0-9,]+' "$RUN_LOG" 2>/dev/null | tail -n1 | awk '{print $3}' | tr -d ',' | tr -d '\n' || true)
    if [[ "$LAST_TOKENS" =~ ^[0-9]+$ ]]; then
      echo "üìä OpenCode tokens used this attempt: $LAST_TOKENS"
      if [ "$LAST_TOKENS" -gt "$TOKEN_LIMIT" ]; then
        echo "‚ö†Ô∏è Token usage $LAST_TOKENS exceeds limit $TOKEN_LIMIT; forcing clean session before retry"
        if [ -d "$SESSION_DIR" ]; then
          find "$SESSION_DIR" -maxdepth 1 -type f -name '*.json' -delete 2>/dev/null || true
        fi
        PREVIOUS_MESSAGE_FILE="$LAST_MESSAGE_FILE"
        COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
        ATTEMPT=$((ATTEMPT + 1))
        continue
      fi
    fi
  fi

  COMPLETION_REASON=""
  # Rex-specific completion criteria (implementation-focused, not quality-focused)
  if [[ "{{github_app}}" == *"Rex"* ]] || [[ "{{github_app}}" == *"rex"* ]]; then
    COMPLETION_PROMPT="Task {{task_id}} completion verification ‚Äî Rex Implementation Agent

**Your Role**: You are Rex, the IMPLEMENTATION agent. Cleo will handle code quality in the next stage.

**FIRST**: Review the FUNCTIONAL requirements in task/acceptance-criteria.md

**Then answer 'yes' if ALL of these are true:**

1. **FUNCTIONAL acceptance criteria implemented** (features exist and basically work)
2. Code COMPILES successfully (\`cargo build\` passes)
3. All code changes are committed to git
4. Changes are pushed to remote branch feature/task-{{task_id}}-implementation

**Code quality issues are OK for Rex - Cleo will fix:**
- ‚ö†Ô∏è Clippy warnings? OK - Cleo will fix
- ‚ö†Ô∏è Formatting issues? OK - Cleo will fix  
- ‚ö†Ô∏è Some tests failing? OK if basic functionality works - Cleo/Tess will fix
- ‚ö†Ô∏è Unused functions/variables? OK - Cleo will clean up

**Focus on**: Does the implementation work? Are the features there?

**Response format:**

If functionally complete (features work, code compiles, PR created), respond with: yes

If features incomplete or code doesn't compile, respond with:
no
REASON: <specific FUNCTIONAL issue>

Example 'yes' response (even with warnings):
yes

Example 'no' response:
no
REASON: Acceptance criteria 2 incomplete - health endpoint not yet implemented. Feature work remains.

Your response:"
  else
    # Default completion prompt for other agents (Cleo, Tess)
    COMPLETION_PROMPT="Task {{task_id}} completion verification.

**FIRST**: Review the acceptance criteria in task/acceptance-criteria.md

**Then answer 'yes' ONLY if ALL of these are true:**

1. **EVERY acceptance criterion is fully implemented** (not just started, but DONE)
2. All code changes are committed to git
3. Changes are pushed to remote branch feature/task-{{task_id}}-implementation
4. A pull request exists (with at least task-{{task_id}} label; other labels are optional)
5. Quality gates passed (cargo fmt, cargo clippy with no warnings, tests pass)

**Be honest**: If ANY acceptance criterion is incomplete or partially implemented, answer 'no' and continue working.

**To verify:**
- Review: \`cat task/acceptance-criteria.md\`
- Git status: \`git status\`
- Commits pushed: \`git log origin/main..HEAD\`
- PR exists: \`gh pr view\`
- Tests pass: Check your test results

**Response format:**

If complete, respond with: yes

If incomplete, respond with:
no
REASON: <specific reason why not complete>

For 'no' responses, REASON must specify:
- Which acceptance criteria are incomplete (list them by number/name)
- What specific work remains (be concrete)
- Any blockers or issues encountered

Example 'no' response:
no
REASON: Acceptance criteria 2 and 4 incomplete. API endpoint /users created but not yet connected to database. PR created but tests failing due to missing error handling in user_controller.rs.

Your response:"
  fi
  COMPLETION_LAST_MESSAGE="/tmp/opencode-completion-${ATTEMPT}.txt"
  COMPLETION_LOG="/tmp/opencode-completion-${ATTEMPT}.jsonl"

  COMPLETION_RESPONSE=""
  if [ "$CONTINUE_SESSION" = "1" ]; then
    # Write completion prompt to file (same pattern as main prompt)
    COMPLETION_PROMPT_FILE="/tmp/opencode-completion-prompt-${ATTEMPT}.txt"
    printf '%s' "$COMPLETION_PROMPT" > "$COMPLETION_PROMPT_FILE"
    
    set +e
    set -o pipefail
    COMPLETION_CMD=(
      "opencode"
      "run"
      "--format"
      "$OPENCODE_FORMAT"
      "--log-level"
      "$OPENCODE_LOG_LEVEL"
    )
    if [ -n "$LATEST_SESSION_ID" ]; then
      COMPLETION_CMD+=("--session" "$LATEST_SESSION_ID")
    else
      COMPLETION_CMD+=("--continue")
    fi
    
    # Pass completion prompt via stdin
    "${COMPLETION_CMD[@]}" < "$COMPLETION_PROMPT_FILE" | tee "$COMPLETION_LOG"
    COMPLETION_EXIT=${PIPESTATUS[0]}
    set +o pipefail
    set -e
    
    # Clean up prompt file
    rm -f "$COMPLETION_PROMPT_FILE"

    if [ $COMPLETION_EXIT -ne 0 ]; then
      echo "‚ö†Ô∏è Completion probe exited with status $COMPLETION_EXIT"
    fi

    write_last_message "$COMPLETION_LOG" "$COMPLETION_LAST_MESSAGE" || true

    echo "[opencode-debug] Completion probe for attempt $ATTEMPT exited $COMPLETION_EXIT"

    if [ -s "$COMPLETION_LAST_MESSAGE" ]; then
      COMPLETION_RESPONSE_RAW=$(tr -d '\r' < "$COMPLETION_LAST_MESSAGE")
      COMPLETION_RESPONSE=$(printf '%s\n' "$COMPLETION_RESPONSE_RAW" | tr '[:upper:]' '[:lower:]')
      echo "üßÆ Completion probe response: $COMPLETION_RESPONSE"
      
      # Extract reason if response is 'no'
      if printf '%s\n' "$COMPLETION_RESPONSE" | grep -Eq '^no'; then
        COMPLETION_REASON=$(printf '%s\n' "$COMPLETION_RESPONSE_RAW" | awk 'BEGIN{IGNORECASE=1}/^reason:/{sub(/^reason:[[:space:]]*/,"");flag=1} flag{print}')
        if [ -n "$COMPLETION_REASON" ]; then
          echo "üìã Incompletion details:"
          echo "$COMPLETION_REASON"
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "‚ïë üîÅ NEXT ITERATION FOCUS (FROM COMPLETION PROBE)              ‚ïë"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          printf '%s\n' "$COMPLETION_REASON"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo ""
          printf -v NEXT_ITERATION_GUIDANCE $'üîÅ **NEXT ITERATION FOCUS (from completion probe attempt %s)**\n\n%s\n\nAddress the items above before rerunning checks.' "$ATTEMPT" "$COMPLETION_REASON"
          LAST_COMPLETION_REASON="$COMPLETION_REASON"
        else
          echo "‚ö†Ô∏è No reason provided for incomplete status"
        fi
      fi
    fi
  else
    echo "‚ÑπÔ∏è Completion probe skipped (session continuation disabled)"
  fi

  if echo "$COMPLETION_RESPONSE" | grep -Eq '^yes'; then
    SUCCESS=1
    COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
    break
  fi

  echo "[opencode-debug] Completion response on attempt $ATTEMPT: $COMPLETION_RESPONSE"

  if [ -n "$COMPLETION_REASON" ]; then
    echo "‚ö†Ô∏è OpenCode reported task incomplete; retrying with new guidance..."
  else
    echo "‚ö†Ô∏è OpenCode reported task incomplete; retrying..."
  fi
  COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
  ATTEMPT=$((ATTEMPT + 1))
done

FINAL_ATTEMPTS=$COMPLETED_ATTEMPTS
if [ "${FINAL_ATTEMPTS:-0}" -le 0 ]; then
  FINAL_ATTEMPTS=$((ATTEMPT - 1))
fi
if [ "$UNLIMITED_RETRIES" != "1" ] && [ $FINAL_ATTEMPTS -gt $MAX_RETRIES ]; then
  FINAL_ATTEMPTS=$MAX_RETRIES
fi

if [ -z "$COMPLETION_REASON" ] && [ -n "$LAST_COMPLETION_REASON" ]; then
  COMPLETION_REASON="$LAST_COMPLETION_REASON"
fi

if [ $SUCCESS -ne 1 ]; then
  if [ "$UNLIMITED_RETRIES" = "1" ]; then
    echo "‚ö†Ô∏è OpenCode did not confirm task completion after $FINAL_ATTEMPTS attempts (unlimited mode)"
  else
    echo "‚ö†Ô∏è OpenCode did not confirm task completion after $MAX_RETRIES attempts"
  fi
  
  # Display the last recorded reason for incompletion
  if [ -n "$COMPLETION_REASON" ]; then
    echo ""
    echo "üí° Last reported reason for incompletion:"
    echo "$COMPLETION_REASON"
  fi
  
  # Document remaining work for downstream agents (Cleo/Tess)
  echo ""
  echo "üìù Creating handoff document for Cleo..."
  HANDOFF_FILE="$OPENCODE_WORK_DIR/task/rex-handoff.md"
  mkdir -p "$OPENCODE_WORK_DIR/task"
  
  # Prepare handoff content with proper variable expansion
  HANDOFF_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
  if [ -n "$COMPLETION_REASON" ]; then
    REMAINING_WORK="$COMPLETION_REASON"
  else
    REMAINING_WORK="Review the completion probe responses in the logs above for details on what remains to be done."
  fi
  
  cat > "$HANDOFF_FILE" << EOF
# Rex Implementation Handoff

**Status**: Incomplete after $FINAL_ATTEMPTS iterations (max: $MAX_RETRIES)
**Date**: $HANDOFF_DATE
**Task**: {{task_id}}

## What Was Accomplished

Rex made $FINAL_ATTEMPTS attempts to complete this task. Review the PR and commit history for details on what was implemented.

## Remaining Work

$REMAINING_WORK

Compare current implementation against acceptance criteria in task/acceptance-criteria.md.

## Next Steps for Cleo

1. Review the PR created by Rex
2. Identify gaps between current implementation and acceptance criteria
3. Complete any remaining implementation work
4. Ensure all quality checks pass before handing off to Tess

## Acceptance Criteria Reference

See \`task/acceptance-criteria.md\` for complete requirements.

---
*Generated by Rex (OpenCode) after $FINAL_ATTEMPTS implementation attempts*
EOF

  echo "‚úÖ Handoff document created at task/rex-handoff.md"
  
  # Commit and push the handoff document
  cd "$OPENCODE_WORK_DIR"
  git add task/rex-handoff.md 2>/dev/null || true
  
  # Build commit message with proper variable expansion
  COMMIT_MSG="docs(task-{{task_id}}): add Rex handoff document

Rex completed $FINAL_ATTEMPTS implementation iterations with incomplete status (max: $MAX_RETRIES).
Handoff document created for Cleo to continue work."
  
  if [ -n "$COMPLETION_REASON" ]; then
    COMMIT_MSG="$COMMIT_MSG

Reason: $COMPLETION_REASON"
  fi
  
  git commit -m "$COMMIT_MSG" 2>/dev/null || echo "‚ö†Ô∏è Could not commit handoff document"
  
  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
  if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "master" ]; then
    git push origin HEAD 2>/dev/null || echo "‚ö†Ô∏è Could not push handoff document"
  fi
  
  echo ""
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo "‚ïë          TASK COMPLETION STATUS: PARTIAL - HANDOFF           ‚ïë"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo ""
  echo "üîÑ NEXT STEPS:"
  echo "   - Handoff document created at task/rex-handoff.md"
  echo "   - Workflow will continue to Cleo for completion"
  echo "   - Cleo will review PR and finish remaining work"
  echo ""
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  
  EXIT_CODE=0  # Always exit successfully to allow Cleo to continue
else
  echo "‚úÖ OpenCode confirmed task completion"
  if [ ${OPENCODE_EXIT:-0} -ne 0 ]; then
    echo "‚ö†Ô∏è OpenCode returned non-zero exit code ${OPENCODE_EXIT}, but completion probe passed"
  fi
  EXIT_CODE=0
fi

if [ $SUCCESS -eq 1 ]; then
  echo "üîç Verifying pull request status"
  ensure_pr_created
elif [[ "{{github_app}}" =~ [Rr]ex ]] && [ "$WORKFLOW_STAGE" = "implementation" ]; then
  echo "üîç Rex implementation agent - creating PR even though completion unconfirmed"
  ensure_pr_created || echo "‚ö†Ô∏è PR creation failed or no PR was created"
else
  echo "‚ö†Ô∏è Skipping auto PR enforcement due to OpenCode completion status"
fi

RESOLVED_PR_URL="$(resolve_pr_url)"

if [ $SUCCESS -eq 1 ]; then
  patch_coderun_status \
    "Running" \
    "Implementation completed - ready for quality review" \
    "ready-for-qa" \
    "" \
    "$RESOLVED_PR_URL" \
    "false"
else
  STATUS_NOTE="$COMPLETION_REASON"
  if [ -z "$STATUS_NOTE" ]; then
    STATUS_NOTE="Implementation requires follow-up"
  fi

  patch_coderun_status \
    "Running" \
    "$STATUS_NOTE" \
    "needs-fixes" \
    "" \
    "$RESOLVED_PR_URL" \
    "false"
fi

# Submit GitHub PR review for Cleo/Tess stages (enables workflow progression)
# Map CodeRun stage values to workflow stage labels expected by container logic
case "${WORKFLOW_STAGE:-}" in
  "quality")
    WORKFLOW_STAGE="quality-in-progress"
    ;;
  "testing")
    WORKFLOW_STAGE="testing-in-progress"
    ;;
  *)
    # Use existing value for other stages (implementation, etc.)
    ;;
esac

if [ "$WORKFLOW_STAGE" = "quality" ] || [ "$WORKFLOW_STAGE" = "security" ] || [ "$WORKFLOW_STAGE" = "testing" ]; then
  PR_NUM="${PR_NUMBER:-}"
  if [ -z "$PR_NUM" ]; then
    # Try to get PR number from current branch
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
    if [ -n "$CURRENT_BRANCH" ]; then
      PR_NUM=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")
    fi
  fi

  if [ -n "$PR_NUM" ]; then
    if [ $SUCCESS -eq 1 ]; then
      STAGE_NAME="Quality"
      STAGE_EMOJI="üõ°Ô∏è"
      CHECKS_PASSED=$'- Code formatting verified
- Linting passed
- Unit tests successful
- Quality standards met'
      NEXT_STAGE="end-to-end testing by Tess"
      
      if [ "$WORKFLOW_STAGE" = "security" ] || [ "$WORKFLOW_STAGE" = "security-in-progress" ]; then
        # Cipher security review
        STAGE_NAME="Security"
        STAGE_EMOJI="üîí"
        CHECKS_PASSED=$'- No vulnerabilities detected
- Dependency audit passed
- Secret scanning completed
- Security best practices verified'
        NEXT_STAGE="QA testing by Tess"
        
        echo "‚úÖ $STAGE_NAME checks passed - handing off to Tess"
        REVIEW_BODY_FILE=$(mktemp)
        cat <<EOF > "$REVIEW_BODY_FILE"
### $STAGE_EMOJI $STAGE_NAME Review - PASSED
All security checks have passed:
$CHECKS_PASSED

**Status:** Ready for $NEXT_STAGE
**Next Step:** Tess will now perform comprehensive QA validation

---
*Security review by Cipher*
EOF
        refresh_token_if_needed || true
        timeout 30 gh pr comment "$PR_NUM" --body-file "$REVIEW_BODY_FILE" 2>&1 || echo "‚ö†Ô∏è PR comment command failed"
        rm -f "$REVIEW_BODY_FILE"
        
        # Add security-approved label
        echo "üè∑Ô∏è  Adding 'security-approved' label"
        timeout 30 gh pr edit "$PR_NUM" --add-label "security-approved" 2>&1 || echo "‚ö†Ô∏è Failed to add security-approved label"
      elif [ "$WORKFLOW_STAGE" = "testing" ]; then
        # Tess has final approval authority
        STAGE_NAME="QA Testing"
        STAGE_EMOJI="üß™"
        CHECKS_PASSED=$'- End-to-end tests passed
- Integration tests successful
- Acceptance criteria validated
- Production readiness confirmed'
        NEXT_STAGE="human review and merge"
        
        # Check if this is the final task requiring deployment verification
        DEPLOYMENT_STATUS=""
        if [ "${FINAL_TASK:-false}" = "true" ]; then
          echo "üéØ Final task detected - verifying Kubernetes deployment"
          
          # Extract service name from repository or use default
          SERVICE_NAME="${SERVICE_NAME:-$(basename "$REPOSITORY" .git)}"
          NAMESPACE="${NAMESPACE:-agent-platform}"
          
          # Check for deployment
          if kubectl get deployment "$SERVICE_NAME" -n "$NAMESPACE" &>/dev/null; then
            READY_REPLICAS=$(kubectl get deployment "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            DESIRED_REPLICAS=$(kubectl get deployment "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")
            
            if [ "$READY_REPLICAS" = "$DESIRED_REPLICAS" ] && [ "$READY_REPLICAS" != "0" ]; then
              echo "‚úÖ Deployment verified: $READY_REPLICAS/$DESIRED_REPLICAS replicas ready"
              
              # Get ingress URLs
              INGRESS_URLS=$(kubectl get ingress -n "$NAMESPACE" -o jsonpath='{range .items[*]}{.spec.rules[*].host}{"\n"}{end}' 2>/dev/null | grep -v "^$" || echo "")
              
              if [ -n "$INGRESS_URLS" ]; then
                DEPLOYMENT_STATUS="

## üöÄ Deployment Verified
- **Service**: $SERVICE_NAME
- **Namespace**: $NAMESPACE
- **Status**: ‚úÖ $READY_REPLICAS/$DESIRED_REPLICAS replicas ready
- **Live URLs**:
$(echo "$INGRESS_URLS" | sed 's/^/  - https:\/\//')"
              else
                DEPLOYMENT_STATUS="

## üöÄ Deployment Verified
- **Service**: $SERVICE_NAME
- **Namespace**: $NAMESPACE
- **Status**: ‚úÖ $READY_REPLICAS/$DESIRED_REPLICAS replicas ready
- **Access**: Service deployed (no ingress configured)"
              fi
            else
              echo "‚ö†Ô∏è Deployment not ready: $READY_REPLICAS/$DESIRED_REPLICAS replicas"
              DEPLOYMENT_STATUS="

## ‚ö†Ô∏è Deployment Not Ready
- **Service**: $SERVICE_NAME
- **Namespace**: $NAMESPACE
- **Status**: ‚è≥ $READY_REPLICAS/$DESIRED_REPLICAS replicas ready
- **Action Required**: Waiting for deployment to stabilize"
            fi
          else
            echo "‚ö†Ô∏è Deployment not found: $SERVICE_NAME in namespace $NAMESPACE"
            DEPLOYMENT_STATUS="

## ‚ö†Ô∏è Deployment Not Found
- **Service**: $SERVICE_NAME
- **Namespace**: $NAMESPACE
- **Status**: ‚ùå Deployment not detected
- **Action Required**: Ensure deployment manifests are applied"
          fi
        fi
        
        echo "‚úÖ $STAGE_NAME complete - posting APPROVE review (Tess final approval)"
        REVIEW_BODY_FILE=$(mktemp)
        cat <<EOF > "$REVIEW_BODY_FILE"
### $STAGE_EMOJI $STAGE_NAME Review - APPROVED
All checks have passed:
$CHECKS_PASSED
Ready for $NEXT_STAGE.$DEPLOYMENT_STATUS

**Final Approval:** Tess has verified all acceptance criteria are met.
EOF
        refresh_token_if_needed || true
        timeout 30 gh pr review "$PR_NUM" --approve --body-file "$REVIEW_BODY_FILE" 2>&1 || echo "‚ö†Ô∏è PR review command failed"
        rm -f "$REVIEW_BODY_FILE"
        
        # Auto-merge if enabled (Tess only)
        if [ "${AUTO_MERGE:-false}" = "true" ]; then
          echo "üîÄ AUTO_MERGE enabled - merging PR automatically"
          if timeout 30 gh pr merge "$PR_NUM" --auto --squash --delete-branch; then
            echo "‚úÖ PR scheduled for auto-merge"
          else
            echo "‚ö†Ô∏è Auto-merge failed - PR may need manual intervention"
          fi
        fi
      else
        # Cleo hands off to Tess via comment and label (NOT approve)
        echo "‚úÖ $STAGE_NAME checks passed - handing off to Tess"
        REVIEW_BODY_FILE=$(mktemp)
        cat <<EOF > "$REVIEW_BODY_FILE"
### $STAGE_EMOJI $STAGE_NAME Review - PASSED
All checks have passed:
$CHECKS_PASSED

**Status:** Ready for $NEXT_STAGE
**Next Step:** Tess will now perform comprehensive QA validation

---
*Quality review by Cleo*
EOF
        refresh_token_if_needed || true
        timeout 30 gh pr comment "$PR_NUM" --body-file "$REVIEW_BODY_FILE" 2>&1 || echo "‚ö†Ô∏è PR comment command failed"
        rm -f "$REVIEW_BODY_FILE"
        
        # Add ready-for-qa label to signal Tess
        echo "üè∑Ô∏è  Adding 'ready-for-qa' label to trigger Tess review"
        timeout 30 gh pr edit "$PR_NUM" --add-label "ready-for-qa" 2>&1 || echo "‚ö†Ô∏è Failed to add ready-for-qa label"
      fi
    else
      STAGE_NAME="Quality"
      STAGE_EMOJI="üõ°Ô∏è"
      ISSUES_DESC=$'- Review code formatting
- Fix linting errors
- Ensure unit tests pass
- Meet quality standards'
      if [ "$WORKFLOW_STAGE" = "security" ]; then
        STAGE_NAME="Security"
        STAGE_EMOJI="üîí"
        ISSUES_DESC=$'- Fix security vulnerabilities
- Update insecure dependencies
- Remove exposed secrets
- Address security best practice violations'
      elif [ "$WORKFLOW_STAGE" = "testing" ]; then
        STAGE_NAME="QA Testing"
        STAGE_EMOJI="üß™"
        ISSUES_DESC=$'- Fix failing end-to-end tests
- Address integration test failures
- Validate acceptance criteria
- Ensure production readiness'
      fi

      echo "‚ùå $STAGE_NAME issues detected - posting REQUEST CHANGES review"
      REVIEW_BODY_FILE=$(mktemp)
      cat <<EOF > "$REVIEW_BODY_FILE"
### üî¥ Required Changes
$STAGE_NAME issues detected. Please address the following:
$ISSUES_DESC
EOF
      refresh_token_if_needed || true
      timeout 30 gh pr review "$PR_NUM" --request-changes --body-file "$REVIEW_BODY_FILE" 2>&1 || echo "‚ö†Ô∏è PR review command failed"
      rm -f "$REVIEW_BODY_FILE"
    fi
  else
    echo "‚ÑπÔ∏è No PR number available for $WORKFLOW_STAGE review submission"
  fi
fi

touch "$TASK_WORKSPACE/.agent_done" 2>/dev/null || true

# Explicitly stop Docker sidecar before exiting
echo "üõë Explicitly stopping Docker sidecar..."
stop_docker_sidecar || true

if [ $SUCCESS -ne 1 ]; then
  {{#if agent_completion_message}}
echo "{{agent_completion_message}}"
  {{else}}
echo "‚ö†Ô∏è OpenCode execution incomplete"
  {{/if}}
  exit $EXIT_CODE
fi

{{#if agent_completion_message}}
echo "{{agent_completion_message}}"
{{else}}
echo "‚úÖ OpenCode execution complete"
{{/if}}
exit $EXIT_CODE
