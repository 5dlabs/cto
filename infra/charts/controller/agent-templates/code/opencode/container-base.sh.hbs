#!/bin/bash
set -euo pipefail

# =========================================================================
# Environment bootstrapping
# =========================================================================

{{#if agent_banner}}
echo "{{agent_banner}}"
{{else}}
echo "üîß Initialising OpenCode environment"
{{/if}}

if [ -f "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi

if [ -f "/root/.cargo/env" ]; then
  . "/root/.cargo/env"
fi

if command -v rustup >/dev/null 2>&1; then
  rustup default stable 2>/dev/null || true
fi

# Preemptively prune stale Rustup downloads to avoid bulk cleanup commands later
if [ -d "$HOME/.rustup/downloads" ]; then
  find "$HOME/.rustup/downloads" -mindepth 1 -delete 2>/dev/null || true
fi

echo "PATH: $PATH"

# =========================================================================
# GitHub App authentication
# =========================================================================

REPO_URL="{{repository_url}}"

if [ -z "${GITHUB_APP_PRIVATE_KEY:-}" ] || [ -z "${GITHUB_APP_ID:-}" ]; then
  echo "‚ùå Missing GitHub App credentials"
  exit 1
fi

echo "üîê Authenticating with GitHub App"
TEMP_KEY_FILE="/tmp/github-app-key.pem"
printf '%b' "$GITHUB_APP_PRIVATE_KEY" >"$TEMP_KEY_FILE"
chmod 600 "$TEMP_KEY_FILE"

JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
NOW=$(date +%s)
EXP=$((NOW + 600))
JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
rm -f "$TEMP_KEY_FILE"

parse_repo() {
  local input="$1"
  if echo "$input" | grep -qE '^https://github.com/'; then
    echo "$input" | sed -E 's|https://github.com/([^/]+)/([^/]+?)(\.git)?$|\1 \2|'
  elif echo "$input" | grep -qE '^git@github.com:'; then
    echo "$input" | sed -E 's|git@github.com:([^/]+)/([^/]+?)(\.git)?$|\1 \2|'
  else
    echo "$input" | sed -E 's|\.git$||' | sed -E 's|([^/]+)/([^/]+)|\1 \2|'
  fi
}

read REPO_OWNER REPO_NAME <<<"$(parse_repo "$REPO_URL")"
REPO_HTTP_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}.git"

INSTALLATION_ID=$(curl -s -L \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
  INSTALLATION_ID=$(curl -s -L \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
fi

if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
  echo "‚ùå Unable to resolve installation ID for $REPO_OWNER/$REPO_NAME"
  exit 1
fi

GITHUB_TOKEN=$(curl -s -X POST \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')

if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
  echo "‚ùå Unable to obtain installation token"
  exit 1
fi

export GITHUB_TOKEN
export GH_TOKEN="$GITHUB_TOKEN"
export GH_HOST="github.com"

export GIT_CONFIG_GLOBAL=/workspace/.gitconfig
CREDENTIALS_FILE=/workspace/.git-credentials
mkdir -p /workspace

git config --global --replace-all credential.helper "store --file=$CREDENTIALS_FILE"

write_git_credentials() {
  if [ -z "${GITHUB_TOKEN:-}" ]; then
    return
  fi
  printf 'https://x-access-token:%s@github.com\n' "$GITHUB_TOKEN" >"$CREDENTIALS_FILE"
  chmod 600 "$CREDENTIALS_FILE" 2>/dev/null || true
}

write_git_credentials

TOKEN_GENERATED_AT=$(date +%s)

refresh_github_token() {
  echo "üîÑ Refreshing GitHub App token..."

  TEMP_KEY_FILE="/tmp/github-app-key-$$"
  printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
  chmod 600 "$TEMP_KEY_FILE"

  JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  NOW=$(date +%s)
  EXP=$((NOW + 600))
  JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

  rm -f "$TEMP_KEY_FILE"

  NEW_INSTALLATION_ID=$(curl -s -L \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

  if [ "$NEW_INSTALLATION_ID" = "null" ] || [ -z "$NEW_INSTALLATION_ID" ]; then
    NEW_INSTALLATION_ID=$(curl -s -L \
      -H "Authorization: Bearer $JWT_TOKEN" \
      -H "Accept: application/vnd.github+json" \
      "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
  fi

  TOKEN_RESPONSE=$(curl -s -X POST \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/app/installations/$NEW_INSTALLATION_ID/access_tokens")

  NEW_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

  if [ "$NEW_TOKEN" != "null" ] && [ -n "$NEW_TOKEN" ]; then
    export GITHUB_TOKEN="$NEW_TOKEN"
    export GH_TOKEN="$NEW_TOKEN"
    TOKEN_GENERATED_AT=$(date +%s)
    write_git_credentials

    if command -v gh >/dev/null 2>&1; then
      printf '%s\n' "$NEW_TOKEN" | timeout 10 gh auth login --with-token --hostname "$GH_HOST" >/dev/null 2>&1 || true
      gh auth setup-git >/dev/null 2>&1 || true
    fi

    echo "‚úÖ Token refreshed"
    return 0
  fi

  echo "‚ùå Failed to refresh token: $TOKEN_RESPONSE"
  return 1
}

refresh_token_if_needed() {
  if [ -z "$TOKEN_GENERATED_AT" ]; then
    refresh_github_token || true
    return
  fi

  NOW=$(date +%s)
  TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))

  if [ $TOKEN_AGE -gt 3000 ]; then
    echo "üîÑ Token age: $((TOKEN_AGE / 60)) minutes ‚Äî refreshing"
    refresh_github_token || true
  fi
}

stop_docker_sidecar() {
  if [ ! -S /var/run/docker.sock ]; then
    return
  fi

  echo "üõë Stopping Docker sidecar"

  if command -v pkill >/dev/null 2>&1; then
    pkill dockerd >/dev/null 2>&1 || true
  elif command -v killall >/dev/null 2>&1; then
    killall dockerd >/dev/null 2>&1 || true
  else
    PID=$(pidof dockerd 2>/dev/null || true)
    if [ -n "$PID" ]; then
      kill "$PID" >/dev/null 2>&1 || true
    fi
  fi
}

trap 'stop_docker_sidecar || true' EXIT

ensure_gh_authenticated() {
  if ! command -v gh >/dev/null 2>&1; then
    echo "‚ö†Ô∏è GitHub CLI (gh) not found; skipping authentication"
    return 0
  fi

  if ! gh auth status -h "$GH_HOST" >/dev/null 2>&1; then
    echo "üîê Logging in to GitHub CLI for host $GH_HOST"
    if ! printf '%s\n' "$GITHUB_TOKEN" | timeout 10 gh auth login --with-token --hostname "$GH_HOST" >/dev/null 2>&1; then
      echo "‚ö†Ô∏è gh auth login returned non-zero or timed out; continuing with GH_TOKEN env"
    fi
  fi

  refresh_token_if_needed || true
  gh auth setup-git >/dev/null 2>&1 || true

  if gh auth status -h "$GH_HOST" >/dev/null 2>&1; then
    echo "‚úÖ GitHub CLI authenticated for $GH_HOST"
  else
    echo "‚ö†Ô∏è Unable to confirm GitHub CLI auth; GH_TOKEN will still be used for git operations"
  fi
}

ensure_gh_authenticated

ensure_pr_created() {
  if [ "${SKIP_AUTO_PR:-0}" = "1" ]; then
    echo "‚è≠Ô∏è  Auto PR creation disabled via SKIP_AUTO_PR=1"
    return
  fi

  if [ ! -d .git ]; then
    echo "‚ö†Ô∏è Repository not initialised; skipping auto PR creation"
    return
  fi

  if ! command -v gh >/dev/null 2>&1; then
    echo "‚ö†Ô∏è GitHub CLI not available; skipping auto PR creation"
    return
  fi

  if ! command -v jq >/dev/null 2>&1; then
    echo "‚ö†Ô∏è jq not available; skipping auto PR creation"
    return
  fi

  if [ -z "${GITHUB_TOKEN:-}" ]; then
    echo "‚ö†Ô∏è GITHUB_TOKEN not set; skipping auto PR creation"
    return
  fi

  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || printf '')
  if [ -z "$CURRENT_BRANCH" ]; then
    echo "‚ö†Ô∏è Unable to determine current branch; skipping auto PR creation"
    return
  fi

  PR_DATA=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number --limit 1 2>/dev/null || echo "[]")
  if [ "$(printf '%s' "$PR_DATA" | jq 'length' 2>/dev/null || echo 0)" -gt 0 ]; then
    echo "‚úÖ Pull request already exists for branch $CURRENT_BRANCH"
    return
  fi

  BASE_BRANCH="${PR_BASE_BRANCH:-main}"
  REMOTE_BASE="origin/$BASE_BRANCH"
  if ! git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
    if git show-ref --verify --quiet "refs/remotes/origin/master"; then
      BASE_BRANCH="master"
      REMOTE_BASE="origin/$BASE_BRANCH"
    else
      DEFAULT_REMOTE=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
      if [ -n "$DEFAULT_REMOTE" ]; then
        BASE_BRANCH="$DEFAULT_REMOTE"
        REMOTE_BASE="origin/$BASE_BRANCH"
      else
        REMOTE_BASE=""
      fi
    fi
  fi

  refresh_token_if_needed || true
  if [ -n "$BASE_BRANCH" ]; then
    git fetch origin "$BASE_BRANCH" >/dev/null 2>&1 || true
  fi

  if [ "$CURRENT_BRANCH" = "HEAD" ] || [ "$CURRENT_BRANCH" = "$BASE_BRANCH" ]; then
    AUTO_BRANCH="task-{{task_id}}-{{service}}-$(date +%Y%m%d-%H%M%S)"
    echo "‚ö†Ô∏è Branch $CURRENT_BRANCH unsuitable for PR; creating $AUTO_BRANCH"
    if ! git checkout -B "$AUTO_BRANCH" >/dev/null 2>&1; then
      echo "‚ùå Failed to create fallback branch $AUTO_BRANCH"
      return
    fi
    CURRENT_BRANCH="$AUTO_BRANCH"
  fi

  git add .
  if git diff --cached --quiet --exit-code; then
    echo "‚ÑπÔ∏è No staged changes detected after auto-staging"
  else
    COMMIT_MSG="chore({{service}}): auto-commit for task {{task_id}}"
    if ! git commit -m "$COMMIT_MSG" >/dev/null 2>&1; then
      echo "‚ö†Ô∏è Failed to commit staged changes automatically"
    else
      echo "‚úÖ Auto-committed staged changes"
    fi
  fi

  if git rev-parse --verify --quiet "$CURRENT_BRANCH" >/dev/null 2>&1; then
    refresh_token_if_needed || true
    if ! git push -u origin "$CURRENT_BRANCH" >/dev/null 2>&1; then
      echo "‚ö†Ô∏è Failed to push branch $CURRENT_BRANCH; skipping auto PR creation"
      return
    fi
  else
    echo "‚ö†Ô∏è Unable to verify branch $CURRENT_BRANCH; skipping auto PR creation"
    return
  fi

  git fetch origin "$CURRENT_BRANCH" >/dev/null 2>&1 || true
  if [ -n "$REMOTE_BASE" ]; then
    AHEAD_COUNT=$(git rev-list --left-right "$REMOTE_BASE...$CURRENT_BRANCH" 2>/dev/null | awk '/^>/{c++} END{print c+0}')
  else
    AHEAD_COUNT=1
  fi
  if [ "${AHEAD_COUNT:-0}" -eq 0 ]; then
    echo "‚ö†Ô∏è Branch $CURRENT_BRANCH has no commits ahead of $BASE_BRANCH; skipping PR creation"
    return
  fi

  RUN_LABEL="run-{{workflow_name}}"
  if [ "${RUN_LABEL#run-}" = "" ]; then
    RUN_LABEL="run-unknown"
  fi

  TASK_LABEL="task-{{task_id}}"
  SERVICE_LABEL="service-{{service}}"
  REPO_SLUG="${REPO_OWNER}/${REPO_NAME}"

  echo "üîç Ensuring PR correlation labels exist"
  for label in "$TASK_LABEL" "$SERVICE_LABEL" "$RUN_LABEL"; do
    if [ -z "$label" ]; then
      continue
    fi

    if gh label view "$label" -R "$REPO_SLUG" >/dev/null 2>&1; then
      echo "   ‚úì Label '$label' already exists"
      continue
    fi

    case "$label" in
      task-*) COLOR="f29513"; DESC="Task correlation" ;;
      service-*) COLOR="0e8a16"; DESC="Service correlation" ;;
      run-*) COLOR="0366d6"; DESC="Workflow correlation" ;;
      *) COLOR="ededed"; DESC="Automation label" ;;
    esac

    if gh label create "$label" -R "$REPO_SLUG" --color "$COLOR" --description "$DESC" >/tmp/gh-label-create.log 2>&1; then
      echo "   ‚úÖ Created label '$label'"
    else
      echo "   ‚ùå Failed to create label '$label'"
      cat /tmp/gh-label-create.log >&2 || true
    fi
    rm -f /tmp/gh-label-create.log
  done

  PR_TITLE="feat({{service}}): complete task {{task_id}}"
  read -r -d '' PR_BODY <<'EOF' || true
## Summary
- Auto-generated fallback PR because the OpenCode agent finished without opening one
- Task {{task_id}} for service {{service}} is ready for review

## Metadata
- Agent: {{github_app}}
- Workflow: {{workflow_name}}
- Branch: \`$CURRENT_BRANCH\` ‚Üí \`$BASE_BRANCH\`

_This PR was created automatically by the OpenCode container._
EOF

  LABEL_ARGS=("--title" "$PR_TITLE" "--body" "$PR_BODY" "--base" "$BASE_BRANCH" "--head" "$CURRENT_BRANCH")

  # Create PR first without labels, then add labels separately
  # This prevents the entire PR creation from failing if a label doesn't exist
  if PR_URL=$(gh pr create "${LABEL_ARGS[@]}" 2>&1); then
    echo "‚úÖ Auto-created pull request: $PR_URL"
    
    # Now add labels one by one (non-critical if they fail)
    for label in "$TASK_LABEL" "$SERVICE_LABEL" "$RUN_LABEL"; do
      if [ -z "$label" ]; then
        continue
      fi
      
      # Try to create label if it doesn't exist
      if ! gh label view "$label" -R "$REPO_SLUG" >/dev/null 2>&1; then
        case "$label" in
          task-*) COLOR="f29513"; DESC="Task correlation" ;;
          service-*) COLOR="0e8a16"; DESC="Service correlation" ;;
          run-*) COLOR="0366d6"; DESC="Workflow correlation" ;;
          *) COLOR="ededed"; DESC="Automation label" ;;
        esac
        gh label create "$label" -R "$REPO_SLUG" --color "$COLOR" --description "$DESC" >/dev/null 2>&1 || true
      fi
      
      # Add label to PR (continue even if it fails)
      if gh pr edit "$CURRENT_BRANCH" --add-label "$label" >/dev/null 2>&1; then
        echo "   ‚úì Added label: $label"
      else
        echo "   ‚ö†Ô∏è Could not add label: $label (PR still created)"
      fi
    done
  else
    echo "‚ö†Ô∏è Failed to create pull request: $PR_URL"
    echo "   This may be because a PR already exists or there's an authentication issue"
  fi
}

git config --global --add safe.directory /workspace
GITHUB_APP="{{github_app}}"

derive_bot_identity() {
  local app_name="$1"

  if [ -z "$app_name" ] || [ "$app_name" = "null" ]; then
    GIT_AUTHOR_NAME="automation[bot]"
    GIT_AUTHOR_EMAIL="automation[bot]@users.noreply.github.com"
    return
  fi

  local slug
  slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-+|-+$//g')
  if [ -z "$slug" ]; then
    slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]')
  fi

  local bot_login="${slug}[bot]"
  local bot_email="${bot_login}@users.noreply.github.com"

  if [ -n "${GITHUB_TOKEN:-}" ]; then
    local encoded_login
    encoded_login=$(printf '%s' "$bot_login" | sed 's/\[/%5B/g; s/\]/%5D/g')
    local bot_response
    bot_response=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/users/${encoded_login}" 2>/dev/null || true)
    local bot_id
    bot_id=$(printf '%s' "$bot_response" | jq -r '.id // empty' 2>/dev/null || echo '')
    if [ -n "$bot_id" ]; then
      bot_email="${bot_id}+${bot_login}@users.noreply.github.com"
    fi
  fi

  GIT_AUTHOR_NAME="$bot_login"
  GIT_AUTHOR_EMAIL="$bot_email"
}

GITHUB_APP="{{github_app}}"
derive_bot_identity "$GITHUB_APP"

git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

export GIT_AUTHOR_NAME
export GIT_AUTHOR_EMAIL
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true
# Repository checkout
# =========================================================================

WORK_DIR="{{working_directory}}"
if [ -z "$WORK_DIR" ] || [ "$WORK_DIR" = "null" ]; then
  WORK_DIR="{{service}}"
fi

TARGET_DIR="/workspace/$WORK_DIR"
mkdir -p "$TARGET_DIR"
cd /workspace

REPO_ROOT="/workspace/$REPO_NAME"
git config --global --add safe.directory "$REPO_ROOT"

if [ -d "$REPO_NAME/.git" ]; then
  echo "üîÅ Repository already cloned, fetching latest"
  cd "$REPO_NAME"
  refresh_token_if_needed
  git fetch --all --prune
else
  echo "‚¨áÔ∏è  Cloning repository"
  refresh_token_if_needed
  git clone "$REPO_HTTP_URL"
  cd "$REPO_NAME"
fi

git config --global --add safe.directory "$REPO_ROOT"
cd "$REPO_ROOT"

# Remove stale automation-managed files that block branch checkout when rerunning
MANAGED_PATHS=(
  ".mcp.json"
  "AGENTS.md"
  "client-config.json"
  "coding-guidelines.md"
  "github-guidelines.md"
  "task"
)

for managed_path in "${MANAGED_PATHS[@]}"; do
  if git ls-files --error-unmatch "$managed_path" >/dev/null 2>&1; then
    continue
  fi
  if [ -e "$managed_path" ]; then
    echo "üßπ Removing stale file to allow checkout: $managed_path"
    rm -rf "$managed_path"
  fi
done

BASE_BRANCH="${PR_BASE_BRANCH:-main}"
REMOTE_BASE="origin/$BASE_BRANCH"

if ! git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
  if git show-ref --verify --quiet "refs/remotes/origin/master"; then
    BASE_BRANCH="master"
    REMOTE_BASE="origin/$BASE_BRANCH"
  else
    DEFAULT_REMOTE=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    if [ -n "$DEFAULT_REMOTE" ]; then
      BASE_BRANCH="$DEFAULT_REMOTE"
      REMOTE_BASE="origin/$BASE_BRANCH"
    else
      REMOTE_BASE=""
    fi
  fi
fi

if [ -n "$BASE_BRANCH" ]; then
  git fetch origin "$BASE_BRANCH" >/dev/null 2>&1 || true
fi

FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
if git show-ref --verify --quiet "refs/heads/$FEATURE_BRANCH"; then
  echo "Feature branch '$FEATURE_BRANCH' exists, checking out..."
  # Stash any local changes from previous runs to avoid checkout conflicts
  if ! git diff-index --quiet HEAD -- || [ -n "$(git ls-files --others --exclude-standard)" ]; then
    echo "üîÑ Stashing local changes and untracked files before checkout"
    git stash push --include-untracked -m "Auto-stash before checkout ($(date -u +%Y%m%d-%H%M%S))" || true
  fi
  git checkout "$FEATURE_BRANCH"
  if [ -n "$REMOTE_BASE" ]; then
    echo "üì• Fast-forwarding $FEATURE_BRANCH with $REMOTE_BASE"
    if ! git merge "$REMOTE_BASE" --ff-only >/dev/null 2>&1; then
      echo "‚ö†Ô∏è Unable to fast-forward $FEATURE_BRANCH; creating fresh branch from $REMOTE_BASE"
      NEW_BRANCH="${FEATURE_BRANCH}-$(date -u +%Y%m%d%H%M%S)"
      git checkout -B "$NEW_BRANCH" "$REMOTE_BASE"
      FEATURE_BRANCH="$NEW_BRANCH"
    fi
  fi
else
  echo "Creating new feature branch '$FEATURE_BRANCH'"
  if [ -n "$REMOTE_BASE" ] && git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
    git checkout -b "$FEATURE_BRANCH" "$REMOTE_BASE"
  else
    git checkout -b "$FEATURE_BRANCH"
  fi
fi

git config --local user.name "$GIT_AUTHOR_NAME"
git config --local user.email "$GIT_AUTHOR_EMAIL"
git config --local push.autoSetupRemote true
export IMPLEMENTATION_BRANCH="$FEATURE_BRANCH"
echo "‚úì Using feature branch: $FEATURE_BRANCH (base: ${BASE_BRANCH:-unknown})"

OPENCODE_WORK_DIR="$REPO_ROOT"
if [ "$WORK_DIR" != "$REPO_NAME" ]; then
  OPENCODE_WORK_DIR="$OPENCODE_WORK_DIR/$WORK_DIR"
  mkdir -p "$OPENCODE_WORK_DIR"
fi

cd "$OPENCODE_WORK_DIR"
echo "‚úì Working directory: $OPENCODE_WORK_DIR"

echo "üì¶ git status"
refresh_token_if_needed
git status --short || true

# =========================================================================
# Materialise task context
# =========================================================================

echo "üß± Syncing task assets"
mkdir -p "$OPENCODE_WORK_DIR/task"
cp -R /task-files/task/* "$OPENCODE_WORK_DIR/task/" 2>/dev/null || true

DOCS_REPO_URL="{{docs_repository_url}}"
DOCS_BRANCH="{{docs_branch}}"
DOCS_PROJECT_DIRECTORY="{{docs_project_directory}}"

if [ -n "$DOCS_REPO_URL" ] && [ "$DOCS_REPO_URL" != "null" ]; then
  refresh_token_if_needed
  if [ -z "$DOCS_BRANCH" ] || [ "$DOCS_BRANCH" = "null" ]; then
    DOCS_BRANCH="main"
  fi

  echo "üìö Syncing docs repository: $DOCS_REPO_URL (branch: $DOCS_BRANCH)"
  DOCS_CLONE_DIR="/tmp/docs-repo"
  rm -rf "$DOCS_CLONE_DIR"

  read DOCS_OWNER DOCS_NAME <<<"$(parse_repo "$DOCS_REPO_URL")"
  DOCS_HTTP_URL="https://github.com/${DOCS_OWNER}/${DOCS_NAME}.git"

  if git clone --quiet --branch "$DOCS_BRANCH" --single-branch "$DOCS_HTTP_URL" "$DOCS_CLONE_DIR"; then
    echo "‚úì Docs repository cloned"
    DOCS_BASE_PATH="$DOCS_CLONE_DIR/.taskmaster"
    if [ -n "$DOCS_PROJECT_DIRECTORY" ] && [ "$DOCS_PROJECT_DIRECTORY" != "null" ]; then
      DOCS_BASE_PATH="$DOCS_CLONE_DIR/$DOCS_PROJECT_DIRECTORY/.taskmaster"
    fi

    echo "üîç Docs base path: $DOCS_BASE_PATH"
    TASK_DIR="$DOCS_BASE_PATH/docs/task-{{task_id}}"

  if [ -d "$TASK_DIR" ]; then
    echo "‚úì Copying task definition from $TASK_DIR"
    refresh_token_if_needed
    cp -R "$TASK_DIR"/. "$OPENCODE_WORK_DIR/task/" 2>/dev/null || true
    else
      echo "‚ùå CRITICAL: Task directory not found at $TASK_DIR"
    fi

    if [ -f "$DOCS_BASE_PATH/tasks.json" ]; then
      refresh_token_if_needed
      cp "$DOCS_BASE_PATH/tasks.json" "$OPENCODE_WORK_DIR/task/" 2>/dev/null || true
    fi
  fi
fi
if [ -f /task-files/coding-guidelines.md ]; then
  cp /task-files/coding-guidelines.md "$OPENCODE_WORK_DIR/"
  echo "‚úì Copied coding-guidelines.md to working directory"
fi

if [ -f /task-files/github-guidelines.md ]; then
  cp /task-files/github-guidelines.md "$OPENCODE_WORK_DIR/"
  echo "‚úì Copied github-guidelines.md to working directory"
fi

if [ -f /task-files/AGENTS.md ]; then
  cp /task-files/AGENTS.md "$OPENCODE_WORK_DIR/AGENTS.md"
  echo "‚úì Copied AGENTS.md to working directory"
fi

if [ -f /task-files/client-config.json ]; then
  cp /task-files/client-config.json "$OPENCODE_WORK_DIR/"
  echo "‚úì Copied client-config.json to working directory"
fi

if [ -f /task-files/mcp.json ]; then
  cp /task-files/mcp.json "$OPENCODE_WORK_DIR/.mcp.json"
fi

export OPENCODE_PERMISSION='{"bash":{"*":"allow"},"edit":"allow","webfetch":"allow"}'

# Guard against destructive workspace cleanup
guard_rm() {
  if [ "$#" -ge 2 ]; then
    local flags=()
    local targets=()
    for arg in "$@"; do
      case "$arg" in
        -*) flags+=("$arg") ;;
        *) targets+=("$arg") ;;
      esac
    done

    local has_recursive=0
    local has_force=0
    for flag in "${flags[@]}"; do
      case "$flag" in
        -*)
          [[ "$flag" == *r* || "$flag" == *R* ]] && has_recursive=1
          [[ "$flag" == *f* || "$flag" == *F* ]] && has_force=1
          ;;
      esac
    done

    if ((has_recursive && has_force)); then
      for target in "${targets[@]}"; do
        [ -z "$target" ] && continue
        local expanded="$target"
        case "$target" in
          ~*) expanded="${target/#\~/$HOME}" ;;
        esac
        local resolved
        resolved=$(realpath -m "$expanded" 2>/dev/null || printf '%s' "$expanded")
        if [ "$resolved" = "$OPENCODE_WORK_DIR" ] || [ "$resolved" = "/workspace" ] ||
           [ "$resolved" = "$HOME" ] || [[ "$resolved" == "$HOME/.rustup"* ]]; then
          echo "‚ùå Guard: destructive rm blocked (target=$target)" >&2
          return 1
        fi
      done
    fi
  fi

  return 0
}

rm() {
  if guard_rm "$@"; then
    command rm "$@"
  else
    return 1
  fi
}

export -f guard_rm rm

if [ ! -f "$OPENCODE_WORK_DIR/client-config.json" ]; then
  echo "‚ùå client-config.json missing from workspace; required for MCP/toolman"
  exit 1
fi

echo "=== MCP CLIENT CONFIG ==="
WORKSPACE_CFG="$OPENCODE_WORK_DIR/client-config.json"
SOURCE_CFG="/task-files/client-config.json"
TARGET_CFG="${MCP_CLIENT_CONFIG:-/workspace/client-config.json}"

is_valid_cfg() {
  local path="$1"
  [ -f "$path" ] || return 1
  if command -v jq >/dev/null 2>&1; then
    jq -e 'type=="object" and length>=0' "$path" >/dev/null 2>&1
  else
    [ -s "$path" ]
  fi
}

if is_valid_cfg "$WORKSPACE_CFG"; then
  cp "$WORKSPACE_CFG" "$TARGET_CFG"
  echo "‚úì Using MCP client config from workspace: $TARGET_CFG"
elif is_valid_cfg "$SOURCE_CFG"; then
  cp "$SOURCE_CFG" "$WORKSPACE_CFG"
  cp "$SOURCE_CFG" "$TARGET_CFG"
  echo "‚úì Restored MCP client config from source: $TARGET_CFG"
else
  echo "‚ùå No valid MCP client config available (checked $WORKSPACE_CFG and $SOURCE_CFG)"
  if [ -f "$WORKSPACE_CFG" ]; then
    echo "   Workspace contents preview:"; head -c 200 "$WORKSPACE_CFG" 2>/dev/null || echo "   <unreadable>"
  fi
  if [ -f "$SOURCE_CFG" ]; then
    echo "   Source contents preview:"; head -c 200 "$SOURCE_CFG" 2>/dev/null || echo "   <unreadable>"
  fi
  exit 1
fi

MCP_CLIENT_CONFIG="$TARGET_CFG"
export MCP_CLIENT_CONFIG

if [ -f "$MCP_CLIENT_CONFIG" ]; then
  if command -v jq >/dev/null 2>&1; then
    echo "[client-config] summary:"
    if ! jq -r '"remoteTools=" + ((.remoteTools // []) | length | tostring) + ", localServers=" + ((.localServers // {} | keys) | join(","))' "$MCP_CLIENT_CONFIG" 2>/dev/null; then
      echo "  (not valid JSON)"
    fi
  fi
fi

echo "=== client-config.json ==="
if command -v jq >/dev/null 2>&1; then
  jq '.' "$MCP_CLIENT_CONFIG" 2>/dev/null || cat "$MCP_CLIENT_CONFIG"
else
  cat "$MCP_CLIENT_CONFIG"
fi
echo "=========================="

# Configure OpenCode config directory
mkdir -p "$HOME/.opencode"
if [ -f /task-files/opencode-config.json ]; then
  cp /task-files/opencode-config.json "$HOME/.opencode/config.json"
  echo "‚úì Installed opencode-config.json"
else
  echo "‚ö†Ô∏è opencode-config.json not provided; falling back to defaults"
fi

echo "=== MCP PRECHECKS ==="
if ! command -v toolman >/dev/null 2>&1; then
  echo "‚ùå 'toolman' CLI not found in PATH; required for MCP"
  exit 1
fi

TOOLMAN_URL=${TOOLMAN_SERVER_URL:-"http://toolman.agent-platform.svc.cluster.local:3000/mcp"}
TOOLMAN_URL="${TOOLMAN_URL%/}"
echo "üîç Checking Toolman endpoint: $TOOLMAN_URL"
if ! curl -sSf --connect-timeout 2 --max-time 6 \
  -X POST "$TOOLMAN_URL" \
  -H 'Content-Type: application/json' \
  -d '{"jsonrpc":"2.0","id":"health","method":"tools/list","params":{}}' >/tmp/toolman-ping.log 2>&1; then
  echo "‚ùå Unable to reach Toolman server at $TOOLMAN_URL"
  cat /tmp/toolman-ping.log >&2 || true
  rm -f /tmp/toolman-ping.log
  exit 1
fi
rm -f /tmp/toolman-ping.log
echo "‚úì Toolman endpoint reachable"

# Verify OpenCode provider API key is set based on config
OPENCODE_CONFIG_PATH="$HOME/.opencode/config.json"
if [ -f "$OPENCODE_CONFIG_PATH" ]; then
  PROVIDER_ENV_KEY=$(jq -r '.provider.envKey // "OPENAI_API_KEY"' "$OPENCODE_CONFIG_PATH")
else
  PROVIDER_ENV_KEY="OPENAI_API_KEY"
fi

if [ -z "${!PROVIDER_ENV_KEY:-}" ]; then
  echo "‚ùå $PROVIDER_ENV_KEY is not set; OpenCode cannot authenticate with its provider"
  exit 1
fi

echo "üîë Configuring OpenCode authentication (provider key: $PROVIDER_ENV_KEY)"

if [ ! -f "$OPENCODE_WORK_DIR/AGENTS.md" ]; then
  echo "‚ö†Ô∏è No AGENTS.md guidance file detected; creating placeholder"
  cat <<'PLACEHOLDER' > "$OPENCODE_WORK_DIR/AGENTS.md"
# Project Guidance

This OpenCode run was triggered without AGENTS.md content. Provide project context in AGENTS.md to give OpenCode richer instructions.
PLACEHOLDER
fi

# =========================================================================
# Prompt assembly and OpenCode execution
# =========================================================================

PROMPT_PREFIX=""
if [ -f "$OPENCODE_WORK_DIR/task/toolman-guide.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}üîß **CRITICAL: Tool Usage Reference**\n\n$(cat "$OPENCODE_WORK_DIR/task/toolman-guide.md")\n\n---\n\n"
fi

PROMPT_PREFIX="${PROMPT_PREFIX}‚ö†Ô∏è **EXECUTION REQUIREMENTS (MANDATORY)**\n\n- **Project already initialized**: You are already in the project root. Check for existing Cargo.toml or project structure before running initialization commands.\n- **Follow patterns**: reference @coding-guidelines.md and @github-guidelines.md in this workspace.\n- **No mocks or stubs**: integrate with live services, APIs, and configuration; remove all placeholders.\n- **Parameterize everything**: every endpoint, threshold, or trading pair must come from env vars, config, or CLI flags.\n- **GitHub auth ready**: the GitHub App token (\`GH_TOKEN\`) is already configured; skip manual \`gh auth login\` flows and avoid hitting user-only endpoints like \`/user\`.\n- **Feature branch only**: stay on \`feature/task-{{task_id}}-implementation\`; never push directly to main/master or retarget the branch upstream.\n- **Execute without pause**: if you outline a plan, immediately carry it out‚Äîdo not wait for confirmation or additional input.\n- **Quality gates**: run \`cargo fmt --all -- --check\`, \`cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic\`, and \`cargo test --workspace --all-features\` before declaring success.\n- **Documentation & PR**: update project docs and open a PR via \`gh pr create\` with labels task-{{task_id}}, service-{{service}}, and run-{{workflow_name}}.\n- **Preserve workspace**: never delete the repository or run destructive cleanup commands (for example \`rm -rf\`); leave artifacts in place for QA.\n\n---\n\n"

PROMPT_PREFIX="${PROMPT_PREFIX}üéØ **ACCEPTANCE CRITERIA - YOUR SUCCESS CRITERIA**\n\n**READ THIS FILE NOW**: @task/acceptance-criteria.md\n\nYour task is NOT complete until EVERY acceptance criterion is fully implemented and verified.\n\n**Keep working until:**\n- ‚úÖ Every acceptance criterion passes\n- ‚úÖ All required features are implemented\n- ‚úÖ All tests pass\n- ‚úÖ Code is committed and PR created\n\n**Do NOT stop** until you can honestly say \"all acceptance criteria are met.\"\n\n---\n\n"

PROMPT_PREFIX="${PROMPT_PREFIX}üö¶ **Autonomy Rules (CRITICAL - READ FIRST)**\n\n- **IMPLEMENT, DON'T JUST PLAN**: Write actual code files, don't just outline what to do\n- **COMPLETE THE ENTIRE TASK**: Don't stop after creating one file - implement ALL requirements\n- **Continue iterating until FULLY done**: Do not exit early, do not defer work, do not leave TODOs\n- **Write PRODUCTION CODE**: No placeholders, no stubs, no \"// TODO\" comments - real, working code\n- **Use tools proactively**: bash, edit, git - permissions are pre-approved, use them freely\n- **Commit frequently**: After each significant change, run \`git add . && git commit && git push\`\n- **Provide concrete results**: Show actual code changes and test results, not summaries\n- **CRITICAL**: If a bash command fails, DO NOT repeat it. Try a different approach (check with \`ls\`, \`pwd\`, create files one at a time)\n- **Working Directory**: All bash commands run in \`/workspace\` (your repository root)\n\n**You have 40 minutes and 256k context - use them to complete the ENTIRE task thoroughly.**\n\n---\n\n"

PROMPT_PREFIX="${PROMPT_PREFIX}üìù **Git & PR Workflow (MANDATORY - READ CAREFULLY)**\n\n**COMMIT AFTER EVERY SIGNIFICANT CHANGE!** This is not optional.\n\nAfter each meaningful change (new file, feature implementation, bug fix):\n1. \`git add .\`\n2. \`git commit -m \"feat: [what you just did]\"\`\n3. \`git push origin HEAD\`\n\n**CREATE PR AS SOON AS YOU HAVE WORKING CODE:**\n- Do NOT wait until everything is perfect\n- Create PR early (after first working commit)\n- You can update it with more commits later\n- Command: \`gh pr create --title \"Task {{task_id}}: [brief description]\" --body \"Implementation for task {{task_id}}\" --base main\`\n- Add labels after: \`gh pr edit --add-label task-{{task_id}} --add-label service-{{service}} --add-label run-{{workflow_name}}\`\n- Verify: \`gh pr view\`\n\n**YOUR TASK WILL FAIL WITHOUT A PR.** Create it early, update it often.\n\n---\n\n"

if [ -f "$OPENCODE_WORK_DIR/github-guidelines.md" ] || [ -f "$OPENCODE_WORK_DIR/coding-guidelines.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}üìö **Reference Materials Available**\n"
  if [ -f "$OPENCODE_WORK_DIR/github-guidelines.md" ]; then
    PROMPT_PREFIX="${PROMPT_PREFIX}- @github-guidelines.md\n"
  fi
  if [ -f "$OPENCODE_WORK_DIR/coding-guidelines.md" ]; then
    PROMPT_PREFIX="${PROMPT_PREFIX}- @coding-guidelines.md\n"
  fi
  PROMPT_PREFIX="${PROMPT_PREFIX}\n---\n\n"
fi

GUIDANCE_TOKEN=""
if [ -f "$OPENCODE_WORK_DIR/AGENTS.md" ]; then
  GUIDANCE_TOKEN="@AGENTS.md"
fi

if [ -n "$GUIDANCE_TOKEN" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}üß† **Agent Guidance**\n\n${GUIDANCE_TOKEN}\n\n---\n\n"
fi

echo "üîç DEBUG: About to check for prompt.md at: $OPENCODE_WORK_DIR/task/prompt.md"
echo "üîç DEBUG: Contents of task directory:"
ls -la "$OPENCODE_WORK_DIR/task/" || echo "Task directory not found or empty"
echo "üîç DEBUG: Current working directory contents:"
ls -la "$OPENCODE_WORK_DIR/" || echo "Working directory not accessible"

PROMPT_FILE="$OPENCODE_WORK_DIR/task/prompt.md"
if [ ! -f "$PROMPT_FILE" ]; then
  echo "‚ùå prompt.md not found at $PROMPT_FILE"
  exit 1
fi

echo "startingTask:{{task_id}}"
echo ""

PROMPT_CONTENT="${PROMPT_PREFIX}$(cat "$PROMPT_FILE")"

# Print prompt preview (similar to Factory/Claude CLIs)
echo "üì§ Sending prompt to OpenCode/Grok (truncated to 2000 chars for log safety):"
echo "=================================================================================="
PROMPT_PREVIEW=$(printf '%s' "$PROMPT_CONTENT" | head -c 2000)
printf '%s\n' "$PROMPT_PREVIEW"
echo "..."
echo "=================================================================================="
PROMPT_BYTES=$(printf '%s' "$PROMPT_CONTENT" | wc -c | tr -d '[:space:]')
echo "üìè Total prompt size: $PROMPT_BYTES bytes"
echo ""

ORIGINAL_PROMPT="$PROMPT_CONTENT"
PREVIOUS_MESSAGE_FILE=""

# Grok Code Fast 1 has 256k context window - MAX IT OUT
TOKEN_LIMIT=${OPENCODE_TOKEN_LIMIT:-256000}

# Grok is fast (190 tokens/sec) so can handle longer timeouts
OPENCODE_TIMEOUT=${OPENCODE_EXEC_TIMEOUT:-2400}  # 40 minutes (was 30)

RESET_SESSION_ON_RETRY=${OPENCODE_RESET_SESSION_ON_RETRY:-1}
CONTINUE_SESSION=${OPENCODE_CONTINUE_SESSION:-1}

# Reasonable retries for Grok - not too many to waste tokens
MAX_RETRIES=${OPENCODE_MAX_RETRIES:-6}
ATTEMPT=1
SUCCESS=0
OPENCODE_EXIT=1
LAST_MESSAGE_FILE=""
RUN_LOG=""

SESSION_DIR="$HOME/.opencode/sessions"
LATEST_SESSION_ID=""

# Circuit breaker: track repeated command failures
declare -A FAILED_COMMANDS
MAX_SAME_COMMAND_FAILURES=3

has_existing_sessions() {
  local session_dir="$1"
  if [ ! -d "$session_dir" ]; then
    return 1
  fi

  for session_file in "$session_dir"/*.json; do
    if [ -f "$session_file" ]; then
      return 0
    fi
  done

  return 1
}

extract_session_id() {
  local log_file="$1"
  [ -f "$log_file" ] || return 1
  if command -v jq >/dev/null 2>&1; then
    jq -r 'select(.sessionID != null) | .sessionID' "$log_file" 2>/dev/null | tail -n1 | tr -d '\r' | tr -d '\n'
  else
    awk '
      {
        gsub(/\033\[[0-9;]*[mK]/, "");
        if ($0 ~ /sessionID"[[:space:]]*:[[:space:]]*"[0-9a-fA-F-]{4,}/) {
          match($0, /sessionID"[[:space:]]*:[[:space:]]*"([0-9a-fA-F-]+)/, a);
          if (a[1] != "") last=a[1];
        } else if ($0 ~ /opencode session[[:space:]]+[0-9a-fA-F-]{4,}/) {
          match($0, /opencode session[[:space:]]+([0-9a-fA-F-]+)/, a);
          if (a[1] != "") last=a[1];
        }
      }
      END {
        if (last != "") print last;
      }
    ' "$log_file" 2>/dev/null
  fi
}

if [ "$CONTINUE_SESSION" = "1" ]; then
  if ! has_existing_sessions "$SESSION_DIR"; then
    echo "‚ÑπÔ∏è No existing OpenCode sessions detected; starting new session"
    CONTINUE_SESSION=0
  fi
fi

write_last_message() {
  local log_file="$1"
  local dest_file="$2"
  [ -f "$log_file" ] || return 1

  if command -v jq >/dev/null 2>&1; then
    local last_text
    last_text=$(jq -r '
      select(.type == "text")
      | (if (.text | type) == "object" then .text.text
         else if (.part | type) == "object" then .part.text
         else .text end)
      | select(. != null and . != "")
    ' "$log_file" 2>/dev/null | tail -n1)

    if [ -n "$last_text" ]; then
      printf '%s\n' "$last_text" > "$dest_file"
      return 0
    fi
  fi

  tail -n 100 "$log_file" 2>/dev/null > "$dest_file"
  return 0
}

if [ "$CONTINUE_SESSION" = "1" ]; then
  echo "‚ÑπÔ∏è OpenCode will attempt to continue the most recent session when available."
else
  if [ -d "$SESSION_DIR" ]; then
    find "$SESSION_DIR" -maxdepth 1 -type f -name '*.json' -delete 2>/dev/null || true
  fi
fi

while [ $ATTEMPT -le $MAX_RETRIES ]; do
  echo "üöÄ OpenCode execution attempt $ATTEMPT/$MAX_RETRIES"
  LAST_MESSAGE_FILE="/tmp/opencode-last-message-${ATTEMPT}.txt"
  RUN_LOG="/tmp/opencode-run-${ATTEMPT}.jsonl"

  if [ "$RESET_SESSION_ON_RETRY" = "1" ] && [ "$CONTINUE_SESSION" != "1" ] && [ $ATTEMPT -gt 1 ] && [ -d "$SESSION_DIR" ]; then
    find "$SESSION_DIR" -maxdepth 1 -type f -name '*.json' -delete 2>/dev/null || true
  fi

  if [ $ATTEMPT -eq 1 ]; then
    PROMPT_PAYLOAD="$ORIGINAL_PROMPT"
  else
    if [ -n "$PREVIOUS_MESSAGE_FILE" ] && [ -s "$PREVIOUS_MESSAGE_FILE" ]; then
      PREVIOUS_SNIPPET=$(tail -n 40 "$PREVIOUS_MESSAGE_FILE" 2>/dev/null | sed 's/^/    /')
    else
      PREVIOUS_SNIPPET="    <no previous OpenCode summary available>"
    fi
    PROMPT_PAYLOAD="üîÑ **CONTINUATION - Attempt $ATTEMPT/$MAX_RETRIES**

Task {{task_id}} is NOT complete. You need to continue working.

Previous attempt summary:
$PREVIOUS_SNIPPET

**‚ö†Ô∏è REMINDER: Review @task/acceptance-criteria.md**

Go through EACH acceptance criterion and verify if it's met. If not, implement it NOW.

**CRITICAL INSTRUCTIONS FOR THIS ATTEMPT:**

1. **CHECK ACCEPTANCE CRITERIA** - Review @task/acceptance-criteria.md, identify what's missing
2. **WRITE ACTUAL CODE** - Don't just plan or outline, IMPLEMENT the features
3. **IMPLEMENT ALL REQUIREMENTS** - Don't stop until EVERY acceptance criterion is met
4. **COMMIT YOUR CHANGES** - Run \`git add . && git commit -m \"...\"\` after making progress
5. **RUN TESTS** - Verify your code works (cargo test, cargo clippy, etc.)
6. **VERIFY COMPLETION** - Can you honestly say all acceptance criteria are met?
7. **CREATE/UPDATE PR** - Run \`gh pr create\` or push more commits to existing PR

**What you MUST do now:**
- Read acceptance criteria: \`cat task/acceptance-criteria.md\`
- Check what files exist: \`ls -la\`
- Review previous work: \`git log --oneline -5\`  
- Identify which acceptance criteria are NOT yet met
- IMPLEMENT the missing functionality (don't just describe it)
- Commit and push your changes
- Verify ALL criteria are now met

**DO NOT:**
- Just repeat what you did before
- Only write TODO comments or plans
- Stop after one file - implement ALL required functionality
- Give up if something fails - try a different approach
- Say you're done unless EVERY acceptance criterion is fully implemented

Focus on meeting EVERY acceptance criterion, not just some of them."
  fi

  set +e
  set -o pipefail
  OPENCODE_CMD=(
    "opencode"
    "run"
    "--format"
    "json"
    "--log-level"
    "DEBUG"
  )
  if [ "$CONTINUE_SESSION" = "1" ]; then
    if [ -n "$LATEST_SESSION_ID" ]; then
      OPENCODE_CMD+=("--session" "$LATEST_SESSION_ID")
    else
      OPENCODE_CMD+=("--continue")
    fi
  fi
  OPENCODE_CMD+=("$PROMPT_PAYLOAD")

  if command -v timeout >/dev/null 2>&1; then
    timeout "$OPENCODE_TIMEOUT" "${OPENCODE_CMD[@]}" | tee "$RUN_LOG"
  else
    "${OPENCODE_CMD[@]}" | tee "$RUN_LOG"
  fi
  OPENCODE_EXIT=${PIPESTATUS[0]}
  set +o pipefail
  set -e

  if [ $OPENCODE_EXIT -eq 124 ]; then
    echo "‚è±Ô∏è OpenCode command exceeded ${OPENCODE_TIMEOUT}s timeout; terminating session"
    pkill -f "opencode" 2>/dev/null || true
    PREVIOUS_MESSAGE_FILE="$LAST_MESSAGE_FILE"
    ATTEMPT=$((ATTEMPT + 1))
    continue
  fi

  echo "[opencode-debug] Attempt $ATTEMPT finished with exit code $OPENCODE_EXIT"

  if [ $OPENCODE_EXIT -ne 0 ]; then
    echo "‚ö†Ô∏è OpenCode exited with status $OPENCODE_EXIT on attempt $ATTEMPT"
  fi

  # Circuit breaker: detect repeated failing bash commands
  if [ -f "$RUN_LOG" ]; then
    # Extract failed bash commands from the log
    FAILED_CMD=$(jq -r 'select(.type=="tool_use" and .part.tool=="bash" and .part.state.status=="completed" and .part.state.metadata.exit!=0) | .part.state.input.command' "$RUN_LOG" 2>/dev/null | tail -n1 | head -c 100)
    
    if [ -n "$FAILED_CMD" ]; then
      # Track how many times this command has failed
      FAILED_COMMANDS["$FAILED_CMD"]=$((${FAILED_COMMANDS["$FAILED_CMD"]:-0} + 1))
      FAIL_COUNT=${FAILED_COMMANDS["$FAILED_CMD"]}
      
      if [ $FAIL_COUNT -ge $MAX_SAME_COMMAND_FAILURES ]; then
        echo "üî¥ CIRCUIT BREAKER TRIGGERED: Command has failed $FAIL_COUNT times in a row:"
        echo "   Command: $FAILED_CMD"
        echo "   This indicates the agent is stuck in a loop. Adding explicit guidance..."
        
        # Force a stronger prompt for next retry
        PROMPT_PAYLOAD="‚ö†Ô∏è **LOOP DETECTED**: You have tried this command $FAIL_COUNT times:
\`\`\`bash
$FAILED_CMD
\`\`\`

It keeps failing with the same error. **STOP REPEATING THIS COMMAND.**

Instead:
1. Check your working directory with \`pwd\`
2. List files with \`ls -la\`
3. Try a completely different approach (create files one at a time, use different syntax, etc.)
4. If directories don't exist, create them step-by-step and verify each step

Continuing Task {{task_id}} - focus on solving the underlying issue, not repeating the same failed command."
        
        # Reset the counter to give it a fresh chance with new guidance
        FAILED_COMMANDS["$FAILED_CMD"]=0
      fi
    fi
  fi

  write_last_message "$RUN_LOG" "$LAST_MESSAGE_FILE" || true

  if [ -s "$LAST_MESSAGE_FILE" ]; then
    echo "üìù OpenCode summary (attempt $ATTEMPT):"
    sed 's/^/    /' "$LAST_MESSAGE_FILE"
  else
    echo "‚ÑπÔ∏è No textual summary captured from OpenCode on attempt $ATTEMPT"
  fi

  NEW_SESSION_ID=""
  if [ -n "$RUN_LOG" ] && [ -f "$RUN_LOG" ]; then
    NEW_SESSION_ID=$(extract_session_id "$RUN_LOG" || true)
  fi
  if [ -n "$NEW_SESSION_ID" ]; then
    if [ "$LATEST_SESSION_ID" != "$NEW_SESSION_ID" ]; then
      echo "‚ÑπÔ∏è  Captured OpenCode session ID: $NEW_SESSION_ID"
      LATEST_SESSION_ID="$NEW_SESSION_ID"
    fi
    CONTINUE_SESSION=1
  fi

  PREVIOUS_MESSAGE_FILE="$LAST_MESSAGE_FILE"

  if [ "${TOKEN_LIMIT:-0}" -gt 0 ] && [ -f "$RUN_LOG" ]; then
    LAST_TOKENS=$(grep -Eo 'tokens used: [0-9,]+' "$RUN_LOG" 2>/dev/null | tail -n1 | awk '{print $3}' | tr -d ',' | tr -d '\n' || true)
    if [[ "$LAST_TOKENS" =~ ^[0-9]+$ ]]; then
      echo "üìä OpenCode tokens used this attempt: $LAST_TOKENS"
      if [ "$LAST_TOKENS" -gt "$TOKEN_LIMIT" ]; then
        echo "‚ö†Ô∏è Token usage $LAST_TOKENS exceeds limit $TOKEN_LIMIT; forcing clean session before retry"
        if [ -d "$SESSION_DIR" ]; then
          find "$SESSION_DIR" -maxdepth 1 -type f -name '*.json' -delete 2>/dev/null || true
        fi
        PREVIOUS_MESSAGE_FILE="$LAST_MESSAGE_FILE"
        ATTEMPT=$((ATTEMPT + 1))
        continue
      fi
    fi
  fi

  COMPLETION_PROMPT="Task {{task_id}} completion verification.

**FIRST**: Review the acceptance criteria in task/acceptance-criteria.md

**Then answer 'yes' ONLY if ALL of these are true:**

1. **EVERY acceptance criterion is fully implemented** (not just started, but DONE)
2. All code changes are committed to git
3. Changes are pushed to remote branch feature/task-{{task_id}}-implementation
4. A pull request exists with labels: task-{{task_id}}, service-{{service}}, run-{{workflow_name}}
5. Quality gates passed (cargo fmt, cargo clippy with no warnings, tests pass)

**Be honest**: If ANY acceptance criterion is incomplete or partially implemented, answer 'no' and continue working.

**To verify:**
- Review: \`cat task/acceptance-criteria.md\`
- Git status: \`git status\`
- Commits pushed: \`git log origin/main..HEAD\`
- PR exists: \`gh pr view\`
- Tests pass: Check your test results

Based on your honest assessment of acceptance criteria completion, answer with a single word: yes or no

Response (one word only):"
  COMPLETION_LAST_MESSAGE="/tmp/opencode-completion-${ATTEMPT}.txt"
  COMPLETION_LOG="/tmp/opencode-completion-${ATTEMPT}.jsonl"

  COMPLETION_RESPONSE=""
  if [ "$CONTINUE_SESSION" = "1" ]; then
    set +e
    set -o pipefail
    COMPLETION_CMD=(
      "opencode"
      "run"
      "--format"
      "json"
      "--log-level"
      "DEBUG"
    )
    if [ -n "$LATEST_SESSION_ID" ]; then
      COMPLETION_CMD+=("--session" "$LATEST_SESSION_ID")
    else
      COMPLETION_CMD+=("--continue")
    fi
    COMPLETION_CMD+=("$COMPLETION_PROMPT")
    "${COMPLETION_CMD[@]}" | tee "$COMPLETION_LOG"
    COMPLETION_EXIT=${PIPESTATUS[0]}
    set +o pipefail
    set -e

    if [ $COMPLETION_EXIT -ne 0 ]; then
      echo "‚ö†Ô∏è Completion probe exited with status $COMPLETION_EXIT"
    fi

    write_last_message "$COMPLETION_LOG" "$COMPLETION_LAST_MESSAGE" || true

    echo "[opencode-debug] Completion probe for attempt $ATTEMPT exited $COMPLETION_EXIT"

    if [ -s "$COMPLETION_LAST_MESSAGE" ]; then
      COMPLETION_RESPONSE=$(tr -d '\r' < "$COMPLETION_LAST_MESSAGE" | tr '[:upper:]' '[:lower:]')
      echo "üßÆ Completion probe response: $COMPLETION_RESPONSE"
    fi
  else
    echo "‚ÑπÔ∏è Completion probe skipped (session continuation disabled)"
  fi

  if echo "$COMPLETION_RESPONSE" | grep -Eq '^yes'; then
    SUCCESS=1
    break
  fi

  echo "[opencode-debug] Completion response on attempt $ATTEMPT: $COMPLETION_RESPONSE"

  echo "‚ö†Ô∏è OpenCode reported task incomplete; retrying..."
  ATTEMPT=$((ATTEMPT + 1))
done

if [ $SUCCESS -ne 1 ]; then
  echo "‚ö†Ô∏è OpenCode did not confirm task completion after $MAX_RETRIES attempts"
  echo "‚ùå Task incomplete - marking as FAILED"
  EXIT_CODE=1  # FAIL the job so it doesn't appear successful
else
  echo "‚úÖ OpenCode confirmed task completion"
  if [ ${OPENCODE_EXIT:-0} -ne 0 ]; then
    echo "‚ö†Ô∏è OpenCode returned non-zero exit code ${OPENCODE_EXIT}, but completion probe passed"
  fi
  EXIT_CODE=0
fi

if [ $SUCCESS -eq 1 ]; then
  echo "üîç Verifying pull request status"
  ensure_pr_created
else
  echo "‚ö†Ô∏è Skipping auto PR enforcement due to OpenCode completion status"
fi

touch /workspace/.agent_done 2>/dev/null || true

if [ $SUCCESS -ne 1 ]; then
  {{#if agent_completion_message}}
echo "{{agent_completion_message}}"
  {{else}}
echo "‚ö†Ô∏è OpenCode execution incomplete"
  {{/if}}
  exit $EXIT_CODE
fi

{{#if agent_completion_message}}
echo "{{agent_completion_message}}"
{{else}}
echo "‚úÖ OpenCode execution complete"
{{/if}}
exit $EXIT_CODE