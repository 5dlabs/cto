#!/bin/sh

# Task-specific workspace for parallel execution isolation
# Define BEFORE cleanup function so cleanup uses correct path
TASK_WORKSPACE="/workspace/task-{{task_id}}"

# Signal docker-daemon to shut down on ANY exit (success or failure)
# This prevents docker-daemon from running indefinitely when Claude crashes
cleanup_docker() {
    echo "ğŸ§¹ Cleanup: Signaling docker-daemon to shut down..."
    touch "$TASK_WORKSPACE/.agent_done" 2>/dev/null || true
}
trap cleanup_docker EXIT

# Ensure Rust environment is always properly set up
echo "ğŸ”§ Setting up Rust environment..."

# Source Rust environment if available (fixes cargo not found issues)
if [ -f "$HOME/.cargo/env" ]; then
    . "$HOME/.cargo/env"
    echo "âœ“ Sourced Rust environment from $HOME/.cargo/env"
fi

# Also try root cargo env as fallback
if [ -f "/root/.cargo/env" ]; then
    . "/root/.cargo/env"
    echo "âœ“ Sourced Rust environment from /root/.cargo/env"
fi

# Ensure rustup has a default toolchain set
if command -v rustup >/dev/null 2>&1; then
    rustup default stable 2>/dev/null || true
    echo "âœ“ Ensured stable Rust toolchain is default"
else
    echo "âš ï¸ rustup not found in PATH"
fi

# Verify Rust is available
if command -v cargo >/dev/null 2>&1; then
    echo "âœ“ Cargo is available: $(cargo --version)"
else
    echo "âŒ Cargo not found in PATH"
    echo "Current PATH: $PATH"
    echo "Attempting to find cargo..."
    find /usr -name cargo 2>/dev/null | head -5 || echo "No cargo found in /usr"
    find /home -name cargo 2>/dev/null | head -5 || echo "No cargo found in /home"
fi

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
printf 'â•‘  ğŸ¤– AGENT: %-50sâ•‘\n' '{{github_app}}'
echo 'â•‘  IMPLEMENTATION TASK STARTING                                â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'

# Ensure workspace directories exist (TASK_WORKSPACE already defined above)
mkdir -p /workspace
mkdir -p "$TASK_WORKSPACE"
echo "ğŸ“ Using task-specific workspace: $TASK_WORKSPACE"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."

    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"

    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"

    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."

    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âš ï¸ Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âŒ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    echo "Installation ID: $INSTALLATION_ID"

    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "âŒ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"

    # Export the token for git to use
    export GITHUB_TOKEN

    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials

    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token

    echo "âœ“ GitHub App authenticated successfully"

else
    echo "âŒ GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
    exit 1
fi

# Git configuration with proper GitHub App attribution
git config --global --add safe.directory "$TASK_WORKSPACE"

# Set GitHub App attribution - use generic format for all agents
derive_bot_identity() {
    local app_name="$1"

    if [ -z "$app_name" ] || [ "$app_name" = "null" ]; then
        GIT_AUTHOR_NAME="automation[bot]"
        GIT_AUTHOR_EMAIL="automation[bot]@users.noreply.github.com"
        return
    fi

    local slug
    slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-+|-+$//g')
    if [ -z "$slug" ]; then
        slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]')
    fi

    local bot_login="${slug}[bot]"
    local bot_email="${bot_login}@users.noreply.github.com"

    if [ -n "${GITHUB_TOKEN:-}" ]; then
        local encoded_login
        encoded_login=$(printf '%s' "$bot_login" | sed 's/\[/%5B/g; s/\]/%5D/g')
        local bot_response
        bot_response=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/users/${encoded_login}" 2>/dev/null || true)
        local bot_id
        bot_id=$(printf '%s' "$bot_response" | jq -r '.id // empty' 2>/dev/null || echo '')
        if [ -n "$bot_id" ]; then
            bot_email="${bot_id}+${bot_login}@users.noreply.github.com"
        fi
    fi

    GIT_AUTHOR_NAME="$bot_login"
    GIT_AUTHOR_EMAIL="$bot_email"
}

GITHUB_APP="{{github_app}}"
derive_bot_identity "$GITHUB_APP"

# Configure git with proper GitHub App attribution
git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

# Set environment variables for Claude Code to use
export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
echo "âœ“ Git configured"

# =============================================================================
# AUTHENTICATION VERIFICATION
# =============================================================================
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ğŸ” AUTHENTICATION VERIFICATION"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Repository URLs - Handle both full URLs and org/repo format
# Check if repository_url already contains https://github.com/
if echo "{{repository_url}}" | grep -q "^https://github.com/"; then
    REPO_HTTP_URL="{{repository_url}}"
    if ! echo "{{repository_url}}" | grep -q "\.git$"; then
        REPO_HTTP_URL="${REPO_HTTP_URL}.git"
    fi
else
    REPO_HTTP_URL="https://github.com/{{repository_url}}.git"
fi

# Same for docs repository
if echo "{{docs_repository_url}}" | grep -q "^https://github.com/"; then
    DOCS_HTTP_URL="{{docs_repository_url}}"
    if ! echo "{{docs_repository_url}}" | grep -q "\.git$"; then
        DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
    fi
else
    DOCS_HTTP_URL="https://github.com/{{docs_repository_url}}.git"
fi

# DEBUG: Show what URLs are being constructed
echo "ğŸ” DEBUG: URL Construction & Parameters"
echo "  Input repository_url: '{{repository_url}}'"
echo "  Input docs_repository_url: '{{docs_repository_url}}'"
echo "  Input docs_project_directory: '{{docs_project_directory}}'"
echo "  Input working_directory: '{{working_directory}}'"
echo "  Input docs_branch: '{{docs_branch}}'"
echo "  Input github_app: '{{github_app}}'"
echo "  Input task_id: '{{task_id}}'"
echo "  Input service: '{{service}}'"
echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
echo "  Current working directory: $(pwd)"
echo "  Available environment variables:"
env | grep -E "(GITHUB|ANTHROPIC)" | sort

# Test HTTPS access to repository
echo "ğŸ” DEBUG: Testing HTTPS repository access..."
echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
  echo "âœ“ HTTPS repository access successful"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Output: $(cat /tmp/repo_test.out | head -1)"
else
  echo "âŒ HTTPS repository access failed"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Error output: $(cat /tmp/repo_test.out)"
  echo "  Git credential helper status:"
  git config --list | grep credential || echo "  No credential helpers configured"
  echo ""
  echo "ğŸš« ABORTING: Cannot access repository via HTTPS"
  exit 1
fi

# Test docs repository access
echo "ğŸ” DEBUG: Testing docs repository access..."
echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
  echo "âœ“ Docs repository access successful"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Output: $(cat /tmp/docs_test.out | head -1)"
else
  echo "âŒ Docs repository access failed"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Error output: $(cat /tmp/docs_test.out)"
  echo ""
  echo "ğŸš« ABORTING: Cannot access docs repository via HTTPS"
  exit 1
fi

# Dual Repository Setup - Platform repo for docs, Target repo for implementation
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                 DUAL REPOSITORY SETUP                        â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Repository Information
DOCS_BRANCH="{{docs_branch}}"
GITHUB_APP="{{github_app}}"

# Helper: derive safe workspace directory name from repo input (URL, SSH, or slug)
sanitize_repo_dir() {
    input="$1"
    if echo "$input" | grep -qE '^https://github.com/'; then
        owner=$(echo "$input" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        name=$(echo "$input" | sed -E 's|https://github.com/[^/]+/([^/]+)(\\.git)?|\1|')
        printf '%s-%s' "$owner" "$name"
    elif echo "$input" | grep -qE '^git@github.com:'; then
        owner=$(echo "$input" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        name=$(echo "$input" | sed -E 's|git@github.com:[^/]+/([^/]+)(\\.git)?|\1|')
        printf '%s-%s' "$owner" "$name"
    else
        # Assume owner/repo (optionally with .git)
        slug=$(echo "$input" | sed -E 's|\\.git$||')
        echo "$slug" | tr '/' '-'
    fi
}

# Derive workspace directory names (owner-repo)
DOCS_REPO_DIR=$(sanitize_repo_dir "{{docs_repository_url}}")
TARGET_REPO_DIR=$(sanitize_repo_dir "{{repository_url}}")

echo "=== REPOSITORY SETUP ==="
echo "Docs repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
echo "Target repository: {{repository_url}} ($REPO_HTTP_URL)"
echo "Docs branch: $DOCS_BRANCH"
echo "GitHub App: $GITHUB_APP"

# Determine workflow type
echo "ğŸ” DEBUG: Workflow type detection"
echo "  docs_repository_url: '{{docs_repository_url}}'"
echo "  repository_url: '{{repository_url}}'"
echo "  Comparison result: $( [ "{{docs_repository_url}}" = "{{repository_url}}" ] && echo 'EQUAL' || echo 'DIFFERENT' )"

if [ "{{docs_repository_url}}" = "{{repository_url}}" ]; then
    echo "âœ“ Single-repo workflow detected (same repository for docs and implementation)"
    WORKFLOW_TYPE="single-repo"
    echo "  â””â”€ TaskMaster files expected at repository root"
else
    echo "âœ“ Multi-repo workflow detected (separate docs and target repositories)"
    WORKFLOW_TYPE="multi-repo"
    echo "  â””â”€ TaskMaster files expected in docs repo at: {{docs_project_directory}}"
fi
echo "ğŸ” DEBUG: WORKFLOW_TYPE set to: $WORKFLOW_TYPE"

# Repository Setup Based on Workflow Type
if [ "$WORKFLOW_TYPE" = "single-repo" ]; then
    echo "=== SINGLE-REPO WORKFLOW ==="
    # Check if repository already exists (retry scenario)
    echo "ğŸ” DEBUG: Checking for existing repository directory: /workspace/$TARGET_REPO_DIR"
    echo "  Workspace contents: $(ls -la /workspace/ | grep -v '^total')"

    if [ -d "/workspace/$TARGET_REPO_DIR/.git" ]; then
        echo "ğŸ”„ REPOSITORY: UPDATE - valid git repository exists"
        echo "ğŸ“ Found existing repository '/workspace/$TARGET_REPO_DIR', updating..."
        echo "  Directory contents: $(ls -la /workspace/$TARGET_REPO_DIR | head -5)"
        # Fix dubious ownership before git operations
        git config --global --add safe.directory "/workspace/$TARGET_REPO_DIR"
        cd "/workspace/$TARGET_REPO_DIR"
        echo "  Current branch: $(git branch --show-current 2>/dev/null || echo 'unknown')"
        echo "  Git status before update: $(git status --porcelain | wc -l) files changed"
        git fetch origin
        git checkout "$DOCS_BRANCH"
        git reset --hard "origin/$DOCS_BRANCH"
        cd "$TASK_WORKSPACE"
        echo "âœ“ Repository updated successfully to $DOCS_BRANCH"
    elif [ -d "/workspace/$TARGET_REPO_DIR" ]; then
        echo "âš ï¸ REPOSITORY: INVALID - directory exists but not a git repository"
        echo "ğŸ§¹ Removing invalid directory and re-cloning..."
        rm -rf "/workspace/$TARGET_REPO_DIR"
        echo "ğŸ“¥ REPOSITORY: CLONING - after cleanup"
        echo "  Clone command: git clone \"$REPO_HTTP_URL\" \"/workspace/$TARGET_REPO_DIR\""
        if ! git clone "$REPO_HTTP_URL" "/workspace/$TARGET_REPO_DIR"; then
            echo "âŒ Failed to clone repository: {{repository_url}} ($REPO_HTTP_URL)"
            echo "  Last git error: $(git config --get-regexp 'credential|remote')"
            exit 1
        fi
        echo "  Clone successful, changing to directory and checking out $DOCS_BRANCH"
        cd "/workspace/$TARGET_REPO_DIR" && git checkout "$DOCS_BRANCH" && cd "$TASK_WORKSPACE"
        echo "âœ“ Repository cloned successfully to /workspace/$TARGET_REPO_DIR"
        echo "  Final directory structure: $(ls -la /workspace/$TARGET_REPO_DIR | head -5)"
    else
        echo "ğŸ“¥ REPOSITORY: CLONING - first time setup"
        echo "  Clone command: git clone \"$REPO_HTTP_URL\" \"/workspace/$TARGET_REPO_DIR\""
        if ! git clone "$REPO_HTTP_URL" "/workspace/$TARGET_REPO_DIR"; then
            echo "âŒ Failed to clone repository: {{repository_url}} ($REPO_HTTP_URL)"
            echo "  Last git error: $(git config --get-regexp 'credential|remote')"
            exit 1
        fi
        echo "  Clone successful, changing to directory and checking out $DOCS_BRANCH"
        cd "/workspace/$TARGET_REPO_DIR" && git checkout "$DOCS_BRANCH" && cd "$TASK_WORKSPACE"
        echo "âœ“ Repository cloned successfully to /workspace/$TARGET_REPO_DIR"
        echo "  Final directory structure: $(ls -la /workspace/$TARGET_REPO_DIR | head -5)"
    fi

    # Preserve Task Master files before branch switching (single-repo workflow)
    echo "ğŸ”„ Preserving Task Master files from docs branch before switching to feature branch..."
    TEMP_TASK_DIR="/tmp/taskmaster-preserve"
    rm -rf "$TEMP_TASK_DIR"
    mkdir -p "$TEMP_TASK_DIR"

    cd "/workspace/$TARGET_REPO_DIR"
    echo "ğŸ” DEBUG: TaskMaster file preservation"
    echo "  docs_project_directory: '{{docs_project_directory}}'"
    echo "  task_id: '{{task_id}}'"

    # Copy Task Master files from docs branch to temporary location
    {{#if docs_project_directory}}
    if [ "{{docs_project_directory}}" = "." ]; then
        PRESERVE_FROM="/workspace/$TARGET_REPO_DIR/.taskmaster/docs/task-{{task_id}}"
        echo "  â””â”€ Using root taskmaster path (docs_project_directory='.')"
    else
        PRESERVE_FROM="/workspace/$TARGET_REPO_DIR/{{docs_project_directory}}/.taskmaster/docs/task-{{task_id}}"
        echo "  â””â”€ Using project subdirectory: {{docs_project_directory}}"
    fi
    {{else}}
    PRESERVE_FROM="/workspace/$TARGET_REPO_DIR/.taskmaster/docs/task-{{task_id}}"
    echo "  â””â”€ Using default root taskmaster path (no docs_project_directory)"
    {{/if}}

    echo "  PRESERVE_FROM resolved to: $PRESERVE_FROM"

    echo "ğŸ” DEBUG: Attempting to preserve Task Master files from: $PRESERVE_FROM"
    echo "  Checking if directory exists..."
    if [ -d "$PRESERVE_FROM" ]; then
        echo "  âœ“ TaskMaster directory found!"
        echo "  Directory contents: $(ls -la "$PRESERVE_FROM" | wc -l) items"
        ls -la "$PRESERVE_FROM"
        cp -r "$PRESERVE_FROM"/* "$TEMP_TASK_DIR/" 2>/dev/null && echo "âœ“ Task Master files preserved to temporary location" || echo "âš ï¸ Some files may not have been preserved"

        # Also preserve architecture.md from docs directory (one level up from task directory)
        {{#if docs_project_directory}}
        if [ "{{docs_project_directory}}" = "." ]; then
            ARCH_SOURCE="/workspace/$TARGET_REPO_DIR/.taskmaster/docs/architecture.md"
        else
            ARCH_SOURCE="/workspace/$TARGET_REPO_DIR/{{docs_project_directory}}/.taskmaster/docs/architecture.md"
        fi
        {{else}}
        ARCH_SOURCE="/workspace/$TARGET_REPO_DIR/.taskmaster/docs/architecture.md"
        {{/if}}

        if [ -f "$ARCH_SOURCE" ]; then
            cp "$ARCH_SOURCE" "$TEMP_TASK_DIR/" && echo "âœ“ architecture.md preserved from docs branch" || echo "âš ï¸ Failed to preserve architecture.md"
        else
            echo "âš ï¸ architecture.md not found at: $ARCH_SOURCE"
        fi

        echo "ğŸ” DEBUG: Preserved files:"
        ls -la "$TEMP_TASK_DIR/" || echo "No files in temp directory"
    else
        # Special case: taskId 0 is used for non-TaskMaster workflows (e.g., Atlas PR Guardian)
        if [ "{{task_id}}" = "0" ]; then
            echo "â„¹ï¸ TaskId 0 detected - skipping TaskMaster file requirements"
            echo "  This is a non-TaskMaster workflow (e.g., PR Guardian, standalone agent)"
            echo "  Proceeding without TaskMaster files..."
        else
            echo "âŒ Task Master directory not found at: $PRESERVE_FROM"
            echo "âŒ CRITICAL: TaskMaster files must exist at the specified location"
            echo "âŒ Expected location: $PRESERVE_FROM"
            echo "âŒ This job cannot continue without the specified TaskMaster files"
            echo "âŒ Verify that:"
            echo "   1. The docs-project-directory parameter is correct"
            echo "   2. The task-id exists in the TaskMaster directory"
            echo "   3. The docs-branch contains the TaskMaster files"
            exit 1
        fi
    fi
    cd "$TASK_WORKSPACE"

    # Set working directory to the repository root
    REPO_NAME="$TARGET_REPO_DIR"
    echo "âœ“ Working directory: /workspace/$REPO_NAME"
    echo "âœ“ Task files preserved from docs branch"

else
    echo "=== MULTI-REPO WORKFLOW ==="

    # Step 1: Clone or update docs repository temporarily
    if [ -d "/tmp/docs-repo" ]; then
        echo "ğŸ”„ DOCS REPOSITORY: UPDATE - temporary directory exists"
        cd /tmp/docs-repo
        git fetch origin
        git checkout "$DOCS_BRANCH"
        git reset --hard "origin/$DOCS_BRANCH"
        cd "$TASK_WORKSPACE"
        echo "âœ“ Docs repository updated"
    else
        echo "ğŸ“¥ DOCS REPOSITORY: CLONING - extracting task files"
        if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
            echo "âŒ Failed to clone docs repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
            exit 1
        fi
        cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd "$TASK_WORKSPACE"
        echo "âœ“ Docs repository cloned to temporary location"
    fi

    # Step 2: Clone or update target repository
    if [ -d "/workspace/$TARGET_REPO_DIR/.git" ]; then
        echo "ğŸ”„ TARGET REPOSITORY: UPDATE - valid git repository exists"
        echo "ğŸ“ Found existing target repository '/workspace/$TARGET_REPO_DIR', updating..."
        # Fix dubious ownership before git operations
        git config --global --add safe.directory "/workspace/$TARGET_REPO_DIR"
        cd "/workspace/$TARGET_REPO_DIR"
        git fetch origin main
        git reset --hard origin/main
        cd "$TASK_WORKSPACE"
        echo "âœ“ Target repository updated successfully"
    elif [ -d "/workspace/$TARGET_REPO_DIR" ]; then
        echo "âš ï¸ TARGET REPOSITORY: INVALID - directory exists but not a git repository"
        echo "ğŸ§¹ Removing invalid directory and re-cloning..."
        rm -rf "/workspace/$TARGET_REPO_DIR"
        if ! git clone "$REPO_HTTP_URL" "/workspace/$TARGET_REPO_DIR"; then
            echo "âŒ Failed to clone target repository: {{repository_url}} ($REPO_HTTP_URL)"
            exit 1
        fi
        echo "âœ“ Target repository cloned successfully to /workspace/$TARGET_REPO_DIR"
    else
        echo "ğŸ“¥ TARGET REPOSITORY: CLONING - first time setup"
        if ! git clone "$REPO_HTTP_URL" "/workspace/$TARGET_REPO_DIR"; then
            echo "âŒ Failed to clone target repository: {{repository_url}} ($REPO_HTTP_URL)"
            exit 1
        fi
        echo "âœ“ Target repository cloned successfully to /workspace/$TARGET_REPO_DIR"
    fi

    # Step 3: Copy task files from docs repo to target repo
    echo "ğŸ“‹ TASK FILES: COPYING from docs to target repository"
    mkdir -p "/workspace/$TARGET_REPO_DIR/task"

    # Determine docs project directory path
    {{#if docs_project_directory}}
    if [ "{{docs_project_directory}}" = "." ]; then
        DOCS_PATH="/tmp/docs-repo/.taskmaster"
    else
        DOCS_PATH="/tmp/docs-repo/{{docs_project_directory}}/.taskmaster"
    fi
    {{else}}
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
    {{/if}}

    # Copy specific task files
    TASK_DIR="$DOCS_PATH/docs/task-{{task_id}}"
    echo "ğŸ” DEBUG: Looking for task files at: $TASK_DIR"
    echo "ğŸ” DEBUG: Docs path is: $DOCS_PATH"
    echo "ğŸ” DEBUG: Contents of docs temp directory:"
    ls -la /tmp/docs-repo/.taskmaster/ || echo "No .taskmaster found"
    echo "ğŸ” DEBUG: Contents of docs directory:"
    ls -la /tmp/docs-repo/.taskmaster/docs/ || echo "No docs directory found"

    if [ -d "$TASK_DIR" ]; then
        echo "ğŸ” DEBUG: Task directory found, contents:"
        ls -la "$TASK_DIR"

        # Ensure target task directory exists before copying
        mkdir -p "/workspace/$TARGET_REPO_DIR/task"
        echo "âœ“ Created target task directory"

        echo "âœ… Copying task.md..."
        cp "$TASK_DIR/task.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "âœ“ task.md copied" || echo "âŒ task.md copy failed"

        echo "âœ… Copying acceptance-criteria.md..."
        cp "$TASK_DIR/acceptance-criteria.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "âœ“ acceptance-criteria.md copied" || echo "âŒ acceptance-criteria.md copy failed"

        echo "âœ… Copying prompt.md..."
        cp "$TASK_DIR/prompt.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "âœ“ prompt.md copied" || echo "âŒ prompt.md copy failed"

        echo "âœ… Copying client-config.json..."
        if [ -f "$TASK_DIR/client-config.json" ]; then
            cp "$TASK_DIR/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" && echo "âœ“ client-config.json copied to Claude working directory" || echo "âŒ client-config.json copy failed"
        else
            echo "âš ï¸ client-config.json not found - MCP client may not be configured"
        fi

        echo "âœ… Copying toolman-guide.md..."
        if [ -f "$TASK_DIR/toolman-guide.md" ]; then
            cp "$TASK_DIR/toolman-guide.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "âœ“ toolman-guide.md copied" || echo "âŒ toolman-guide.md copy failed"
        else
            echo "âš ï¸ toolman-guide.md not found - code agent won't have tool usage guidance"
        fi

        echo "âœ“ Task {{task_id}} files copied from $TASK_DIR"
    else
        # Special case: taskId 0 is used for non-TaskMaster workflows (e.g., Atlas PR Guardian)
        if [ "{{task_id}}" = "0" ]; then
            echo "â„¹ï¸ TaskId 0 detected - skipping TaskMaster file requirements"
            echo "  This is a non-TaskMaster workflow (e.g., PR Guardian, standalone agent)"
            echo "  Proceeding without TaskMaster files..."
        else
            echo "âŒ CRITICAL: Task {{task_id}} directory not found at: $TASK_DIR"
            echo "ğŸ” DEBUG: Available directories in docs:"
            find /tmp/docs-repo -name "task-*" -type d || echo "No task directories found"
        fi
    fi

    # Copy architecture.md from docs root
    ARCH_FILE="$DOCS_PATH/docs/architecture.md"
    if [ -f "$ARCH_FILE" ]; then
        cp "$ARCH_FILE" "/workspace/$TARGET_REPO_DIR/task/"
        echo "âœ“ Architecture documentation copied"
    else
        echo "âš ï¸ architecture.md not found at: $ARCH_FILE"
    fi

    # Copy tasks.json if it exists
    if [ -f "$DOCS_PATH/tasks.json" ]; then
        cp "$DOCS_PATH/tasks.json" "/workspace/$TARGET_REPO_DIR/task/"
        echo "âœ“ tasks.json copied"
    fi

    echo "âœ“ Task files copied to target repository"

    # DEBUG: Verify files were copied successfully
    echo "ğŸ” DEBUG: Contents of target task directory after copy:"
    ls -la "/workspace/$TARGET_REPO_DIR/task/" || echo "Task directory not found"
    echo "ğŸ” DEBUG: Checking if prompt.md exists:"
    [ -f "/workspace/$TARGET_REPO_DIR/task/prompt.md" ] && echo "âœ… prompt.md exists" || echo "âŒ prompt.md missing"

    # Step 4: Clean up docs repository
    echo "ğŸ§¹ CLEANUP: Removing temporary docs repository"
    rm -rf /tmp/docs-repo
    echo "âœ“ Docs repository cleaned up"

    # Set working directory to the target repository root
    REPO_NAME="$TARGET_REPO_DIR"
    echo "âœ“ Working directory: /workspace/$REPO_NAME"
fi

# Setup feature branch for implementation
echo "=== BRANCH SETUP ==="
cd "/workspace/$REPO_NAME"

# Fix git dubious ownership before any git operations
git config --global --add safe.directory "/workspace/$REPO_NAME"
echo "âœ“ Added repository to git safe directories"

# Sync with latest main to prevent conflicts
echo "ğŸ”„ Syncing with latest main to prevent conflicts..."
git fetch origin main 2>/dev/null || git fetch origin master 2>/dev/null || echo "âš ï¸ Could not fetch main/master branch"

# Create or checkout feature branch
FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
BRANCH_EXISTS="false"

    if git show-ref --verify --quiet refs/heads/$FEATURE_BRANCH; then
        BRANCH_EXISTS="true"
        echo "Feature branch '$FEATURE_BRANCH' exists, checking out..."
        git checkout $FEATURE_BRANCH

        echo "ğŸ“¥ Merging latest main into $FEATURE_BRANCH..."
        if git merge origin/main --no-edit; then
            echo "âœ“ Successfully merged latest main into feature branch"
        else
            echo "âš ï¸ MERGE CONFLICT: Cannot auto-merge main into $FEATURE_BRANCH"
            echo "â— Manual conflict resolution required by Claude agent"
            echo ""
            echo "ğŸ“‹ Conflict files:"
            git status --porcelain | grep "^UU\|^AA\|^DD" || echo "   (Use 'git status' to see details)"
            echo ""
            echo "ğŸ”§ Claude will need to resolve conflicts manually before proceeding"
            # Don't exit - let Claude handle the conflicts
        fi
    else
        # Create new feature branch from latest main
        echo "Creating new feature branch '$FEATURE_BRANCH' from latest main..."
        
        # Stash any local changes to avoid checkout conflicts
        # Exclude task/ directory to preserve task files that were just copied
        if ! git diff-index --quiet HEAD -- || [ -n "$(git ls-files --others --exclude-standard)" ]; then
          echo "ğŸ”„ Stashing local changes and untracked files (excluding task/) before creating new branch"
          git stash push --include-untracked -m "Auto-stash before new branch creation ($(date -u +%Y%m%d-%H%M%S))" -- . ':!task' || true
        fi
        
        git checkout -b $FEATURE_BRANCH origin/main
        echo "âœ“ Created feature branch: $FEATURE_BRANCH"
    fi

# 5. Set Working Directory (Critical for Claude Execution)
WORKSPACE_DIR="$TARGET_REPO_DIR"
WORK_DIR="{{working_directory}}"
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
  CLAUDE_WORK_DIR="/workspace/$WORKSPACE_DIR"
else
  CLAUDE_WORK_DIR="/workspace/$WORKSPACE_DIR/$WORK_DIR"
fi
mkdir -p "$CLAUDE_WORK_DIR" && cd "$CLAUDE_WORK_DIR"
echo "âœ“ Set working directory: $CLAUDE_WORK_DIR"
echo "ğŸ”‘ CRITICAL: Claude will be launched from this directory"

# Working directory setup completed above

# Configure git user after successful clone
echo "=== POST-CLONE GIT CONFIGURATION ==="
# Fix dubious ownership issues
git config --global --add safe.directory "/workspace/$REPO_NAME"
echo "âœ“ Added repository to safe directories"

# Set git config locally in the working repository (persistent on PVC)
if [ -d "/workspace/$REPO_NAME/.git" ]; then
    cd "/workspace/$REPO_NAME"
    git config --local user.name "$GIT_AUTHOR_NAME"
    git config --local user.email "$GIT_AUTHOR_EMAIL"
    # Set up automatic upstream for new branches
    git config --local push.autoSetupRemote true
    echo "âœ“ Configured git user in target repository: $GIT_AUTHOR_NAME"
    echo "âœ“ Enabled automatic upstream setup for new branches"
fi

cd "$TASK_WORKSPACE"

# Copy ConfigMap files to working directory (AFTER repository clone)
echo "=== CONFIGMAP FILE SETUP ==="

# Claude working directory already set above during repository setup

echo "Setting up files in Claude working directory: $CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"

# Copy all files from ConfigMap to working directory
if [ -d "/task-files" ]; then
  echo "Copying ConfigMap files to working directory..."

  # CLAUDE.md Memory Persistence Logic (controlled by overwriteMemory CRD field)
        OVERWRITE_MEMORY="{{overwrite_memory}}"

  # Handle CLAUDE.md based on overwriteMemory setting
        if [ "$OVERWRITE_MEMORY" = "true" ]; then
          # Overwrite mode: Always replace CLAUDE.md with fresh template
    cp "/task-files/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
    cp "/task-files/CLAUDE.md" "/workspace/CLAUDE.md"
          echo "âœ“ Overwrote CLAUDE.md memory file (fresh start requested)"
          echo "âœ“ Copied CLAUDE.md to workspace root for easy access"
        else
          # Preserve mode (default): Only copy if doesn't exist
          if [ ! -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
      # Initial creation - copy from ConfigMap
      cp "/task-files/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
      cp "/task-files/CLAUDE.md" "/workspace/CLAUDE.md"
            echo "âœ“ Created initial CLAUDE.md memory file"
            echo "âœ“ Copied CLAUDE.md to workspace root for easy access"
          else
            echo "âœ“ Preserved existing CLAUDE.md memory file (maintaining accumulated context)"
            # Still copy to workspace root for consistency
            cp "$CLAUDE_WORK_DIR/CLAUDE.md" "/workspace/CLAUDE.md"
            echo "âœ“ Synced CLAUDE.md to workspace root"
          fi
        fi

  # Copy client-config.json to workspace root for MCP configuration
  if [ -f "/task-files/client-config.json" ]; then
    cp \$FACTORY_WORK_DIR/client-config.json "$TASK_WORKSPACE/client-config.json" 2>/dev/null || true
    echo "âœ“ Copied client-config.json to workspace root for MCP configuration"
  else
    echo "âš ï¸ client-config.json not found in task-files, using defaults"
  fi

  # Copy all other markdown files (excluding CLAUDE.md)
  for md_file in /task-files/*.md; do
    if [ -f "$md_file" ]; then
      basename_file=$(basename "$md_file")
      # Skip CLAUDE.md since we handled it above
      if [ "$basename_file" != "CLAUDE.md" ]; then
        cp "$md_file" "$CLAUDE_WORK_DIR/"
        echo "âœ“ Updated $basename_file"
      fi
    fi
  done

  # Verify enterprise settings (mounted directly from ConfigMap)
  if [ -f "/etc/claude-code/managed-settings.json" ]; then
    echo "âœ“ Enterprise settings verified"
    if ! jq empty /etc/claude-code/managed-settings.json 2>/dev/null; then
      echo "âŒ Invalid enterprise settings JSON"
      exit 1
    fi
  else
    echo "âŒ Enterprise settings not found"
    exit 1
  fi

  # Copy guidelines files to working directory
  if [ -f "/task-files/coding-guidelines.md" ]; then
    cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
    echo "âœ“ Copied coding-guidelines.md to working directory"
  fi

  if [ -f "/task-files/github-guidelines.md" ]; then
    cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
    echo "âœ“ Copied github-guidelines.md to working directory"
  fi

  # System prompt will be rendered inline (no file copying needed)
  echo "âœ“ System prompt template will be rendered inline"

  # Hook copying disabled
  echo "! Hook scripts disabled - no hooks will be copied"

  # Set up MCP configuration
  echo "Setting up MCP configuration..."

  # Copy MCP configuration from ConfigMap to project root (project scope)
  if [ -f "/task-files/mcp.json" ]; then
    cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
    echo "âœ“ Copied mcp.json to .mcp.json (project scope)"
    # Also copy to /workspace for Claude's MCP loader
    cp /task-files/mcp.json "/workspace/.mcp.json"
    echo "âœ“ Copied mcp.json to /workspace/.mcp.json for MCP loader"
  else
    echo "âš ï¸  mcp.json template not found"
  fi

  # Enterprise managed settings are mounted directly from ConfigMap
  echo "=== ENTERPRISE MANAGED SETTINGS ==="
  echo "âœ“ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
  echo "âœ“ No copying needed - mount automatically reflects latest ConfigMap changes"

  echo "âœ“ ConfigMap files copied to $CLAUDE_WORK_DIR"
else
  echo "âš ï¸  Warning: /task-files directory not found (ConfigMap not mounted?)"
fi


# Copy Current Task Documentation to Working Directory
echo "=== TASK DOCUMENTATION SETUP ==="
echo "ğŸ” DEBUG: WORKFLOW_TYPE is: $WORKFLOW_TYPE"
echo "ğŸ” DEBUG: REPO_NAME is: $REPO_NAME"
echo "ğŸ” DEBUG: CLAUDE_WORK_DIR is: $CLAUDE_WORK_DIR"
echo "ğŸ” DEBUG: Task ID is: {{task_id}}"

# Task directory should already exist from multi-repo workflow or be created as needed
mkdir -p "$CLAUDE_WORK_DIR/task"
echo "âœ“ Created task directory at: $CLAUDE_WORK_DIR/task"

# Task documentation should already be available in the task/ directory
if [ "$WORKFLOW_TYPE" = "single-repo" ]; then
    # Special case: taskId 0 is used for non-TaskMaster workflows (e.g., Atlas PR Guardian)
    if [ "{{task_id}}" = "0" ]; then
        echo "â„¹ï¸ TaskId 0 detected - skipping TaskMaster file restoration"
        echo "  This is a non-TaskMaster workflow (e.g., PR Guardian, standalone agent)"
        echo "  Proceeding without TaskMaster files..."
    else
        echo "âœ“ Restoring task documentation from preserved temporary location"

        # Use the preserved Task Master files from temporary location
        TEMP_TASK_DIR="/tmp/taskmaster-preserve"
        echo "ğŸ” DEBUG: Restoring task files from: $TEMP_TASK_DIR"

        if [ -d "$TEMP_TASK_DIR" ] && [ "$(ls -A $TEMP_TASK_DIR 2>/dev/null)" ]; then
            echo "âœ“ Preserved Task Master files found"
            echo "ğŸ” DEBUG: Preserved task files:"
            ls -la "$TEMP_TASK_DIR/"

            echo "âœ… Copying all preserved files to task directory..."

            # Copy all files from preserved directory to task directory
            if cp -r "$TEMP_TASK_DIR"/* "$CLAUDE_WORK_DIR/task/" 2>/dev/null; then
                echo "âœ“ All task files copied from preserved temporary location"
            else
                echo "âŒ Failed to copy task files from preserved location"
                exit 1
            fi

            # Copy task.txt as task.md if it exists (specific rename needed)
            if [ -f "$CLAUDE_WORK_DIR/task/task.txt" ]; then
                cp "$CLAUDE_WORK_DIR/task/task.txt" "$CLAUDE_WORK_DIR/task/task.md" && echo "âœ“ task.txt copied as task.md" || echo "âŒ task.txt copy failed"
            fi

            # Move client-config.json to Claude working directory (not in task/ subdirectory)
            if [ -f "$CLAUDE_WORK_DIR/task/client-config.json" ]; then
                mv "$CLAUDE_WORK_DIR/task/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" && echo "âœ“ client-config.json moved to Claude working directory" || echo "âŒ client-config.json move failed"
            else
                echo "âš ï¸ client-config.json not found - MCP client may not be configured"
            fi

            echo "âœ“ Task {{task_id}} files copied from preserved temporary location"

            # Clean up temporary directory
            rm -rf "$TEMP_TASK_DIR"
            echo "âœ“ Cleaned up temporary preservation directory"
        else
            echo "âŒ CRITICAL: No preserved Task Master files found at: $TEMP_TASK_DIR"
            echo "ğŸ” DEBUG: This indicates the Task Master preservation step failed earlier"
            echo "âŒ Task {{task_id}} files are not available for this job"
            exit 1
        fi
    fi

    # DEBUG: Verify files were copied successfully
    echo "ğŸ” DEBUG: Contents of target task directory after copy:"
    ls -la "$CLAUDE_WORK_DIR/task/" || echo "Task directory not found"
    echo "ğŸ” DEBUG: Checking if prompt.md exists:"
    [ -f "$CLAUDE_WORK_DIR/task/prompt.md" ] && echo "âœ… prompt.md exists" || echo "âŒ prompt.md missing"

else
    echo "âœ“ Task documentation copied from docs repository during multi-repo setup"
fi

# Verify client-config.json is available in Claude's working directory
echo "=== TOOLMAN CONFIG SETUP ==="
WORKSPACE_CFG="$CLAUDE_WORK_DIR/client-config.json"
SOURCE_CFG="/task-files/client-config.json"

# Helper to check non-empty JSON object
is_valid_cfg() {
  local p="$1"
  [ -f "$p" ] || return 1
  jq -e 'type=="object" and length>0' "$p" >/dev/null 2>&1
}

SRC_OK=false
WS_OK=false
if is_valid_cfg "$SOURCE_CFG"; then SRC_OK=true; fi
if is_valid_cfg "$WORKSPACE_CFG"; then WS_OK=true; fi

if $SRC_OK; then
  export MCP_CLIENT_CONFIG="$SOURCE_CFG"
  echo "âœ“ Selected MCP_CLIENT_CONFIG from source ConfigMap: $MCP_CLIENT_CONFIG"
elif $WS_OK; then
  export MCP_CLIENT_CONFIG="$WORKSPACE_CFG"
  echo "âœ“ Selected MCP_CLIENT_CONFIG from workspace copy: $MCP_CLIENT_CONFIG"
else
  echo "âŒ No valid client-config.json found (both source and workspace empty/invalid). Aborting."
  if [ -f "$SOURCE_CFG" ]; then
    echo "   Source summary:"; (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' "$SOURCE_CFG" 2>/dev/null || { echo -n "   raw="; head -c 200 "$SOURCE_CFG"; echo; })
  else
    echo "   Source missing: $SOURCE_CFG"
  fi
  if [ -f "$WORKSPACE_CFG" ]; then
    echo "   Workspace summary:"; (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' "$WORKSPACE_CFG" 2>/dev/null || { echo -n "   raw="; head -c 200 "$WORKSPACE_CFG"; echo; })
  else
    echo "   Workspace missing: $WORKSPACE_CFG"
  fi
  exit 1
fi

echo '=== WORKSPACE VALIDATION ==='

# Check for required files in Claude's working directory
MISSING_FILES=""
REQUIRED_FILES="CLAUDE.md"

echo "Checking for required files..."
for file in $REQUIRED_FILES; do
  if [ ! -f "$CLAUDE_WORK_DIR/$file" ]; then
    echo "ERROR: Missing required file: $CLAUDE_WORK_DIR/$file"
    MISSING_FILES="$MISSING_FILES $file"
  else
    echo "âœ“ Found: $CLAUDE_WORK_DIR/$file"
    # Show file size for verification
    size=$(wc -c < "$CLAUDE_WORK_DIR/$file" 2>/dev/null || echo "0")
    echo "  File size: $size bytes"
  fi
done

# Check git repository (REQUIRED for implementation tasks)
if [ ! -d "/workspace/$TARGET_REPO_DIR/.git" ]; then
  echo "âœ— CRITICAL ERROR: No target git repository found!"
  MISSING_FILES="$MISSING_FILES git-repository"
else
  echo "âœ“ Found: target git repository"
fi

# If any files are missing, abort
if [ -n "$MISSING_FILES" ]; then
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "â•‘                 WORKSPACE VALIDATION FAILED                  â•‘"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  echo "The following required files are missing:"
  for missing in $MISSING_FILES; do
    case "$missing" in
      "CLAUDE.md")
        echo "  âŒ $missing - Main task instructions for Claude"
        ;;
      "git-repository")
        echo "  âŒ $missing - Required for committing implementation changes"
        ;;
      *)
        echo "  âŒ $missing"
        ;;
    esac
  done
  echo ""
  echo "These files should have been created by the ConfigMap setup process."
  echo "Claude will NOT be started to avoid wasting API credits."
  echo ""
  exit 1
fi

echo "âœ“ All required files present. Workspace is valid."

echo '=== IMPLEMENTATION TASK DIAGNOSTICS ==='
echo "Project directory: $CLAUDE_WORK_DIR"
echo "Project directory contents:"
ls -la "$CLAUDE_WORK_DIR"
echo ""

# Show git status
echo "Git status:"
git status 2>/dev/null || echo "Git status unavailable"
echo ""

echo '=== CLAUDE EXECUTION ==='

# Export necessary variables
export SERVICE_NAME="{{service}}"
export TASK_ID="{{task_id}}"
export GITHUB_APP="{{github_app}}"

# Change to project directory before running Claude
cd "$CLAUDE_WORK_DIR"
echo "Changed to directory: $(pwd)"

# Verify we're in the correct directory and have required files
echo "=== WORKING DIRECTORY VERIFICATION ==="
echo "Current working directory: $(pwd)"
echo "Expected directory: $CLAUDE_WORK_DIR"
if [ "$(pwd)" != "$CLAUDE_WORK_DIR" ]; then
  echo "âŒ ERROR: Failed to change to correct working directory!"
  echo "Attempting to change directory again..."
  cd "$CLAUDE_WORK_DIR" || exit 1
  echo "âœ“ Successfully changed to: $(pwd)"
fi

# Verify setup
echo "âœ“ Code implementation environment ready"

# Build Claude command
CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Add MCP configuration if available
if [ -f "/workspace/.mcp.json" ]; then
    echo "âœ“ Adding MCP configuration from /workspace/.mcp.json to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --mcp-config /workspace/.mcp.json"
else
    echo "âš ï¸ No MCP configuration file found at /workspace/.mcp.json, MCP servers will not be available"
fi

# Look for agent-specific system prompt file from agents ConfigMap
# The system prompt should be in the agents ConfigMap if configured
if [ -f "/config/agents/{{github_app}}_system-prompt.md" ]; then
    echo "âœ“ Found system prompt file for {{github_app}}, adding to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /config/agents/{{github_app}}_system-prompt.md"
    if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
        echo "[DEBUG] System prompt path: /config/agents/{{github_app}}_system-prompt.md"
        echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "/config/agents/{{github_app}}_system-prompt.md" | sed 's/^/[DEBUG] /'
        echo "[DEBUG] ----"
    fi
elif [ -f "/task-files/{{github_app}}_system-prompt.md" ]; then
    # Fallback to task-files if included inline
    echo "âœ“ Found system prompt in task ConfigMap for {{github_app}}"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /task-files/{{github_app}}_system-prompt.md"
    if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
        echo "[DEBUG] System prompt path: /task-files/{{github_app}}_system-prompt.md"
        echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "/task-files/{{github_app}}_system-prompt.md" | sed 's/^/[DEBUG] /'
        echo "[DEBUG] ----"
    fi
else
    echo "â„¹ï¸ No system prompt file found for agent {{github_app}}, using defaults"
fi

# Model is set via settings.json template, not CLI flag

# Add continue flag if this is a retry attempt or user requested continuation
{{#if continue_session}}
CLAUDE_CMD="$CLAUDE_CMD --continue"
echo 'Adding --continue flag (attempt {{attempts}}{{#if user_requested}} - user requested{{/if}})'
{{/if}}

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                    STARTING CLAUDE EXECUTION                  â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "Command: $CLAUDE_CMD"
echo "Note: Claude will automatically read CLAUDE.md from the working directory"

# Inline system prompt (static content)
SYSTEM_PROMPT='## ğŸš¨ CRITICAL SYSTEM REQUIREMENTS ğŸš¨

**â›” OVERCONFIDENCE MITIGATION - MANDATORY VERIFICATION â›”**

You have a DANGEROUS tendency to declare task completion before actually verifying everything works. This is ABSOLUTELY UNACCEPTABLE.

**MANDATORY VERIFICATION REQUIREMENTS:**
- âœ… **MUST** actually run and test your code - never assume it works
- âœ… **MUST** verify ALL acceptance criteria through actual testing
- âœ… **MUST** confirm your changes don'\''t break existing functionality
- âœ… **MUST** test end-to-end workflows and edge cases
- âœ… **MUST** run all linters and build checks successfully
- âœ… **CANNOT** claim completion based on code appearance alone

**YOU ARE PROHIBITED FROM CLAIMING SUCCESS UNTIL:**
1. You have executed and verified every piece of functionality
2. You have tested integration with existing systems
3. You have confirmed all acceptance criteria pass through testing
4. All automated tests pass (linting, builds, unit tests)
5. You have verified the solution works end-to-end in practice

**IF YOU DECLARE SUCCESS WITHOUT VERIFICATION, YOU HAVE FAILED.**

## ğŸ”§ ORCHESTRATOR EXECUTION CONTEXT

- **Service**: {{service}}
- **Task ID**: {{task_id}}
- **Repository**: {{repository_url}}
- **Docs Repository**: {{docs_repository_url}}
- **Working Directory**: {{working_directory}}
- **GitHub App**: {{github_app}}

{{#if continue_session}}
## ğŸ”„ CONTINUE SESSION - PR COMMENT RESOLUTION PRIORITY

**âš ï¸ MANDATORY FIRST STEP: Before proceeding with any other work, you MUST:**

1. **Check for unresolved PR comments**: Use `gh pr view --json reviews` or check the PR directly
2. **Resolve ALL pending comments first**: Address reviewer feedback, fix issues, respond to questions
3. **Push comment resolutions**: Commit and push any fixes for reviewer concerns
4. **Only then proceed**: After ALL PR comments are resolved, continue with the main task

**This ensures reviewer feedback takes priority and maintains collaborative workflow quality.**

{{/if}}
## âš ï¸ EXECUTION REQUIREMENTS

- **Follow patterns**: Use @coding-guidelines.md and @github-guidelines.md
- **NO MOCKS ALLOWED**: Implement ONLY with real data sources and live APIs - no hard-coded values, no mock data
- **Parameterized Configuration**: ALL business logic parameters (trading pairs, endpoints, thresholds) must be configurable via env vars, config files, or CLI args
- **Pre-PR quality gates (MANDATORY)**: Do NOT open a PR unless all of these pass locally:
  - `cargo fmt --all -- --check`
  - `cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic`
  - `cargo test --workspace --all-features` and high coverage (aim â‰¥95%, target ~100% on critical paths)
- **GitHub workflow**: Read @github-guidelines.md for commit standards and **ğŸš¨ MANDATORY: CREATE A PULL REQUEST USING `gh pr create` - THE TASK IS NOT COMPLETE WITHOUT THIS STEP ğŸš¨**
- **Verify continuously**: Run tests and checks after each significant change
- **Commit incrementally**: Don'\''t save all changes for the end
- **Test thoroughly**: Validate against acceptance criteria before completion

**Remember**: Focus on thorough implementation and verification.'

echo "Starting Claude execution (text output via FIFO)..."
echo "=========================="

# Safe mode toggle for debugging (prevents token consumption)
SAFE_MODE="false"  # Set to "false" for full task execution

if [ "$SAFE_MODE" = "true" ]; then
    echo "ğŸ›¡ï¸ SAFE MODE ENABLED - Running simple test instead of full task"
    FIFO_PATH="/workspace/agent-input.jsonl"
    rm -f "$FIFO_PATH" 2>/dev/null || true
    mkfifo "$FIFO_PATH"
    chmod 666 "$FIFO_PATH" || true
    # Keep a persistent writer open and start Claude in background to avoid EOF race
    exec 9>"$FIFO_PATH"
    $CLAUDE_CMD < "$FIFO_PATH" &
    CLAUDE_PID=$!
    printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":"What time is it? Please answer this simple question and exit immediately."}]}}\n' >&9
    # Close writer so reader can exit cleanly
    exec 9>&-
    wait $CLAUDE_PID
else
    # Debug: Show what's actually in the task directory before checking for prompt.md
    echo "ğŸ” DEBUG: About to check for prompt.md at: $CLAUDE_WORK_DIR/task/prompt.md"
    echo "ğŸ” DEBUG: Contents of task directory:"
    ls -la "$CLAUDE_WORK_DIR/task/" || echo "Task directory not found or empty"
    echo "ğŸ” DEBUG: Current working directory contents:"
    ls -la "$CLAUDE_WORK_DIR/" || echo "Working directory not accessible"

    # Check if prompt.md exists and use it as main prompt
    # Skip for Task ID 0 (non-TaskMaster workflows like Atlas PR Guardian)
    if [ "{{task_id}}" = "0" ]; then
        echo "â„¹ï¸ Task ID 0 detected - launching Claude without task prompt"
        echo "  This is a non-TaskMaster workflow (e.g., PR Guardian, standalone agent)"
        echo "  Claude will use its system prompt and environment variables"

        # For task ID 0, provide FIFO with initial message to avoid hanging
        # Claude expects stream-json input, so we must provide it via FIFO
        FIFO_PATH="/workspace/agent-input.jsonl"
        rm -f "$FIFO_PATH" 2>/dev/null || true
        mkfifo "$FIFO_PATH"
        chmod 666 "$FIFO_PATH" || true
        
        # Start Claude (reader) in background
        $CLAUDE_CMD < "$FIFO_PATH" &
        CLAUDE_PID=$!
        
        # Send initial message via FIFO to unblock Claude
        INITIAL_MSG='{"type":"user","message":{"role":"user","content":[{"type":"text","text":"Begin execution."}]}}'
        exec 9>"$FIFO_PATH"
        printf '%s\n' "$INITIAL_MSG" >&9
        exec 9>&-  # Close writer immediately after sending initial message
        
        echo "ğŸš€ Launching Claude Code (Task ID 0 mode)..."

        # Wait for Claude to complete
        CLAUDE_TIMEOUT="${CLAUDE_TIMEOUT_SECONDS:-21600}"  # 6 hours default
        if timeout "$CLAUDE_TIMEOUT" bash -c "wait $CLAUDE_PID"; then
          echo "âœ… Claude process completed normally"
        else
          echo "âš ï¸  Claude process exceeded timeout (${CLAUDE_TIMEOUT}s), forcing termination"
          kill -TERM "$CLAUDE_PID" 2>/dev/null || true
          sleep 2
          kill -KILL "$CLAUDE_PID" 2>/dev/null || true
        fi
    elif [ -f "$CLAUDE_WORK_DIR/task/prompt.md" ]; then
        echo "âœ“ Using task-specific prompt from docs service: task/prompt.md"

        echo "startingTask:{{task_id}}"
        echo ""

        # DEBUG: Print MCP_CLIENT_CONFIG for troubleshooting client config issues
        echo "ğŸ” DEBUG: MCP_CLIENT_CONFIG is set to: '$MCP_CLIENT_CONFIG'"
        if [ -f "$MCP_CLIENT_CONFIG" ]; then
            echo "ğŸ” DEBUG: MCP_CLIENT_CONFIG file exists and is readable"
            echo "ğŸ” DEBUG: First few lines of client config:"
            head -10 "$MCP_CLIENT_CONFIG" 2>/dev/null || echo "Could not read client config file"
        else
            echo "ğŸ” DEBUG: MCP_CLIENT_CONFIG file does NOT exist or is not readable"
        fi
        echo ""

        # Prepare prompt prefix for toolman guidance
        PROMPT_PREFIX=""
        if [ -f "$CLAUDE_WORK_DIR/task/toolman-guide.md" ]; then
            PROMPT_PREFIX="ğŸ”§ **CRITICAL: Tool Usage Reference**

Before starting implementation, you MUST read and follow the task-specific tool guidance in the file \`task/toolman-guide.md\`. This file contains:
- Selected tools for this specific task
- When and how to use each tool
- Tool arguments, parameters, and configuration options
- Implementation workflow and best practices
- Tool relationships and sequencing

**The toolman-guide.md is your authoritative reference for tool usage in this task.**

---

"
            echo "âœ“ Including toolman guidance prefix"
        else
            echo "âš ï¸ No toolman-guide.md found - proceeding without tool guidance"
        fi

        # Seed initial user turn via a FIFO (system prompts are set via CLI flags, not streamed)
        FIFO_PATH="/workspace/agent-input.jsonl"
        rm -f "$FIFO_PATH" 2>/dev/null || true
        mkfifo "$FIFO_PATH"
        chmod 666 "$FIFO_PATH" || true

        # Start Claude (reader) first in background to avoid writer-open blocking
        $CLAUDE_CMD < "$FIFO_PATH" &
        CLAUDE_PID=$!

        # Compose initial user turn
        USER_COMBINED=$(printf "%s" "${PROMPT_PREFIX}$(cat "$CLAUDE_WORK_DIR/task/prompt.md")" | jq -Rs .)

        # Send initial prompt via FIFO
        exec 9>"$FIFO_PATH"
        printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}\n' "$USER_COMBINED" >&9

        # Optional debug: dump FIFO holders if requested
        if [ "${DEBUG_FIFO:-false}" = "true" ]; then
          echo "[DEBUG] Dumping FIFO holders for $FIFO_PATH"
          for p in /proc/[0-9]*; do
            pid=${p##*/}
            [ -d "$p/fd" ] || continue
            for fd in "$p"/fd/*; do
              tgt=$(readlink "$fd" 2>/dev/null || true)
              case "$tgt" in *agent-input.jsonl*)
                fdnum=${fd##*/}
                comm=$(cat "$p/comm" 2>/dev/null || echo "?")
                echo "  PID=$pid COMM=$comm FD=$fdnum -> $tgt"
              ;;
              esac
            done
          done
        fi

        # Optional hang diagnostics without enforcing a timeout
        if [ -n "${HANG_DIAG_SECONDS:-}" ] && [ "$HANG_DIAG_SECONDS" -gt 0 ] 2>/dev/null; then
          (
            sleep "$HANG_DIAG_SECONDS"
            if kill -0 "$CLAUDE_PID" 2>/dev/null; then
              echo "[DEBUG] Hang diag after ${HANG_DIAG_SECONDS}s: dumping FIFO holders and ps"
              for p in /proc/[0-9]*; do
                pid=${p##*/}; [ -d "$p/fd" ] || continue
                for fd in "$p"/fd/*; do tgt=$(readlink "$fd" 2>/dev/null || true); case "$tgt" in *agent-input.jsonl*) fdnum=${fd##*/}; comm=$(cat "$p/comm" 2>/dev/null || echo "?"); echo "  PID=$pid COMM=$comm FD=$fdnum -> $tgt";; esac; done
              done
              ps -eo pid,ppid,comm,args | head -200 || true
            fi
          ) & HANG_DIAG_PID=$!
        fi

        # Wait for Claude process with timeout safety
        # Claude should exit after completing work, but sometimes hangs
        CLAUDE_TIMEOUT="${CLAUDE_TIMEOUT_SECONDS:-21600}"  # 6 hours default
        
        if timeout "$CLAUDE_TIMEOUT" bash -c "wait $CLAUDE_PID"; then
          echo "âœ… Claude process completed normally"
        else
          echo "âš ï¸  Claude process exceeded timeout (${CLAUDE_TIMEOUT}s), forcing termination"
          kill -TERM "$CLAUDE_PID" 2>/dev/null || true
          sleep 2
          kill -KILL "$CLAUDE_PID" 2>/dev/null || true
        fi
        
        if [ -n "${HANG_DIAG_PID:-}" ]; then kill "$HANG_DIAG_PID" 2>/dev/null || true; fi
        # Close FIFO writer if it was opened (in fallback) now that Claude has exited
        exec 9>&- 2>/dev/null || true

        # No sidecar shutdown needed - container will exit naturally when main process completes
    else
        echo "âŒ ERROR: No prompt.md found from docs service"
        echo "The docs service should always provide task/prompt.md"
        echo "Check docs repository and task configuration"
        exit 1
    fi
fi

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘                 IMPLEMENTATION TASK COMPLETE                 â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'

# Claude execution completed - no hooks configured
echo "Claude has completed successfully."

# Write sentinel file to signal sidecar to stop (Kubernetes-native file watch)
touch "$TASK_WORKSPACE/.agent_done" 2>/dev/null || true

# Exit to terminate the pod
exit 0
