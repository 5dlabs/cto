#!/bin/sh

# Ensure Node.js and frontend environment is properly set up
echo "ðŸ”§ Setting up Node.js frontend environment..."

# Verify Node.js is available
if command -v node >/dev/null 2>&1; then
    NODE_VERSION=$(node --version)
    echo "âœ“ Node.js is available: $NODE_VERSION"
    
    # Verify Node.js version is 20+ (required for Next.js 15)
    NODE_MAJOR=$(echo "$NODE_VERSION" | cut -d'.' -f1 | tr -d 'v')
    if [ "$NODE_MAJOR" -ge 20 ]; then
        echo "âœ“ Node.js version is sufficient for Next.js 15 (v20+)"
    else
        echo "âš ï¸  Node.js version $NODE_VERSION may not support Next.js 15 (requires v20+)"
    fi
else
    echo "âŒ Node.js not found in PATH"
    echo "Current PATH: $PATH"
    echo "Attempting to find node..."
    find /usr -name node 2>/dev/null | head -5 || echo "No node found in /usr"
fi

# Verify pnpm is available (preferred package manager)
if command -v pnpm >/dev/null 2>&1; then
    PNPM_VERSION=$(pnpm --version)
    echo "âœ“ pnpm is available: $PNPM_VERSION"
else
    echo "âš ï¸  pnpm not found in PATH"
    echo "Checking for npm as fallback..."
    if command -v npm >/dev/null 2>&1; then
        NPM_VERSION=$(npm --version)
        echo "âœ“ npm is available: $NPM_VERSION (will install pnpm if needed)"
    else
        echo "âŒ Neither pnpm nor npm found in PATH"
    fi
fi

# Verify kubectl is available (for K8s deployments and Ngrok setup)
if command -v kubectl >/dev/null 2>&1; then
    echo "âœ“ kubectl is available: $(kubectl version --client --short 2>/dev/null || kubectl version --client)"
else
    echo "âš ï¸  kubectl not found (optional - needed for live preview deployments)"
fi

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
printf 'â•‘  ðŸŽ¨ AGENT: %-50sâ•‘\n' '{{github_app}}'
echo 'â•‘  BLAZE FRONTEND WORKFLOW STARTING                            â•‘'
echo 'â•‘  Frontend/UI Specialist Agent Active                         â•‘'
echo 'â•‘  âš ï¸  TASK {{task_id}} ONLY - NO OTHER TASKS âš ï¸                      â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo "ðŸ“š Focus: Documentation-first implementation approach"
echo "ðŸ“‹ Task ID: {{task_id}}"

# Task-specific workspace for parallel execution isolation
TASK_WORKSPACE="/workspace/task-{{task_id}}"
mkdir -p /workspace
mkdir -p "$TASK_WORKSPACE"
echo "ðŸ“ Using task-specific workspace: $TASK_WORKSPACE"

# Docker sidecar cleanup function
stop_docker_sidecar() {
  echo "ðŸ”„ Trap fired: Attempting Docker sidecar cleanup..."
  
  # CRITICAL: Write sentinel file to signal sidecar to stop (file watch mechanism)
  # This must happen BEFORE any returns so sidecar stops even on early exit
  touch "$TASK_WORKSPACE/.agent_done" 2>/dev/null || true
  echo "âœ… Sentinel file created to signal sidecar shutdown"
  
  # Check if Docker processes are running (more reliable than socket check)
  DOCKER_PID=$(pidof dockerd 2>/dev/null || true)
  INIT_PID=$(pidof docker-init 2>/dev/null || true)
  
  # If no processes are running, we're done
  if [ -z "$DOCKER_PID" ] && [ -z "$INIT_PID" ]; then
    # Also check socket for informational purposes
    if [ ! -S /var/run/docker.sock ]; then
      echo "âœ… Docker sidecar not running (no processes found, socket also missing)"
    else
      echo "âš ï¸ Docker processes not found but socket exists - sidecar may be in transition"
    fi
    return
  fi

  # Socket check for informational purposes only (don't block on it)
  if [ ! -S /var/run/docker.sock ]; then
    echo "âš ï¸ Docker socket not found at /var/run/docker.sock but processes are running"
    echo "   Attempting to stop processes directly..."
  else
    echo "ðŸ›‘ Stopping Docker sidecar"
  fi

  # Attempt to stop processes regardless of socket status
  if command -v pkill >/dev/null 2>&1; then
    if [ -n "$DOCKER_PID" ]; then
      pkill dockerd >/dev/null 2>&1 || true
    fi
    if [ -n "$INIT_PID" ]; then
      pkill docker-init >/dev/null 2>&1 || true
    fi
    sleep 1
    # Force kill if still running
    if pidof dockerd >/dev/null 2>&1; then
      pkill -9 dockerd >/dev/null 2>&1 || true
    fi
    if pidof docker-init >/dev/null 2>&1; then
      pkill -9 docker-init >/dev/null 2>&1 || true
    fi
  elif command -v killall >/dev/null 2>&1; then
    killall dockerd >/dev/null 2>&1 || true
    killall docker-init >/dev/null 2>&1 || true
  else
    if [ -n "$DOCKER_PID" ]; then
      kill "$DOCKER_PID" >/dev/null 2>&1 || true
      sleep 1
      if pidof dockerd >/dev/null 2>&1; then
        kill -9 "$DOCKER_PID" >/dev/null 2>&1 || true
      fi
    fi
    if [ -n "$INIT_PID" ]; then
      kill "$INIT_PID" >/dev/null 2>&1 || true
      sleep 1
      if pidof docker-init >/dev/null 2>&1; then
        kill -9 "$INIT_PID" >/dev/null 2>&1 || true
      fi
    fi
  fi

  # Wait for processes to actually stop
  for _ in 1 2 3 4 5; do
    if ! pidof dockerd >/dev/null 2>&1 && ! pidof docker-init >/dev/null 2>&1; then
      echo "âœ… Docker sidecar stopped successfully"
      return
    fi
    sleep 1
  done

  # Final check - report if still running
  REMAINING_DOCKER=$(pidof dockerd 2>/dev/null || true)
  REMAINING_INIT=$(pidof docker-init 2>/dev/null || true)
  if [ -n "$REMAINING_DOCKER" ] || [ -n "$REMAINING_INIT" ]; then
    echo "âš ï¸ Docker sidecar still running after cleanup attempts (dockerd: ${REMAINING_DOCKER:-none}, docker-init: ${REMAINING_INIT:-none})"
    echo "   Sidecar will stop via sentinel file watch mechanism"
  else
    echo "âœ… Docker sidecar stopped"
  fi
}

# Set up EXIT trap to ensure Docker sidecar cleanup
trap 'stop_docker_sidecar || true' EXIT

# =========================================================================
# RETRY CONFIGURATION
# =========================================================================
MAX_RETRIES_CONFIG=${CLAUDE_MAX_RETRIES:-${EXECUTION_MAX_RETRIES:-10}}
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                    RETRY CONFIGURATION                        â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ¤– CLI: {{cli_type}}"
echo "ðŸŽ¯ Model: {{model}}"
echo "ðŸ”„ Maximum Iterations: $MAX_RETRIES_CONFIG"
if [ -n "${CLAUDE_MAX_RETRIES:-}" ]; then
  echo "ðŸ“ Source: CLAUDE_MAX_RETRIES environment variable"
elif [ -n "${EXECUTION_MAX_RETRIES:-}" ]; then
  echo "ðŸ“ Source: EXECUTION_MAX_RETRIES environment variable"
else
  echo "ðŸ“ Source: Default configuration"
fi
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

echo "â›” CRITICAL: You must ONLY work on Task {{task_id}} - ignore ALL other tasks"

# Clean up any leftover sentinel file from previous runs
# This prevents premature sidecar shutdown on sequential task executions
if [ -f "$TASK_WORKSPACE/.agent_done" ]; then
    echo "ðŸ§¹ Cleaning up sentinel file from previous run at $TASK_WORKSPACE/.agent_done"
    rm -f "$TASK_WORKSPACE/.agent_done"
fi

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."

    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"

    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"

    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."

    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âš ï¸ Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âŒ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    echo "Installation ID: $INSTALLATION_ID"

    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    TOKEN_GENERATED_AT=$(date +%s)  # Track when token was generated for refresh logic

    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "âŒ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"

    # Export the token for git to use
    export GITHUB_TOKEN

    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials

    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token

    echo "âœ“ GitHub App authenticated successfully"

    # Token refresh functions for long-running jobs
    refresh_github_token() {
        echo "ðŸ”„ Refreshing GitHub App token..."

        # Create temporary key file
        TEMP_KEY_FILE="/tmp/github-app-key-$$"
        echo "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
        chmod 600 "$TEMP_KEY_FILE"

        # Generate new JWT
        JWT_TOKEN=$(ruby -r openssl -r json -r base64 -e "
        key = OpenSSL::PKey::RSA.new(File.read('$TEMP_KEY_FILE'))
        payload = {
            iat: Time.now.to_i - 60,
            exp: Time.now.to_i + (10 * 60),
            iss: '$GITHUB_APP_ID'
        }
        header = { alg: 'RS256', typ: 'JWT' }

        header_enc = Base64.urlsafe_encode64(header.to_json).gsub('=', '')
        payload_enc = Base64.urlsafe_encode64(payload.to_json).gsub('=', '')
        signature = Base64.urlsafe_encode64(key.sign(OpenSSL::Digest::SHA256.new, \"#{header_enc}.#{payload_enc}\")).gsub('=', '')

        puts \"#{header_enc}.#{payload_enc}.#{signature}\"
        ")

        # Get installation ID (reuse logic from initial auth)
        INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

        if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
            INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
        fi

        # Get new installation token
        TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

        NEW_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

        if [ "$NEW_TOKEN" != "null" ] && [ -n "$NEW_TOKEN" ]; then
            export GITHUB_TOKEN="$NEW_TOKEN"
            export TOKEN_GENERATED_AT=$(date +%s)

            # Update git credentials
            echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
            echo "$GITHUB_TOKEN" | gh auth login --with-token 2>/dev/null

            echo "âœ… Token refreshed successfully"
            rm -f "$TEMP_KEY_FILE"
            return 0
        else
            echo "âŒ Failed to refresh token: $TOKEN_RESPONSE"
            rm -f "$TEMP_KEY_FILE"
            return 1
        fi
    }

    # Check if token needs refresh (call before git operations)
    refresh_token_if_needed() {
        if [ -z "$TOKEN_GENERATED_AT" ]; then
            echo "âš ï¸ No token timestamp found, refreshing token..."
            refresh_github_token
            return
        fi

        NOW=$(date +%s)
        TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))

        # Refresh if token is older than 50 minutes (tokens last 1 hour, refresh at 50 min to be safe)
        if [ $TOKEN_AGE -gt 3000 ]; then
            echo "ðŸ”„ Token is $(($TOKEN_AGE / 60)) minutes old, refreshing..."
            refresh_github_token
        fi
    }

else
    echo "âŒ GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
    exit 1
fi

# Git configuration with proper GitHub App attribution
git config --global --add safe.directory "$TASK_WORKSPACE"

# Set GitHub App attribution - use generic format for all agents
derive_bot_identity() {
    local app_name="$1"

    if [ -z "$app_name" ] || [ "$app_name" = "null" ]; then
        GIT_AUTHOR_NAME="automation[bot]"
        GIT_AUTHOR_EMAIL="automation[bot]@users.noreply.github.com"
        return
    fi

    local slug
    slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-+|-+$//g')
    if [ -z "$slug" ]; then
        slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]')
    fi

    local bot_login="${slug}[bot]"
    local bot_email="${bot_login}@users.noreply.github.com"

    if [ -n "${GITHUB_TOKEN:-}" ]; then
        local encoded_login
        encoded_login=$(printf '%s' "$bot_login" | sed 's/\[/%5B/g; s/\]/%5D/g')
        local bot_response
        bot_response=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/users/${encoded_login}" 2>/dev/null || true)
        local bot_id
        bot_id=$(printf '%s' "$bot_response" | jq -r '.id // empty' 2>/dev/null || echo '')
        if [ -n "$bot_id" ]; then
            bot_email="${bot_id}+${bot_login}@users.noreply.github.com"
        fi
    fi

    GIT_AUTHOR_NAME="$bot_login"
    GIT_AUTHOR_EMAIL="$bot_email"
}

GITHUB_APP="{{github_app}}"
derive_bot_identity "$GITHUB_APP"

# Configure git with proper GitHub App attribution
git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

# Set environment variables for Claude Code to use
export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
echo "âœ“ Git configured"

# =============================================================================
# AUTHENTICATION VERIFICATION
# =============================================================================
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” AUTHENTICATION VERIFICATION"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Repository URLs - Handle both full URLs and org/repo format
# Check if repository_url already contains https://github.com/
if echo "{{repository_url}}" | grep -q "^https://github.com/"; then
    REPO_HTTP_URL="{{repository_url}}"
    if ! echo "{{repository_url}}" | grep -q "\.git$"; then
        REPO_HTTP_URL="${REPO_HTTP_URL}.git"
    fi
else
    REPO_HTTP_URL="https://github.com/{{repository_url}}.git"
fi

# Same for docs repository
if echo "{{docs_repository_url}}" | grep -q "^https://github.com/"; then
    DOCS_HTTP_URL="{{docs_repository_url}}"
    if ! echo "{{docs_repository_url}}" | grep -q "\.git$"; then
        DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
    fi
else
    DOCS_HTTP_URL="https://github.com/{{docs_repository_url}}.git"
fi

# DEBUG: Show what URLs are being constructed
echo "ðŸ” DEBUG: URL Construction & Parameters"
echo "  Input repository_url: '{{repository_url}}'"
echo "  Input docs_repository_url: '{{docs_repository_url}}'"
echo "  Input docs_project_directory: '{{docs_project_directory}}'"
echo "  Input working_directory: '{{working_directory}}'"
echo "  Input docs_branch: '{{docs_branch}}'"
echo "  Input github_app: '{{github_app}}'"
echo "  Input task_id: '{{task_id}}'"
echo "  Input service: '{{service}}'"
echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
echo "  Current working directory: $(pwd)"
echo "  Available environment variables:"
env | grep -E "(GITHUB|ANTHROPIC)" | sort

# Test HTTPS access to repository
echo "ðŸ” DEBUG: Testing HTTPS repository access..."
echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
  echo "âœ“ HTTPS repository access successful"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Output: $(cat /tmp/repo_test.out | head -1)"
else
  echo "âŒ HTTPS repository access failed"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Error output: $(cat /tmp/repo_test.out)"
  echo "  Git credential helper status:"
  git config --list | grep credential || echo "  No credential helpers configured"
  echo ""
  echo "ðŸš« ABORTING: Cannot access repository via HTTPS"
  exit 1
fi

# Test docs repository access
echo "ðŸ” DEBUG: Testing docs repository access..."
echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
  echo "âœ“ Docs repository access successful"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Output: $(cat /tmp/docs_test.out | head -1)"
else
  echo "âŒ Docs repository access failed"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Error output: $(cat /tmp/docs_test.out)"
  echo ""
  echo "ðŸš« ABORTING: Cannot access docs repository via HTTPS"
  exit 1
fi

# Dual Repository Setup - Platform repo for docs, Target repo for implementation
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                 DUAL REPOSITORY SETUP                        â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Repository Information
DOCS_BRANCH="{{docs_branch}}"
GITHUB_APP="{{github_app}}"

# Helper: derive safe workspace directory name from repo input (URL, SSH, or slug)
sanitize_repo_dir() {
    input="$1"
    if echo "$input" | grep -qE '^https://github.com/'; then
        owner=$(echo "$input" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        name=$(echo "$input" | sed -E 's|https://github.com/[^/]+/([^/]+)(\\.git)?|\1|')
        printf '%s-%s' "$owner" "$name"
    elif echo "$input" | grep -qE '^git@github.com:'; then
        owner=$(echo "$input" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        name=$(echo "$input" | sed -E 's|git@github.com:[^/]+/([^/]+)(\\.git)?|\1|')
        printf '%s-%s' "$owner" "$name"
    else
        # Assume owner/repo (optionally with .git)
        slug=$(echo "$input" | sed -E 's|\\.git$||')
        echo "$slug" | tr '/' '-'
    fi
}

# Derive workspace directory names (owner-repo)
DOCS_REPO_DIR=$(sanitize_repo_dir "{{docs_repository_url}}")
TARGET_REPO_DIR=$(sanitize_repo_dir "{{repository_url}}")

echo "=== REPOSITORY SETUP ==="
echo "Docs repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
echo "Target repository: {{repository_url}} ($REPO_HTTP_URL)"
echo "Docs branch: $DOCS_BRANCH"
echo "GitHub App: $GITHUB_APP"

# Always use consistent workflow approach
# Even if docs and target are the same repo, we clone them separately
# This avoids complex branch switching and file preservation issues
echo "=== UNIFIED WORKFLOW APPROACH ==="
echo "  docs_repository_url: '{{docs_repository_url}}'"
echo "  repository_url: '{{repository_url}}'"
echo "  â””â”€ TaskMaster files will be copied from docs repo at: {{docs_project_directory}}"

# Repository Setup - Always use consistent approach
echo "=== REPOSITORY SETUP ==="

# Step 1: Clone or update docs repository temporarily
if [ -d "/tmp/docs-repo" ]; then
    echo "ðŸ”„ DOCS REPOSITORY: UPDATE - temporary directory exists"
    cd /tmp/docs-repo
    git fetch origin
    git checkout "$DOCS_BRANCH"
    git reset --hard "origin/$DOCS_BRANCH"
    cd "$TASK_WORKSPACE"
    echo "âœ“ Docs repository updated"
else
    echo "ðŸ“¥ DOCS REPOSITORY: CLONING - extracting task files"
    if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
        echo "âŒ Failed to clone docs repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
        exit 1
    fi
    cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd "$TASK_WORKSPACE"
    echo "âœ“ Docs repository cloned to temporary location"
fi

# Step 2: Clone or update target repository TO TASK-SPECIFIC WORKSPACE
# This prevents task-1's branch from contaminating task-4's workspace
TASK_REPO_DIR="$TASK_WORKSPACE/$TARGET_REPO_DIR"

# Set working directory early (needed for correct file placement)
WORK_DIR="{{working_directory}}"
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
  CLAUDE_WORK_DIR="$TASK_REPO_DIR"
else
  CLAUDE_WORK_DIR="$TASK_REPO_DIR/$WORK_DIR"
fi
echo "âœ“ Claude working directory: $CLAUDE_WORK_DIR"

if [ -d "$TASK_REPO_DIR/.git" ]; then
    echo "ðŸ”„ TARGET REPOSITORY: UPDATE - valid git repository exists in task workspace"
    echo "ðŸ“ Found existing target repository in task-{{task_id}} workspace, updating..."
    # Fix dubious ownership before git operations
    git config --global --add safe.directory "$TASK_REPO_DIR"
    cd "$TASK_REPO_DIR"
    git fetch origin main
    git reset --hard origin/main
    cd "$TASK_WORKSPACE"
    echo "âœ“ Target repository updated successfully"
elif [ -d "$TASK_REPO_DIR" ]; then
    echo "âš ï¸ TARGET REPOSITORY: INVALID - directory exists but not a git repository"
    echo "ðŸ§¹ Removing invalid directory and re-cloning..."
    rm -rf "$TASK_REPO_DIR"
    if ! git clone "$REPO_HTTP_URL" "$TASK_REPO_DIR"; then
        echo "âŒ Failed to clone target repository: {{repository_url}} ($REPO_HTTP_URL)"
        exit 1
    fi
    echo "âœ“ Target repository cloned successfully to $TASK_REPO_DIR"
else
    echo "ðŸ“¥ TARGET REPOSITORY: CLONING - first time setup to task-specific workspace"
    if ! git clone "$REPO_HTTP_URL" "$TASK_REPO_DIR"; then
        echo "âŒ Failed to clone target repository: {{repository_url}} ($REPO_HTTP_URL)"
        exit 1
    fi
    echo "âœ“ Target repository cloned successfully to $TASK_REPO_DIR"
fi

# Load resilient task setup functions (mounted from shared ConfigMap)
source /agent-templates/shared_task-setup-functions.sh || {
    echo "âš ï¸ Warning: Resilient task functions not available, using basic operations"
    # Define minimal fallback functions
    safe_copy_file() { cp "$1" "$2" && echo "âœ“ $3 copied" || echo "âŒ $3 copy failed"; }
    safe_copy_directory() { cp -r "$1" "$2" && echo "âœ“ $3 copied" || echo "âŒ $3 copy failed"; }
    safe_ensure_directory() { mkdir -p "$1"; }
    verify_task_files() { [ -f "$1/prompt.md" ] && echo "âœ… Task files verified" || echo "âŒ Task files missing"; }
    create_error_report() { echo "âŒ ERROR: $3"; }
    attempt_task_recovery() { echo "âŒ Recovery not available"; return 1; }
}

# Step 3: Copy task files from docs repo to target repo with resilient operations
echo "ðŸ“‹ TASK FILES: COPYING from docs to target repository (RESILIENT MODE)"

# Determine docs project directory path
{{#if docs_project_directory}}
if [ "{{docs_project_directory}}" = "." ]; then
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
else
    DOCS_PATH="/tmp/docs-repo/{{docs_project_directory}}/.taskmaster"
fi
{{else}}
DOCS_PATH="/tmp/docs-repo/.taskmaster"
{{/if}}

# Copy specific task files
# Check both regular location and .completed location (tasks moved after completion)
TASK_DIR="$DOCS_PATH/docs/task-{{task_id}}"
COMPLETED_TASK_DIR="$DOCS_PATH/docs/.completed/task-{{task_id}}"

echo "ðŸ” DEBUG: Source task directory (regular): $TASK_DIR"
echo "ðŸ” DEBUG: Source task directory (completed): $COMPLETED_TASK_DIR"
echo "ðŸ” DEBUG: Docs path: $DOCS_PATH"

# Enhanced debugging for task directory discovery
echo "ðŸ” DEBUG: Docs repository structure:"
find /tmp/docs-repo -name "*.md" -path "*/task-*/*" 2>/dev/null | head -10 || echo "No task files found"

# Determine which task directory to use (prefer regular, fallback to completed)
if [ -d "$TASK_DIR" ]; then
    echo "âœ… Found task directory at regular location: $TASK_DIR"
    USE_TASK_DIR="$TASK_DIR"
elif [ -d "$COMPLETED_TASK_DIR" ]; then
    echo "âœ… Found task directory at completed location: $COMPLETED_TASK_DIR"
    echo "â„¹ï¸ Task appears to be completed - using files from .completed folder"
    USE_TASK_DIR="$COMPLETED_TASK_DIR"
else
    echo "âŒ CRITICAL: Task {{task_id}} directory not found. Checked:"
    echo "   - Regular location: $TASK_DIR"
    echo "   - Completed location: $COMPLETED_TASK_DIR"
    echo "ðŸ” DEBUG: Available directories in docs:"
    find /tmp/docs-repo -name "task-*" -type d || echo "No task directories found"
    USE_TASK_DIR=""
fi

if [ -n "$USE_TASK_DIR" ] && [ -d "$USE_TASK_DIR" ]; then
    echo "ðŸ” DEBUG: Task directory found, contents:"
    ls -la "$USE_TASK_DIR"

    # Ensure target task directory exists before copying (using Claude's working directory)
    mkdir -p "$CLAUDE_WORK_DIR/task"
    echo "âœ“ Created target task directory at $CLAUDE_WORK_DIR/task"

    echo "âœ… Copying task.md..."
    cp "$USE_TASK_DIR/task.md" "$CLAUDE_WORK_DIR/task/" && echo "âœ“ task.md copied" || echo "âŒ task.md copy failed"

    echo "âœ… Copying acceptance-criteria.md..."
    cp "$USE_TASK_DIR/acceptance-criteria.md" "$CLAUDE_WORK_DIR/task/" && echo "âœ“ acceptance-criteria.md copied" || echo "âŒ acceptance-criteria.md copy failed"

    echo "âœ… Copying prompt.md..."
    cp "$USE_TASK_DIR/prompt.md" "$CLAUDE_WORK_DIR/task/" && echo "âœ“ prompt.md copied" || echo "âŒ prompt.md copy failed"

    echo "âœ… Copying client-config.json..."
    if [ -f "/task-files/client-config.json" ]; then
        cp "/task-files/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" && echo "âœ“ client-config.json copied to Claude working directory" || echo "âŒ client-config.json copy failed"
        cp "$CLAUDE_WORK_DIR/client-config.json" "$TASK_WORKSPACE/client-config.json" 2>/dev/null || true && echo "âœ“ client-config.json copied to workspace root" || echo "âŒ client-config.json copy to workspace failed"
    else
        echo "âš ï¸ client-config.json not found - MCP client may not be configured"
    fi

    echo "âœ… Copying tools-guide.md..."
    if [ -f "$USE_TASK_DIR/tools-guide.md" ]; then
        cp "$USE_TASK_DIR/tools-guide.md" "$CLAUDE_WORK_DIR/task/" && echo "âœ“ tools-guide.md copied" || echo "âŒ tools-guide.md copy failed"
    else
        echo "âš ï¸ tools-guide.md not found - code agent won't have tool usage guidance"
    fi

    echo "âœ“ Task {{task_id}} files copied from $USE_TASK_DIR"
fi

# Copy architecture.md from docs root
ARCH_FILE="$DOCS_PATH/docs/architecture.md"
if [ -f "$ARCH_FILE" ]; then
    cp "$ARCH_FILE" "$CLAUDE_WORK_DIR/task/"
    echo "âœ“ Architecture documentation copied"
else
    echo "âš ï¸ architecture.md not found at: $ARCH_FILE"
fi

# Copy tasks.json if it exists
if [ -f "$DOCS_PATH/tasks.json" ]; then
    cp "$DOCS_PATH/tasks.json" "$CLAUDE_WORK_DIR/task/"
    echo "âœ“ tasks.json copied"
fi

echo "âœ“ Task files copied to target repository"

# DEBUG: Verify files were copied successfully
echo "ðŸ” DEBUG: Contents of target task directory after copy:"
ls -la "$CLAUDE_WORK_DIR/task/" || echo "Task directory not found"
echo "ðŸ” DEBUG: Checking if prompt.md exists:"
[ -f "$CLAUDE_WORK_DIR/task/prompt.md" ] && echo "âœ… prompt.md exists" || echo "âŒ prompt.md missing"

# Step 4: Clean up docs repository
echo "ðŸ§¹ CLEANUP: Removing temporary docs repository"
rm -rf /tmp/docs-repo
echo "âœ“ Docs repository cleaned up"

# Ensure Claude working directory exists (already defined earlier for file placement)
mkdir -p "$CLAUDE_WORK_DIR"
echo "âœ“ Ensured Claude working directory exists: $CLAUDE_WORK_DIR"

# Step 4.5: Setup shadcn/ui Component Library for Blaze
echo "=== SHADCN/UI SETUP FOR BLAZE ==="
cd "$TASK_WORKSPACE"

# Create shadcn/ui component index for Blaze
echo "ðŸ“š Indexing shadcn/ui component library..."
cat > "$CLAUDE_WORK_DIR/shadcn-components-index.md" <<'EOF'
# shadcn/ui Component Library

**Installation:** `npx shadcn@latest add [component-name]`

## Available Components

Reference: `/workspace/docs/ui/apps/www/content/docs/components/`

### Forms & Input
- `button` - Buttons with variants (default, destructive, outline, secondary, ghost, link)
- `input` - Text input field
- `textarea` - Multi-line text input
- `select` - Dropdown selection
- `checkbox` - Boolean checkbox input
- `radio-group` - Single choice from options
- `switch` - Toggle switch
- `slider` - Range selection
- `form` - Form wrapper with validation (react-hook-form + zod)
- `label` - Form labels

### Layout
- `card` - Content container with header/body/footer
- `separator` - Visual divider
- `tabs` - Content organization tabs
- `navigation-menu` - Primary navigation
- `breadcrumb` - Hierarchical navigation
- `scroll-area` - Scrollable container

### Feedback
- `dialog` - Modal dialogs
- `alert-dialog` - Confirmation dialogs
- `toast` - Notification toasts
- `alert` - Inline alerts
- `skeleton` - Loading placeholders
- `progress` - Progress bars

### Display
- `table` - Basic data tables
- `badge` - Status indicators
- `avatar` - User images
- `tooltip` - Hover hints
- `popover` - Contextual popups
- `dropdown-menu` - Action menus
- `accordion` - Collapsible content
- `aspect-ratio` - Maintain aspect ratios

### Advanced
- `data-table` - Sortable/filterable tables
- `command` - Command palette (âŒ˜K)
- `calendar` - Date selection
- `date-picker` - Date input with calendar
- `charts` - Data visualization

## Quick Install Common Sets

```bash
# Forms
npx shadcn@latest add button input textarea select checkbox form label

# Dashboard
npx shadcn@latest add card badge separator skeleton

# Data Tables
npx shadcn@latest add table data-table

# Modals & Dialogs
npx shadcn@latest add dialog alert-dialog

# Navigation
npx shadcn@latest add navigation-menu breadcrumb tabs

# All Common Components
npx shadcn@latest add button input form card table dialog \
  alert toast badge separator tabs command
```

## Usage Pattern

```tsx
// 1. Install component
npx shadcn@latest add button

// 2. Import component
import { Button } from "@/components/ui/button"

// 3. Use in JSX
<Button variant="default">Click me</Button>
<Button variant="destructive">Delete</Button>
<Button variant="outline" size="sm">Small</Button>
```

## Design System Reference

See `$CLAUDE_WORK_DIR/design-system.md` for complete documentation:
- Component library and installation commands
- PRD â†’ Component mapping
- Composition patterns (dashboard, forms, tables)
- Responsive design patterns
- Quality checklist
EOF

echo "âœ… shadcn/ui component index created at $CLAUDE_WORK_DIR/shadcn-components-index.md"

# Copy design system from agent-templates mount to Claude working directory
if [ -f "/agent-templates/shared_design-system.md" ]; then
    cp "/agent-templates/shared_design-system.md" "$CLAUDE_WORK_DIR/design-system.md"
    echo "âœ… Design system copied to Claude working directory"
elif [ -f "/agent-templates/shared/design-system.md" ]; then
    cp "/agent-templates/shared/design-system.md" "$CLAUDE_WORK_DIR/design-system.md"
    echo "âœ… Design system copied to Claude working directory (alternative path)"
else
    echo "âš ï¸ Design system not found at /agent-templates/shared_design-system.md or /agent-templates/shared/design-system.md"
fi

# List available shadcn/ui components from the cloned docs
if [ -d "/workspace/docs/ui/apps/www/content/docs/components" ]; then
    echo "ðŸ“¦ Available shadcn/ui components:"
    find /workspace/docs/ui/apps/www/content/docs/components -name "*.mdx" -exec basename {} .mdx \; | sort | head -20
    COMPONENT_COUNT=$(find /workspace/docs/ui/apps/www/content/docs/components -name "*.mdx" | wc -l)
    echo "âœ… Total components available: $COMPONENT_COUNT"
else
    echo "âš ï¸ shadcn/ui component docs not found. Expected at /workspace/docs/ui/"
fi

echo "âœ… Blaze frontend setup complete"

# Setup feature branch for implementation
echo "=== BRANCH SETUP ==="
cd "$TASK_REPO_DIR"

# Fix git dubious ownership before any git operations
git config --global --add safe.directory "$TASK_REPO_DIR"
echo "âœ“ Added repository to git safe directories"

# Sync with latest main to prevent conflicts
echo "ðŸ”„ Syncing with latest main to prevent conflicts..."
git fetch origin main 2>/dev/null || git fetch origin master 2>/dev/null || echo "âš ï¸ Could not fetch main/master branch"

# Create or checkout feature branch (with conflict-safe fallback)
FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
BRANCH_EXISTS="false"

if git show-ref --verify --quiet refs/heads/$FEATURE_BRANCH; then
    BRANCH_EXISTS="true"
    echo "Feature branch '$FEATURE_BRANCH' exists, checking out..."
    git checkout $FEATURE_BRANCH
    
    # Check if upstream branch is gone (deleted after previous PR was closed)
    UPSTREAM_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")
    if [ -n "$UPSTREAM_BRANCH" ]; then
        if ! git show-ref --verify --quiet "refs/remotes/$UPSTREAM_BRANCH"; then
            echo "âš ï¸ Upstream branch $UPSTREAM_BRANCH is gone (deleted from remote)"
            echo "ðŸ” Checking for closed PRs from previous runs..."
            
            # Check if there's a CLOSED PR for this branch
            CLOSED_PR=$(gh pr list --state closed --head "$FEATURE_BRANCH" --json number --limit 1 2>/dev/null | jq -r '.[0].number // empty')
            
            if [ -n "$CLOSED_PR" ]; then
                echo "âœ… Found CLOSED PR #$CLOSED_PR from previous run"
                echo "ðŸ”„ Deleting stale branch and recreating fresh from origin/main"
                
                # Switch off the branch before deleting it
                git checkout origin/main 2>/dev/null || git checkout -b temp-cleanup-branch origin/main
                git branch -D "$FEATURE_BRANCH" 2>/dev/null || true
                
                # Recreate fresh branch
                git checkout -b "$FEATURE_BRANCH" origin/main
                echo "âœ… Created fresh branch $FEATURE_BRANCH from origin/main"
                echo "â„¹ï¸ Previous PR was closed - starting with clean slate"
            else
                echo "â„¹ï¸ No closed PRs found - will unset upstream and continue"
                git branch --unset-upstream 2>/dev/null || true
            fi
        fi
    fi

    echo "ðŸ“¥ Merging latest main into $FEATURE_BRANCH..."
    if git merge origin/main --no-edit; then
        echo "âœ“ Successfully merged latest main into feature branch"
    else
        echo "âš ï¸ MERGE CONFLICT: Cannot auto-merge main into $FEATURE_BRANCH"
        # Check if PR exists before creating timestamped fallback
        echo "ðŸ” Checking for existing PR for this branch..."
        EXISTING_PR=$(gh pr list --state open --head "$FEATURE_BRANCH" --json number --limit 1 2>/dev/null | jq -r '.[0].number // empty')
        
        if [ -n "$EXISTING_PR" ]; then
            echo "âœ… Found existing PR #$EXISTING_PR for branch $FEATURE_BRANCH"
            echo "â„¹ï¸ Continuing with this branch despite merge conflict (will be resolved in PR)"
            # Abort the merge but stay on the branch
            git merge --abort 2>/dev/null || true
        else
            echo "â„¹ï¸ No existing PR found; recreating branch from origin/main"
        # Abort merge if in progress
        git merge --abort 2>/dev/null || true
            # Delete local branch and recreate fresh from base
            git checkout origin/main 2>/dev/null || git checkout -b temp-branch origin/main
            git branch -D "$FEATURE_BRANCH" 2>/dev/null || true
            git checkout -b "$FEATURE_BRANCH" origin/main
            echo "âœ… Recreated $FEATURE_BRANCH from origin/main"
        fi
    fi
else
    # Create new feature branch from latest main
    echo "Creating new feature branch '$FEATURE_BRANCH' from latest main..."
    
    # Stash any local changes to avoid checkout conflicts
    # Exclude task/ directory to preserve task files that were just copied
    if ! git diff-index --quiet HEAD -- || [ -n "$(git ls-files --others --exclude-standard)" ]; then
      echo "ðŸ”„ Stashing local changes and untracked files (excluding task/) before creating new branch"
      git stash push --include-untracked -m "Auto-stash before new branch creation ($(date -u +%Y%m%d-%H%M%S))" -- . ':!task' || true
    fi
    
    git checkout -b $FEATURE_BRANCH origin/main
    echo "âœ“ Created feature branch: $FEATURE_BRANCH"
fi

# 5. Change to Claude Working Directory (already set up earlier)
cd "$CLAUDE_WORK_DIR"
echo "âœ“ Changed to Claude working directory: $CLAUDE_WORK_DIR"
echo "ðŸ”‘ CRITICAL: Claude will be launched from this directory"

# Working directory setup completed above

# Configure git user after successful clone
echo "=== POST-CLONE GIT CONFIGURATION ==="
# Fix dubious ownership issues
git config --global --add safe.directory "$TASK_REPO_DIR"
echo "âœ“ Added repository to safe directories"

# Set git config locally in the working repository (persistent on PVC)
if [ -d "$TASK_REPO_DIR/.git" ]; then
    cd "$TASK_REPO_DIR"
    git config --local user.name "$GIT_AUTHOR_NAME"
    git config --local user.email "$GIT_AUTHOR_EMAIL"
    # Set up automatic upstream for new branches
    git config --local push.autoSetupRemote true
    echo "âœ“ Configured git user in target repository: $GIT_AUTHOR_NAME"
    echo "âœ“ Enabled automatic upstream setup for new branches"
fi

cd "$TASK_WORKSPACE"

# Copy ConfigMap files to working directory (AFTER repository clone)
echo "=== CONFIGMAP FILE SETUP ==="

# Claude working directory already set above during repository setup

echo "Setting up files in Claude working directory: $CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"

# Copy all files from ConfigMap to working directory
if [ -d "/task-files" ]; then
  echo "Copying ConfigMap files to working directory..."

  # CLAUDE.md Memory Persistence Logic (controlled by overwriteMemory CRD field)
        OVERWRITE_MEMORY="{{overwrite_memory}}"

  # Handle CLAUDE.md based on overwriteMemory setting
        if [ "$OVERWRITE_MEMORY" = "true" ]; then
          # Overwrite mode: Always replace CLAUDE.md with fresh template
    cp "/task-files/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
    cp "/task-files/CLAUDE.md" "/workspace/CLAUDE.md"
          echo "âœ“ Overwrote CLAUDE.md memory file (fresh start requested)"
          echo "âœ“ Copied CLAUDE.md to workspace root for easy access"
        else
          # Preserve mode (default): Only copy if doesn't exist
          if [ ! -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
      # Initial creation - copy from ConfigMap
      cp "/task-files/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
      cp "/task-files/CLAUDE.md" "/workspace/CLAUDE.md"
            echo "âœ“ Created initial CLAUDE.md memory file"
            echo "âœ“ Copied CLAUDE.md to workspace root for easy access"
          else
            echo "âœ“ Preserved existing CLAUDE.md memory file (maintaining accumulated context)"
            # Still copy to workspace root for consistency
            cp "$CLAUDE_WORK_DIR/CLAUDE.md" "/workspace/CLAUDE.md"
            echo "âœ“ Synced CLAUDE.md to workspace root"
          fi
        fi

  # Copy all other markdown files (excluding CLAUDE.md)
  for md_file in /task-files/*.md; do
    if [ -f "$md_file" ]; then
      basename_file=$(basename "$md_file")
      # Skip CLAUDE.md since we handled it above
      if [ "$basename_file" != "CLAUDE.md" ]; then
        cp "$md_file" "$CLAUDE_WORK_DIR/"
        echo "âœ“ Updated $basename_file"
      fi
    fi
  done

  # Verify enterprise settings (mounted directly from ConfigMap)
  if [ -f "/etc/claude-code/managed-settings.json" ]; then
    echo "âœ“ Enterprise settings verified"
    if ! jq empty /etc/claude-code/managed-settings.json 2>/dev/null; then
      echo "âŒ Invalid enterprise settings JSON"
      exit 1
    fi
  else
    echo "âŒ Enterprise settings not found"
    exit 1
  fi

  # Copy guidelines files to working directory
  if [ -f "/task-files/coding-guidelines.md" ]; then
    cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
    echo "âœ“ Copied coding-guidelines.md to working directory"
  fi

  if [ -f "/task-files/github-guidelines.md" ]; then
    cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
    echo "âœ“ Copied github-guidelines.md to working directory"
  fi

  # System prompt will be rendered inline (no file copying needed)
  echo "âœ“ System prompt template will be rendered inline"

  # Hook copying disabled
  echo "! Hook scripts disabled - no hooks will be copied"

  # Set up MCP configuration
  echo "Setting up MCP configuration..."

  # Copy MCP configuration from ConfigMap to project root (project scope)
  if [ -f "/task-files/mcp.json" ]; then
    cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
    echo "âœ“ Copied mcp.json to .mcp.json (project scope)"
    # Also copy to /workspace for Claude's MCP loader
    cp /task-files/mcp.json "/workspace/.mcp.json"
    echo "âœ“ Copied mcp.json to /workspace/.mcp.json for MCP loader"
  else
    echo "âš ï¸  mcp.json template not found"
  fi

  # Enterprise managed settings - copy to writable location for model rotation
  echo "=== ENTERPRISE MANAGED SETTINGS ==="
  echo "âœ“ Settings source: /etc/claude-code/managed-settings.json (ConfigMap mount)"
  
  # Copy enterprise settings to writable location
  # ConfigMap mounts use symlinks that can't be modified, so we copy to a writable path
  # Claude will use this writable copy, allowing model rotation to work
  mkdir -p "/etc/claude-code-writable"
  if [ -f "/etc/claude-code/managed-settings.json" ]; then
    cp "/etc/claude-code/managed-settings.json" "/etc/claude-code-writable/managed-settings.json"
    echo "âœ“ Copied enterprise settings to /etc/claude-code-writable/managed-settings.json (writable)"
    echo "âœ“ Model rotation will modify this writable copy"
  else
    echo "âš ï¸ Enterprise settings not found, Claude will use defaults"
  fi

  echo "âœ“ ConfigMap files copied to $CLAUDE_WORK_DIR"
else
  echo "âš ï¸  Warning: /task-files directory not found (ConfigMap not mounted?)"
fi


# Resilient Task Documentation Setup - PRESERVE EXISTING FILES
echo "=== TASK DOCUMENTATION SETUP (RESILIENT MODE) ==="
echo "ðŸ” DEBUG: REPO_NAME is: $REPO_NAME"
echo "ðŸ” DEBUG: CLAUDE_WORK_DIR is: $CLAUDE_WORK_DIR"
echo "ðŸ” DEBUG: Task ID is: {{task_id}}"

# CRITICAL: Use safe_ensure_directory to avoid overwriting existing files
TASK_FINAL_DIR="$CLAUDE_WORK_DIR/task"
echo "ðŸ“ Ensuring task directory exists WITHOUT overwriting files..."

if ! safe_ensure_directory "$TASK_FINAL_DIR" "final task directory"; then
    echo "âŒ CRITICAL: Cannot ensure task directory exists"
    create_error_report "$TASK_FINAL_DIR" "{{task_id}}" "Cannot create final task directory"
    exit 1
fi

# Verify that critical files are present after directory setup
echo "ðŸ” VERIFICATION: Checking if task files survived directory setup..."
if verify_task_files "$TASK_FINAL_DIR" "{{task_id}}"; then
    echo "âœ… Task files verification: PASSED - all critical files present"
else
    echo "âŒ CRITICAL: Task files missing after directory setup!"
    
    # Task files are missing - this indicates a problem with the copy operation
    echo "âŒ No recovery available - task files were never copied or copy operation failed"
    echo "ðŸ” DEBUG: Expected location: $TASK_FINAL_DIR"
    echo "ðŸ” DEBUG: Source location: $TASK_DIR"
    echo "ðŸ” DEBUG: Checking source directory:"
    ls -la "$TASK_DIR" 2>/dev/null || echo "Source directory not accessible"
    create_error_report "$TASK_FINAL_DIR" "{{task_id}}" "Task files missing - copy operation may have failed"
    exit 1
fi

# Final comprehensive verification
echo "ðŸ” FINAL VERIFICATION: Task setup completion check..."
if verify_task_files "$TASK_FINAL_DIR" "{{task_id}}"; then
    echo "âœ… TASK SETUP SUCCESS: All critical files verified in final location"
    echo "ðŸ“Š Final task directory contents:"
    ls -la "$TASK_FINAL_DIR/" | sed 's/^/    /'
else
    echo "âŒ TASK SETUP FAILED: Critical files missing in final verification"
    create_error_report "$TASK_FINAL_DIR" "{{task_id}}" "Final verification failed - critical files missing"
    exit 1
fi

# Move client-config.json if it's in the task directory
if [ -f "$CLAUDE_WORK_DIR/task/client-config.json" ]; then
    mv "$CLAUDE_WORK_DIR/task/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" && echo "âœ“ client-config.json moved to Claude working directory" || echo "âŒ client-config.json move failed"
fi

# DEBUG: Verify files were copied successfully
echo "ðŸ” DEBUG: Contents of target task directory:"
ls -la "$CLAUDE_WORK_DIR/task/" || echo "Task directory not found"
echo "ðŸ” DEBUG: Checking if prompt.md exists:"
[ -f "$CLAUDE_WORK_DIR/task/prompt.md" ] && echo "âœ… prompt.md exists" || echo "âŒ prompt.md missing"

# Verify client-config.json is available in Claude's working directory
echo "=== TOOLS CONFIG SETUP ==="
WORKSPACE_CFG="$CLAUDE_WORK_DIR/client-config.json"
SOURCE_CFG="/task-files/client-config.json"

# Helper to check non-empty JSON object
is_valid_cfg() {
  local p="$1"
  [ -f "$p" ] || return 1
  jq -e 'type=="object" and length>0' "$p" >/dev/null 2>&1
}

# --- Remediation status label helpers ---------------------------------------

STATUS_LABEL_NEEDS_FIXES="needs-fixes"
STATUS_LABEL_FIXING="fixing-in-progress"
STATUS_LABEL_NEEDS_CLEO="needs-cleo"
STATUS_LABEL_NEEDS_TESS="needs-tess"
STATUS_LABEL_APPROVED="approved"
STATUS_LABEL_FAILED="failed-remediation"
STATUS_LABEL_NEEDS_TESTS_LEGACY="needs tests"

ensure_status_labels() {
  local repo="$1"
  shift
  command -v gh >/dev/null 2>&1 || return 0

  for entry in "$@"; do
    [ -n "$entry" ] || continue
    local label="${entry%%:*}"
    local rest="${entry#*:}"
    local color="${rest%%:*}"
    local desc="${rest#*:}"

    if ! gh label list -R "$repo" --search "$label" 2>/dev/null | grep -q "^$label"; then
      gh label create "$label" --force -R "$repo" --color "$color" --description "$desc" >/dev/null 2>&1 || true
    fi
  done
}

pr_add_labels() {
  local repo="$1"
  local pr_number="$2"
  local pr_url="$3"
  shift 3

  command -v gh >/dev/null 2>&1 || return 0

  for label in "$@"; do
    [ -n "$label" ] || continue
    if [ -n "$pr_number" ]; then
      gh pr edit "$pr_number" -R "$repo" --add-label "$label" >/dev/null 2>&1 || echo "âš ï¸ Failed to add label '$label' to PR #$pr_number"
    elif [ -n "$pr_url" ]; then
      gh pr edit "$pr_url" --add-label "$label" >/dev/null 2>&1 || echo "âš ï¸ Failed to add label '$label' to PR $pr_url"
    fi
  done
}

pr_remove_labels() {
  local repo="$1"
  local pr_number="$2"
  local pr_url="$3"
  shift 3

  command -v gh >/dev/null 2>&1 || return 0

  for label in "$@"; do
    [ -n "$label" ] || continue
    if [ -n "$pr_number" ]; then
      gh pr edit "$pr_number" -R "$repo" --remove-label "$label" >/dev/null 2>&1 || true
    elif [ -n "$pr_url" ]; then
      gh pr edit "$pr_url" --remove-label "$label" >/dev/null 2>&1 || true
    fi
  done
}

update_coderun_status() {
  local remediation="$1"
  local qa="$2"
  local pr_url_value="${3:-$PR_URL}"

  if ! command -v kubectl >/dev/null 2>&1; then
    return
  fi

  if ! command -v jq >/dev/null 2>&1; then
    echo "âš ï¸ jq not available; skipping CodeRun status update"
    return
  fi

  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  local patch
  patch=$(jq -n \
    --arg ts "$timestamp" \
    --arg pr "$pr_url_value" \
    --arg rem "$remediation" \
    --arg qa "$qa" \
    '{status: ({lastUpdate: $ts}
        + (if $pr != "" then {pullRequestUrl: $pr} else {} end)
        + (if $rem != "" then {remediationStatus: $rem} else {} end)
        + (if $qa != "" then {qaStatus: $qa} else {} end))}')

  if [ -n "$CODERUN_NAME" ] && [ -n "$NAMESPACE" ]; then
    kubectl patch coderun "$CODERUN_NAME" -n "$NAMESPACE" --type=merge --subresource=status -p "$patch" >/dev/null 2>&1 || \
      echo "âš ï¸ Failed to update CodeRun status with remediation context"
  fi
}

SRC_OK=false
WS_OK=false
if is_valid_cfg "$SOURCE_CFG"; then SRC_OK=true; fi
if is_valid_cfg "$WORKSPACE_CFG"; then WS_OK=true; fi

if $SRC_OK; then
  export MCP_CLIENT_CONFIG="$SOURCE_CFG"
  echo "âœ“ Selected MCP_CLIENT_CONFIG from source ConfigMap: $MCP_CLIENT_CONFIG"
elif $WS_OK; then
  export MCP_CLIENT_CONFIG="$WORKSPACE_CFG"
  echo "âœ“ Selected MCP_CLIENT_CONFIG from workspace copy: $MCP_CLIENT_CONFIG"
else
  echo "âŒ No valid client-config.json found (both source and workspace empty/invalid). Aborting."
  if [ -f "$SOURCE_CFG" ]; then
    echo "   Source summary:"; (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' "$SOURCE_CFG" 2>/dev/null || { echo -n "   raw="; head -c 200 "$SOURCE_CFG"; echo; })
  else
    echo "   Source missing: $SOURCE_CFG"
  fi
  if [ -f "$WORKSPACE_CFG" ]; then
    echo "   Workspace summary:"; (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' "$WORKSPACE_CFG" 2>/dev/null || { echo -n "   raw="; head -c 200 "$WORKSPACE_CFG"; echo; })
  else
    echo "   Workspace missing: $WORKSPACE_CFG"
  fi
  exit 1
fi

echo '=== WORKSPACE VALIDATION ==='

# Check for required files in Claude's working directory
MISSING_FILES=""
REQUIRED_FILES="CLAUDE.md"

echo "Checking for required files..."
for file in $REQUIRED_FILES; do
  if [ ! -f "$CLAUDE_WORK_DIR/$file" ]; then
    echo "ERROR: Missing required file: $CLAUDE_WORK_DIR/$file"
    MISSING_FILES="$MISSING_FILES $file"
  else
    echo "âœ“ Found: $CLAUDE_WORK_DIR/$file"
    # Show file size for verification
    size=$(wc -c < "$CLAUDE_WORK_DIR/$file" 2>/dev/null || echo "0")
    echo "  File size: $size bytes"
  fi
done

# Check git repository (REQUIRED for implementation tasks)
if [ ! -d "$TASK_REPO_DIR/.git" ]; then
  echo "âœ— CRITICAL ERROR: No target git repository found!"
  MISSING_FILES="$MISSING_FILES git-repository"
else
  echo "âœ“ Found: target git repository"
fi

# If any files are missing, abort
if [ -n "$MISSING_FILES" ]; then
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "â•‘                 WORKSPACE VALIDATION FAILED                  â•‘"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  echo "The following required files are missing:"
  for missing in $MISSING_FILES; do
    case "$missing" in
      "CLAUDE.md")
        echo "  âŒ $missing - Main task instructions for Claude"
        ;;
      "git-repository")
        echo "  âŒ $missing - Required for committing implementation changes"
        ;;
      *)
        echo "  âŒ $missing"
        ;;
    esac
  done
  echo ""
  echo "These files should have been created by the ConfigMap setup process."
  echo "Claude will NOT be started to avoid wasting API credits."
  echo ""
  exit 1
fi

echo "âœ“ All required files present. Workspace is valid."

echo '=== IMPLEMENTATION TASK DIAGNOSTICS ==='
echo "Project directory: $CLAUDE_WORK_DIR"
echo "Project directory contents:"
ls -la "$CLAUDE_WORK_DIR"
echo ""

# Show git status from repository root
echo "Git status:"
(cd "$TASK_REPO_DIR" && git status 2>/dev/null) || echo "Git status unavailable"
echo ""

echo '=== CLAUDE EXECUTION ==='

# Export necessary variables
export SERVICE_NAME="{{service}}"
export TASK_ID="{{task_id}}"
export GITHUB_APP="{{github_app}}"

# Change to project directory before running Claude
cd "$CLAUDE_WORK_DIR"
echo "Changed to directory: $(pwd)"

# Verify we're in the correct directory and have required files
echo "=== WORKING DIRECTORY VERIFICATION ==="
echo "Current working directory: $(pwd)"
echo "Expected directory: $CLAUDE_WORK_DIR"
if [ "$(pwd)" != "$CLAUDE_WORK_DIR" ]; then
  echo "âŒ ERROR: Failed to change to correct working directory!"
  echo "Attempting to change directory again..."
  cd "$CLAUDE_WORK_DIR" || exit 1
  echo "âœ“ Successfully changed to: $(pwd)"
fi

# Verify git repository is accessible from Claude working directory
echo "=== GIT REPOSITORY VERIFICATION ==="
if [ ! -d ".git" ]; then
  echo "âŒ ERROR: No .git directory found in Claude working directory: $(pwd)"
  echo "ðŸ“‚ Checking parent directory structure:"
  echo "  Current: $(pwd)"
  echo "  Contents: $(ls -la . | head -5)"
  if [ -d "$TASK_REPO_DIR/.git" ]; then
    echo "  Found .git at: $TASK_REPO_DIR/"
    echo "ðŸ”§ This indicates a working directory path mismatch"
    echo "ðŸ”§ CLAUDE_WORK_DIR: $CLAUDE_WORK_DIR"
    echo "ðŸ”§ Expected git repo: /workspace/$REPO_NAME"
  fi
  exit 1
else
  echo "âœ… Git repository verified at: $(pwd)/.git"
  echo "âœ… Repository status: $(git status --porcelain | wc -l) modified files"
  echo "âœ… Current branch: $(git branch --show-current 2>/dev/null || echo 'detached')"
fi

# Verify setup
echo "âœ“ Code implementation environment ready"

# =========================================================================
# MCP TOOLS VALIDATION
# =========================================================================
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                 VALIDATING MCP TOOLS ACCESS                   â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "ðŸ” Verifying Claude MCP tools..."

TOOL_VERIFICATION_FAILED=false

if command -v claude >/dev/null 2>&1; then
  # Check MCP servers first
  echo "ðŸ“‹ Checking MCP servers..."
  MCP_LIST=$(claude mcp list 2>&1 || echo "FAILED")
  
  if echo "$MCP_LIST" | grep -q "Connected"; then
    echo "  âœ“ MCP servers connected"
    echo "$MCP_LIST" | grep "Connected" | sed 's/^/  /'
  else
    echo "  âš ï¸ No MCP servers connected"
    TOOL_VERIFICATION_FAILED=true
  fi
  
  # Blaze needs: Context7, shadcn, GitHub
  REQUIRED_SERVERS=("tools")
  
  echo ""
  echo "ðŸ” Verifying required MCP servers..."
  for server in "${REQUIRED_SERVERS[@]}"; do
    if echo "$MCP_LIST" | grep -q "$server.*Connected"; then
      echo "  âœ“ $server server available"
    else
      echo "  âŒ $server server NOT available"
      TOOL_VERIFICATION_FAILED=true
    fi
  done
  
  echo ""
else
  echo "  âš ï¸ claude CLI not available for tool verification"
  TOOL_VERIFICATION_FAILED=true
fi

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

if [ "$TOOL_VERIFICATION_FAILED" = "true" ]; then
  echo ""
  echo "âŒ TOOL VERIFICATION FAILED"
  echo "Critical MCP servers are not available. Cannot proceed with task."
  echo ""
  echo "Common issues:"
  echo "  - Tools server not reachable"
  echo "  - MCP servers not initialized properly"
  echo "  - .mcp.json misconfigured"
  echo ""
  echo "Full MCP server list:"
  claude mcp list 2>&1 || echo "Failed to list MCP servers"
  echo ""
  exit 1
fi

echo "âœ… All critical MCP tools verified successfully"
echo ""
# =========================================================================

# Build Claude command
CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Add writable enterprise settings for model rotation
if [ -f "/etc/claude-code-writable/managed-settings.json" ]; then
    echo "âœ“ Using writable enterprise settings for model rotation"
    CLAUDE_CMD="$CLAUDE_CMD --settings /etc/claude-code-writable/managed-settings.json"
fi

# Add MCP configuration if available
if [ -f "/workspace/.mcp.json" ]; then
    echo "âœ“ Adding MCP configuration from /workspace/.mcp.json to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --mcp-config /workspace/.mcp.json"
else
    echo "âš ï¸ No MCP configuration file found at /workspace/.mcp.json, MCP servers will not be available"
fi

# Look for Rex-specific system prompt file, then combine with inline SYSTEM_PROMPT so it is always utilized
SELECTED_SYS_PROMPT=""
if [ -f "/task-files/rex-system-prompt.md" ]; then
    echo "âœ“ Found Rex system prompt file"
    SELECTED_SYS_PROMPT="/task-files/rex-system-prompt.md"
    if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
        echo "[DEBUG] System prompt path: $SELECTED_SYS_PROMPT"
        echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "$SELECTED_SYS_PROMPT" | sed 's/^/[DEBUG] /'
        echo "[DEBUG] ----"
    fi
elif [ -f "/config/agents/{{github_app}}_system-prompt.md" ]; then
    echo "âœ“ Found system prompt file for {{github_app}}"
    SELECTED_SYS_PROMPT="/config/agents/{{github_app}}_system-prompt.md"
    if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
        echo "[DEBUG] System prompt path: $SELECTED_SYS_PROMPT"
        echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "$SELECTED_SYS_PROMPT" | sed 's/^/[DEBUG] /'
        echo "[DEBUG] ----"
    fi
else
    echo "â„¹ï¸ No system prompt file found for agent {{github_app}}"
fi

# Defer combining with inline SYSTEM_PROMPT until after it is defined

# Model is set via settings.json template, not CLI flag

# Add continue flag if this is a retry attempt or user requested continuation
{{#if continue_session}}
CLAUDE_CMD="$CLAUDE_CMD --continue"
echo 'Adding --continue flag (attempt {{attempts}}{{#if user_requested}} - user requested{{/if}})'
{{/if}}

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                    STARTING CLAUDE EXECUTION                  â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "Command: $CLAUDE_CMD"
echo "Note: Claude will automatically read CLAUDE.md from the working directory"

# Inline system prompt (static content)
SYSTEM_PROMPT='## ðŸš¨ CRITICAL SYSTEM REQUIREMENTS ðŸš¨

**â›” OVERCONFIDENCE MITIGATION - MANDATORY VERIFICATION â›”**

You have a DANGEROUS tendency to declare task completion before actually verifying everything works. This is ABSOLUTELY UNACCEPTABLE.

**MANDATORY VERIFICATION REQUIREMENTS:**
- âœ… **MUST** actually run and test your code - never assume it works
- âœ… **MUST** verify ALL acceptance criteria through actual testing
- âœ… **MUST** confirm your changes don'\''t break existing functionality
- âœ… **MUST** test end-to-end workflows and edge cases
- âœ… **MUST** run all linters and build checks successfully
- âœ… **CANNOT** claim completion based on code appearance alone

**YOU ARE PROHIBITED FROM CLAIMING SUCCESS UNTIL:**
1. You have executed and verified every piece of functionality
2. You have tested integration with existing systems
3. You have confirmed all acceptance criteria pass through testing
4. All automated tests pass (linting, builds, unit tests)
5. You have verified the solution works end-to-end in practice

**IF YOU DECLARE SUCCESS WITHOUT VERIFICATION, YOU HAVE FAILED.**

## ðŸ”§ ORCHESTRATOR EXECUTION CONTEXT

- **Service**: {{service}}
- **Task ID**: {{task_id}}
- **Repository**: {{repository_url}}
- **Docs Repository**: {{docs_repository_url}}
- **Working Directory**: {{working_directory}}
- **GitHub App**: {{github_app}}

{{#if continue_session}}
## ðŸ”„ CONTINUE SESSION - PR COMMENT RESOLUTION PRIORITY

**âš ï¸ MANDATORY FIRST STEP: Before proceeding with any other work, you MUST:**

1. **Check for unresolved PR comments**: Use `gh pr view --json reviews` or check the PR directly
2. **Resolve ALL pending comments first**: Address reviewer feedback, fix issues, respond to questions
3. **Push comment resolutions**: Commit and push any fixes for reviewer concerns
4. **Only then proceed**: After ALL PR comments are resolved, continue with the main task

**This ensures reviewer feedback takes priority and maintains collaborative workflow quality.**

{{/if}}
## âš ï¸ EXECUTION REQUIREMENTS

- **Follow patterns**: Use @coding-guidelines.md and @github-guidelines.md
- **NO MOCKS ALLOWED**: Implement ONLY with real data sources and live APIs - no hard-coded values, no mock data
- **Parameterized Configuration**: ALL business logic parameters (trading pairs, endpoints, thresholds) must be configurable via env vars, config files, or CLI args
- **Pre-PR quality gates (MANDATORY)**: Do NOT open a PR unless all of these pass locally:
  - `cargo fmt --all -- --check`
  - `cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic`
  - `cargo test --workspace --all-features` and high coverage (aim â‰¥95%, target ~100% on critical paths)
- **GitHub workflow**: Read @github-guidelines.md for commit standards
- **Verify continuously**: Run tests and checks after each significant change
- **Commit incrementally**: Don'\''t save all changes for the end
- **Test thoroughly**: Validate against acceptance criteria before completion

## ðŸš¨ NON-NEGOTIABLE PULL REQUEST REQUIREMENT ðŸš¨

**â›” CRITICAL: YOU MUST CREATE A PULL REQUEST - NO EXCEPTIONS â›”**

**MANDATORY FINAL STEP:**
- **MUST** create a pull request using `gh pr create` command
- **MUST** include proper labels (task-{{task_id}}, run-{{workflow.name}}, service-{{service}})
- **MUST** verify PR creation succeeded before claiming task completion
- **THE TASK IS INCOMPLETE AND FAILED IF NO PR IS CREATED**

**YOU CANNOT COMPLETE THIS TASK WITHOUT CREATING A PULL REQUEST.**
**IF YOU DO NOT CREATE A PR, YOU HAVE FAILED THE TASK COMPLETELY.**

**Remember**: Focus on thorough implementation and verification.'

# Now that SYSTEM_PROMPT is defined, combine with selected file and add to CLI
COMBINED_SYS_PROMPT="/tmp/system-prompt-combined.md"
{
  if [ -n "$SELECTED_SYS_PROMPT" ]; then
    cat "$SELECTED_SYS_PROMPT" || true
    echo "\n---\n(Appended inline system requirements)\n"
  else
    echo "---"
    echo "name: InlineSystem"
    echo "description: Appended inline system requirements"
    echo "---"
  fi
  printf '%s' "$SYSTEM_PROMPT"
} > "$COMBINED_SYS_PROMPT"

# Ensure we pass the combined system prompt
CLAUDE_CMD="$CLAUDE_CMD --system-prompt $COMBINED_SYS_PROMPT"

# Initialize retry loop variables
MAX_RETRIES=${CLAUDE_MAX_RETRIES:-${EXECUTION_MAX_RETRIES:-10}}
ATTEMPT=1
SUCCESS=0
CLAUDE_EXIT_CODE=1

echo "ðŸ”„ Rex will retry up to $MAX_RETRIES times until implementation is complete"
echo ""

# =========================================================================
# Model rotation configuration
# =========================================================================
DEFAULT_MODEL="{{model}}"
MODEL_ROTATION=()
MODEL_ROTATION_COUNT=0
{{#if model_rotation}}
MODEL_ROTATION=(
{{#each model_rotation}}
"{{this}}"
{{/each}}
)
MODEL_ROTATION_COUNT=${#MODEL_ROTATION[@]}
if [ $MODEL_ROTATION_COUNT -gt 0 ]; then
  echo "ðŸŽ¯ Model rotation enabled (${MODEL_ROTATION_COUNT} models): ${MODEL_ROTATION[*]}"
fi
{{/if}}
if [ -z "$DEFAULT_MODEL" ] && [ $MODEL_ROTATION_COUNT -gt 0 ]; then
  DEFAULT_MODEL="${MODEL_ROTATION[0]}"
fi
if [ -n "$DEFAULT_MODEL" ]; then
  echo "ðŸŽ¯ Default model: $DEFAULT_MODEL"
fi

# Retry loop - Rex will continue until PR is created with working code
COMPLETED_ATTEMPTS=0
while [ $ATTEMPT -le $MAX_RETRIES ]; do
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "ðŸš€ Rex Implementation Attempt $ATTEMPT/$MAX_RETRIES"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

  CURRENT_ATTEMPT=$ATTEMPT

  # Calculate which model to use for this attempt
  CURRENT_MODEL="$DEFAULT_MODEL"
  if [ $MODEL_ROTATION_COUNT -gt 0 ]; then
    MODEL_INDEX=$(((ATTEMPT - 1) % MODEL_ROTATION_COUNT))
    CURRENT_MODEL="${MODEL_ROTATION[$MODEL_INDEX]}"
  fi
  if [ -n "$CURRENT_MODEL" ]; then
    echo "ðŸŽ¯ Attempt $ATTEMPT will use model: $CURRENT_MODEL"
    
    # Update writable copy of enterprise settings with current model
    if [ -f "/etc/claude-code-writable/managed-settings.json" ]; then
      jq --arg model "$CURRENT_MODEL" '.model = $model' "/etc/claude-code-writable/managed-settings.json" > /tmp/settings-rotated.json && \
      mv /tmp/settings-rotated.json "/etc/claude-code-writable/managed-settings.json"
      echo "âœ“ Updated model rotation settings"
    fi
  fi

echo "Starting Claude execution (text output via FIFO)..."
echo "=========================="

# Safe mode toggle for debugging (prevents token consumption)
SAFE_MODE="false"  # Set to "false" for full task execution

if [ "$SAFE_MODE" = "true" ]; then
    echo "ðŸ›¡ï¸ SAFE MODE ENABLED - Running simple test instead of full task"
    FIFO_PATH="/workspace/agent-input.jsonl"
    rm -f "$FIFO_PATH" 2>/dev/null || true
    mkfifo "$FIFO_PATH"
    chmod 666 "$FIFO_PATH" || true
    # Keep a persistent writer open and start Claude in background to avoid EOF race
    exec 9>"$FIFO_PATH"
    $CLAUDE_CMD < "$FIFO_PATH" &
    CLAUDE_PID=$!
    printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":"What time is it? Please answer this simple question and exit immediately."}]}}\n' >&9
    # Close writer so reader can exit cleanly
    exec 9>&-
    wait $CLAUDE_PID
else
    # Debug: Show what's actually in the task directory before checking for prompt.md
    echo "ðŸ” DEBUG: About to check for prompt.md at: $CLAUDE_WORK_DIR/task/prompt.md"
    echo "ðŸ” DEBUG: Contents of task directory:"
    ls -la "$CLAUDE_WORK_DIR/task/" || echo "Task directory not found or empty"
    echo "ðŸ” DEBUG: Current working directory contents:"
    ls -la "$CLAUDE_WORK_DIR/" || echo "Working directory not accessible"

    # Check if prompt.md exists and use it as main prompt
    if [ -f "$CLAUDE_WORK_DIR/task/prompt.md" ]; then
        echo "âœ“ Using task-specific prompt from docs service: task/prompt.md"

        echo "startingTask:{{task_id}}"
        echo ""

        # DEBUG: Print MCP_CLIENT_CONFIG for troubleshooting client config issues
        echo "ðŸ” DEBUG: MCP_CLIENT_CONFIG is set to: '$MCP_CLIENT_CONFIG'"
        if [ -f "$MCP_CLIENT_CONFIG" ]; then
            echo "ðŸ” DEBUG: MCP_CLIENT_CONFIG file exists and is readable"
            echo "ðŸ” DEBUG: First few lines of client config:"
            head -10 "$MCP_CLIENT_CONFIG" 2>/dev/null || echo "Could not read client config file"
        else
            echo "ðŸ” DEBUG: MCP_CLIENT_CONFIG file does NOT exist or is not readable"
        fi
        echo ""

        # Prepare prompt prefix with CRITICAL task isolation instruction
        PROMPT_PREFIX="â›” **CRITICAL TASK ISOLATION REQUIREMENT** â›”

You are assigned to work on **TASK {{task_id}} ONLY**.

**STRICT RULES:**
1. You MUST ONLY implement Task {{task_id}} - ignore ALL other tasks
2. DO NOT skip ahead to other tasks, even if you see evidence of previous work
3. DO NOT implement task-2, task-3, task-4, etc. - ONLY Task {{task_id}}
4. If you see existing code from other tasks, IGNORE IT
5. If your memory (CLAUDE.md) mentions other tasks, IGNORE those parts
6. Focus SOLELY on the requirements in task/prompt.md for Task {{task_id}}
7. NEVER use mocks or hard-coded values - implement with real APIs, databases, and configurable parameters
        
        **TASK VERIFICATION:** Before starting, confirm you are working on Task {{task_id}} by stating: \"Starting implementation of Task {{task_id}} only.\"
        
        ---
        
        ðŸš¨ NON-NEGOTIABLE PR REQUIREMENT ðŸš¨
        
        After you finish implementation and validations:
        - Stage and commit changes with a clear message
        - Push the feature branch to origin
        - Create a pull request targeting main using 'gh pr create' with an informative title/body
        - Do NOT claim completion until 'gh pr list --head <current-branch>' returns a PR number
        - If PR creation fails (auth/network), diagnose and retry until successful
        
        ---
        
        "

        # Add tools guidance if available
        if [ -f "$CLAUDE_WORK_DIR/task/tools-guide.md" ]; then
            PROMPT_PREFIX="${PROMPT_PREFIX}ðŸ”§ **Tool Usage Reference**

Before starting implementation, you MUST read and follow the task-specific tool guidance in the file \`task/tools-guide.md\`. This file contains:
- Selected tools for this specific task
- When and how to use each tool
- Tool arguments, parameters, and configuration options
- Implementation workflow and best practices
- Tool relationships and sequencing

**The tools-guide.md is your authoritative reference for tool usage in this task.**

---

"
            echo "âœ“ Including task isolation instructions and tools guidance"
        else
            echo "âœ“ Including task isolation instructions (no tools guide found)"
        fi

        # CRITICAL: Inject design system documentation for Blaze (frontend agent)
        # This ensures shadcn/ui requirements are in the initial context, not just referenced
        if [ -f "$CLAUDE_WORK_DIR/design-system.md" ]; then
            PROMPT_PREFIX="${PROMPT_PREFIX}ðŸ“ **MANDATORY DESIGN SYSTEM - READ THIS FIRST**

ðŸš« **CRITICAL RULE: NO Material-UI**
**Material-UI (MUI) is PROHIBITED. Always use shadcn/ui for React components.**

**Technology Stack Requirements:**
- Framework: Next.js 15 + React 19 (NOT React 18, NOT Remix, NOT CRA)
- Components: shadcn/ui (copied into your repo via \`npx shadcn@latest add [components]\`)
- Styling: Tailwind CSS 4 ONLY (NO Material-UI, NO @mui/*, NO CSS-in-JS)

**DO:**
- Use \`npx shadcn@latest add button card form\` to install components
- Use React 19.0.0+ and Next.js 15.0.0+
- Import from \`@/components/ui/\` (shadcn pattern)

**NEVER:**
- Install @mui/material, @mui/core, or any Material-UI packages
- Use React 18.x or older versions
- Import from @mui/* packages

**Complete design system documentation is available in \`design-system.md\` in your working directory.**

---

"
            echo "âœ“ Including critical design system requirements in initial context"
        else
            echo "âš ï¸ Warning: design-system.md not found - Blaze may use incorrect component library"
        fi

        # Compose initial user turn
        USER_COMBINED=$(printf "%s" "${PROMPT_PREFIX}$(cat "$CLAUDE_WORK_DIR/task/prompt.md")" | jq -Rs .)
        
        # Construct JSON for direct stdin piping (no sidecar, no FIFO)
        PROMPT_JSON=$(printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}' "$USER_COMBINED")
        
        # Start Claude with prompt piped directly to stdin
        printf '%s\n' "$PROMPT_JSON" | $CLAUDE_CMD &
        CLAUDE_PID=$!
        echo "âœ“ Started Claude with task prompt (PID: $CLAUDE_PID)"

        # Start background token refresh for long-running jobs
        (
            while kill -0 $CLAUDE_PID 2>/dev/null; do
                sleep 2700  # Check every 45 minutes

                if [ -n "$TOKEN_GENERATED_AT" ] && [ -n "$GITHUB_APP_PRIVATE_KEY" ]; then
                    NOW=$(date +%s)
                    TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))

                    if [ $TOKEN_AGE -gt 2700 ]; then
                        echo "[Background] Token is $(($TOKEN_AGE / 60)) minutes old, refreshing..."
                        refresh_github_token
                    fi
                fi
            done
        ) &
        TOKEN_REFRESH_PID=$!
        echo "âœ“ Started background token refresh (PID: $TOKEN_REFRESH_PID)"


        # Optional hang diagnostics without enforcing a timeout
        # NOTE: FIFO diagnostics below are OBSOLETE after sidecar removal (no more agent-input.jsonl FIFO)
        # This code is retained but will never find FIFO holders since we now pipe directly to stdin
        if [ -n "${HANG_DIAG_SECONDS:-}" ] && [ "$HANG_DIAG_SECONDS" -gt 0 ] 2>/dev/null; then
          (
            sleep "$HANG_DIAG_SECONDS"
            if kill -0 "$CLAUDE_PID" 2>/dev/null; then
              echo "[DEBUG] Hang diag after ${HANG_DIAG_SECONDS}s: dumping process info"
              echo "[DEBUG] NOTE: FIFO holder diagnostics are obsolete (no FIFO used after sidecar removal)"
              for p in /proc/[0-9]*; do
                pid=${p##*/}; [ -d "$p/fd" ] || continue
                for fd in "$p"/fd/*; do tgt=$(readlink "$fd" 2>/dev/null || true); case "$tgt" in *agent-input.jsonl*) fdnum=${fd##*/}; comm=$(cat "$p/comm" 2>/dev/null || echo "?"); echo "  PID=$pid COMM=$comm FD=$fdnum -> $tgt (UNEXPECTED - FIFO should not exist)";; esac; done
              done
              ps -eo pid,ppid,comm,args | head -200 || true
            fi
          ) & HANG_DIAG_PID=$!
        fi

        # Wait for Claude process to complete naturally
        echo "â³ Waiting for Claude process (PID: $CLAUDE_PID) to complete..."

        # Simple wait - Claude should exit naturally when done
        wait "$CLAUDE_PID"
        CLAUDE_EXIT_CODE=$?

        # Stop token refresh background process
        if [ -n "$TOKEN_REFRESH_PID" ]; then
            kill $TOKEN_REFRESH_PID 2>/dev/null || true
            echo "âœ“ Stopped token refresh process"
        fi

        if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
          echo "âœ… Claude process completed successfully"
        else
          echo "âŒ Claude process FAILED with exit code: $CLAUDE_EXIT_CODE"
          echo "ðŸ” Critical error - Claude did not complete successfully"
          echo "ðŸ“‹ This typically indicates:"
          echo "   - API rate limiting or authentication issues"
          echo "   - MCP client configuration problems"
          echo "   - Invalid prompt or system message formatting"
          echo "   - Tool execution failures"
          echo ""
          echo "âš ï¸ ABORTING: Cannot continue without successful Claude execution"
          echo "ðŸ”š Force terminating container with error status..."
          
          # Clean up background processes
          if [ -n "$TOKEN_REFRESH_PID" ]; then
              kill $TOKEN_REFRESH_PID 2>/dev/null || true
          fi
          if [ -n "${HANG_DIAG_PID:-}" ]; then 
              kill "$HANG_DIAG_PID" 2>/dev/null || true
          fi
          
          # Write failure marker for debugging
          echo "rex-implementation-failed:$(date -u +%Y-%m-%dT%H:%M:%SZ):exit-code-$CLAUDE_EXIT_CODE" > /workspace/.rex-failed
          
          # Exit with error to signal pod failure
          exit $CLAUDE_EXIT_CODE
        fi

        # Stop diagnostics if running
        if [ -n "${HANG_DIAG_PID:-}" ]; then kill "$HANG_DIAG_PID" 2>/dev/null || true; fi

        # Ensure FIFO cleanup happens regardless of how Claude exited
        echo "ðŸ”§ Performing FIFO cleanup..."

        # Close FIFO writer if it was opened (in fallback)
        if [ "$FIFO_OPENED" = "true" ]; then
          echo "ðŸ”§ Closing FIFO file descriptor..."
          # Try multiple methods to ensure fd 9 gets closed
          exec 9>&- 2>/dev/null || {
            echo "âš ï¸ exec 9>&- failed, trying alternative close method"
            eval "exec 9>&-" 2>/dev/null || {
              echo "âš ï¸ Alternative close failed, FIFO fd may remain open"
            }
          }
        else
          echo "â„¹ï¸ FIFO was not opened via fallback, checking sidecar"
        fi

        # Clean up FIFO file to ensure no processes are blocked
        if [ -p "$FIFO_PATH" ]; then
          echo "ðŸ”§ Removing FIFO to ensure clean shutdown"
          rm -f "$FIFO_PATH" 2>/dev/null || echo "âš ï¸ Could not remove FIFO"
        fi

        # No sidecar shutdown needed - container will exit naturally when main process completes
    else
        echo "âŒ ERROR: No prompt.md found from docs service"
        echo "The docs service should always provide task/prompt.md"
        echo "Check docs repository and task configuration"
        exit 1
    fi
fi

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘                 IMPLEMENTATION TASK COMPLETE                 â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'

# Claude execution completed â€” run post-completion hook if present to ensure PR creation
echo "ðŸ”— Checking for post-completion PR hook..."
if [ -f "/task-files/hooks-stop-code-pr-creation.sh" ]; then
  echo "ðŸ”— Found stop hook: /task-files/hooks-stop-code-pr-creation.sh"
  
  # Copy script to writable location to fix permission issues
  HOOK_SCRIPT="/tmp/hooks-stop-code-pr-creation.sh"
  cp "/task-files/hooks-stop-code-pr-creation.sh" "$HOOK_SCRIPT"
  chmod +x "$HOOK_SCRIPT"
  echo "âœ“ Copied hook script to writable location with execute permissions"
  
  echo "ðŸš€ Running stop hook to commit, push, and create PR (as fallback)..."
  (
    cd "$CLAUDE_WORK_DIR" && "$HOOK_SCRIPT"
  ) || echo "âš ï¸ Stop hook failed (continuing to PR verification)"
else
  echo "â„¹ï¸ No stop hook found; relying on agent-driven PR creation"
fi

echo "Claude has completed successfully."

# =============================================================================
# CRITICAL PR VERIFICATION - MUST HAVE CREATED A PR
# =============================================================================
echo ""
echo "ðŸ” VERIFYING PULL REQUEST CREATION (MANDATORY)..."
echo ""

# Give GitHub API a moment to register the PR if just created
sleep 3

# Check if a PR was created for this branch
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
PR_CHECK_FAILED=false

if [ "$CURRENT_BRANCH" != "unknown" ] && [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "master" ]; then
    echo "ðŸ“‹ Checking for PR on branch: $CURRENT_BRANCH"
    
    # Try to find PR by branch (need to specify repo)
    PR_EXISTS=$(gh pr list -R "$REPO_SLUG" --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")
    
    if [ -z "$PR_EXISTS" ]; then
        # Also check by task label as backup
        TASK_LABEL="task-${TASK_ID}"
        PR_EXISTS=$(gh pr list -R "$REPO_SLUG" --label "$TASK_LABEL" --json number --jq '.[0].number' 2>/dev/null || echo "")
    fi

    # If still not found, run the stop hook one more time (idempotent) then re-check
    if [ -z "$PR_EXISTS" ] && [ -f "/task-files/hooks-stop-code-pr-creation.sh" ]; then
        echo "ðŸ” No PR detected yet; retrying stop hook once more..."
        
        # Use the same writable copy approach for retry
        HOOK_SCRIPT="/tmp/hooks-stop-code-pr-creation.sh"
        if [ ! -f "$HOOK_SCRIPT" ]; then
            cp "/task-files/hooks-stop-code-pr-creation.sh" "$HOOK_SCRIPT"
            chmod +x "$HOOK_SCRIPT"
        fi
        
        (
          cd "$CLAUDE_WORK_DIR" && "$HOOK_SCRIPT"
        ) || echo "âš ï¸ Stop hook retry failed"
        echo "â³ Waiting briefly before re-checking PR..."
        sleep 3
        PR_EXISTS=$(gh pr list -R "$REPO_SLUG" --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")
    fi
    
    if [ -z "$PR_EXISTS" ]; then
        echo "âŒ CRITICAL ERROR: No pull request found!"
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "â•‘                    PR CREATION FAILED                        â•‘"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "Rex was required to create a pull request but failed to do so."
        echo "This is a MANDATORY requirement that was not met."
        echo ""
        echo "Possible reasons:"
        echo "  1. No code changes were made"
        echo "  2. Changes were not committed"
        echo "  3. Branch was not pushed to remote"
        echo "  4. PR creation command failed"
        echo "  5. GitHub authentication issues"
        echo ""
        echo "Diagnostic information:"
        echo "  Branch: $CURRENT_BRANCH"
        echo "  Task ID: ${TASK_ID}"
        
        # Check if there are uncommitted changes
        if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
            echo "  âš ï¸ There are uncommitted changes in the repository"
        fi
        
        # Check if branch exists on remote
        if ! git ls-remote --heads origin "$CURRENT_BRANCH" | grep -q "$CURRENT_BRANCH"; then
            echo "  âš ï¸ Branch not found on remote repository"
        fi
        
        echo ""
        echo "ðŸ”š FAILING CONTAINER: Rex did not create required pull request"
        
        # Write failure marker
        echo "rex-no-pr-created:$(date -u +%Y-%m-%dT%H:%M:%SZ):branch-$CURRENT_BRANCH" > /workspace/.rex-pr-failed
        
        # Exit with error
        exit 1
    else
        echo "âœ… Pull request #${PR_EXISTS} found successfully"
        echo "Rex has completed the task and created the required PR."
    fi
else
    echo "âš ï¸ WARNING: Unable to verify PR (branch detection failed)"
    echo "Branch: $CURRENT_BRANCH"
    # Don't fail here as this might be a git configuration issue
fi

# =============================================================================
# PR DETECTION AND LABELING
# =============================================================================
# After Claude completes, check if a PR was created and apply correlation labels
if [ -n "${GITHUB_TOKEN:-}" ] && command -v gh >/dev/null 2>&1; then
  echo "ðŸ” Checking for PRs created by this task..."

  # Debug: Show current directory and work directory
  echo "ðŸ“ Current directory: $(pwd)"
  echo "ðŸ“ Claude work directory: $CLAUDE_WORK_DIR"

  # Determine implementation repository slug for gh -R
  REPO_SLUG="${REPO_OWNER}/${REPO_NAME}"
  if [ -z "$REPO_OWNER" ] || [ -z "$REPO_NAME" ]; then
    ORIGIN_URL=$(git -C "$CLAUDE_WORK_DIR" remote get-url origin 2>/dev/null || echo "")
    if echo "$ORIGIN_URL" | grep -qE '^https://github.com/'; then
      REPO_SLUG=$(echo "$ORIGIN_URL" | sed -E 's|https://github.com/([^/]+/[^/]+)(\.git)?|\1|')
    elif echo "$ORIGIN_URL" | grep -qE '^git@github.com:'; then
      REPO_SLUG=$(echo "$ORIGIN_URL" | sed -E 's|git@github.com:([^/]+/[^/]+)(\.git)?|\1|')
    fi
  fi

  echo "ðŸ“ Repository: $REPO_SLUG"

  # Retry loop for PR detection (sometimes GitHub API takes a moment)
  MAX_RETRIES=${CLAUDE_MAX_RETRIES:-${EXECUTION_MAX_RETRIES:-5}}
  if [ "$MAX_RETRIES" = "0" ]; then
    echo "ðŸ”„ PR detection running in unlimited mode"
    UNLIMITED_PR_CHECK=1
  else
    UNLIMITED_PR_CHECK=0
  fi

  RETRY_COUNT=0
  PR_NUMBER=""

  while true; do
    if [ "$UNLIMITED_PR_CHECK" != "1" ] && [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
      break
    fi

    if [ $RETRY_COUNT -gt 0 ]; then
      if [ "$UNLIMITED_PR_CHECK" = "1" ]; then
        echo "â³ Retry $RETRY_COUNT (unlimited mode): Waiting for PR to appear in GitHub API..."
      else
        echo "â³ Retry $RETRY_COUNT/$MAX_RETRIES: Waiting for PR to appear in GitHub API..."
      fi
      sleep 3
    fi

    # First, try to find PR by task label (Claude may have added task-N label)
    TASK_LABEL="task-${TASK_ID}"
    PR_NUMBER=$(gh pr list -R "$REPO_SLUG" --label "$TASK_LABEL" --json number --jq '.[0].number' 2>/dev/null || true)

    # If not found by label, try by branch name (current branch)
    if [ -z "$PR_NUMBER" ]; then
      CURRENT_BRANCH=$(cd "$CLAUDE_WORK_DIR" && git rev-parse --abbrev-ref HEAD 2>/dev/null || true)
      if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "main" ]; then
        echo "ðŸ” Checking for PR on branch: $CURRENT_BRANCH"
        PR_NUMBER=$(gh pr list -R "$REPO_SLUG" --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || true)
      fi
    fi

    if [ -n "$PR_NUMBER" ]; then
      break
    fi

    RETRY_COUNT=$((RETRY_COUNT + 1))
  done

  if [ -n "$PR_NUMBER" ]; then
    echo "âœ… Found PR #${PR_NUMBER}"

    # Get the PR URL
    PR_URL="https://github.com/${REPO_SLUG}/pull/${PR_NUMBER}"
    echo "ðŸ“ PR URL: $PR_URL"
    echo "â„¹ï¸  Morgan PM will link this PR to the GitHub Project during workflow execution"

    ensure_status_labels "$REPO_SLUG" \
      "${STATUS_LABEL_NEEDS_FIXES}:d73a4a:Remediation requested by Tess" \
      "${STATUS_LABEL_FIXING}:fbca04:Rex is actively applying fixes" \
      "${STATUS_LABEL_NEEDS_CLEO}:0e8a16:Awaiting Cleo quality review" \
      "${STATUS_LABEL_NEEDS_TESS}:5319e7:Awaiting Tess QA review" \
      "${STATUS_LABEL_APPROVED}:2da44e:All automated reviews approved" \
      "${STATUS_LABEL_FAILED}:b60205:Remediation failed or aborted"

    pr_remove_labels "$REPO_SLUG" "$PR_NUMBER" "$PR_URL" \
      "$STATUS_LABEL_NEEDS_FIXES" \
      "$STATUS_LABEL_FIXING" \
      "$STATUS_LABEL_NEEDS_TESS" \
      "$STATUS_LABEL_APPROVED" \
      "$STATUS_LABEL_FAILED" \
      "$STATUS_LABEL_NEEDS_TESTS_LEGACY"

    # Note: No longer adding needs-cleo label - stage transitions use GitHub PR reviews
    # Correlation labels are added below (task-*, service-*, run-*)

    # Apply correlation labels with comprehensive debugging
    echo "ðŸ·ï¸ Adding correlation labels to PR #${PR_NUMBER}..."

    # Debug: Check environment variables
    echo "ðŸ” DEBUG: Environment check for label creation:"
    echo "   TASK_ID: '${TASK_ID}'"
    echo "   WORKFLOW_NAME: '${WORKFLOW_NAME}'"
    echo "   SERVICE_NAME: '${SERVICE_NAME}'"
    echo "   CODERUN_NAME: '${CODERUN_NAME}'"
    echo "   GitHub Token: $([ -n "$GITHUB_TOKEN" ] && echo 'Present' || echo 'Missing')"

    # Validate required variables
    if [ -z "$WORKFLOW_NAME" ]; then
      echo "âŒ ERROR: WORKFLOW_NAME is not set!"
      echo "ðŸ” DEBUG: Attempting to extract from CODERUN_NAME..."
      # Try to extract workflow name from CodeRun name pattern
      if [ -n "$CODERUN_NAME" ]; then
        # Pattern: service-t{task}-stage-{hash} created by workflow
        echo "   CODERUN_NAME format: $CODERUN_NAME"
      fi

      # Check if we can get it from Kubernetes labels
      if command -v kubectl >/dev/null 2>&1 && [ -n "$CODERUN_NAME" ] && [ -n "$NAMESPACE" ]; then
        echo "ðŸ” DEBUG: Trying to get workflow name from CodeRun labels..."
        WORKFLOW_FROM_LABELS=$(kubectl get coderun "$CODERUN_NAME" -n "$NAMESPACE" -o jsonpath='{.metadata.labels.workflow-name}' 2>/dev/null || echo "")
        if [ -n "$WORKFLOW_FROM_LABELS" ]; then
          echo "âœ… Found workflow name from CodeRun labels: $WORKFLOW_FROM_LABELS"
          WORKFLOW_NAME="$WORKFLOW_FROM_LABELS"
        else
          echo "âŒ Could not retrieve workflow name from CodeRun labels"
        fi
      fi

      # Final check - if still no workflow name, fail loudly
      if [ -z "$WORKFLOW_NAME" ]; then
        echo "âŒ CRITICAL: Cannot determine WORKFLOW_NAME - this will cause correlation issues!"
        echo "ðŸ” DEBUG: Available environment variables:"
        env | grep -E "WORKFLOW|CODERUN|TASK|SERVICE" | sort
        # DO NOT use 'unknown' - exit with error instead
        echo "âŒ Refusing to use 'unknown' label - failing task"
        exit 1
      fi
    fi

    TASK_LABEL="task-${TASK_ID}"
    RUN_LABEL="run-${WORKFLOW_NAME}"
    SERVICE_LABEL="service-${SERVICE_NAME}"

    echo "ðŸ“‹ Labels to apply:"
    echo "   Task: $TASK_LABEL"
    echo "   Run: $RUN_LABEL"
    echo "   Service: $SERVICE_LABEL"

    # Pre-create labels if they don't exist (do this BEFORE trying to add them)
    echo "ðŸ” Ensuring labels exist in repository..."
    for label in "$TASK_LABEL" "$RUN_LABEL" "$SERVICE_LABEL"; do
      if ! gh label list -R "$REPO_SLUG" --search "$label" | grep -q "^$label"; then
        echo "   ðŸ“ Creating label '$label'..."
        case "$label" in
          task-*) COLOR="28a745"; DESC="Task correlation" ;;
          run-*) COLOR="0366d6"; DESC="Workflow run correlation" ;;
          service-*) COLOR="0e8a16"; DESC="Service correlation" ;;
          *) COLOR="ededed"; DESC="Correlation label" ;;
        esac
        gh label create "$label" --force -R "$REPO_SLUG" --color "$COLOR" --description "$DESC" 2>/dev/null || true
      else
        echo "   âœ“ Label '$label' already exists"
      fi
    done

    # Try to add labels with detailed error capture
    echo "ðŸ” Attempting to add labels to PR #${PR_NUMBER}..."
    LABEL_ERROR=$(gh pr edit "$PR_NUMBER" -R "$REPO_SLUG" --add-label "${TASK_LABEL},${RUN_LABEL},${SERVICE_LABEL}" 2>&1)
    LABEL_EXIT_CODE=$?

    if [ $LABEL_EXIT_CODE -eq 0 ]; then
      echo "âœ… Added correlation labels successfully"
    else
      echo "âš ï¸ Failed to add labels (exit code: $LABEL_EXIT_CODE)"
      echo "ðŸ” DEBUG: Error output: $LABEL_ERROR"

      # Check if labels exist
      echo "ðŸ” DEBUG: Checking which labels exist..."
      for label in "$TASK_LABEL" "$RUN_LABEL" "$SERVICE_LABEL"; do
        if gh label list -R "$REPO_SLUG" --search "$label" | grep -q "^$label"; then
          echo "   âœ“ Label '$label' exists"
        else
          echo "   âœ— Label '$label' does not exist"
          # Create the missing label
          echo "   ðŸ“ Creating label '$label'..."
          case "$label" in
            task-*) COLOR="28a745"; DESC="Task correlation" ;;
            run-*) COLOR="0366d6"; DESC="Workflow run correlation" ;;
            service-*) COLOR="0e8a16"; DESC="Service correlation" ;;
            *) COLOR="ededed"; DESC="Unknown label type" ;;
          esac

          CREATE_ERROR=$(gh label create "$label" --force -R "$REPO_SLUG" --color "$COLOR" --description "$DESC" 2>&1)
          CREATE_EXIT=$?
          if [ $CREATE_EXIT -eq 0 ]; then
            echo "   âœ… Created label '$label'"
          else
            echo "   âŒ Failed to create label '$label': $CREATE_ERROR"
          fi
        fi
      done

      # Retry adding labels with individual attempts
      echo "ðŸ” DEBUG: Retrying label addition individually..."
      LABELS_ADDED=0
      for label in "$TASK_LABEL" "$RUN_LABEL" "$SERVICE_LABEL"; do
        RETRY_ERROR=$(gh pr edit "$PR_NUMBER" -R "$REPO_SLUG" --add-label "$label" 2>&1)
        RETRY_EXIT=$?
        if [ $RETRY_EXIT -eq 0 ]; then
          echo "   âœ… Added label '$label'"
          LABELS_ADDED=$((LABELS_ADDED + 1))
        else
          echo "   âŒ Failed to add label '$label': $RETRY_ERROR"
        fi
      done

      if [ $LABELS_ADDED -eq 3 ]; then
        echo "âœ… All labels added successfully after retry"
      elif [ $LABELS_ADDED -gt 0 ]; then
        echo "âš ï¸ Partial success: $LABELS_ADDED/3 labels added"
      else
        echo "âŒ CRITICAL: Could not add any labels to PR"
        echo "ðŸ” DEBUG: Checking PR state..."
        PR_STATE=$(gh pr view "$PR_NUMBER" -R "$REPO_SLUG" --json state -q .state 2>/dev/null || echo "UNKNOWN")
        echo "   PR State: $PR_STATE"
        if [ "$PR_STATE" = "CLOSED" ] || [ "$PR_STATE" = "MERGED" ]; then
          echo "âŒ PR is $PR_STATE - cannot add labels to closed/merged PRs"
        fi
      fi
    fi

    # Final verification that labels were applied
    echo "ðŸ” Final verification of PR labels..."
    PR_LABELS=$(gh pr view "$PR_NUMBER" -R "$REPO_SLUG" --json labels --jq '.labels[].name' 2>/dev/null || echo "")
    if echo "$PR_LABELS" | grep -q "^task-${TASK_ID}$" && \
       echo "$PR_LABELS" | grep -q "^run-${WORKFLOW_NAME}$" && \
       echo "$PR_LABELS" | grep -q "^service-${SERVICE_NAME}$"; then
      echo "âœ… VERIFIED: All correlation labels are present on PR #${PR_NUMBER}"
    else
      echo "âš ï¸ WARNING: Some labels may be missing. Current labels:"
      echo "$PR_LABELS" | sed 's/^/   - /'
      echo ""
      echo "Expected labels:"
      echo "   - task-${TASK_ID}"
      echo "   - run-${WORKFLOW_NAME}"
      echo "   - service-${SERVICE_NAME}"
    fi

    # CRITICAL: Update CodeRun status with PR URL and work_completed=true
    # This prevents duplicate job creation when controller reconciles
    echo "ðŸ”„ Updating CodeRun status with PR URL and completion flag..."
    if [ -n "$CODERUN_NAME" ] && [ -n "$NAMESPACE" ] && [ -n "$PR_URL" ]; then
      if command -v kubectl >/dev/null 2>&1 && command -v jq >/dev/null 2>&1; then
        TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        PATCH=$(jq -n \
          --arg ts "$TIMESTAMP" \
          --arg pr "$PR_URL" \
          '{status: {
            lastUpdate: $ts,
            pullRequestUrl: $pr,
            workCompleted: true,
            phase: "Succeeded",
            message: "Code implementation completed successfully and PR created"
          }}')
        
        if kubectl patch coderun "$CODERUN_NAME" -n "$NAMESPACE" --type=merge --subresource=status -p "$PATCH" 2>/dev/null; then
          echo "âœ… Updated CodeRun status with PR URL and work_completed=true"
        else
          echo "âš ï¸ Failed to update CodeRun status (this may cause duplicate job creation)"
        fi
      else
        echo "âš ï¸ kubectl or jq not available, cannot update CodeRun status"
      fi
    else
      echo "âš ï¸ Missing required variables for CodeRun status update:"
      echo "   CODERUN_NAME: ${CODERUN_NAME:-<not set>}"
      echo "   NAMESPACE: ${NAMESPACE:-<not set>}"
      echo "   PR_URL: ${PR_URL:-<not set>}"
    fi
  else
    echo "â„¹ï¸ No PR found for this task (Claude may not have created one)"
  fi
else
  echo "â„¹ï¸ Skipping PR labeling: missing GITHUB_TOKEN or gh CLI"
fi

# Write sentinel file to signal sidecar to stop (Kubernetes-native file watch)
touch "$TASK_WORKSPACE/.agent_done" 2>/dev/null || true

  # Check if implementation was successful
  # Rex is successful if Claude exited cleanly (PR should be created)
  if [ ${CLAUDE_PID:-0} -ne 0 ]; then
    wait $CLAUDE_PID 2>/dev/null || true
    CLAUDE_EXIT_CODE=$?
  fi
  
  if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
    echo "âœ… Attempt $ATTEMPT: Implementation completed successfully"
    SUCCESS=1
    COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
    break
  else
    echo "âš ï¸ Attempt $ATTEMPT: Implementation incomplete (exit code: $CLAUDE_EXIT_CODE)"
    COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
    
    if [ $ATTEMPT -lt $MAX_RETRIES ]; then
      echo "ðŸ”„ Will retry... ($((MAX_RETRIES - ATTEMPT)) attempts remaining)"
      ATTEMPT=$((ATTEMPT + 1))
      echo ""
      # Brief pause before retry
      sleep 2
    else
      echo "âŒ Maximum retry attempts reached"
      break
    fi
  fi
done

FINAL_ATTEMPTS=$COMPLETED_ATTEMPTS
if [ "${FINAL_ATTEMPTS:-0}" -le 0 ]; then
  FINAL_ATTEMPTS=$((ATTEMPT - 1))
fi
if [ $FINAL_ATTEMPTS -gt $MAX_RETRIES ]; then
  FINAL_ATTEMPTS=$MAX_RETRIES
fi

# Report final status
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
if [ $SUCCESS -eq 1 ]; then
  echo "âœ… REX IMPLEMENTATION SUCCESSFUL"
  echo "   Completed after $FINAL_ATTEMPTS attempt(s)"
else
  echo "âš ï¸ REX IMPLEMENTATION INCOMPLETE"
  echo "   Attempted $FINAL_ATTEMPTS time(s)"
  echo "   Implementation not completed"
  
  # Document remaining work for downstream agents (Cleo/Tess)
  echo ""
  echo "ðŸ“ Creating handoff document for Cleo..."
  HANDOFF_FILE="$CLAUDE_WORK_DIR/task/rex-handoff.md"
  mkdir -p "$CLAUDE_WORK_DIR/task"
  
  # Prepare handoff content with proper variable expansion
  HANDOFF_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
  
  cat > "$HANDOFF_FILE" << EOF
# Rex Implementation Handoff

**Status**: Incomplete after $FINAL_ATTEMPTS iterations (max: $MAX_RETRIES)
**Date**: $HANDOFF_DATE
**Task**: {{task_id}}

## What Was Accomplished

Rex made $FINAL_ATTEMPTS attempts to complete this task. Review the PR and commit history for details on what was implemented.

## Remaining Work

Review Claude's output in the logs above for details on what remains to be done.
Compare current implementation against acceptance criteria in task/acceptance-criteria.md.

## Next Steps for Cleo

1. Review the PR created by Rex
2. Identify gaps between current implementation and acceptance criteria
3. Complete any remaining implementation work
4. Ensure all quality checks pass before handing off to Tess

## Acceptance Criteria Reference

See \`task/acceptance-criteria.md\` for complete requirements.

---
*Generated by Rex (Claude CLI) after $FINAL_ATTEMPTS implementation attempts*
EOF

  echo "âœ… Handoff document created at task/rex-handoff.md"
  
  # Commit and push the handoff document (from repository root for consistency)
  cd "$TASK_REPO_DIR"
  git add task/rex-handoff.md 2>/dev/null || true
  git commit -m "docs(task-{{task_id}}): add Rex handoff document

Rex completed $FINAL_ATTEMPTS implementation iterations with incomplete status (max: $MAX_RETRIES).
Handoff document created for Cleo to continue work." 2>/dev/null || echo "âš ï¸ Could not commit handoff document"
  
  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
  if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "master" ]; then
    git push origin HEAD 2>/dev/null || echo "âš ï¸ Could not push handoff document"
  fi
  
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "â•‘          TASK COMPLETION STATUS: PARTIAL - HANDOFF           â•‘"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  echo "ðŸ”„ NEXT STEPS:"
  echo "   - Handoff document created at task/rex-handoff.md"
  echo "   - Workflow will continue to Cleo for completion"
  echo "   - Cleo will review PR and finish remaining work"
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
fi
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Final termination sequence
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘                 REX CONTAINER TERMINATION                    â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo "Container PID: $$"
echo "Final Process Check:"
ps aux | head -5

# Write completion marker for workflow tracking
echo "rex-implementation-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.rex-complete

# Explicitly stop Docker sidecar before exiting
echo "ðŸ›‘ Explicitly stopping Docker sidecar..."
stop_docker_sidecar || true

# Check if Rex made any commits before deciding to handoff vs fail
if [ $SUCCESS -ne 1 ]; then
  CURRENT_BRANCH=$(git -C "$TASK_REPO_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
  REMOTE_BASE="origin/${BASE_BRANCH:-main}"
  COMMITS_MADE=0
  
  if [ -n "$CURRENT_BRANCH" ]; then
    git -C "$TASK_REPO_DIR" fetch origin "$BASE_BRANCH" >/dev/null 2>&1 || true
    AHEAD_COUNT=$(git -C "$TASK_REPO_DIR" rev-list --left-right "$REMOTE_BASE...$CURRENT_BRANCH" 2>/dev/null | awk '/^>/{c++} END{print c+0}')
    if [ "${AHEAD_COUNT:-0}" -gt 0 ]; then
      COMMITS_MADE=1
      echo "âœ… Rex made $AHEAD_COUNT commit(s) - will handoff to Cleo"
    else
      echo "âš ï¸ Rex made NO commits - cannot handoff without progress"
    fi
  fi
  
  if [ "$COMMITS_MADE" -eq 0 ]; then
    echo "âŒ Rex failed to make any commits after $FINAL_ATTEMPTS attempts"
    echo "   CodeRun will retry this task"
    echo "ðŸ”š Terminating container with failure status to trigger retry..."
    exit 1
  fi
fi

# Exit with success if task completed OR if partial progress made (handoff to Cleo)
if [ $SUCCESS -eq 1 ]; then
  echo "ðŸ”š Terminating container with success status..."
  exit 0
else
  echo "ðŸ”š Terminating container with success status (handoff to Cleo)..."
  echo "ðŸ“ Implementation incomplete after $FINAL_ATTEMPTS attempt(s) - Cleo will continue"
  exit 0  # Exit successfully because commits were made (validated above)
fi
