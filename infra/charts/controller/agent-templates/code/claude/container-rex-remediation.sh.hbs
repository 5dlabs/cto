#!/bin/sh

# Ensure Rust environment is always properly set up
echo "ğŸ”§ Setting up Rust environment..."

# Source Rust environment if available (fixes cargo not found issues)
if [ -f "$HOME/.cargo/env" ]; then
    . "$HOME/.cargo/env"
    echo "âœ“ Sourced Rust environment from $HOME/.cargo/env"
fi

# Also try root cargo env as fallback
if [ -f "/root/.cargo/env" ]; then
    . "/root/.cargo/env"
    echo "âœ“ Sourced Rust environment from /root/.cargo/env"
fi

# Ensure rustup has a default toolchain set
if command -v rustup >/dev/null 2>&1; then
    rustup default stable 2>/dev/null || true
    echo "âœ“ Ensured stable Rust toolchain is default"
else
    echo "âš ï¸ rustup not found in PATH"
fi

# Verify Rust is available
if command -v cargo >/dev/null 2>&1; then
    echo "âœ“ Cargo is available: $(cargo --version)"
else
    echo "âŒ Cargo not found in PATH"
    echo "Current PATH: $PATH"
    echo "Attempting to find cargo..."
    find /usr -name cargo 2>/dev/null | head -5 || echo "No cargo found in /usr"
    find /home -name cargo 2>/dev/null | head -5 || echo "No cargo found in /home"
fi

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
printf 'â•‘  ğŸ¤– AGENT: %-50sâ•‘\n' '{{github_app}}'
echo 'â•‘  ğŸ”§ REX REMEDIATION WORKFLOW STARTING                        â•‘'
echo 'â•‘  Remediation Agent Active                                    â•‘'
echo 'â•‘  âš ï¸  FIXING FEEDBACK - NO NEW IMPLEMENTATION âš ï¸                    â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo "ğŸ”§ Mode: Remediation - Fix Only"
echo "ğŸ“‹ Task ID: {{task_id}}"
echo "ğŸš¨ CRITICAL: ONLY fix the issues identified in feedback"

# Task-specific workspace for parallel execution isolation
TASK_WORKSPACE="/workspace/task-{{task_id}}"
mkdir -p /workspace
mkdir -p "$TASK_WORKSPACE"
echo "ğŸ“ Using task-specific workspace: $TASK_WORKSPACE"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."

    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"

    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"

    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."

    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âš ï¸ Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âŒ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    echo "Installation ID: $INSTALLATION_ID"

    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "âŒ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"

    # Export the token for git to use
    export GITHUB_TOKEN

    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials

    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token

    echo "âœ“ GitHub App authenticated successfully"

else
    echo "âŒ GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
    exit 1
fi

# Git configuration with proper GitHub App attribution
git config --global --add safe.directory "$TASK_WORKSPACE"

# Set GitHub App attribution - use generic format for all agents
derive_bot_identity() {
    local app_name="$1"

    if [ -z "$app_name" ] || [ "$app_name" = "null" ]; then
        GIT_AUTHOR_NAME="automation[bot]"
        GIT_AUTHOR_EMAIL="automation[bot]@users.noreply.github.com"
        return
    fi

    local slug
    slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-+|-+$//g')
    if [ -z "$slug" ]; then
        slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]')
    fi

    local bot_login="${slug}[bot]"
    local bot_email="${bot_login}@users.noreply.github.com"

    if [ -n "${GITHUB_TOKEN:-}" ]; then
        local encoded_login
        encoded_login=$(printf '%s' "$bot_login" | sed 's/\[/%5B/g; s/\]/%5D/g')
        local bot_response
        bot_response=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/users/${encoded_login}" 2>/dev/null || true)
        local bot_id
        bot_id=$(printf '%s' "$bot_response" | jq -r '.id // empty' 2>/dev/null || echo '')
        if [ -n "$bot_id" ]; then
            bot_email="${bot_id}+${bot_login}@users.noreply.github.com"
        fi
    fi

    GIT_AUTHOR_NAME="$bot_login"
    GIT_AUTHOR_EMAIL="$bot_email"
}

GITHUB_APP="{{github_app}}"
derive_bot_identity "$GITHUB_APP"

# Configure git with proper GitHub App attribution
git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

# Set environment variables for Claude Code to use
export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
echo "âœ“ Git configured"

# =============================================================================
# REMEDIATION MODE VALIDATION
# =============================================================================

# Validate remediation environment variables
echo ""
echo "ğŸ”§ REMEDIATION MODE VALIDATION"

if [ -z "${FEEDBACK_COMMENT_ID:-}" ]; then
    echo "âŒ ERROR: FEEDBACK_COMMENT_ID is required in remediation mode"
    exit 1
fi

if [ -z "${ITERATION_COUNT:-}" ]; then
    echo "âŒ ERROR: ITERATION_COUNT is required in remediation mode"
    exit 1
fi

echo "ğŸ”§ Remediation Mode Configuration:"
echo "   Task ID: ${TASK_ID:-"Not specified"}"
echo "   PR Number: ${PR_NUMBER:-"Not specified"}"
echo "   Feedback Comment ID: ${FEEDBACK_COMMENT_ID}"
echo "   Iteration: ${ITERATION_COUNT}"
echo "   Feedback Author: ${FEEDBACK_AUTHOR:-"Unknown"}"

# Check iteration limits
MAX_ITERATIONS=10
if [ "${ITERATION_COUNT}" -gt "${MAX_ITERATIONS}" ]; then
    echo "âŒ ERROR: Maximum iterations (${MAX_ITERATIONS}) exceeded (current: ${ITERATION_COUNT})"
    echo "ğŸš¨ Triggering escalation..."

    # Post escalation comment
    ESCALATION_BODY=$(cat <<EOF
## ğŸš¨ Remediation Escalation Required

**Iteration Limit Reached**: ${ITERATION_COUNT}/10

The automated remediation process has reached its maximum iteration limit and requires human intervention.

### Next Steps:
1. **Review the feedback history** in this PR for all attempted fixes
2. **Manually address** the remaining issues identified in the feedback
3. **Consider** if the original requirements need clarification or adjustment
4. **Merge or close** this PR based on the remediation outcome

### Context:
- **Task ID**: ${TASK_ID:-"Unknown"}
- **PR**: #${PR_NUMBER:-"Unknown"}
- **Last Attempt**: Iteration ${ITERATION_COUNT}
- **Feedback Source**: Comment ID ${FEEDBACK_COMMENT_ID}

@platform-team @cto - Manual intervention required for this remediation.

---
*Posted by Rex Remediation Agent*
EOF
    )

    if [ -n "${PR_NUMBER:-}" ] && [ -n "${GITHUB_TOKEN:-}" ]; then
        if gh pr comment "${PR_NUMBER}" --body "${ESCALATION_BODY}" 2>/dev/null; then
            echo "âœ… Escalation comment posted successfully"
        else
            echo "âš ï¸ Failed to post escalation comment"
        fi
    fi

    exit 1
fi

if [ "${ITERATION_COUNT}" -eq "${MAX_ITERATIONS}" ]; then
    echo "âš ï¸ WARNING: Final iteration (${ITERATION_COUNT}/${MAX_ITERATIONS}) - this is the last attempt"
fi

echo "âœ… Iteration check passed: ${ITERATION_COUNT}/${MAX_ITERATIONS}"

# Fetch feedback comment
echo ""
echo "ğŸ“¥ Fetching feedback comment ${FEEDBACK_COMMENT_ID}..."
MAX_RETRIES=3
RETRY_COUNT=0
FEEDBACK_COMMENT=""

while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
    if FEEDBACK_COMMENT=$(gh api "/repos/{{repository_url}}/issues/comments/${FEEDBACK_COMMENT_ID}" --jq '.body' 2>/dev/null); then
        echo "âœ… Feedback comment fetched successfully (${#FEEDBACK_COMMENT} characters)"
        break
    else
        RETRY_COUNT=$((RETRY_COUNT + 1))
        echo "âš ï¸ Failed to fetch comment (attempt ${RETRY_COUNT}/${MAX_RETRIES})"

        if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
            sleep $((2 ** RETRY_COUNT))  # Exponential backoff
        fi
    fi
done

if [ -z "${FEEDBACK_COMMENT}" ]; then
    echo "âŒ Failed to fetch feedback comment after ${MAX_RETRIES} attempts"
    echo "Cannot proceed with remediation without feedback context"
    exit 1
fi

# Parse feedback metadata
echo ""
echo "ğŸ” Parsing feedback metadata..."
SEVERITY="medium"
ISSUE_TYPES=""

if echo "${FEEDBACK_COMMENT}" | grep -q "ğŸ”´"; then
    SEVERITY="critical"
elif echo "${FEEDBACK_COMMENT}" | grep -q "ğŸŸ¡"; then
    SEVERITY="high"
elif echo "${FEEDBACK_COMMENT}" | grep -q "ğŸŸ¢"; then
    SEVERITY="low"
fi

if echo "${FEEDBACK_COMMENT}" | grep -qi "security\|vulnerability\|exploit"; then
    ISSUE_TYPES="${ISSUE_TYPES}security,"
fi
if echo "${FEEDBACK_COMMENT}" | grep -qi "performance\|slow\|optimization"; then
    ISSUE_TYPES="${ISSUE_TYPES}performance,"
fi
if echo "${FEEDBACK_COMMENT}" | grep -qi "bug\|error\|exception\|crash"; then
    ISSUE_TYPES="${ISSUE_TYPES}bug,"
fi
if echo "${FEEDBACK_COMMENT}" | grep -qi "test\|testing\|coverage"; then
    ISSUE_TYPES="${ISSUE_TYPES}testing,"
fi
if echo "${FEEDBACK_COMMENT}" | grep -qi "documentation\|docs\|readme"; then
    ISSUE_TYPES="${ISSUE_TYPES}documentation,"
fi

ISSUE_TYPES="${ISSUE_TYPES%,}"
if [ -z "${ISSUE_TYPES}" ]; then
    ISSUE_TYPES="general"
fi

echo "ğŸ“Š Detected severity: ${SEVERITY}"
echo "ğŸ·ï¸ Detected issue types: ${ISSUE_TYPES}"

# Fetch original task context for reference (not as main prompt)
echo ""
echo "ğŸ“‹ Fetching original task context..."
TASK_CONTENT=""

TASK_FILE="/tmp/docs-repo/{{docs_project_directory}}/.taskmaster/docs/task-${TASK_ID}/task.md"
if [ -f "${TASK_FILE}" ]; then
    TASK_CONTENT=$(cat "${TASK_FILE}")
    echo "âœ… Found task file: ${TASK_FILE}"
else
    echo "âš ï¸ Task file not found, using default context"
    TASK_CONTENT="Task ${TASK_ID}: Implement the required functionality with proper error handling and testing."
fi

# Create remediation-specific CLAUDE.md
echo ""
echo "ğŸ“ Preparing remediation context for Claude..."

cat > /workspace/CLAUDE.md << EOF
# ğŸ”§ REMEDIATION MODE - Fix Required Issues

**Iteration ${ITERATION_COUNT}/10** | **Severity: ${SEVERITY^^}** | **Task: ${TASK_ID}**

You are operating in **REX REMEDIATION MODE**. Your mission is to fix specific issues identified in QA feedback while preserving all working functionality. This is NOT a reimplementation - focus on surgical, targeted fixes.

---

## ğŸ¯ ORIGINAL TASK REQUIREMENTS (Reference Only)

${TASK_CONTENT}

---

## ğŸš¨ ISSUES TO FIX (Priority: ${SEVERITY^^})

**Issue Categories:** ${ISSUE_TYPES}

${FEEDBACK_COMMENT}

---

## ğŸ“‹ REMEDIATION INSTRUCTIONS

### Your Mission:
1. **PRESERVE** all working functionality - do NOT break anything that currently works
2. **FIX** only the specific issues mentioned in the feedback above
3. **FOCUS** on surgical changes, not broad reimplementation
4. **VERIFY** each fix addresses the exact problem described
5. **TEST** that your changes solve the issues without introducing new problems
6. **MAINTAIN LIVE DATA**: If fixing implementations, ensure NO mocks are introduced - keep real databases, APIs, and configurable parameters

### Key Principles:
- **Targeted Fixes**: Address specific problems, not general improvements
- **Minimal Changes**: Make the smallest possible changes to fix issues
- **Preserve Architecture**: Keep existing patterns and structures intact
- **Risk Management**: Avoid changes that could break other features

### What to Avoid:
- âŒ Reimplementing working features
- âŒ Major refactoring unless specifically requested
- âŒ Adding new features or capabilities
- âŒ Changing established patterns or conventions
- âŒ Introducing mocks or hard-coded values where live data existed
- âŒ Replacing configurable parameters with fixed values

---

## ğŸ” FEEDBACK ANALYSIS

**PR Number:** ${PR_NUMBER:-"Unknown"}
**Comment ID:** ${FEEDBACK_COMMENT_ID}
**Author:** ${FEEDBACK_AUTHOR:-"Unknown"}
**Iteration:** ${ITERATION_COUNT} of 10

**Metadata:**
- Severity: ${SEVERITY}
- Categories: ${ISSUE_TYPES}
- Source: GitHub PR Comment

---

## âœ… SUCCESS CRITERIA

Your remediation is successful when:
1. All issues mentioned in the feedback are resolved
2. No existing functionality is broken
3. Changes are minimal and targeted
4. Code quality is maintained
5. Tests (if present) continue to pass

---

## ğŸš¨ ESCALATION WARNING

If you cannot fix these issues within this iteration:
- Be explicit about what cannot be fixed and why
- Document any blockers or limitations encountered
- Suggest alternative approaches for human review
- This is iteration ${ITERATION_COUNT}/10 - use it wisely

---

*Generated by Rex Remediation Agent v1.0.0*
EOF

echo "âœ… Remediation context prepared at /workspace/CLAUDE.md"

# =============================================================================
# AUTHENTICATION VERIFICATION
# =============================================================================
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ğŸ” AUTHENTICATION VERIFICATION"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Repository URLs - Handle both full URLs and org/repo format
# Check if repository_url already contains https://github.com/
if echo "{{repository_url}}" | grep -q "^https://github.com/"; then
    REPO_HTTP_URL="{{repository_url}}"
    if ! echo "{{repository_url}}" | grep -q "\.git$"; then
        REPO_HTTP_URL="${REPO_HTTP_URL}.git"
    fi
else
    REPO_HTTP_URL="https://github.com/{{repository_url}}.git"
fi

# Same for docs repository
if echo "{{docs_repository_url}}" | grep -q "^https://github.com/"; then
    DOCS_HTTP_URL="{{docs_repository_url}}"
    if ! echo "{{docs_repository_url}}" | grep -q "\.git$"; then
        DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
    fi
else
    DOCS_HTTP_URL="https://github.com/{{docs_repository_url}}.git"
fi

# DEBUG: Show what URLs are being constructed
echo "ğŸ” DEBUG: URL Construction & Parameters"
echo "  Input repository_url: '{{repository_url}}'"
echo "  Input docs_repository_url: '{{docs_repository_url}}'"
echo "  Input docs_project_directory: '{{docs_project_directory}}'"
echo "  Input working_directory: '{{working_directory}}'"
echo "  Input docs_branch: '{{docs_branch}}'"
echo "  Input github_app: '{{github_app}}'"
echo "  Input task_id: '{{task_id}}'"
echo "  Input service: '{{service}}'"
echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
echo "  Current working directory: $(pwd)"
echo "  Available environment variables:"
env | grep -E "(GITHUB|ANTHROPIC)" | sort

# Test HTTPS access to repository
echo "ğŸ” DEBUG: Testing HTTPS repository access..."
echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
  echo "âœ“ HTTPS repository access successful"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Output: $(cat /tmp/repo_test.out | head -1)"
else
  echo "âŒ HTTPS repository access failed"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Error output: $(cat /tmp/repo_test.out)"
  echo "  Git credential helper status:"
  git config --list | grep credential || echo "  No credential helpers configured"
  echo ""
  echo "ğŸš« ABORTING: Cannot access repository via HTTPS"
  exit 1
fi

# Test docs repository access
echo "ğŸ” DEBUG: Testing docs repository access..."
echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
  echo "âœ“ Docs repository access successful"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Output: $(cat /tmp/docs_test.out | head -1)"
else
  echo "âŒ Docs repository access failed"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Error output: $(cat /tmp/docs_test.out)"
  echo ""
  echo "ğŸš« ABORTING: Cannot access docs repository via HTTPS"
  exit 1
fi

# Dual Repository Setup - Platform repo for docs, Target repo for implementation
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                 DUAL REPOSITORY SETUP                        â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Repository Information
DOCS_BRANCH="{{docs_branch}}"
GITHUB_APP="{{github_app}}"

# Helper: derive safe workspace directory name from repo input (URL, SSH, or slug)
sanitize_repo_dir() {
    input="$1"
    if echo "$input" | grep -qE '^https://github.com/'; then
        owner=$(echo "$input" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        name=$(echo "$input" | sed -E 's|https://github.com/[^/]+/([^/]+)(\\.git)?|\1|')
        printf '%s-%s' "$owner" "$name"
    elif echo "$input" | grep -qE '^git@github.com:'; then
        owner=$(echo "$input" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        name=$(echo "$input" | sed -E 's|git@github.com:[^/]+/([^/]+)(\\.git)?|\1|')
        printf '%s-%s' "$owner" "$name"
    else
        # Assume owner/repo (optionally with .git)
        slug=$(echo "$input" | sed -E 's|\\.git$||')
        echo "$slug" | tr '/' '-'
    fi
}

# Derive workspace directory names (owner-repo)
DOCS_REPO_DIR=$(sanitize_repo_dir "{{docs_repository_url}}")
TARGET_REPO_DIR=$(sanitize_repo_dir "{{repository_url}}")

echo "=== REPOSITORY SETUP ==="
echo "Docs repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
echo "Target repository: {{repository_url}} ($REPO_HTTP_URL)"
echo "Docs branch: $DOCS_BRANCH"
echo "GitHub App: $GITHUB_APP"

# Always use consistent workflow approach
# Even if docs and target are the same repo, we clone them separately
# This avoids complex branch switching and file preservation issues
echo "=== UNIFIED WORKFLOW APPROACH ==="
echo "  docs_repository_url: '{{docs_repository_url}}'"
echo "  repository_url: '{{repository_url}}'"
echo "  â””â”€ TaskMaster files will be copied from docs repo at: {{docs_project_directory}}"

# Repository Setup - Always use consistent approach
echo "=== REPOSITORY SETUP ==="

# Step 1: Clone or update docs repository temporarily
if [ -d "/tmp/docs-repo" ]; then
    echo "ğŸ”„ DOCS REPOSITORY: UPDATE - temporary directory exists"
    cd /tmp/docs-repo
    git fetch origin
    git checkout "$DOCS_BRANCH"
    git reset --hard "origin/$DOCS_BRANCH"
    cd "$TASK_WORKSPACE"
    echo "âœ“ Docs repository updated"
else
    echo "ğŸ“¥ DOCS REPOSITORY: CLONING - extracting task files"
    if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
        echo "âŒ Failed to clone docs repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
        exit 1
    fi
    cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd "$TASK_WORKSPACE"
    echo "âœ“ Docs repository cloned to temporary location"
fi

# Step 2: Clone or update target repository TO TASK-SPECIFIC WORKSPACE
# This prevents task-1's branch from contaminating task-4's workspace
TASK_REPO_DIR="$TASK_WORKSPACE/$TARGET_REPO_DIR"

if [ -d "$TASK_REPO_DIR/.git" ]; then
    echo "ğŸ”„ TARGET REPOSITORY: UPDATE - valid git repository exists in task workspace"
    echo "ğŸ“ Found existing target repository in task-{{task_id}} workspace, updating..."
    # Fix dubious ownership before git operations
    git config --global --add safe.directory "$TASK_REPO_DIR"
    cd "$TASK_REPO_DIR"
    git fetch origin main
    git reset --hard origin/main
    cd "$TASK_WORKSPACE"
    echo "âœ“ Target repository updated successfully"
elif [ -d "$TASK_REPO_DIR" ]; then
    echo "âš ï¸ TARGET REPOSITORY: INVALID - directory exists but not a git repository"
    echo "ğŸ§¹ Removing invalid directory and re-cloning..."
    rm -rf "$TASK_REPO_DIR"
    if ! git clone "$REPO_HTTP_URL" "$TASK_REPO_DIR"; then
        echo "âŒ Failed to clone target repository: {{repository_url}} ($REPO_HTTP_URL)"
        exit 1
    fi
    echo "âœ“ Target repository cloned successfully to task workspace"
else
    echo "ğŸ“¥ TARGET REPOSITORY: CLONING - first time setup"
    if ! git clone "$REPO_HTTP_URL" "$TASK_REPO_DIR"; then
        echo "âŒ Failed to clone target repository: {{repository_url}} ($REPO_HTTP_URL)"
        exit 1
    fi
    echo "âœ“ Target repository cloned successfully to task workspace"
fi

# Step 3: Set up working directory paths BEFORE file operations
# This ensures CLAUDE_WORK_DIR is available for client-config.json copy
WORKSPACE_DIR="task-{{task_id}}/$TARGET_REPO_DIR"
WORK_DIR="{{working_directory}}"
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
  CLAUDE_WORK_DIR="/workspace/$WORKSPACE_DIR"
else
  CLAUDE_WORK_DIR="/workspace/$WORKSPACE_DIR/$WORK_DIR"
fi
echo "âœ“ Claude working directory: $CLAUDE_WORK_DIR"

# Step 4: Copy task files from docs repo to target repo
echo "ğŸ“‹ TASK FILES: COPYING from docs to target repository"
mkdir -p "$CLAUDE_WORK_DIR/task"

# Determine docs project directory path
{{#if docs_project_directory}}
if [ "{{docs_project_directory}}" = "." ]; then
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
else
    DOCS_PATH="/tmp/docs-repo/{{docs_project_directory}}/.taskmaster"
fi
{{else}}
DOCS_PATH="/tmp/docs-repo/.taskmaster"
{{/if}}

# Copy specific task files
TASK_DIR="$DOCS_PATH/docs/task-{{task_id}}"
echo "ğŸ” DEBUG: Looking for task files at: $TASK_DIR"
echo "ğŸ” DEBUG: Docs path is: $DOCS_PATH"
echo "ğŸ” DEBUG: Contents of docs temp directory:"
ls -la /tmp/docs-repo/.taskmaster/ || echo "No .taskmaster found"
echo "ğŸ” DEBUG: Contents of docs directory:"
ls -la /tmp/docs-repo/.taskmaster/docs/ || echo "No docs directory found"

if [ -d "$TASK_DIR" ]; then
    echo "ğŸ” DEBUG: Task directory found, contents:"
    ls -la "$TASK_DIR"

    # Ensure target task directory exists before copying (using Claude's working directory)
    mkdir -p "$CLAUDE_WORK_DIR/task"
    echo "âœ“ Created target task directory at $CLAUDE_WORK_DIR/task"

    echo "âœ… Copying task.md..."
    cp "$TASK_DIR/task.md" "$CLAUDE_WORK_DIR/task/" && echo "âœ“ task.md copied" || echo "âŒ task.md copy failed"

    echo "âœ… Copying acceptance-criteria.md..."
    cp "$TASK_DIR/acceptance-criteria.md" "$CLAUDE_WORK_DIR/task/" && echo "âœ“ acceptance-criteria.md copied" || echo "âŒ acceptance-criteria.md copy failed"

    echo "âœ… Copying prompt.md..."
    cp "$TASK_DIR/prompt.md" "$CLAUDE_WORK_DIR/task/" && echo "âœ“ prompt.md copied" || echo "âŒ prompt.md copy failed"

    echo "âœ… Copying client-config.json..."
    if [ -f "/task-files/client-config.json" ]; then
        cp "/task-files/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" && echo "âœ“ client-config.json copied to Claude working directory" || echo "âŒ client-config.json copy failed"
        cp "$FACTORY_WORK_DIR/client-config.json" "$TASK_WORKSPACE/client-config.json" 2>/dev/null || true && echo "âœ“ client-config.json copied to workspace root" || echo "âŒ client-config.json copy to workspace failed"
    else
        echo "âš ï¸ client-config.json not found - MCP client may not be configured"
    fi

    echo "âœ… Copying toolman-guide.md..."
    if [ -f "$TASK_DIR/toolman-guide.md" ]; then
        cp "$TASK_DIR/toolman-guide.md" "$CLAUDE_WORK_DIR/task/" && echo "âœ“ toolman-guide.md copied" || echo "âŒ toolman-guide.md copy failed"
    else
        echo "âš ï¸ toolman-guide.md not found - code agent won't have tool usage guidance"
    fi

    echo "âœ“ Task {{task_id}} files copied from $TASK_DIR"
else
    echo "âŒ CRITICAL: Task {{task_id}} directory not found at: $TASK_DIR"
    echo "ğŸ” DEBUG: Available directories in docs:"
    find /tmp/docs-repo -name "task-*" -type d || echo "No task directories found"
fi

# Copy architecture.md from docs root
ARCH_FILE="$DOCS_PATH/docs/architecture.md"
if [ -f "$ARCH_FILE" ]; then
    cp "$ARCH_FILE" "$CLAUDE_WORK_DIR/task/"
    echo "âœ“ Architecture documentation copied"
else
    echo "âš ï¸ architecture.md not found at: $ARCH_FILE"
fi

# Copy tasks.json if it exists
if [ -f "$DOCS_PATH/tasks.json" ]; then
    cp "$DOCS_PATH/tasks.json" "$CLAUDE_WORK_DIR/task/"
    echo "âœ“ tasks.json copied"
fi

echo "âœ“ Task files copied to target repository"

# DEBUG: Verify files were copied successfully
echo "ğŸ” DEBUG: Contents of target task directory after copy:"
ls -la "$CLAUDE_WORK_DIR/task/" || echo "Task directory not found"
echo "ğŸ” DEBUG: Checking if prompt.md exists:"
[ -f "$CLAUDE_WORK_DIR/task/prompt.md" ] && echo "âœ… prompt.md exists" || echo "âŒ prompt.md missing"

# Step 5: Clean up docs repository
echo "ğŸ§¹ CLEANUP: Removing temporary docs repository"
rm -rf /tmp/docs-repo
echo "âœ“ Docs repository cleaned up"

# Ensure Claude working directory exists (already defined earlier for file placement)
mkdir -p "$CLAUDE_WORK_DIR"
echo "âœ“ Ensured Claude working directory exists: $CLAUDE_WORK_DIR"

# Setup feature branch for implementation
echo "=== BRANCH SETUP ==="
cd "$TASK_REPO_DIR"

# Fix git dubious ownership before any git operations
git config --global --add safe.directory "$TASK_REPO_DIR"
echo "âœ“ Added repository to git safe directories"

# Sync with latest main to prevent conflicts
echo "ğŸ”„ Syncing with latest main to prevent conflicts..."
git fetch origin main 2>/dev/null || git fetch origin master 2>/dev/null || echo "âš ï¸ Could not fetch main/master branch"

# Create or checkout feature branch (with conflict-safe fallback)
FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
BRANCH_EXISTS="false"

if git show-ref --verify --quiet refs/heads/$FEATURE_BRANCH; then
    BRANCH_EXISTS="true"
    echo "Feature branch '$FEATURE_BRANCH' exists, checking out..."
    git checkout $FEATURE_BRANCH

    echo "ğŸ“¥ Merging latest main into $FEATURE_BRANCH..."
    if git merge origin/main --no-edit; then
        echo "âœ“ Successfully merged latest main into feature branch"
    else
        echo "âš ï¸ MERGE CONFLICT: Cannot auto-merge main into $FEATURE_BRANCH"
        # Check if PR exists before creating timestamped fallback
        echo "ğŸ” Checking for existing PR for this branch..."
        EXISTING_PR=$(gh pr list --state open --head "$FEATURE_BRANCH" --json number --limit 1 2>/dev/null | jq -r '.[0].number // empty')
        
        if [ -n "$EXISTING_PR" ]; then
            echo "âœ… Found existing PR #$EXISTING_PR for branch $FEATURE_BRANCH"
            echo "â„¹ï¸ Continuing with this branch despite merge conflict (will be resolved in PR)"
            # Abort the merge but stay on the branch
            git merge --abort 2>/dev/null || true
        else
            echo "â„¹ï¸ No existing PR found; recreating branch from origin/main"
        # Abort merge if in progress
        git merge --abort 2>/dev/null || true
            # Delete local branch and recreate fresh from base
            git checkout origin/main 2>/dev/null || git checkout -b temp-branch origin/main
            git branch -D "$FEATURE_BRANCH" 2>/dev/null || true
            git checkout -b "$FEATURE_BRANCH" origin/main
            echo "âœ… Recreated $FEATURE_BRANCH from origin/main"
        fi
    fi
else
    # Create new feature branch from latest main
    echo "Creating new feature branch '$FEATURE_BRANCH' from latest main..."
    
    # Stash any local changes to avoid checkout conflicts
    # Exclude task/ directory to preserve task files that were just copied
    if ! git diff-index --quiet HEAD -- || [ -n "$(git ls-files --others --exclude-standard)" ]; then
      echo "ğŸ”„ Stashing local changes and untracked files (excluding task/) before creating new branch"
      git stash push --include-untracked -m "Auto-stash before new branch creation ($(date -u +%Y%m%d-%H%M%S))" -- . ':!task' || true
    fi
    
    git checkout -b $FEATURE_BRANCH origin/main
    echo "âœ“ Created feature branch: $FEATURE_BRANCH"
fi

# 5. Change to Claude Working Directory (already set up earlier)
cd "$CLAUDE_WORK_DIR"
echo "âœ“ Changed to Claude working directory: $CLAUDE_WORK_DIR"
echo "ğŸ”‘ CRITICAL: Claude will be launched from this directory"

# Working directory setup completed above

# Configure git user after successful clone
echo "=== POST-CLONE GIT CONFIGURATION ==="
# Fix dubious ownership issues (already done above, but keeping for safety)
git config --global --add safe.directory "$TASK_REPO_DIR"
echo "âœ“ Added repository to safe directories"

# Set git config locally in the working repository (persistent on PVC)
if [ -d "$TASK_REPO_DIR/.git" ]; then
    cd "$TASK_REPO_DIR"
    git config --local user.name "$GIT_AUTHOR_NAME"
    git config --local user.email "$GIT_AUTHOR_EMAIL"
    # Set up automatic upstream for new branches
    git config --local push.autoSetupRemote true
    echo "âœ“ Configured git user in target repository: $GIT_AUTHOR_NAME"
    echo "âœ“ Enabled automatic upstream setup for new branches"
fi

cd "$TASK_WORKSPACE"

# Copy ConfigMap files to working directory (AFTER repository clone)
echo "=== CONFIGMAP FILE SETUP ==="

# Claude working directory already set above during repository setup

echo "Setting up files in Claude working directory: $CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"

# Copy all files from ConfigMap to working directory
if [ -d "/task-files" ]; then
  echo "Copying ConfigMap files to working directory..."

  # CLAUDE.md Memory Persistence Logic (controlled by overwriteMemory CRD field)
        OVERWRITE_MEMORY="{{overwrite_memory}}"

  # Handle CLAUDE.md based on overwriteMemory setting
        if [ "$OVERWRITE_MEMORY" = "true" ]; then
          # Overwrite mode: Always replace CLAUDE.md with fresh template
    cp "/task-files/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
    cp "/task-files/CLAUDE.md" "/workspace/CLAUDE.md"
          echo "âœ“ Overwrote CLAUDE.md memory file (fresh start requested)"
          echo "âœ“ Copied CLAUDE.md to workspace root for easy access"
        else
          # Preserve mode (default): Only copy if doesn't exist
          if [ ! -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
      # Initial creation - copy from ConfigMap
      cp "/task-files/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
      cp "/task-files/CLAUDE.md" "/workspace/CLAUDE.md"
            echo "âœ“ Created initial CLAUDE.md memory file"
            echo "âœ“ Copied CLAUDE.md to workspace root for easy access"
          else
            echo "âœ“ Preserved existing CLAUDE.md memory file (maintaining accumulated context)"
            # Still copy to workspace root for consistency
            cp "$CLAUDE_WORK_DIR/CLAUDE.md" "/workspace/CLAUDE.md"
            echo "âœ“ Synced CLAUDE.md to workspace root"
          fi
        fi

  # Copy all other markdown files (excluding CLAUDE.md)
  for md_file in /task-files/*.md; do
    if [ -f "$md_file" ]; then
      basename_file=$(basename "$md_file")
      # Skip CLAUDE.md since we handled it above
      if [ "$basename_file" != "CLAUDE.md" ]; then
        cp "$md_file" "$CLAUDE_WORK_DIR/"
        echo "âœ“ Updated $basename_file"
      fi
    fi
  done

  # Verify enterprise settings (mounted directly from ConfigMap)
  if [ -f "/etc/claude-code/managed-settings.json" ]; then
    echo "âœ“ Enterprise settings verified"
    if ! jq empty /etc/claude-code/managed-settings.json 2>/dev/null; then
      echo "âŒ Invalid enterprise settings JSON"
      exit 1
    fi
  else
    echo "âŒ Enterprise settings not found"
    exit 1
  fi

  # Copy guidelines files to working directory
  if [ -f "/task-files/coding-guidelines.md" ]; then
    cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
    echo "âœ“ Copied coding-guidelines.md to working directory"
  fi

  if [ -f "/task-files/github-guidelines.md" ]; then
    cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
    echo "âœ“ Copied github-guidelines.md to working directory"
  fi

  # System prompt will be rendered inline (no file copying needed)
  echo "âœ“ System prompt template will be rendered inline"

  # Hook copying disabled
  echo "! Hook scripts disabled - no hooks will be copied"

  # Set up MCP configuration
  echo "Setting up MCP configuration..."

  # Copy MCP configuration from ConfigMap to project root (project scope)
  if [ -f "/task-files/mcp.json" ]; then
    cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
    echo "âœ“ Copied mcp.json to .mcp.json (project scope)"
    # Also copy to /workspace for Claude's MCP loader
    cp /task-files/mcp.json "/workspace/.mcp.json"
    echo "âœ“ Copied mcp.json to /workspace/.mcp.json for MCP loader"
  else
    echo "âš ï¸  mcp.json template not found"
  fi

  # Enterprise managed settings are mounted directly from ConfigMap
  echo "=== ENTERPRISE MANAGED SETTINGS ==="
  echo "âœ“ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
  echo "âœ“ No copying needed - mount automatically reflects latest ConfigMap changes"

  echo "âœ“ ConfigMap files copied to $CLAUDE_WORK_DIR"
else
  echo "âš ï¸  Warning: /task-files directory not found (ConfigMap not mounted?)"
fi


# Move client-config.json if it exists in task directory
if [ -f "$CLAUDE_WORK_DIR/task/client-config.json" ]; then
    mv "$CLAUDE_WORK_DIR/task/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" && echo "âœ“ client-config.json moved to Claude working directory" || echo "âŒ client-config.json move failed"
fi

# Verify client-config.json is available and valid
echo "=== TOOLMAN CONFIG SETUP ==="
WORKSPACE_CFG="$CLAUDE_WORK_DIR/client-config.json"
SOURCE_CFG="/task-files/client-config.json"

# Helper to check non-empty JSON object
is_valid_cfg() {
  local p="$1"
  [ -f "$p" ] || return 1
  jq -e 'type=="object" and length>0' "$p" >/dev/null 2>&1
}

STATUS_LABEL_NEEDS_FIXES="needs-fixes"
STATUS_LABEL_FIXING="fixing-in-progress"
STATUS_LABEL_NEEDS_CLEO="needs-cleo"
STATUS_LABEL_NEEDS_TESS="needs-tess"
STATUS_LABEL_APPROVED="approved"
STATUS_LABEL_FAILED="failed-remediation"
STATUS_LABEL_NEEDS_TESTS_LEGACY="needs tests"

ensure_status_labels() {
  local repo="$1"
  shift
  command -v gh >/dev/null 2>&1 || return 0

  for entry in "$@"; do
    [ -n "$entry" ] || continue
    local label="${entry%%:*}"
    local rest="${entry#*:}"
    local color="${rest%%:*}"
    local desc="${rest#*:}"

    if ! gh label list -R "$repo" --search "$label" 2>/dev/null | grep -q "^$label"; then
      gh label create "$label" --force -R "$repo" --color "$color" --description "$desc" >/dev/null 2>&1 || true
    fi
  done
}

pr_add_labels() {
  local repo="$1"
  local pr_number="$2"
  local pr_url="$3"
  shift 3

  command -v gh >/dev/null 2>&1 || return 0

  for label in "$@"; do
    [ -n "$label" ] || continue
    if [ -n "$pr_number" ]; then
      gh pr edit "$pr_number" -R "$repo" --add-label "$label" >/dev/null 2>&1 || echo "âš ï¸ Failed to add label '$label' to PR #$pr_number"
    elif [ -n "$pr_url" ]; then
      gh pr edit "$pr_url" --add-label "$label" >/dev/null 2>&1 || echo "âš ï¸ Failed to add label '$label' to PR $pr_url"
    fi
  done
}

pr_remove_labels() {
  local repo="$1"
  local pr_number="$2"
  local pr_url="$3"
  shift 3

  command -v gh >/dev/null 2>&1 || return 0

  for label in "$@"; do
    [ -n "$label" ] || continue
    if [ -n "$pr_number" ]; then
      gh pr edit "$pr_number" -R "$repo" --remove-label "$label" >/dev/null 2>&1 || true
    elif [ -n "$pr_url" ]; then
      gh pr edit "$pr_url" --remove-label "$label" >/dev/null 2>&1 || true
    fi
  done
}

SRC_OK=false
WS_OK=false
if is_valid_cfg "$SOURCE_CFG"; then SRC_OK=true; fi
if is_valid_cfg "$WORKSPACE_CFG"; then WS_OK=true; fi

if $SRC_OK; then
  export MCP_CLIENT_CONFIG="$SOURCE_CFG"
  echo "âœ“ Selected MCP_CLIENT_CONFIG from source ConfigMap: $MCP_CLIENT_CONFIG"
elif $WS_OK; then
  export MCP_CLIENT_CONFIG="$WORKSPACE_CFG"
  echo "âœ“ Selected MCP_CLIENT_CONFIG from workspace copy: $MCP_CLIENT_CONFIG"
else
  echo "âŒ No valid client-config.json found (both source and workspace empty/invalid). Aborting."
  if [ -f "$SOURCE_CFG" ]; then
    echo "   Source summary:"; (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' "$SOURCE_CFG" 2>/dev/null || { echo -n "   raw="; head -c 200 "$SOURCE_CFG"; echo; })
  else
    echo "   Source missing: $SOURCE_CFG"
  fi
  if [ -f "$WORKSPACE_CFG" ]; then
    echo "   Workspace summary:"; (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' "$WORKSPACE_CFG" 2>/dev/null || { echo -n "   raw="; head -c 200 "$WORKSPACE_CFG"; echo; })
  else
    echo "   Workspace missing: $WORKSPACE_CFG"
  fi
  exit 1
fi

echo '=== WORKSPACE VALIDATION ==='

# Check for required files in Claude's working directory
MISSING_FILES=""
REQUIRED_FILES="CLAUDE.md"

echo "Checking for required files..."
for file in $REQUIRED_FILES; do
  if [ ! -f "$CLAUDE_WORK_DIR/$file" ]; then
    echo "ERROR: Missing required file: $CLAUDE_WORK_DIR/$file"
    MISSING_FILES="$MISSING_FILES $file"
  else
    echo "âœ“ Found: $CLAUDE_WORK_DIR/$file"
    # Show file size for verification
    size=$(wc -c < "$CLAUDE_WORK_DIR/$file" 2>/dev/null || echo "0")
    echo "  File size: $size bytes"
  fi
done

# Check git repository (REQUIRED for implementation tasks)
if [ ! -d "/workspace/$TARGET_REPO_DIR/.git" ]; then
  echo "âœ— CRITICAL ERROR: No target git repository found!"
  MISSING_FILES="$MISSING_FILES git-repository"
else
  echo "âœ“ Found: target git repository"
fi

# If any files are missing, abort
if [ -n "$MISSING_FILES" ]; then
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "â•‘                 WORKSPACE VALIDATION FAILED                  â•‘"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  echo "The following required files are missing:"
  for missing in $MISSING_FILES; do
    case "$missing" in
      "CLAUDE.md")
        echo "  âŒ $missing - Main task instructions for Claude"
        ;;
      "git-repository")
        echo "  âŒ $missing - Required for committing implementation changes"
        ;;
      *)
        echo "  âŒ $missing"
        ;;
    esac
  done
  echo ""
  echo "These files should have been created by the ConfigMap setup process."
  echo "Claude will NOT be started to avoid wasting API credits."
  echo ""
  exit 1
fi

echo "âœ“ All required files present. Workspace is valid."

echo '=== IMPLEMENTATION TASK DIAGNOSTICS ==='
echo "Project directory: $CLAUDE_WORK_DIR"
echo "Project directory contents:"
ls -la "$CLAUDE_WORK_DIR"
echo ""

# Show git status
echo "Git status:"
git status 2>/dev/null || echo "Git status unavailable"
echo ""

echo '=== CLAUDE EXECUTION ==='

# Export necessary variables
export SERVICE_NAME="{{service}}"
export TASK_ID="{{task_id}}"
export GITHUB_APP="{{github_app}}"

# Change to project directory before running Claude
cd "$CLAUDE_WORK_DIR"
echo "Changed to directory: $(pwd)"

# Verify we're in the correct directory and have required files
echo "=== WORKING DIRECTORY VERIFICATION ==="
echo "Current working directory: $(pwd)"
echo "Expected directory: $CLAUDE_WORK_DIR"
if [ "$(pwd)" != "$CLAUDE_WORK_DIR" ]; then
  echo "âŒ ERROR: Failed to change to correct working directory!"
  echo "Attempting to change directory again..."
  cd "$CLAUDE_WORK_DIR" || exit 1
  echo "âœ“ Successfully changed to: $(pwd)"
fi

# Verify git repository is accessible from Claude working directory
echo "=== GIT REPOSITORY VERIFICATION ==="
if [ ! -d ".git" ]; then
  echo "âŒ ERROR: No .git directory found in Claude working directory: $(pwd)"
  echo "ğŸ“‚ Checking parent directory structure:"
  echo "  Current: $(pwd)"
  echo "  Contents: $(ls -la . | head -5)"
  if [ -d "$TASK_REPO_DIR/.git" ]; then
    echo "  Found .git at: $TASK_REPO_DIR/"
    echo "ğŸ”§ This indicates a working directory path mismatch"
    echo "ğŸ”§ CLAUDE_WORK_DIR: $CLAUDE_WORK_DIR"
    echo "ğŸ”§ Expected git repo: $TASK_REPO_DIR"
  fi
  exit 1
else
  echo "âœ… Git repository verified at: $(pwd)/.git"
  echo "âœ… Repository status: $(git status --porcelain | wc -l) modified files"
  echo "âœ… Current branch: $(git branch --show-current 2>/dev/null || echo 'detached')"
fi

# Verify setup
echo "âœ“ Code implementation environment ready"

# Build Claude command
CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Look for Rex-specific system prompt file (remediation uses same Rex prompt)
# Rex container always uses rex-system-prompt.md
if [ -f "/task-files/rex-system-prompt.md" ]; then
    echo "âœ“ Found Rex system prompt file, adding to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /task-files/rex-system-prompt.md"
    if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
        echo "[DEBUG] System prompt path: /task-files/rex-system-prompt.md"
        echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "/task-files/rex-system-prompt.md" | sed 's/^/[DEBUG] /'
        echo "[DEBUG] ----"
    fi
elif [ -f "/config/agents/{{github_app}}_system-prompt.md" ]; then
    # Fallback to direct GitHub App name
    echo "âœ“ Found system prompt file for {{github_app}}"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /config/agents/{{github_app}}_system-prompt.md"
    if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
        echo "[DEBUG] System prompt path: /config/agents/{{github_app}}_system-prompt.md"
        echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "/config/agents/{{github_app}}_system-prompt.md" | sed 's/^/[DEBUG] /'
        echo "[DEBUG] ----"
    fi
else
    echo "â„¹ï¸ No system prompt file found for agent {{github_app}}, using defaults"
fi

# Model is set via settings.json template, not CLI flag

# Add continue flag if this is a retry attempt or user requested continuation
{{#if continue_session}}
CLAUDE_CMD="$CLAUDE_CMD --continue"
echo 'Adding --continue flag (attempt {{attempts}}{{#if user_requested}} - user requested{{/if}})'
{{/if}}

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                    STARTING CLAUDE EXECUTION                  â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "Command: $CLAUDE_CMD"
echo "Note: Claude will automatically read CLAUDE.md from the working directory"

# Inline system prompt (static content)
SYSTEM_PROMPT='## ğŸš¨ CRITICAL SYSTEM REQUIREMENTS ğŸš¨

**â›” OVERCONFIDENCE MITIGATION - MANDATORY VERIFICATION â›”**

You have a DANGEROUS tendency to declare task completion before actually verifying everything works. This is ABSOLUTELY UNACCEPTABLE.

**MANDATORY VERIFICATION REQUIREMENTS:**
- âœ… **MUST** actually run and test your code - never assume it works
- âœ… **MUST** verify ALL acceptance criteria through actual testing
- âœ… **MUST** confirm your changes don'\''t break existing functionality
- âœ… **MUST** test end-to-end workflows and edge cases
- âœ… **MUST** run all linters and build checks successfully
- âœ… **CANNOT** claim completion based on code appearance alone

**YOU ARE PROHIBITED FROM CLAIMING SUCCESS UNTIL:**
1. You have executed and verified every piece of functionality
2. You have tested integration with existing systems
3. You have confirmed all acceptance criteria pass through testing
4. All automated tests pass (linting, builds, unit tests)
5. You have verified the solution works end-to-end in practice

**IF YOU DECLARE SUCCESS WITHOUT VERIFICATION, YOU HAVE FAILED.**

## ğŸ”§ ORCHESTRATOR EXECUTION CONTEXT

- **Service**: {{service}}
- **Task ID**: {{task_id}}
- **Repository**: {{repository_url}}
- **Docs Repository**: {{docs_repository_url}}
- **Working Directory**: {{working_directory}}
- **GitHub App**: {{github_app}}

{{#if continue_session}}
## ğŸ”„ CONTINUE SESSION - PR COMMENT RESOLUTION PRIORITY

**âš ï¸ MANDATORY FIRST STEP: Before proceeding with any other work, you MUST:**

1. **Check for unresolved PR comments**: Use `gh pr view --json reviews` or check the PR directly
2. **Resolve ALL pending comments first**: Address reviewer feedback, fix issues, respond to questions
3. **Push comment resolutions**: Commit and push any fixes for reviewer concerns
4. **Only then proceed**: After ALL PR comments are resolved, continue with the main task

**This ensures reviewer feedback takes priority and maintains collaborative workflow quality.**

{{/if}}
## âš ï¸ EXECUTION REQUIREMENTS

- **Follow patterns**: Use @coding-guidelines.md and @github-guidelines.md
- **Pre-PR quality gates (MANDATORY)**: Do NOT open a PR unless all of these pass locally:
  - `cargo fmt --all -- --check`
  - `cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic`
  - `cargo test --workspace --all-features` and high coverage (aim â‰¥95%, target ~100% on critical paths)
- **GitHub workflow**: Read @github-guidelines.md for commit standards
- **Verify continuously**: Run tests and checks after each significant change
- **Commit incrementally**: Don'\''t save all changes for the end
- **Test thoroughly**: Validate against acceptance criteria before completion

## ğŸš¨ NON-NEGOTIABLE PULL REQUEST REQUIREMENT ğŸš¨

**â›” CRITICAL: YOU MUST CREATE A PULL REQUEST - NO EXCEPTIONS â›”**

**MANDATORY FINAL STEP:**
- **MUST** create a pull request using `gh pr create` command
- **MUST** include proper labels (task-{{task_id}}, run-{{workflow.name}}, service-{{service}})
- **MUST** verify PR creation succeeded before claiming task completion
- **THE TASK IS INCOMPLETE AND FAILED IF NO PR IS CREATED**

**YOU CANNOT COMPLETE THIS TASK WITHOUT CREATING A PULL REQUEST.**
**IF YOU DO NOT CREATE A PR, YOU HAVE FAILED THE TASK COMPLETELY.**

**Remember**: Focus on thorough implementation and verification.'

echo "Starting Claude execution (text output via FIFO)..."
echo "=========================="

# Safe mode toggle for debugging (prevents token consumption)
SAFE_MODE="false"  # Set to "false" for full task execution

if [ "$SAFE_MODE" = "true" ]; then
    echo "ğŸ›¡ï¸ SAFE MODE ENABLED - Running simple test instead of full task"
    FIFO_PATH="/workspace/agent-input.jsonl"
    rm -f "$FIFO_PATH" 2>/dev/null || true
    mkfifo "$FIFO_PATH"
    chmod 666 "$FIFO_PATH" || true
    # Keep a persistent writer open and start Claude in background to avoid EOF race
    exec 9>"$FIFO_PATH"
    $CLAUDE_CMD < "$FIFO_PATH" &
    CLAUDE_PID=$!
    printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":"What time is it? Please answer this simple question and exit immediately."}]}}\n' >&9
    # Close writer so reader can exit cleanly
    exec 9>&-
    wait $CLAUDE_PID
else
    # For remediation, we use the CLAUDE.md we created earlier
    # No need to read prompt.md - remediation context is already prepared
    echo "âœ“ Using remediation context from CLAUDE.md"

    echo "startingRemediation:{{task_id}}"
    echo ""

        # DEBUG: Print MCP_CLIENT_CONFIG for troubleshooting client config issues
        echo "ğŸ” DEBUG: MCP_CLIENT_CONFIG is set to: '$MCP_CLIENT_CONFIG'"
        if [ -f "$MCP_CLIENT_CONFIG" ]; then
            echo "ğŸ” DEBUG: MCP_CLIENT_CONFIG file exists and is readable"
            echo "ğŸ” DEBUG: First few lines of client config:"
            head -10 "$MCP_CLIENT_CONFIG" 2>/dev/null || echo "Could not read client config file"
        else
            echo "ğŸ” DEBUG: MCP_CLIENT_CONFIG file does NOT exist or is not readable"
        fi
        echo ""

        # For remediation, we don't need complex prompt composition
        # The CLAUDE.md file contains all the necessary context and instructions
        echo "ğŸ”§ Starting Claude with remediation context..."




        # Seed initial user turn via a FIFO (system prompts are set via CLI flags, not streamed)
        FIFO_PATH="/workspace/agent-input.jsonl"
        rm -f "$FIFO_PATH" 2>/dev/null || true
        mkfifo "$FIFO_PATH"
        chmod 666 "$FIFO_PATH" || true

        # Start Claude (reader) first in background to avoid writer-open blocking
        $CLAUDE_CMD < "$FIFO_PATH" &
        CLAUDE_PID=$!

        # For remediation, we send a simple start message since CLAUDE.md contains all context
        USER_MESSAGE="ğŸ”§ REMEDIATION MODE ACTIVATED

Please review the CLAUDE.md file for complete context and instructions. You are in remediation mode - focus on fixing the specific issues identified in the feedback while preserving existing functionality."

        # Prefer sending via sidecar HTTP endpoint (opens-writes-closes per request)
        if printf '{"text":%s}\n' "$(printf '%s' "$USER_MESSAGE" | jq -Rs .)" | \
             curl -fsS -X POST http://127.0.0.1:8080/input \
               -H 'Content-Type: application/json' \
               --data-binary @- >/dev/null 2>&1; then
          echo "âœ“ Remediation prompt sent via sidecar /input"
        else
          echo "âš ï¸ Sidecar /input failed, falling back to direct FIFO write"
          # Fallback: open FIFO writer, send prompt, and close immediately to send EOF
          exec 9>"$FIFO_PATH"
          printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}\n' "$(printf '%s' "$USER_MESSAGE" | jq -Rs .)" >&9
          exec 9>&-  # Close immediately to send EOF to Claude
        fi

        # Optional debug: dump FIFO holders if requested
        if [ "${DEBUG_FIFO:-false}" = "true" ]; then
          echo "[DEBUG] Dumping FIFO holders for $FIFO_PATH"
          for p in /proc/[0-9]*; do
            pid=${p##*/}
            [ -d "$p/fd" ] || continue
            for fd in "$p"/fd/*; do
              tgt=$(readlink "$fd" 2>/dev/null || true)
              case "$tgt" in *agent-input.jsonl*)
                fdnum=${fd##*/}
                comm=$(cat "$p/comm" 2>/dev/null || echo "?")
                echo "  PID=$pid COMM=$comm FD=$fdnum -> $tgt"
              ;;
              esac
            done
          done
        fi

        # Optional hang diagnostics without enforcing a timeout
        if [ -n "${HANG_DIAG_SECONDS:-}" ] && [ "$HANG_DIAG_SECONDS" -gt 0 ] 2>/dev/null; then
          (
            sleep "$HANG_DIAG_SECONDS"
            if kill -0 "$CLAUDE_PID" 2>/dev/null; then
              echo "[DEBUG] Hang diag after ${HANG_DIAG_SECONDS}s: dumping FIFO holders and ps"
              for p in /proc/[0-9]*; do
                pid=${p##*/}; [ -d "$p/fd" ] || continue
                for fd in "$p"/fd/*; do tgt=$(readlink "$fd" 2>/dev/null || true); case "$tgt" in *agent-input.jsonl*) fdnum=${fd##*/}; comm=$(cat "$p/comm" 2>/dev/null || echo "?"); echo "  PID=$pid COMM=$comm FD=$fdnum -> $tgt";; esac; done
              done
              ps -eo pid,ppid,comm,args | head -200 || true
            fi
          ) & HANG_DIAG_PID=$!
        fi

        # Wait for Claude process to complete naturally
        echo "â³ Waiting for Claude process (PID: $CLAUDE_PID) to complete..."

        # Simple wait - Claude should exit naturally when done
        wait "$CLAUDE_PID"
        CLAUDE_EXIT_CODE=$?

        if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
          echo "âœ… Claude process completed successfully"
        else
          echo "âŒ Claude remediation process FAILED with exit code: $CLAUDE_EXIT_CODE"
          echo "ğŸ” Critical error - Claude did not complete remediation successfully"
          echo "ğŸ“‹ This typically indicates:"
          echo "   - API rate limiting or authentication issues"
          echo "   - MCP client configuration problems"
          echo "   - Invalid prompt or system message formatting"
          echo "   - Tool execution failures"
          echo ""
          echo "âš ï¸ ABORTING: Cannot continue without successful Claude execution"
          echo "ğŸ”š Force terminating container with error status..."
          
          # Clean up background processes
          if [ -n "$TOKEN_REFRESH_PID" ]; then
              kill $TOKEN_REFRESH_PID 2>/dev/null || true
          fi
          if [ -n "${HANG_DIAG_PID:-}" ]; then 
              kill "$HANG_DIAG_PID" 2>/dev/null || true
          fi
          
          # Write failure marker for debugging
          echo "rex-remediation-failed:$(date -u +%Y-%m-%dT%H:%M:%SZ):exit-code-$CLAUDE_EXIT_CODE" > /workspace/.rex-remediation-failed
          
          # Exit with error to signal pod failure
          exit $CLAUDE_EXIT_CODE
        fi

        # Stop diagnostics if running
        if [ -n "${HANG_DIAG_PID:-}" ]; then kill "$HANG_DIAG_PID" 2>/dev/null || true; fi

        # Ensure FIFO cleanup happens regardless of how Claude exited
        echo "ğŸ”§ Performing FIFO cleanup..."

        # Close FIFO writer if it was opened (in fallback)
        if [ "$FIFO_OPENED" = "true" ]; then
          echo "ğŸ”§ Closing FIFO file descriptor..."
          # Try multiple methods to ensure fd 9 gets closed
          exec 9>&- 2>/dev/null || {
            echo "âš ï¸ exec 9>&- failed, trying alternative close method"
            eval "exec 9>&-" 2>/dev/null || {
              echo "âš ï¸ Alternative close failed, FIFO fd may remain open"
            }
          }
        else
          echo "â„¹ï¸ FIFO was not opened via fallback, checking sidecar"
        fi

        # Clean up FIFO file to ensure no processes are blocked
        if [ -p "$FIFO_PATH" ]; then
          echo "ğŸ”§ Removing FIFO to ensure clean shutdown"
          rm -f "$FIFO_PATH" 2>/dev/null || echo "âš ï¸ Could not remove FIFO"
        fi

        # No sidecar shutdown needed - container will exit naturally when main process completes
fi

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘                 REMEDIATION TASK COMPLETE                    â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'

# Claude execution completed - no hooks configured
echo "Claude has completed successfully."

# =============================================================================
# PR DETECTION AND LABELING
# =============================================================================
# After Claude completes, check if a PR was created and apply correlation labels
if [ -n "${GITHUB_TOKEN:-}" ] && command -v gh >/dev/null 2>&1; then
  echo "ğŸ” Checking for PRs created by this task..."

  # First, try to find PR by task label (Claude should have added task-N label)
  TASK_LABEL="task-${TASK_ID}"
  PR_NUMBER=$(gh pr list -R "{{docs_repository_url}}" --label "$TASK_LABEL" --json number --jq '.[0].number' 2>/dev/null || true)

  # If not found by label, try by branch name (current branch)
  if [ -z "$PR_NUMBER" ]; then
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)
    if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "main" ]; then
      PR_NUMBER=$(gh pr list -R "{{docs_repository_url}}" --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || true)
    fi
  fi

  if [ -n "$PR_NUMBER" ]; then
    echo "âœ… Found PR #${PR_NUMBER}"

    # Get the PR URL
    PR_URL="https://github.com/{{docs_repository_url}}/pull/${PR_NUMBER}"
    echo "ğŸ“ PR URL: $PR_URL"

    REPO_SLUG="{{docs_repository_url}}"
    ensure_status_labels "$REPO_SLUG" \
      "${STATUS_LABEL_NEEDS_FIXES}:d73a4a:Remediation requested by Tess" \
      "${STATUS_LABEL_FIXING}:fbca04:Rex is actively applying fixes" \
      "${STATUS_LABEL_NEEDS_CLEO}:0e8a16:Awaiting Cleo quality review" \
      "${STATUS_LABEL_NEEDS_TESS}:5319e7:Awaiting Tess QA review" \
      "${STATUS_LABEL_APPROVED}:2da44e:All automated reviews approved" \
      "${STATUS_LABEL_FAILED}:b60205:Remediation failed or aborted"

    pr_remove_labels "$REPO_SLUG" "$PR_NUMBER" "$PR_URL" \
      "$STATUS_LABEL_NEEDS_FIXES" \
      "$STATUS_LABEL_FIXING" \
      "$STATUS_LABEL_NEEDS_TESS" \
      "$STATUS_LABEL_APPROVED" \
      "$STATUS_LABEL_FAILED" \
      "$STATUS_LABEL_NEEDS_TESTS_LEGACY"

    pr_add_labels "$REPO_SLUG" "$PR_NUMBER" "$PR_URL" "$STATUS_LABEL_NEEDS_CLEO"

    # Update CodeRun status with PR URL via Kubernetes API
    echo "ğŸ”„ Updating CodeRun status with PR URL..."
    if command -v kubectl >/dev/null 2>&1; then
      # Create a patch to update the CodeRun status
      PATCH_JSON=$(cat <<EOF
{
  "status": {
    "pullRequestUrl": "$PR_URL",
    "lastUpdate": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  }
}
EOF
)

      # Apply the patch to update CodeRun status
      if kubectl patch coderun "$CODERUN_NAME" -n "$NAMESPACE" --type=merge --subresource=status -p "$PATCH_JSON" 2>/dev/null; then
        echo "âœ… Updated CodeRun status with PR URL"
      else
        echo "âš ï¸ Failed to update CodeRun status (kubectl patch failed)"
      fi
    else
      echo "âš ï¸ kubectl not available, cannot update CodeRun status"
    fi

    # Apply correlation labels with comprehensive debugging
    echo "ğŸ·ï¸ Adding correlation labels to PR #${PR_NUMBER}..."

    # Debug: Check environment variables
    echo "ğŸ” DEBUG: Environment check for label creation:"
    echo "   TASK_ID: '${TASK_ID}'"
    echo "   WORKFLOW_NAME: '${WORKFLOW_NAME}'"
    echo "   SERVICE_NAME: '${SERVICE_NAME}'"
    echo "   CODERUN_NAME: '${CODERUN_NAME}'"
    echo "   GitHub Token: $([ -n "$GITHUB_TOKEN" ] && echo 'Present' || echo 'Missing')"

    # Validate required variables
    if [ -z "$WORKFLOW_NAME" ]; then
      echo "âŒ ERROR: WORKFLOW_NAME is not set!"
      echo "ğŸ” DEBUG: Attempting to extract from CODERUN_NAME..."
      # Try to extract workflow name from CodeRun name pattern
      if [ -n "$CODERUN_NAME" ]; then
        # Pattern: service-t{task}-stage-{hash} created by workflow
        echo "   CODERUN_NAME format: $CODERUN_NAME"
      fi

      # Check if we can get it from Kubernetes labels
      if command -v kubectl >/dev/null 2>&1 && [ -n "$CODERUN_NAME" ] && [ -n "$NAMESPACE" ]; then
        echo "ğŸ” DEBUG: Trying to get workflow name from CodeRun labels..."
        WORKFLOW_FROM_LABELS=$(kubectl get coderun "$CODERUN_NAME" -n "$NAMESPACE" -o jsonpath='{.metadata.labels.workflow-name}' 2>/dev/null || echo "")
        if [ -n "$WORKFLOW_FROM_LABELS" ]; then
          echo "âœ… Found workflow name from CodeRun labels: $WORKFLOW_FROM_LABELS"
          WORKFLOW_NAME="$WORKFLOW_FROM_LABELS"
        else
          echo "âŒ Could not retrieve workflow name from CodeRun labels"
        fi
      fi

      # Final check - if still no workflow name, fail loudly
      if [ -z "$WORKFLOW_NAME" ]; then
        echo "âŒ CRITICAL: Cannot determine WORKFLOW_NAME - this will cause correlation issues!"
        echo "ğŸ” DEBUG: Available environment variables:"
        env | grep -E "WORKFLOW|CODERUN|TASK|SERVICE" | sort
        # DO NOT use 'unknown' - exit with error instead
        echo "âŒ Refusing to use 'unknown' label - failing task"
        exit 1
      fi
    fi

    TASK_LABEL="task-${TASK_ID}"
    RUN_LABEL="run-${WORKFLOW_NAME}"
    SERVICE_LABEL="service-${SERVICE_NAME}"

    echo "ğŸ“‹ Labels to apply:"
    echo "   Task: $TASK_LABEL"
    echo "   Run: $RUN_LABEL"
    echo "   Service: $SERVICE_LABEL"

    # Try to add labels with detailed error capture
    echo "ğŸ” DEBUG: Attempting to add labels to PR..."
    LABEL_ERROR=$(gh pr edit "$PR_NUMBER" -R "{{docs_repository_url}}" --add-label "${TASK_LABEL},${RUN_LABEL},${SERVICE_LABEL}" 2>&1)
    LABEL_EXIT_CODE=$?

    if [ $LABEL_EXIT_CODE -eq 0 ]; then
      echo "âœ… Added correlation labels successfully"
    else
      echo "âš ï¸ Failed to add labels (exit code: $LABEL_EXIT_CODE)"
      echo "ğŸ” DEBUG: Error output: $LABEL_ERROR"

      # Check if labels exist
      echo "ğŸ” DEBUG: Checking which labels exist..."
      for label in "$TASK_LABEL" "$RUN_LABEL" "$SERVICE_LABEL"; do
        if gh label list -R "{{docs_repository_url}}" --search "$label" | grep -q "^$label"; then
          echo "   âœ“ Label '$label' exists"
        else
          echo "   âœ— Label '$label' does not exist"
          # Create the missing label
          echo "   ğŸ“ Creating label '$label'..."
          case "$label" in
            task-*) COLOR="f29513"; DESC="Task correlation" ;;
            run-*) COLOR="0366d6"; DESC="Workflow run correlation" ;;
            service-*) COLOR="0e8a16"; DESC="Service correlation" ;;
            *) COLOR="ededed"; DESC="Unknown label type" ;;
          esac

          CREATE_ERROR=$(gh label create "$label" --force -R "{{docs_repository_url}}" --color "$COLOR" --description "$DESC" 2>&1)
          CREATE_EXIT=$?
          if [ $CREATE_EXIT -eq 0 ]; then
            echo "   âœ… Created label '$label'"
          else
            echo "   âŒ Failed to create label '$label': $CREATE_ERROR"
          fi
        fi
      done

      # Retry adding labels with individual attempts
      echo "ğŸ” DEBUG: Retrying label addition individually..."
      LABELS_ADDED=0
      for label in "$TASK_LABEL" "$RUN_LABEL" "$SERVICE_LABEL"; do
        RETRY_ERROR=$(gh pr edit "$PR_NUMBER" -R "{{docs_repository_url}}" --add-label "$label" 2>&1)
        RETRY_EXIT=$?
        if [ $RETRY_EXIT -eq 0 ]; then
          echo "   âœ… Added label '$label'"
          LABELS_ADDED=$((LABELS_ADDED + 1))
        else
          echo "   âŒ Failed to add label '$label': $RETRY_ERROR"
        fi
      done

      if [ $LABELS_ADDED -eq 3 ]; then
        echo "âœ… All labels added successfully after retry"
      elif [ $LABELS_ADDED -gt 0 ]; then
        echo "âš ï¸ Partial success: $LABELS_ADDED/3 labels added"
      else
        echo "âŒ CRITICAL: Could not add any labels to PR"
        echo "ğŸ” DEBUG: Checking PR state..."
        PR_STATE=$(gh pr view "$PR_NUMBER" -R "{{docs_repository_url}}" --json state -q .state 2>/dev/null || echo "UNKNOWN")
        echo "   PR State: $PR_STATE"
        if [ "$PR_STATE" = "CLOSED" ] || [ "$PR_STATE" = "MERGED" ]; then
          echo "âŒ PR is $PR_STATE - cannot add labels to closed/merged PRs"
        fi
      fi
    fi
  else
    echo "â„¹ï¸ No PR found for this task (Claude may not have created one)"
  fi
else
  echo "â„¹ï¸ Skipping PR labeling: missing GITHUB_TOKEN or gh CLI"
fi

# Write sentinel file to signal sidecar to stop (Kubernetes-native file watch)
touch "$TASK_WORKSPACE/.agent_done" 2>/dev/null || true

# Final termination sequence
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘                 REX CONTAINER TERMINATION                    â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo "Container PID: $$"
echo "Final Process Check:"
ps aux | head -5

# Write completion marker for workflow tracking
echo "rex-remediation-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.rex-complete

# Force exit to terminate the pod
echo "ğŸ”š Force terminating container..."
exit 0
