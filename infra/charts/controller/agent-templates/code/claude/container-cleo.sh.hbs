#!/bin/sh

# Ensure Rust environment is always properly set up
echo "ðŸ”§ Setting up Rust environment..."

# Source Rust environment if available (fixes cargo not found issues)
if [ -f "$HOME/.cargo/env" ]; then
    . "$HOME/.cargo/env"
    echo "âœ“ Sourced Rust environment from $HOME/.cargo/env"
fi

# Also try root cargo env as fallback
if [ -f "/root/.cargo/env" ]; then
    . "/root/.cargo/env"
    echo "âœ“ Sourced Rust environment from /root/.cargo/env"
fi

# Ensure rustup has a default toolchain set
if command -v rustup >/dev/null 2>&1; then
    rustup default stable 2>/dev/null || true
    echo "âœ“ Ensured stable Rust toolchain is default"
else
    echo "âš ï¸ rustup not found in PATH"
fi

# Verify Rust is available
if command -v cargo >/dev/null 2>&1; then
    echo "âœ“ Cargo is available: $(cargo --version)"
else
    echo "âŒ Cargo not found in PATH"
    echo "Current PATH: $PATH"
    echo "Attempting to find cargo..."
    find /usr -name cargo 2>/dev/null | head -5 || echo "No cargo found in /usr"
    find /home -name cargo 2>/dev/null | head -5 || echo "No cargo found in /home"
fi

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘              CLEO CODE QUALITY WORKFLOW STARTING             â•‘'
echo 'â•‘     Code Quality & CI/CD Pipeline Enforcement Agent          â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo "ðŸŽ¯ Agent: {{github_app}}"
echo "ðŸ” Focus: Code quality, CI/CD setup, and Docker image building"
echo "ðŸ“‹ Task ID: {{task_id}}"
echo "âœ… Mission: Perfect code quality AND working CI/CD pipeline with Docker builds"

# Clean up any leftover completion marker from previous runs
# This prevents issues with sequential task executions on the same PVC
if [ -f /workspace/.cleo-complete ]; then
    echo "ðŸ§¹ Cleaning up completion marker from previous run"
    rm -f /workspace/.cleo-complete
fi

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication for code quality checks"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."

    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"

    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"

    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."

    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âš ï¸ Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âŒ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    echo "Installation ID: $INSTALLATION_ID"

    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    TOKEN_GENERATED_AT=$(date +%s)  # Track when token was generated for refresh logic

    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "âŒ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    echo "âœ… Successfully authenticated with GitHub App"

    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"

    # Export the token for git to use
    export GITHUB_TOKEN

    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials

    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token

    # Token refresh functions for long-running jobs
    refresh_github_token() {
        echo "ðŸ”„ Refreshing GitHub App token..."

        # Create temporary key file
        TEMP_KEY_FILE="/tmp/github-app-key-$$"
        echo "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
        chmod 600 "$TEMP_KEY_FILE"

        # Generate new JWT
        JWT_TOKEN=$(ruby -r openssl -r json -r base64 -e "
        key = OpenSSL::PKey::RSA.new(File.read('$TEMP_KEY_FILE'))
        payload = {
            iat: Time.now.to_i - 60,
            exp: Time.now.to_i + (10 * 60),
            iss: '$GITHUB_APP_ID'
        }
        header = { alg: 'RS256', typ: 'JWT' }

        header_enc = Base64.urlsafe_encode64(header.to_json).gsub('=', '')
        payload_enc = Base64.urlsafe_encode64(payload.to_json).gsub('=', '')
        signature = Base64.urlsafe_encode64(key.sign(OpenSSL::Digest::SHA256.new, \"#{header_enc}.#{payload_enc}\")).gsub('=', '')

        puts \"#{header_enc}.#{payload_enc}.#{signature}\"
        ")

        # Get installation ID (reuse logic from initial auth)
        INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

        if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
            INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
        fi

        # Get new installation token
        TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

        NEW_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

        if [ "$NEW_TOKEN" != "null" ] && [ -n "$NEW_TOKEN" ]; then
            export GITHUB_TOKEN="$NEW_TOKEN"
            export TOKEN_GENERATED_AT=$(date +%s)

            # Update git credentials
            echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
            echo "$GITHUB_TOKEN" | gh auth login --with-token 2>/dev/null

            echo "âœ… Token refreshed successfully"
            rm -f "$TEMP_KEY_FILE"
            return 0
        else
            echo "âŒ Failed to refresh token: $TOKEN_RESPONSE"
            rm -f "$TEMP_KEY_FILE"
            return 1
        fi
    }

    # Check if token needs refresh (call before git operations)
    refresh_token_if_needed() {
        if [ -z "$TOKEN_GENERATED_AT" ]; then
            echo "âš ï¸ No token timestamp found, refreshing token..."
            refresh_github_token
            return
        fi

        NOW=$(date +%s)
        TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))

        # Refresh if token is older than 50 minutes (tokens last 1 hour, refresh at 50 min to be safe)
        if [ $TOKEN_AGE -gt 3000 ]; then
            echo "ðŸ”„ Token is $(($TOKEN_AGE / 60)) minutes old, refreshing..."
            refresh_github_token
        fi
    }

else
    echo "âŒ GitHub App credentials not found"
    exit 1
fi

# Target repository directory name - this is where the git repo will be
TARGET_REPO_DIR="{{#if working_directory}}{{working_directory}}{{else}}{{service}}{{/if}}"

# Set working directory for the agent - should match the repository location
CLAUDE_WORK_DIR="/workspace/$TARGET_REPO_DIR"
mkdir -p "$CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"
echo "ðŸ”§ Working directory set to: $CLAUDE_WORK_DIR"

# Prepare environment for QA checks
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ“Š PREPARING CODE QUALITY ENVIRONMENT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Configure Git identity
git config --global user.email "cleo@5dlabs.com"
git config --global user.name "5DLabs-Cleo"
git config --global init.defaultBranch main

# =============================================================================
# AUTHENTICATION VERIFICATION
# =============================================================================
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” AUTHENTICATION VERIFICATION"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Repository URLs - Handle both full URLs and org/repo format
# Check if repository_url already contains https://github.com/
if echo "{{repository_url}}" | grep -q "^https://github.com/"; then
    REPO_HTTP_URL="{{repository_url}}"
    if ! echo "{{repository_url}}" | grep -q "\.git$"; then
        REPO_HTTP_URL="${REPO_HTTP_URL}.git"
    fi
else
    REPO_HTTP_URL="https://github.com/{{repository_url}}.git"
fi

# Same for docs repository
if echo "{{docs_repository_url}}" | grep -q "^https://github.com/"; then
    DOCS_HTTP_URL="{{docs_repository_url}}"
    if ! echo "{{docs_repository_url}}" | grep -q "\.git$"; then
        DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
    fi
else
    DOCS_HTTP_URL="https://github.com/{{docs_repository_url}}.git"
fi

# DEBUG: Show what URLs are being constructed
echo "ðŸ” DEBUG: URL Construction & Parameters"
echo "  Input repository_url: '{{repository_url}}'"
echo "  Input docs_repository_url: '{{docs_repository_url}}'"
echo "  Input docs_project_directory: '{{docs_project_directory}}'"
echo "  Input working_directory: '{{working_directory}}'"
echo "  Input docs_branch: '{{docs_branch}}'"
echo "  Input github_app: '{{github_app}}'"
echo "  Input task_id: '{{task_id}}'"
echo "  Input service: '{{service}}'"
echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
echo "  Current working directory: $(pwd)"
echo "  Available environment variables:"
env | grep -E "(GITHUB|ANTHROPIC)" | sort

# Test HTTPS access to repository
echo "ðŸ” DEBUG: Testing HTTPS repository access..."
echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
  echo "âœ“ HTTPS repository access successful"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Output: $(cat /tmp/repo_test.out | head -1)"
else
  echo "âŒ HTTPS repository access failed"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Error output: $(cat /tmp/repo_test.out)"
  echo "  Git credential helper status:"
  git config --list | grep credential || echo "  No credential helpers configured"
  echo ""
  echo "ðŸš« ABORTING: Cannot access repository via HTTPS"
  exit 1
fi

# Test docs repository access
echo "ðŸ” DEBUG: Testing docs repository access..."
echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
  echo "âœ“ Docs repository access successful"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Output: $(cat /tmp/docs_test.out | head -1)"
else
  echo "âŒ Docs repository access failed"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Error output: $(cat /tmp/docs_test.out)"
  echo ""
  echo "ðŸš« ABORTING: Cannot access docs repository via HTTPS"
  exit 1
fi

# Clone or update repository
if [ -d "$CLAUDE_WORK_DIR" ] && [ -d "$CLAUDE_WORK_DIR/.git" ]; then
    echo "ðŸ“ Found existing repository at '$CLAUDE_WORK_DIR', updating..."
    cd "$CLAUDE_WORK_DIR"
    git fetch origin
else
    echo "ðŸ“¥ Cloning repository to '$CLAUDE_WORK_DIR'..."
    # Use the REPO_HTTP_URL constructed in authentication verification section
    if ! git clone "$REPO_HTTP_URL" "$CLAUDE_WORK_DIR"; then
        echo "âŒ Failed to clone repository"
        exit 1
    fi
    cd "$CLAUDE_WORK_DIR"
fi

# Derive repository slug for gh CLI operations
REPO_SLUG=""
if git -C "$CLAUDE_WORK_DIR" remote get-url origin >/dev/null 2>&1; then
  ORIGIN_URL=$(git -C "$CLAUDE_WORK_DIR" remote get-url origin 2>/dev/null || echo "")
  if echo "$ORIGIN_URL" | grep -qE '^https://github.com/'; then
    REPO_SLUG=$(echo "$ORIGIN_URL" | sed -E 's|https://github.com/([^/]+/[^/]+)(\\.git)?|\\1|')
  elif echo "$ORIGIN_URL" | grep -qE '^git@github.com:'; then
    REPO_SLUG=$(echo "$ORIGIN_URL" | sed -E 's|git@github.com:([^/]+/[^/]+)(\\.git)?|\\1|')
  fi
fi

# If PR context is missing, try to discover by task label
if [ -z "${PR_NUMBER:-}" ] || [ -z "${PR_URL:-}" ]; then
  TASK_LABEL="task-${TASK_ID}"
  if command -v gh >/dev/null 2>&1 && [ -n "$REPO_SLUG" ]; then
    CAND_NUM=$(gh pr list -R "$REPO_SLUG" --label "$TASK_LABEL" --json number --jq '.[0].number' 2>/dev/null || true)
    if [ -n "$CAND_NUM" ]; then
      PR_NUMBER="$CAND_NUM"
      PR_URL=$(gh pr view "$PR_NUMBER" -R "$REPO_SLUG" --json url -q .url 2>/dev/null || echo "")
      echo "âœ“ Discovered PR context via label: PR #$PR_NUMBER ($PR_URL)"
    fi
  fi
fi

# Checkout PR branch for quality review
if [ -n "$PR_NUMBER" ] && [ -n "$PR_URL" ]; then
    echo "ðŸ”„ Checking out PR #$PR_NUMBER for quality review..."
    cd "$CLAUDE_WORK_DIR"

    # Fetch all latest changes including PR branches
    git fetch origin --prune

    # Get PR branch information and checkout
    PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName' 2>/dev/null || echo "")
    if [ -n "$PR_BRANCH" ]; then
        echo "ðŸ“¦ Checking out PR branch: $PR_BRANCH"
        if git checkout "$PR_BRANCH" 2>/dev/null; then
            echo "ðŸ“¥ Pulling latest changes from $PR_BRANCH..."
            git pull origin "$PR_BRANCH" || echo "âš ï¸  Could not pull latest changes"
        elif git checkout -b "$PR_BRANCH" "origin/$PR_BRANCH" 2>/dev/null; then
            echo "âœ… Created and checked out tracking branch for $PR_BRANCH"
        else
            echo "âš ï¸  Branch checkout failed, trying GitHub CLI method..."
            gh pr checkout "$PR_NUMBER" || echo "âŒ Failed to checkout PR via gh CLI"
        fi
    else
        echo "âš ï¸  Could not determine PR branch name, using GitHub CLI to checkout PR directly"
        gh pr checkout "$PR_NUMBER" || echo "âŒ Failed to checkout PR"
    fi

    # Verify we're on the right commit
    CURRENT_SHA=$(git rev-parse HEAD)
    echo "ðŸ“ Current commit: $CURRENT_SHA"

    # Don't change directory yet - we'll cd to CLAUDE_WORK_DIR at the end
    echo "âœ… Repository positioned at PR #$PR_NUMBER with latest changes"
else
    echo "âš ï¸  No PR context found (PR_NUMBER=$PR_NUMBER, PR_URL=$PR_URL)"
    echo "ðŸ“‹ Will perform quality review on current repository state"
fi

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” CODE QUALITY ANALYSIS PREPARATION"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "MISSION: Enforce rigorous code quality standards:"
echo "1. Run Clippy pedantic checks on all Rust code changes"
echo "2. Verify code formatting with cargo fmt --check"
echo "3. Execute all tests with cargo test"
echo "4. Lint YAML files when YAML changes are detected"
echo "5. Add 'ready-for-qa' label only when all quality checks pass"
echo ""
echo "Quality Standards:"
echo "- Zero clippy warnings (pedantic level)"
echo "- Perfect code formatting"
echo "- 100% test passing rate"
echo "- Clean YAML syntax and structure"
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Task files should already be present in the project repository at /task
echo "ðŸ“‹ Checking for task files in project repository..."
if [ -d "$CLAUDE_WORK_DIR/task" ]; then
    echo "âœ“ Found task directory in project repository"
    ls -la "$CLAUDE_WORK_DIR/task/"
else
    echo "âš ï¸ No /task directory found in project repository"
fi

# Ensure we're in the git repository working directory
echo "âœ“ Working directly in git repository at: $CLAUDE_WORK_DIR"

# Check if we should continue previous session
{{#if continue_session}}
echo "ðŸ“‚ Continuing from previous session..."
# Preserve existing CLAUDE.md if it exists
if [ -f "/workspace/CLAUDE.md" ]; then
    echo "âœ“ Found existing CLAUDE.md, preserving session memory"
fi
{{else}}
{{#if overwrite_memory}}
echo "ðŸ”„ Overwriting session memory as requested..."
rm -f /workspace/CLAUDE.md
{{/if}}
{{/if}}

# Generate configuration files from templates
echo "ðŸ”§ Generating Cleo-specific configuration files..."

# Enterprise managed settings are mounted directly from ConfigMap
echo "=== ENTERPRISE MANAGED SETTINGS ==="
echo "âœ“ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
echo "âœ“ No copying needed - mount automatically reflects latest ConfigMap changes"

# Verify client-config.json is available and valid
echo "=== TOOLMAN CONFIG SETUP ==="
WORKSPACE_CFG="$CLAUDE_WORK_DIR/client-config.json"
SOURCE_CFG="/task-files/client-config.json"

# Helper to check non-empty JSON object
is_valid_cfg() {
  local p="$1"
  [ -f "$p" ] || return 1
  jq -e 'type=="object" and length>0' "$p" >/dev/null 2>&1
}

STATUS_LABEL_NEEDS_FIXES="needs-fixes"
STATUS_LABEL_FIXING="fixing-in-progress"
STATUS_LABEL_NEEDS_CLEO="needs-cleo"
STATUS_LABEL_NEEDS_TESS="needs-tess"
STATUS_LABEL_APPROVED="approved"
STATUS_LABEL_FAILED="failed-remediation"
STATUS_LABEL_NEEDS_TESTS_LEGACY="needs tests"

ensure_status_labels() {
  local repo="$1"
  shift
  command -v gh >/dev/null 2>&1 || return 0

  for entry in "$@"; do
    [ -n "$entry" ] || continue
    local label="${entry%%:*}"
    local rest="${entry#*:}"
    local color="${rest%%:*}"
    local desc="${rest#*:}"

    if ! gh label list -R "$repo" --search "$label" 2>/dev/null | grep -q "^$label"; then
      gh label create "$label" -R "$repo" --color "$color" --description "$desc" >/dev/null 2>&1 || true
    fi
  done
}

pr_add_labels() {
  local repo="$1"
  local pr_number="$2"
  local pr_url="$3"
  shift 3

  command -v gh >/dev/null 2>&1 || return 0

  for label in "$@"; do
    [ -n "$label" ] || continue
    if [ -n "$pr_number" ]; then
      gh pr edit "$pr_number" -R "$repo" --add-label "$label" >/dev/null 2>&1 || echo "âš ï¸ Failed to add label '$label' to PR #$pr_number"
    elif [ -n "$pr_url" ]; then
      gh pr edit "$pr_url" --add-label "$label" >/dev/null 2>&1 || echo "âš ï¸ Failed to add label '$label' to PR $pr_url"
    fi
  done
}

pr_remove_labels() {
  local repo="$1"
  local pr_number="$2"
  local pr_url="$3"
  shift 3

  command -v gh >/dev/null 2>&1 || return 0

  for label in "$@"; do
    [ -n "$label" ] || continue
    if [ -n "$pr_number" ]; then
      gh pr edit "$pr_number" -R "$repo" --remove-label "$label" >/dev/null 2>&1 || true
    elif [ -n "$pr_url" ]; then
      gh pr edit "$pr_url" --remove-label "$label" >/dev/null 2>&1 || true
    fi
  done
}

update_coderun_status() {
  local remediation="$1"
  local qa="$2"
  local pr_url_value="${3:-$PR_URL}"

  if ! command -v kubectl >/dev/null 2>&1; then
    return
  fi

  if ! command -v jq >/dev/null 2>&1; then
    echo "âš ï¸ jq not available; skipping CodeRun status update"
    return
  fi

  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  local patch
  patch=$(jq -n \
    --arg ts "$timestamp" \
    --arg pr "$pr_url_value" \
    --arg rem "$remediation" \
    --arg qa "$qa" \
    '{status: ({lastUpdate: $ts}
        + (if $pr != "" then {pullRequestUrl: $pr} else {} end)
        + (if $rem != "" then {remediationStatus: $rem} else {} end)
        + (if $qa != "" then {qaStatus: $qa} else {} end))}')

  if [ -n "$CODERUN_NAME" ] && [ -n "$NAMESPACE" ]; then
    kubectl patch coderun "$CODERUN_NAME" -n "$NAMESPACE" --type=merge --subresource=status -p "$patch" >/dev/null 2>&1 || \
      echo "âš ï¸ Failed to update CodeRun status with remediation context"
  fi
}


# Generate client-config.json from cto-config.json in the cloned repository
echo "ðŸ”§ Generating client-config.json from cto-config.json..."
CTO_CONFIG_PATH="$CLAUDE_WORK_DIR/cto-config.json"
CLIENT_CONFIG_PATH="$CLAUDE_WORK_DIR/client-config.json"

if [ -f "$CTO_CONFIG_PATH" ]; then
  echo "âœ“ Found cto-config.json at $CTO_CONFIG_PATH"
  
  # Extract agent name from github_app (e.g., "5DLabs-Cleo" -> "cleo")
  GITHUB_APP="{{github_app}}"
  AGENT_NAME=$(echo "$GITHUB_APP" | sed 's/^.*-//' | tr '[:upper:]' '[:lower:]')
  echo "ðŸ“ Extracting tools configuration for agent: $AGENT_NAME (from $GITHUB_APP)"
  
  # Debug: Show what we're reading
  echo "ðŸ” DEBUG: Checking agents.$AGENT_NAME in cto-config.json"
  if command -v jq >/dev/null 2>&1; then
    jq -r ".agents.${AGENT_NAME} // empty | if . then \"âœ“ Found agent config\" else empty end" "$CTO_CONFIG_PATH" || echo "âš ï¸ Agent '$AGENT_NAME' not found in cto-config.json"
  fi
  
  # Extract tools configuration and generate client-config.json
  if command -v jq >/dev/null 2>&1; then
    jq -n \
      --arg agent "$AGENT_NAME" \
      --slurpfile cto "$CTO_CONFIG_PATH" \
      '{
        remoteTools: ($cto[0].agents[$agent].tools.remote // []),
        localServers: ($cto[0].agents[$agent].tools.localServers // {})
      }' > "$CLIENT_CONFIG_PATH"
    
    if [ -f "$CLIENT_CONFIG_PATH" ] && [ -s "$CLIENT_CONFIG_PATH" ]; then
      echo "âœ… Generated client-config.json from cto-config.json"
      echo "ðŸ” DEBUG: Generated client-config.json contents:"
      jq -r '"remoteTools=" + ((.remoteTools // []) | length | tostring) + ", localServers.keys=" + ((.localServers // {} | keys) | join(","))' "$CLIENT_CONFIG_PATH" 2>/dev/null || cat "$CLIENT_CONFIG_PATH"
    else
      echo "âŒ Failed to generate client-config.json - file is empty or missing"
      rm -f "$CLIENT_CONFIG_PATH"
    fi
  else
    echo "âš ï¸ jq not available; cannot generate client-config.json from cto-config.json"
  fi
else
  echo "âš ï¸ cto-config.json not found at $CTO_CONFIG_PATH"
fi

# Fallback: copy from task-files if generation failed or cto-config.json not found
# Copy client-config.json from task files first
if [ -f "/task-files/client-config.json" ]; then
  cp /task-files/client-config.json "$CLAUDE_WORK_DIR/client-config.json"
  cp /task-files/client-config.json "/workspace/client-config.json"
  echo "âœ“ client-config.json copied from ConfigMap to both working directory and workspace root"
else
  echo "âš ï¸ client-config.json not found in task-files"
fi

SRC_OK=false
WS_OK=false
if is_valid_cfg "$SOURCE_CFG"; then SRC_OK=true; fi
if is_valid_cfg "$WORKSPACE_CFG"; then WS_OK=true; fi

if $SRC_OK; then
  export MCP_CLIENT_CONFIG="$SOURCE_CFG"
  echo "âœ“ Selected MCP_CLIENT_CONFIG from source ConfigMap: $MCP_CLIENT_CONFIG"
elif $WS_OK; then
  export MCP_CLIENT_CONFIG="$WORKSPACE_CFG"
  echo "âœ“ Selected MCP_CLIENT_CONFIG from workspace copy: $MCP_CLIENT_CONFIG"
else
  echo "âŒ No valid client-config.json found (both source and workspace empty/invalid). Aborting."
  if [ -f "$SOURCE_CFG" ]; then
    echo "   Source summary:"; (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' "$SOURCE_CFG" 2>/dev/null || { echo -n "   raw="; head -c 200 "$SOURCE_CFG"; echo; })
  else
    echo "   Source missing: $SOURCE_CFG"
  fi
  if [ -f "$WORKSPACE_CFG" ]; then
    echo "   Workspace summary:"; (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' "$WORKSPACE_CFG" 2>/dev/null || { echo -n "   raw="; head -c 200 "$WORKSPACE_CFG"; echo; })
  else
    echo "   Workspace missing: $WORKSPACE_CFG"
  fi
  exit 1
fi

# Check if CLAUDE.md already exists (created by controller)
if [ -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
    echo "âœ“ CLAUDE.md already exists (from controller), using existing file"
elif [ -f "/workspace/CLAUDE.md" ]; then
    echo "âœ“ Found CLAUDE.md in workspace, copying to working directory"
    cp "/workspace/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
else
    echo "ðŸ“ Creating Cleo-specific CLAUDE.md memory file"
    cat > "$CLAUDE_WORK_DIR/CLAUDE.md" << 'EOF'
# CLEO - Code Quality Enforcement Agent

## Agent Role
- **Primary**: Rigorous code quality enforcement and CI/CD maintenance
- **Focus**: Fix CI failures, resolve merge conflicts, enforce quality standards
- **Secondary**: YAML linting for infrastructure changes
- **Critical**: Add "ready-for-qa" label only when ALL quality checks pass

## PRIORITY TASKS

### 1. Merge Conflict Resolution (DO FIRST!)
Check for merge conflicts and resolve them immediately:
\\\`\\\`\\\`bash
# Check if PR has conflicts
gh pr view $PR_NUM --json mergeable,mergeStateStatus

# If conflicts exist:
git fetch origin main
git merge origin/main
# Resolve conflicts intelligently, preserving functionality
git add -A
git commit -m "fix: resolve merge conflicts with main"
git push
\\\`\\\`\\\`

### 2. CI/CD Failure Fixes (HIGH PRIORITY)
Monitor CI status and fix any failures OR stuck jobs:
\\\`\\\`\\\`bash
# Check if repository has workflows before checking CI status
if [ -d ".github/workflows" ] && [ "\\\$(ls .github/workflows/*.yml .github/workflows/*.yaml 2>/dev/null | wc -l)" -gt 0 ]; then
  # Check CI status - look for BOTH failures AND stuck jobs
  gh pr checks $PR_NUM
  # Get PR branch dynamically
  PR_BRANCH=\\\$(gh pr view $PR_NUM --json headRefName -q .headRefName)
  gh run list --branch="\\\$PR_BRANCH" --limit 5
else
  echo "â„¹ï¸  No GitHub Actions workflows found in repository"
  echo "   CI/CD checks will be skipped for this repository"
fi

# If jobs are stuck/not starting:
# 1. Check workflow syntax:
cat .github/workflows/*.yml | head -50
# 2. Verify runner labels exist
# 3. Check for workflow errors in GitHub UI

# Common fixes for stuck jobs:
# - Fix 'runs-on:' to use valid runner (ubuntu-latest, ubuntu-22.04, etc.)
# - Fix action versions (e.g., actions/checkout@v4)
# - Ensure workflow triggers match (push, pull_request)
# - Remove or fix invalid workflow syntax

# Common fixes for failed jobs:
# - Fix linting errors (cargo fmt, black, eslint --fix)
# - Fix type errors
# - Update dependencies if needed
# - Fix test failures
# - Adjust CI configuration if needed
\\\`\\\`\\\`

## Code Quality Requirements

### CRITICAL: Clippy Pedantic Enforcement
**ABSOLUTE PRIORITY: Avoid #[allow(clippy::...)] bypasses at all costs!**
- **DO NOT** add \`#[allow(clippy::pedantic)]\` or similar suppressions
- **DO NOT** use \`#![allow(...)]\` at module or crate level
- **ALWAYS** fix the underlying code issue instead of suppressing warnings
- **ONLY** bypass if absolutely necessary AND document WHY in detail
- Each bypass is a code smell that should be addressed, not hidden

### Change Detection Logic
Analyze git diff to determine appropriate quality checks:
\\\`\\\`\\\`bash
RUST_CHANGES=\\\$(git diff --name-only origin/main...HEAD | grep -E '\\\.(rs|toml)\\\$' || true)
YAML_CHANGES=\\\$(git diff --name-only origin/main...HEAD | grep -E '\\\.(yaml|yml)\\\$' || true)
\\\`\\\`\\\`

### Quality Check Execution
**For Rust Changes:**
1. \\\`cargo clippy -- -D warnings -D clippy::pedantic\\\` (ZERO tolerance, NO bypasses)
2. Review existing code for any \`#[allow(clippy::...)]\` and remove them by fixing the code
3. \\\`cargo fmt\\\` (auto-fix formatting)
4. \\\`cargo test\\\` (all tests must pass)

**For YAML Changes:**
1. YAML syntax validation with yamllint
2. Auto-fix trailing spaces and formatting issues

### Error Handling
- **NEVER** suppress Clippy warnings with #[allow(...)]
- **ALWAYS** fix the root cause of Clippy warnings
- Automatically fix formatting and linting issues properly
- Fix compilation errors if straightforward
- Update outdated dependencies if causing CI failures
- Never approve when quality checks fail after fixes

### GitHub Integration
- Monitor PR for CI failures and merge conflicts
- Fix issues proactively without waiting
- Post PR comments about fixes made
- Add "ready-for-qa" label only when CI is green
- Use GitHub CLI for all PR operations

## Success Criteria
- PR has no merge conflicts
- All CI checks passing (green)
- Zero clippy warnings at pedantic level
- Perfect code formatting consistency
- 100% test pass rate
- Clean YAML syntax and structure
EOF

    # Append base CLAUDE.md from ConfigMap if it exists
    if [ -f "/task-files/CLAUDE.md" ]; then
        echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md"
        cat "/task-files/CLAUDE.md" >> "$CLAUDE_WORK_DIR/CLAUDE.md"
        echo "âœ“ Appended base CLAUDE.md content from ConfigMap"
    fi
fi

# Copy guidelines files to working directory (match Rex pattern)
if [ -f "/task-files/coding-guidelines.md" ]; then
  cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "âœ“ Copied coding-guidelines.md to working directory"
fi

if [ -f "/task-files/github-guidelines.md" ]; then
  cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "âœ“ Copied github-guidelines.md to working directory"
fi

# Copy MCP configuration from ConfigMap to project root (project scope)
if [ -f "/task-files/mcp.json" ]; then
  cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
  echo "âœ“ Copied mcp.json to .mcp.json (project scope)"
else
  echo "âš ï¸ mcp.json template not found"
fi

# Setup hook scripts
echo "ðŸ”§ Setting up Cleo-specific hook scripts..."
mkdir -p "$CLAUDE_WORK_DIR/hooks"

{{#each hook_scripts}}
cat > "$CLAUDE_WORK_DIR/hooks/{{@key}}" << 'EOF'
{{{this}}}
EOF
chmod +x "$CLAUDE_WORK_DIR/hooks/{{@key}}"
{{/each}}

# Export environment for Claude
export CLAUDE_WORK_DIR
export GITHUB_TOKEN
export REPO_OWNER
export REPO_NAME
export TARGET_REPO_DIR

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "âœ… CLEO CODE QUALITY AGENT READY"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ“ Working Directory: $CLAUDE_WORK_DIR"
echo "ðŸ“¦ Repository: $REPO_OWNER/$REPO_NAME"
echo "ðŸ“‹ Task: {{task_id}}"
echo "ðŸŽ¯ Focus: Rigorous code quality enforcement"
echo "âš ï¸  CRITICAL: Must pass all quality checks before adding 'ready-for-qa' label"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Export necessary variables for Claude execution
export SERVICE_NAME="{{service}}"
export TASK_ID="{{task_id}}"
export GITHUB_APP="{{github_app}}"

# Start Claude with Cleo-specific configuration
cd "$CLAUDE_WORK_DIR"

# Build Claude command
CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Look for Cleo-specific system prompt file
if [ -f "/task-files/cleo-system-prompt.md" ]; then
    echo "âœ“ Found Cleo system prompt file, adding to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /task-files/cleo-system-prompt.md"
else
    echo "â„¹ï¸ No Cleo system prompt file found, using inline prompt"
fi

# Create Cleo's static prompt (fallback if no system prompt file)
echo "âœ“ Creating Cleo's code quality enforcement prompt"

# Build static prompt with task context
CLEO_PROMPT="# Code Quality Review Assignment

You are Cleo, a rigorous code quality enforcement agent. Your mission is to ensure zero-tolerance quality standards for this pull request.

## Your Role
- **Primary Focus**: Code quality enforcement AND CI/CD pipeline setup
- **Quality Tools**: Clippy (pedantic), cargo fmt, cargo test, YAML linting
- **DevOps Setup**: GitHub Actions workflows, Docker image building, CI verification
- **Decision Authority**: Add 'ready-for-qa' label only when ALL quality checks AND CI builds pass
- **Standards**: Zero warnings, perfect formatting, 100% test pass rate, working Docker builds

## Current Context

### Pull Request Information
- **PR Number**: ${PR_NUMBER:-"Not specified"}
- **PR URL**: ${PR_URL:-"Not specified"}
- **Repository**: $REPO_OWNER/$REPO_NAME
- **Working Directory**: $CLAUDE_WORK_DIR"

# Add task context if available
if [ -f "$CLAUDE_WORK_DIR/task/task.md" ]; then
    CLEO_PROMPT="$CLEO_PROMPT

### Task Information (for context)
$(cat "$CLAUDE_WORK_DIR/task/task.md")

### Task Requirements (Rex was asked to implement)
$(cat "$CLAUDE_WORK_DIR/task/prompt.md" 2>/dev/null || echo "No prompt.md found")

### Acceptance Criteria (what Rex needed to achieve)
$(cat "$CLAUDE_WORK_DIR/task/acceptance-criteria.md" 2>/dev/null || echo "No acceptance-criteria.md found")

### Architecture Reference (if available)
$(cat "$CLAUDE_WORK_DIR/task/architecture.md" 2>/dev/null || echo "No architecture.md found")"
else
    CLEO_PROMPT="$CLEO_PROMPT

### Task Information
No task files found in /task directory - proceeding with general code quality review."
fi

# Complete the prompt
CLEO_PROMPT="$CLEO_PROMPT

## Your Instructions
1. **Analyze the PR changes**: The repository has been automatically positioned at the PR branch with latest changes
2. **Detect change types**: Identify Rust files (.rs, .toml) and YAML files (.yml, .yaml)
3. **Verify Live Data Implementation**: Ensure NO mocks exist - all implementations must use real databases, APIs, and configurable parameters (no hard-coded trading pairs, endpoints, etc.)
4. **Run quality checks (CRITICAL - NO BYPASSES)**:
   - For Rust: cargo clippy -- -D warnings -W clippy::pedantic
   - **ABSOLUTELY CRITICAL**: DO NOT add #[allow(clippy::...)] to bypass warnings!
   - Instead, FIX the underlying code issues that Clippy identifies
   - Review existing code and REMOVE any #[allow(clippy::...)] attributes by fixing the code
   - Run cargo fmt to fix any formatting issues
   - For YAML: YAML linting and validation
   - IMPORTANT: Commit and push ALL fixes immediately (don't wait until the end)
   - NOTE: Do NOT write tests - Tess handles all testing
5. **Set up CI/CD Pipeline (CRITICAL - Use These EXACT Patterns)**:
   - Check if .github/workflows/ci.yml exists (or similar CI workflow)
   - If not, create using these PROVEN TEMPLATES:

   **a) Dockerfile (Runtime-only, expects pre-built binary):**
   \\\`\\\`\\\`dockerfile
   FROM debian:bookworm-slim
   RUN apt-get update && apt-get install -y \\\\
       ca-certificates libssl3 wget --no-install-recommends \\\\
       && rm -rf /var/lib/apt/lists/* && apt-get clean
   RUN useradd -r -u 1000 -m -d /app -s /bin/bash app
   WORKDIR /app
   COPY binary-name /app/binary-name
   RUN chmod +x /app/binary-name && chown -R app:app /app
   USER app
   EXPOSE 8080
   HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\\
       CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1
   CMD ["./binary-name"]
   \\\`\\\`\\\`

   **b) CI Workflow (.github/workflows/ci.yml):**
   \\\`\\\`\\\`yaml
   name: Continuous Integration
   on:
     push:
       branches: [main]
     pull_request:
       branches: [main]

   jobs:
     lint-rust:
       runs-on: ubuntu-22.04
       steps:
         - uses: actions/checkout@v4
         - uses: actions-rust-lang/setup-rust-toolchain@v1
           with:
             toolchain: stable
             components: rustfmt, clippy
         - uses: Swatinem/rust-cache@v2
           with:
             workspaces: . -> target
             shared-key: "rust-cache-ci"
         - name: Format check
           run: cargo fmt --all -- --check
         - name: Clippy
           run: cargo clippy --all-targets --all-features -- -D warnings -W clippy::pedantic

     test-rust:
       runs-on: ubuntu-22.04
       steps:
         - uses: actions/checkout@v4
         - uses: actions-rust-lang/setup-rust-toolchain@v1
           with:
             toolchain: stable
         - uses: Swatinem/rust-cache@v2
           with:
             workspaces: . -> target
             shared-key: "rust-cache-ci"
         - name: Run tests
           run: cargo test --all-features --all-targets
   \\\`\\\`\\\`

   **c) Deploy Workflow (.github/workflows/deploy.yml) for k8s-runner:**
   \\\`\\\`\\\`yaml
   name: Deploy
   on:
     push:
       branches: [main, develop, feature/*, feat/*, fix/*]

   env:
     REGISTRY: ghcr.io
     IMAGE_BASE: ${{ github.repository_owner }}

   jobs:
     build:
       runs-on: [k8s-runner]  # Use self-hosted runner for speed
       permissions:
         contents: read
         packages: write
       steps:
         - uses: actions/checkout@v4
         - name: Build binary
           env:
             RUSTC_WRAPPER: "sccache"
             CARGO_TARGET_DIR: "\$HOME/cache/target"
           run: |
             cargo build --release
             cp \$HOME/cache/target/release/<binary> ./<binary>
         - uses: docker/setup-buildx-action@v3
         - uses: docker/login-action@v3
           with:
             registry: ghcr.io
             username: ${{ github.actor }}
             password: ${{ secrets.GITHUB_TOKEN }}
         - uses: docker/build-push-action@v5
           with:
             context: .
             file: ./Dockerfile
             platforms: linux/amd64,linux/arm64
             push: true
             tags: |
               ghcr.io/${{ github.repository }}:latest
               ghcr.io/${{ github.repository }}:${{ github.sha }}
             cache-from: type=gha
             cache-to: type=gha,mode=max
   \\\`\\\`\\\`

   - Commit and push the CI configuration
   - Push any code fixes you made locally
   - Use 'gh workflow run' to trigger the build if needed
   - Use 'gh run list' and 'gh run view' to monitor status
   - **WATCH FOR STUCK JOBS**: If jobs show "Waiting" > 2 min:
     * Check runner availability and labels
     * Verify workflow syntax is correct
     * Fix any workflow configuration issues
   - KEEP ITERATING: Fix issues, push, check CI, repeat until ALL JOBS RUN AND PASS
5. **Verify CI Success (THE ONLY MEASURE OF SUCCESS)**:
   - **If repository has workflows**: Use 'gh pr checks {{pr_number}}' to confirm ALL checks are passing
   - **If no workflows**: Skip CI validation and proceed to code quality checks
   - **CRITICAL: Check for stuck/pending jobs** (only if workflows exist):
     * Look for jobs showing "Waiting" or "Pending" for > 2 minutes
     * Check 'gh run list --branch=$(gh pr view {{pr_number}} --json headRefName -q .headRefName)' for workflow status
     * If jobs aren't starting, investigate:
       - Missing runner labels? Check 'runs-on:' in workflow
       - Workflow syntax errors? Validate with 'actionlint' or GitHub UI
       - Missing workflow triggers? Check 'on:' section
       - Concurrency limits? Check workflow 'concurrency:' settings
   - **Common fixes for stuck jobs** (only if workflows exist):
     * Add/fix 'runs-on: ubuntu-latest' (or appropriate runner)
     * Remove invalid actions or fix version tags
     * Ensure workflow file is in .github/workflows/
     * Check if workflow needs to be enabled in Actions settings
   - Specifically verify 'cargo clippy -- -D warnings -W clippy::pedantic' passes in CI (when workflows exist)
   - **VERIFY NO #[allow(clippy::...)] BYPASSES**: Check that no warnings are suppressed
   - SUCCESS = Code quality checks pass + CI passes (if workflows exist) OR code quality checks pass (if no workflows)
   - Do NOT proceed until quality standards are met
7. **Review against task requirements**: Verify implementation matches acceptance criteria
8. **Report results**: Provide detailed summary of checks performed, CI setup, and any fixes applied
9. **Success criteria**: Quality checks must pass for approval. CI/CD validation required only when workflows exist.

## Quality Standards (MUST PASS IN GITHUB ACTIONS WHEN WORKFLOWS EXIST, OTHERWISE LOCALLY!)
- **Zero tolerance** for clippy warnings at pedantic level (in CI if workflows exist, locally otherwise)
- **NO CLIPPY BYPASSES** - Absolutely no #[allow(clippy::...)] attributes unless critically necessary with documented justification
- **FIX THE CODE, NOT THE WARNING** - Address the underlying issues Clippy identifies
- **Perfect formatting** required (cargo fmt --check must pass in CI if workflows exist, locally otherwise)
- **All tests pass** (cargo test must succeed in CI if workflows exist, locally otherwise)
- **Clean YAML** syntax and structure
- **CI/CD Pipeline** SHOULD be working with successful Docker image build (when workflows exist)
- **GitHub Actions** SHOULD show green checks for ALL quality gates (when workflows exist)
- **Task compliance** (implementation should meet acceptance criteria)
- **NO MOCKS ALLOWED** (all implementations must use live data and real APIs - no hard-coded or mock values)
- **Parameterized Configuration** (trading pairs, endpoints, and business logic must be configurable, not hard-coded)

## CRITICAL REMINDER
Your success is measured by:
- **If workflows exist**: GitHub Actions CI status, NOT local checks
  - You MUST push your changes to see them tested in CI
  - You MUST iterate: fix locally â†’ push â†’ check CI â†’ repeat until green
  - Clippy pedantic MUST pass in GitHub Actions before you can add 'ready-for-qa' label
  - **ALL CI JOBS MUST ACTUALLY RUN** - stuck/pending jobs = FAILURE
- **If no workflows**: Local quality checks and task compliance
  - Run quality checks locally: cargo clippy, cargo fmt, cargo test
  - Ensure code meets quality standards before approval

## TROUBLESHOOTING STUCK CI JOBS
If CI jobs won't start (showing \"Waiting\" or \"Pending\" indefinitely):
1. **Check runner labels**: Ensure 'runs-on:' uses valid runners
   - Common: ubuntu-latest, ubuntu-22.04, ubuntu-20.04
   - Self-hosted: [self-hosted], [k8s-runner]
2. **Validate workflow syntax**: Run locally or check GitHub UI for errors
3. **Check workflow triggers**: Ensure 'on:' section includes your event
4. **Fix common issues**:
   - Missing or misspelled action names
   - Invalid YAML syntax (use yamllint)
   - Workflow file not in .github/workflows/
   - Workflow disabled in repo settings
- The PR checks page on GitHub is your source of truth

Begin your code quality review now."

# Debug: Print the actual prompt and CLAUDE.md content
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” DEBUG: CLEO PROMPT CONTENT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "$CLEO_PROMPT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” DEBUG: CLAUDE.md MEMORY CONTENT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
if [ -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
    cat "$CLAUDE_WORK_DIR/CLAUDE.md"
else
    echo "âŒ No CLAUDE.md found at $CLAUDE_WORK_DIR/CLAUDE.md"
fi
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Send the static prompt to Claude
FIFO_PATH="/workspace/agent-input.jsonl"
rm -f "$FIFO_PATH" 2>/dev/null || true
mkfifo "$FIFO_PATH"
chmod 666 "$FIFO_PATH" || true

# Start Claude (reader) first in background
$CLAUDE_CMD < "$FIFO_PATH" &
CLAUDE_PID=$!

# Start background token refresh for long-running jobs
(
    while kill -0 $CLAUDE_PID 2>/dev/null; do
        sleep 2700  # Check every 45 minutes

        if [ -n "$TOKEN_GENERATED_AT" ] && [ -n "$GITHUB_APP_PRIVATE_KEY" ]; then
            NOW=$(date +%s)
            TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))

            if [ $TOKEN_AGE -gt 2700 ]; then
                echo "[Background] Token is $(($TOKEN_AGE / 60)) minutes old, refreshing..."
                refresh_github_token
            fi
        fi
    done
) &
TOKEN_REFRESH_PID=$!
echo "âœ“ Started background token refresh (PID: $TOKEN_REFRESH_PID)"

# Compose initial user turn with the static prompt
USER_COMBINED=$(printf "%s" "$CLEO_PROMPT" | jq -Rs .)

# Send via sidecar HTTP endpoint
if printf '{"text":%s}\n' "$USER_COMBINED" | \
     curl -fsS -X POST http://127.0.0.1:8080/input \
       -H 'Content-Type: application/json' \
       --data-binary @- >/dev/null 2>&1; then
  echo "âœ“ Static Cleo prompt sent via sidecar /input"
else
  echo "âš ï¸ Sidecar /input failed, falling back to direct FIFO write"
  exec 9>"$FIFO_PATH"
  printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}\n' "$USER_COMBINED" >&9
  exec 9>&- 2>/dev/null || true  # Close immediately
fi

# Wait for Claude process to complete
wait "$CLAUDE_PID"
CLAUDE_EXIT_CODE=$?

# Stop token refresh background process
if [ -n "$TOKEN_REFRESH_PID" ]; then
    kill $TOKEN_REFRESH_PID 2>/dev/null || true
    echo "âœ“ Stopped token refresh process"
fi

# Always attempt to complete quality review - don't exit on Claude failures
echo "ðŸ”„ Processing quality review results..."
if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
  echo "âœ… Claude quality review completed successfully"
fi

# Always attempt to post PR comment and add label regardless of Claude exit status
# Determine OWNER/REPO slug for gh -R
REPO_INPUT="{{repository_url}}"
if echo "$REPO_INPUT" | grep -q "^https://github.com/"; then
  REPO_SLUG=$(echo "$REPO_INPUT" | sed -E 's|https://github.com/([^/]+/[^/.]+)(\.git)?$|\1|')
else
  REPO_SLUG="$REPO_INPUT"
fi

# Post quality review comment to PR
if [ -n "$PR_NUMBER" ] || [ -n "$PR_URL" ]; then
  echo "ðŸ’¬ Posting quality review comment to PR..."

  # Create comment body based on Claude exit status
  if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
    COMMENT_BODY="## ðŸ” Code Quality Review by Cleo

âœ… **Quality checks completed successfully**

### Review Summary
- Code has been reviewed for quality standards
- All required checks have passed
- Ready for QA testing

---
*Reviewed by Cleo - 5DLabs Code Quality Agent*"
  else
    COMMENT_BODY="## ðŸ” Code Quality Review by Cleo

âš ï¸ **Quality review encountered issues**

### Current Status
- Quality checks are being processed
- Some issues may need to be resolved
- Review will continue until standards are met

### Next Steps
- Monitor CI/CD pipeline status
- Address any failing quality checks
- Iterate until all standards are met

---
*Reviewed by Cleo - 5DLabs Code Quality Agent*"
  fi

  # Post comment using PR number or URL
  if [ -n "$PR_NUMBER" ]; then
    if echo "$COMMENT_BODY" | gh pr comment "$PR_NUMBER" -R "$REPO_SLUG" --body-file - 2>/dev/null; then
      echo "âœ… Successfully posted quality review comment"
    else
      echo "âš ï¸ Failed to post comment using PR number"
    fi
  elif [ -n "$PR_URL" ]; then
    if echo "$COMMENT_BODY" | gh pr comment "$PR_URL" --body-file - 2>/dev/null; then
      echo "âœ… Successfully posted quality review comment"
    else
      echo "âš ï¸ Failed to post comment"
    fi
  fi
fi

# Update remediation status labels for Cleo's outcome
if [ -n "$PR_NUMBER" ] || [ -n "$PR_URL" ]; then
  ensure_status_labels "$REPO_SLUG" \
    "${STATUS_LABEL_NEEDS_FIXES}:d73a4a:Remediation requested by Tess" \
    "${STATUS_LABEL_FIXING}:fbca04:Rex is actively applying fixes" \
    "${STATUS_LABEL_NEEDS_CLEO}:0e8a16:Awaiting Cleo quality review" \
    "${STATUS_LABEL_NEEDS_TESS}:5319e7:Awaiting Tess QA review" \
    "${STATUS_LABEL_APPROVED}:2da44e:All automated reviews approved" \
    "${STATUS_LABEL_FAILED}:b60205:Remediation failed or aborted"

  if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
    echo "ðŸ·ï¸ Updating remediation labels: Cleo approved quality checks"
    pr_remove_labels "$REPO_SLUG" "$PR_NUMBER" "$PR_URL" \
      "$STATUS_LABEL_NEEDS_CLEO" \
      "$STATUS_LABEL_NEEDS_FIXES" \
      "$STATUS_LABEL_FIXING" \
      "$STATUS_LABEL_APPROVED" \
      "$STATUS_LABEL_FAILED" \
      "$STATUS_LABEL_NEEDS_TESTS_LEGACY"
    pr_add_labels "$REPO_SLUG" "$PR_NUMBER" "$PR_URL" "$STATUS_LABEL_NEEDS_TESS"
    update_coderun_status "$STATUS_LABEL_NEEDS_TESS" "pending" "$PR_URL"
  else
    echo "ðŸ·ï¸ Updating remediation labels: Quality issues detected"
    pr_remove_labels "$REPO_SLUG" "$PR_NUMBER" "$PR_URL" \
      "$STATUS_LABEL_NEEDS_CLEO" \
      "$STATUS_LABEL_NEEDS_TESS" \
      "$STATUS_LABEL_APPROVED" \
      "$STATUS_LABEL_FAILED" \
      "$STATUS_LABEL_NEEDS_TESTS_LEGACY"
    pr_add_labels "$REPO_SLUG" "$PR_NUMBER" "$PR_URL" "$STATUS_LABEL_NEEDS_FIXES"
    update_coderun_status "$STATUS_LABEL_NEEDS_FIXES" "changes_requested" "$PR_URL"
  fi
else
  echo "âš ï¸ No PR reference available, skipping remediation label update"
  update_coderun_status "$STATUS_LABEL_NEEDS_FIXES" "changes_requested" ""
fi

# Gracefully stop sidecar (with enhanced debugging and retries)
if [ "${SKIP_MCP_SHUTDOWN:-0}" = "1" ]; then
  echo "â­ï¸  Skipping MCP sidecar shutdown (SKIP_MCP_SHUTDOWN=1)"
else
  echo "ðŸ”§ Attempting sidecar shutdown..."
  shutdown_attempts=0
  max_shutdown_attempts=3

  while [ $shutdown_attempts -lt $max_shutdown_attempts ]; do
    if curl -fsS -X POST http://127.0.0.1:8080/shutdown -m 5 2>/dev/null; then
      echo "âœ“ Sidecar shutdown request successful (attempt $((shutdown_attempts + 1)))"
      break
    else
      shutdown_attempts=$((shutdown_attempts + 1))
      echo "âš ï¸ Sidecar shutdown request failed (attempt $shutdown_attempts/$max_shutdown_attempts)"
      if [ $shutdown_attempts -lt $max_shutdown_attempts ]; then
        echo "Retrying in 2 seconds..."
        sleep 2
      fi
    fi
  done

  if [ $shutdown_attempts -eq $max_shutdown_attempts ]; then
    echo "âŒ Failed to shutdown sidecar after $max_shutdown_attempts attempts"
    echo "ðŸ”§ Force terminating sidecar processes..."
    pkill -f "sidecar" || echo "No sidecar processes found to kill"
  fi

# Wait for sidecar to actually terminate
  echo "â³ Waiting for sidecar termination..."
  timeout=10
  while [ $timeout -gt 0 ]; do
    if ! pgrep -f "sidecar" > /dev/null 2>&1; then
      echo "âœ… Sidecar terminated successfully"
      break
    fi
    sleep 1
    timeout=$((timeout - 1))
  done

  if [ $timeout -eq 0 ]; then
    echo "âš ï¸ Sidecar still running after wait period"
  fi
fi

# Cleanup and exit
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                  CLEO CODE QUALITY COMPLETE                  â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ“‹ Task: {{task_id}}"
echo "âœ… Code quality checks completed"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Final termination sequence
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ”š TERMINATING CLEO CONTAINER"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "Claude Exit Code: $CLAUDE_EXIT_CODE"
echo "Container PID: $$"
echo "Final Process Check:"
ps aux | head -5

# Write completion marker for workflow tracking
echo "cleo-quality-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.cleo-complete

# Cleanup FIFO
rm -f "$FIFO_PATH" 2>/dev/null || true

# Always exit successfully to keep workflow running
echo "ðŸ”š Force terminating container..."
echo "ðŸ“ Note: Container always exits with code 0 to allow workflow continuation"
exit 0
