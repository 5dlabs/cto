#!/bin/bash
set -euo pipefail

# =========================================================================
# Environment bootstrapping
# =========================================================================

{{#if agent_banner}}
echo "{{agent_banner}}"
{{else}}
echo "üîß Initialising Factory environment"
{{/if}}

if [ -f "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi

if [ -f "/root/.cargo/env" ]; then
  . "/root/.cargo/env"
fi

if command -v rustup >/dev/null 2>&1; then
  rustup default stable 2>/dev/null || true
fi

echo "PATH: $PATH"

# =========================================================================
# RETRY CONFIGURATION
# =========================================================================
MAX_RETRIES_CONFIG=${FACTORY_MAX_RETRIES:-${EXECUTION_MAX_RETRIES:-10}}
echo ""
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "‚ïë                    RETRY CONFIGURATION                        ‚ïë"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "ü§ñ CLI: {{cli_type}}"
echo "üéØ Model: {{model}}"
echo "üîÑ Maximum Iterations: $MAX_RETRIES_CONFIG"
if [ -n "${FACTORY_MAX_RETRIES:-}" ]; then
  echo "üìç Source: FACTORY_MAX_RETRIES environment variable"
elif [ -n "${EXECUTION_MAX_RETRIES:-}" ]; then
  echo "üìç Source: EXECUTION_MAX_RETRIES environment variable"
else
  echo "üìç Source: Default configuration"
fi
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo ""

# =========================================================================
# GitHub App authentication
# =========================================================================

REPO_URL="{{repository_url}}"

if [ -z "${GITHUB_APP_PRIVATE_KEY:-}" ] || [ -z "${GITHUB_APP_ID:-}" ]; then
  echo "‚ùå Missing GitHub App credentials"
  exit 1
fi

echo "üîê Authenticating with GitHub App"
TEMP_KEY_FILE="/tmp/github-app-key.pem"
printf '%b' "$GITHUB_APP_PRIVATE_KEY" >"$TEMP_KEY_FILE"
chmod 600 "$TEMP_KEY_FILE"

JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
NOW=$(date +%s)
EXP=$((NOW + 600))
JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
rm -f "$TEMP_KEY_FILE"

parse_repo() {
  local input="$1"
  if echo "$input" | grep -qE '^https://github.com/'; then
    echo "$input" | sed -E 's|https://github.com/([^/]+)/([^/]+?)(\.git)?$|\1 \2|'
  elif echo "$input" | grep -qE '^git@github.com:'; then
    echo "$input" | sed -E 's|git@github.com:([^/]+)/([^/]+?)(\.git)?$|\1 \2|'
  else
    echo "$input" | sed -E 's|\.git$||' | sed -E 's|([^/]+)/([^/]+)|\1 \2|'
  fi
}

read REPO_OWNER REPO_NAME <<<"$(parse_repo "$REPO_URL")"
REPO_HTTP_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}.git"

INSTALLATION_ID=$(curl -s -L \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
  INSTALLATION_ID=$(curl -s -L \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
fi

if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
  echo "‚ùå Unable to resolve installation ID for $REPO_OWNER/$REPO_NAME"
  exit 1
fi

GITHUB_TOKEN=$(curl -s -X POST \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')

if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
  echo "‚ùå Unable to obtain installation token"
  exit 1
fi

export GITHUB_TOKEN
export GH_TOKEN="$GITHUB_TOKEN"
export GH_HOST="github.com"

# Task-specific workspace for parallel execution isolation
TASK_WORKSPACE="/workspace/task-{{task_id}}"
mkdir -p /workspace
mkdir -p "$TASK_WORKSPACE"
export GH_CONFIG_DIR="$TASK_WORKSPACE/.config/gh"
mkdir -p "$GH_CONFIG_DIR"
echo "üìÅ Using task-specific workspace: $TASK_WORKSPACE"

# Clean up any leftover sentinel file from previous runs
# This prevents premature sidecar shutdown on sequential task executions
if [ -f "$TASK_WORKSPACE/.agent_done" ]; then
    echo "üßπ Cleaning up sentinel file from previous run at $TASK_WORKSPACE/.agent_done"
    rm -f "$TASK_WORKSPACE/.agent_done"
fi

# Clean up any leftover completion marker from previous runs
# This prevents issues with sequential task executions on the same PVC
if [ -f /workspace/.cipher-complete ]; then
    echo "üßπ Cleaning up completion marker from previous run"
    rm -f /workspace/.cipher-complete
fi

export GIT_CONFIG_GLOBAL="$TASK_WORKSPACE/.gitconfig"
CREDENTIALS_FILE="$TASK_WORKSPACE/.git-credentials"

git config --global --replace-all credential.helper "store --file=$CREDENTIALS_FILE"
echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > "$CREDENTIALS_FILE"

gh_hosts_file() {
  if [ -n "${GH_CONFIG_DIR:-}" ] && [ -f "${GH_CONFIG_DIR}/hosts.yml" ]; then
    printf '%s\n' "${GH_CONFIG_DIR}/hosts.yml"
    return
  fi
  if [ -f "$HOME/.config/gh/hosts.yml" ]; then
    printf '%s\n' "$HOME/.config/gh/hosts.yml"
    return
  fi
  printf ''
}

sync_gh_hosts_to_path() {
  local target="$1"
  if [ -z "$target" ]; then
    return
  fi
  local source
  source=$(gh_hosts_file)
  if [ -z "$source" ] || [ ! -f "$source" ]; then
    return
  fi
  local dest_dir="$target/.config/gh"
  mkdir -p "$dest_dir"
  if cp "$source" "$dest_dir/hosts.yml" >/dev/null 2>&1; then
    chmod 600 "$dest_dir/hosts.yml" 2>/dev/null || true
  fi
}

TOKEN_GENERATED_AT=$(date +%s)

refresh_github_token() {
  echo "üîÑ Refreshing GitHub App token..."

  TEMP_KEY_FILE="/tmp/github-app-key-$$"
  printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
  chmod 600 "$TEMP_KEY_FILE"

  JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  NOW=$(date +%s)
  EXP=$((NOW + 600))
  JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

  rm -f "$TEMP_KEY_FILE"

  NEW_INSTALLATION_ID=$(curl -s -L \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

  if [ "$NEW_INSTALLATION_ID" = "null" ] || [ -z "$NEW_INSTALLATION_ID" ]; then
    NEW_INSTALLATION_ID=$(curl -s -L \
      -H "Authorization: Bearer $JWT_TOKEN" \
      -H "Accept: application/vnd.github+json" \
      "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
  fi

  TOKEN_RESPONSE=$(curl -s -X POST \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/app/installations/$NEW_INSTALLATION_ID/access_tokens")

  NEW_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

  if [ "$NEW_TOKEN" != "null" ] && [ -n "$NEW_TOKEN" ]; then
    export GITHUB_TOKEN="$NEW_TOKEN"
    export GH_TOKEN="$NEW_TOKEN"
    TOKEN_GENERATED_AT=$(date +%s)
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > "$CREDENTIALS_FILE"
    echo "‚úÖ Token refreshed"
    return 0
  fi

  echo "‚ùå Failed to refresh token: $TOKEN_RESPONSE"
  return 1
}

refresh_token_if_needed() {
  if [ -z "$TOKEN_GENERATED_AT" ]; then
    refresh_github_token || true
    return
  fi

  NOW=$(date +%s)
  TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))

  if [ $TOKEN_AGE -gt 3000 ]; then
    echo "üîÑ Token age: $((TOKEN_AGE / 60)) minutes ‚Äî refreshing"
    refresh_github_token || true
  fi
}

sanitize_status_message() {
  printf '%s' "$1" | tr '\n' ' ' | tr '\r' ' '
}

resolve_pr_url() {
  if [ -n "${PR_URL:-}" ]; then
    printf '%s' "$PR_URL"
    return
  fi

  if [ -n "${PR_NUMBER:-}" ] && [ -n "${REPO_OWNER:-}" ] && [ -n "${REPO_NAME:-}" ]; then
    printf 'https://github.com/%s/%s/pull/%s' "$REPO_OWNER" "$REPO_NAME" "$PR_NUMBER"
    return
  fi

  if command -v gh >/dev/null 2>&1; then
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || printf '')
    if [ -n "$current_branch" ]; then
      local pr_url
      pr_url=$(gh pr list --state all --head "$current_branch" --json url --jq '.[0].url' 2>/dev/null || printf '')
      if [ -n "$pr_url" ]; then
        printf '%s' "$pr_url"
        return
      fi
    fi
  fi

  printf ''
}

patch_coderun_status() {
  local phase="$1"
  local message="$2"
  local remediation_status="${3:-}"
  local qa_status="${4:-}"
  local pr_url="${5:-}"
  local work_completed_flag="${6:-false}"

  if [ -z "${CODERUN_NAME:-}" ] || [ -z "${NAMESPACE:-}" ]; then
    return
  fi

  local token_path="/var/run/secrets/kubernetes.io/serviceaccount/token"
  local ca_path="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"

  if [ ! -f "$token_path" ] || [ ! -f "$ca_path" ]; then
    echo "‚ÑπÔ∏è Service account credentials unavailable; skipping CodeRun status update"
    return
  fi

  if ! command -v jq >/dev/null 2>&1; then
    echo "‚ÑπÔ∏è jq not available; skipping CodeRun status update"
    return
  fi

  local work_completed="false"
  if [ "$work_completed_flag" = "true" ]; then
    work_completed="true"
  fi

  local payload
  payload=$(jq -n \
    --arg phase "$phase" \
    --arg message "$(sanitize_status_message "$message")" \
    --arg remediation "$remediation_status" \
    --arg qa "$qa_status" \
    --arg pr "$pr_url" \
    --arg workCompleted "$work_completed" \
    '{
      status: (
        {
          phase: $phase,
          message: $message,
          workCompleted: ($workCompleted == "true")
        }
        + (if $remediation != "" then {remediationStatus: $remediation} else {} end)
        + (if $qa != "" then {qaStatus: $qa} else {} end)
        + (if $pr != "" then {pullRequestUrl: $pr} else {} end)
      )
    }'
  ) || return

  local api_host="${KUBERNETES_SERVICE_HOST:-}"
  local api_port="${KUBERNETES_SERVICE_PORT_HTTPS:-${KUBERNETES_SERVICE_PORT:-443}}"

  if [ -z "$api_host" ]; then
    echo "‚ÑπÔ∏è Kubernetes API host unavailable; skipping CodeRun status update"
    return
  fi

  local token
  token=$(cat "$token_path")

  curl -sS -X PATCH \
    -H "Authorization: Bearer $token" \
    -H "Content-Type: application/merge-patch+json" \
    --cacert "$ca_path" \
    --data "$payload" \
    "https://${api_host}:${api_port}/apis/agents.platform/v1/namespaces/${NAMESPACE}/coderuns/${CODERUN_NAME}/status" >/dev/null 2>&1 || \
    echo "‚ö†Ô∏è Failed to patch CodeRun status"
}

stop_docker_sidecar() {
  if [ ! -S /var/run/docker.sock ]; then
    return
  fi

  echo "üõë Stopping Docker sidecar"

  if command -v pkill >/dev/null 2>&1; then
    pkill dockerd >/dev/null 2>&1 || true
    sleep 1
    if pidof dockerd >/dev/null 2>&1; then
      pkill -9 dockerd >/dev/null 2>&1 || true
    fi
    if pidof docker-init >/dev/null 2>&1; then
      pkill docker-init >/dev/null 2>&1 || true
    fi
  elif command -v killall >/dev/null 2>&1; then
    killall dockerd >/dev/null 2>&1 || true
  else
    PID=$(pidof dockerd 2>/dev/null || true)
    if [ -n "$PID" ]; then
      kill "$PID" >/dev/null 2>&1 || true
    fi
    PID_INIT=$(pidof docker-init 2>/dev/null || true)
    if [ -n "$PID_INIT" ]; then
      kill "$PID_INIT" >/dev/null 2>&1 || true
    fi
  fi

  for _ in 1 2 3 4 5; do
    if ! pidof dockerd >/dev/null 2>&1 && ! pidof docker-init >/dev/null 2>&1; then
      echo "‚úÖ Docker sidecar stopped"
      return
    fi
    sleep 1
  done

  REMAINING_DOCKER=$(pidof dockerd 2>/dev/null || true)
  REMAINING_INIT=$(pidof docker-init 2>/dev/null || true)
  echo "‚ö†Ô∏è Docker sidecar still running (dockerd: ${REMAINING_DOCKER:-none}, docker-init: ${REMAINING_INIT:-none})"
}

trap 'stop_docker_sidecar || true' EXIT

ensure_gh_authenticated() {
  if ! command -v gh >/dev/null 2>&1; then
    echo "‚ö†Ô∏è GitHub CLI (gh) not found; skipping authentication"
    return 0
  fi

  if ! gh auth status -h "$GH_HOST" >/dev/null 2>&1; then
    echo "üîê Logging in to GitHub CLI for host $GH_HOST"
    refresh_github_token || true
    if ! printf '%s\n' "$GITHUB_TOKEN" | timeout 10 gh auth login --with-token --hostname "$GH_HOST" >/dev/null 2>&1; then
      echo "‚ö†Ô∏è gh auth login returned non-zero or timed out; continuing with GH_TOKEN env"
    fi
  fi

  refresh_token_if_needed || true
  gh auth setup-git >/dev/null 2>&1 || true

  if gh auth status -h "$GH_HOST" >/dev/null 2>&1; then
    echo "‚úÖ GitHub CLI authenticated for $GH_HOST"
  else
    echo "‚ö†Ô∏è Unable to confirm GitHub CLI auth; GH_TOKEN will still be used for git operations"
  fi
}

ensure_gh_authenticated

sync_gh_hosts_to_path "$TASK_WORKSPACE"

ensure_pr_created() {
  if [ "${SKIP_AUTO_PR:-0}" = "1" ]; then
    echo "‚è≠Ô∏è  Auto PR creation disabled via SKIP_AUTO_PR=1"
    return
  fi

  # CRITICAL GUARD #1: Check if orchestrator already provided PR_NUMBER
  # This must be checked BEFORE any other logic to prevent duplicate PRs
  if [ -n "${PR_NUMBER:-}" ]; then
    echo "‚ÑπÔ∏è PR_NUMBER=${PR_NUMBER} provided by orchestrator; skipping fallback PR creation"
    return
  fi

  # CRITICAL GUARD #2: Only auto-create PRs during implementation stage
  # Quality/security/testing agents should NEVER create PRs
  if [ "${WORKFLOW_STAGE:-}" != "implementation" ]; then
    echo "‚ÑπÔ∏è Not in implementation stage (${WORKFLOW_STAGE:-unknown}); skipping fallback PR creation"
    return
  fi

  if [ ! -d .git ]; then
    echo "‚ö†Ô∏è Repository not initialised; skipping auto PR creation"
    return
  fi

  if ! command -v gh >/dev/null 2>&1; then
    echo "‚ö†Ô∏è GitHub CLI not available; skipping auto PR creation"
    return
  fi

  if ! command -v jq >/dev/null 2>&1; then
    echo "‚ö†Ô∏è jq not available; skipping auto PR creation"
    return
  fi

  if [ -z "${GITHUB_TOKEN:-}" ]; then
    echo "‚ö†Ô∏è GITHUB_TOKEN not set; skipping auto PR creation"
    return
  fi

  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || printf '')
  if [ -z "$CURRENT_BRANCH" ]; then
    echo "‚ö†Ô∏è Unable to determine current branch; skipping auto PR creation"
    return
  fi

  # Ensure we have repo context for PR checks
  REPO_SLUG="${REPO_OWNER:-}/${REPO_NAME:-}"
  if [ "$REPO_SLUG" = "/" ] || [ -z "$REPO_OWNER" ] || [ -z "$REPO_NAME" ]; then
    echo "‚ö†Ô∏è REPO_OWNER/REPO_NAME not set; checking for PRs without explicit repo context"
    REPO_SLUG=""
  fi

  # Check if PR already exists for this branch (with explicit repo context)
  # First check for open PRs, then closed PRs if needed
  refresh_token_if_needed || true
  if [ -n "$REPO_SLUG" ]; then
    PR_OUTPUT=$(gh pr list -R "$REPO_SLUG" --state open --head "$CURRENT_BRANCH" --json number,state --limit 1 2>&1)
  else
    PR_OUTPUT=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number,state --limit 1 2>&1)
  fi
  PR_EXIT_CODE=$?

  if [ $PR_EXIT_CODE -ne 0 ] && printf '%s' "$PR_OUTPUT" | grep -qi "HTTP 401"; then
    echo "‚ö†Ô∏è gh pr list returned HTTP 401; refreshing GitHub credentials"
    refresh_github_token || true
    ensure_gh_authenticated
    if [ -n "$REPO_SLUG" ]; then
      PR_OUTPUT=$(gh pr list -R "$REPO_SLUG" --state open --head "$CURRENT_BRANCH" --json number,state --limit 1 2>&1)
    else
      PR_OUTPUT=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number,state --limit 1 2>&1)
    fi
    PR_EXIT_CODE=$?
  fi

  if [ $PR_EXIT_CODE -ne 0 ]; then
    printf '%s\n' "$PR_OUTPUT" >&2
    PR_DATA="[]"
  else
    PR_DATA="$PR_OUTPUT"
  fi

  if [ -z "$PR_DATA" ]; then
    PR_DATA="[]"
  fi

  # Check if open PR exists
  if [ "$(printf '%s' "$PR_DATA" | jq 'length' 2>/dev/null || echo 0)" -gt 0 ]; then
    EXISTING_PR_NUM=$(printf '%s' "$PR_DATA" | jq -r '.[0].number // empty')
    echo "‚úÖ Pull request already exists for branch $CURRENT_BRANCH: PR #$EXISTING_PR_NUM"
    return
  fi

  # If no open PR, check for closed PRs (may indicate previous run)
  # If closed PR exists, we should still create a new PR for this run
  if [ -n "$REPO_SLUG" ]; then
    CLOSED_PR_OUTPUT=$(gh pr list -R "$REPO_SLUG" --state closed --head "$CURRENT_BRANCH" --json number,state --limit 1 2>&1)
  else
    CLOSED_PR_OUTPUT=$(gh pr list --state closed --head "$CURRENT_BRANCH" --json number,state --limit 1 2>&1)
  fi

  if [ "$(printf '%s' "$CLOSED_PR_OUTPUT" | jq 'length' 2>/dev/null || echo 0)" -gt 0 ]; then
    CLOSED_PR_NUM=$(printf '%s' "$CLOSED_PR_OUTPUT" | jq -r '.[0].number // empty')
    echo "‚ÑπÔ∏è Found CLOSED PR #$CLOSED_PR_NUM for branch $CURRENT_BRANCH (from previous run)"
    echo "   Creating new PR for current workflow run..."
    # Continue to create new PR below
  fi

  BASE_BRANCH="${PR_BASE_BRANCH:-main}"
  REMOTE_BASE="origin/$BASE_BRANCH"
  if ! git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
    if git show-ref --verify --quiet "refs/remotes/origin/master"; then
      BASE_BRANCH="master"
      REMOTE_BASE="origin/$BASE_BRANCH"
    else
      DEFAULT_REMOTE=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
      if [ -n "$DEFAULT_REMOTE" ]; then
        BASE_BRANCH="$DEFAULT_REMOTE"
        REMOTE_BASE="origin/$BASE_BRANCH"
      else
        REMOTE_BASE=""
      fi
    fi
  fi

  refresh_token_if_needed || true
  if [ -n "$BASE_BRANCH" ]; then
    git fetch origin "$BASE_BRANCH" >/dev/null 2>&1 || true
  fi

  if [ "$CURRENT_BRANCH" = "HEAD" ] || [ "$CURRENT_BRANCH" = "$BASE_BRANCH" ]; then
    AUTO_BRANCH="task-{{task_id}}-{{service}}-$(date +%Y%m%d-%H%M%S)"
    echo "‚ö†Ô∏è Branch $CURRENT_BRANCH unsuitable for PR; creating $AUTO_BRANCH"
    if ! git checkout -B "$AUTO_BRANCH" >/dev/null 2>&1; then
      echo "‚ùå Failed to create fallback branch $AUTO_BRANCH"
      return
    fi
    CURRENT_BRANCH="$AUTO_BRANCH"
  fi

  git add .
  if git diff --cached --quiet --exit-code; then
    echo "‚ÑπÔ∏è No staged changes detected after auto-staging"
  else
    COMMIT_MSG="chore({{service}}): auto-commit for task {{task_id}}"
    if ! git commit -m "$COMMIT_MSG" >/dev/null 2>&1; then
      echo "‚ö†Ô∏è Failed to commit staged changes automatically"
    else
      echo "‚úÖ Auto-committed staged changes"
    fi
  fi

  if git rev-parse --verify --quiet "$CURRENT_BRANCH" >/dev/null 2>&1; then
    refresh_token_if_needed || true
    if ! git push -u origin "$CURRENT_BRANCH" >/dev/null 2>&1; then
      echo "‚ö†Ô∏è Failed to push branch $CURRENT_BRANCH; skipping auto PR creation"
      return
    fi
  else
    echo "‚ö†Ô∏è Unable to verify branch $CURRENT_BRANCH; skipping auto PR creation"
    return
  fi

  git fetch origin "$CURRENT_BRANCH" >/dev/null 2>&1 || true
  if [ -n "$REMOTE_BASE" ]; then
    AHEAD_COUNT=$(git rev-list --left-right "$REMOTE_BASE...$CURRENT_BRANCH" 2>/dev/null | awk '/^>/{c++} END{print c+0}')
  else
    AHEAD_COUNT=1
  fi
  if [ "${AHEAD_COUNT:-0}" -eq 0 ]; then
    echo "‚ö†Ô∏è Branch $CURRENT_BRANCH has no commits ahead of $BASE_BRANCH; skipping PR creation"
    return
  fi

  # Use environment variable WORKFLOW_NAME if available, otherwise fall back to template
  RUN_LABEL="run-${WORKFLOW_NAME:-{{workflow_name}}}"
  if [ "${RUN_LABEL#run-}" = "" ] || [ "$RUN_LABEL" = "run-" ]; then
    RUN_LABEL="run-unknown"
  fi

  TASK_LABEL="task-{{task_id}}"
  SERVICE_LABEL="service-{{service}}"
  REPO_SLUG="${REPO_OWNER}/${REPO_NAME}"

  echo "üîç Ensuring PR correlation labels exist"
  for label in "$TASK_LABEL" "$SERVICE_LABEL" "$RUN_LABEL"; do
    if [ -z "$label" ]; then
      continue
    fi

    if gh label view "$label" -R "$REPO_SLUG" >/dev/null 2>&1; then
      echo "   ‚úì Label '$label' already exists"
      continue
    fi

    case "$label" in
      task-*) COLOR="28a745"; DESC="Task correlation" ;;
      service-*) COLOR="0e8a16"; DESC="Service correlation" ;;
      run-*) COLOR="0366d6"; DESC="Workflow correlation" ;;
      *) COLOR="ededed"; DESC="Automation label" ;;
    esac

    if gh label create "$label" --force -R "$REPO_SLUG" --color "$COLOR" --description "$DESC" >/tmp/gh-label-create.log 2>&1; then
      echo "   ‚úÖ Created label '$label'"
    else
      echo "   ‚ùå Failed to create label '$label'"
      cat /tmp/gh-label-create.log >&2 || true
    fi
    rm -f /tmp/gh-label-create.log
  done

  # VALIDATION: Check for problematic commits before creating PR
  echo "üîç Validating changes before PR creation..."

  # Check total diff size
  TOTAL_ADDITIONS=$(git diff --numstat "$BASE_BRANCH"..."$CURRENT_BRANCH" | awk '{sum+=$1} END {print sum+0}')
  TOTAL_DELETIONS=$(git diff --numstat "$BASE_BRANCH"..."$CURRENT_BRANCH" | awk '{sum+=$2} END {print sum+0}')
  TOTAL_CHANGES=$((TOTAL_ADDITIONS + TOTAL_DELETIONS))

  echo "   üìä Total changes: +$TOTAL_ADDITIONS -$TOTAL_DELETIONS (total: $TOTAL_CHANGES lines)"

  # Warn if commit is suspiciously large
  if [[ $TOTAL_CHANGES -gt 100000 ]]; then
    echo "   ‚ö†Ô∏è  WARNING: Very large commit detected ($TOTAL_CHANGES lines)!"
    echo "   This may include unwanted files like node_modules or build artifacts"
  fi

  # Check for commonly ignored files that shouldn't be committed
  PROBLEMATIC_FILES=$(git diff --name-only "$BASE_BRANCH"..."$CURRENT_BRANCH" | grep -E "(node_modules/|\.next/|dist/|build/|target/debug/|\.pyc$|__pycache__/)" || echo "")

  if [[ -n "$PROBLEMATIC_FILES" ]]; then
    echo "   ‚ùå ERROR: Detected files that should be gitignored!"
    echo "$PROBLEMATIC_FILES" | head -10 | sed 's/^/      /'
    if [[ $(echo "$PROBLEMATIC_FILES" | wc -l) -gt 10 ]]; then
      echo "      ... and $(($(echo "$PROBLEMATIC_FILES" | wc -l) - 10)) more"
    fi
    echo ""
    echo "   üõë BLOCKING PR CREATION"
    echo "   Please add a .gitignore file and remove these files from git"
    echo "   Suggested .gitignore entries:"
    echo "      node_modules/"
    echo "      dist/"
    echo "      build/"
    echo "      target/debug/"
    echo "      __pycache__/"
    return 1
  fi

  # Check file count
  FILE_COUNT=$(git diff --name-only "$BASE_BRANCH"..."$CURRENT_BRANCH" | wc -l)
  echo "   üìÅ Files changed: $FILE_COUNT"

  if [[ $FILE_COUNT -gt 100 ]]; then
    echo "   ‚ö†Ô∏è  WARNING: Large number of files changed ($FILE_COUNT)"
    echo "   Verify this is intentional and not due to dependency/build commits"
  fi

  echo "   ‚úÖ Validation passed"

  # Find the GitHub issue for this task (created by Morgan PM)
  ISSUE_NUMBER=$(gh issue list -R "$REPO_SLUG" --label "task-{{task_id}}" --json number --jq '.[0].number' 2>/dev/null || echo "")

  ISSUE_LINK=""
  if [ -n "$ISSUE_NUMBER" ]; then
    echo "üîó Found GitHub issue #$ISSUE_NUMBER for task {{task_id}}"
    ISSUE_LINK="Closes #$ISSUE_NUMBER"
  fi

  PR_TITLE="feat({{service}}): complete task {{task_id}}"
  read -r -d '' PR_BODY <<EOF || true
## Summary
- Auto-generated fallback PR because the Factory agent finished without opening one
- Task {{task_id}} for service {{service}} is ready for review

## Metadata
- Agent: {{github_app}}
- Workflow: {{workflow_name}}
- Branch: \`$CURRENT_BRANCH\` ‚Üí \`$BASE_BRANCH\`
${ISSUE_LINK:+
## Links
$ISSUE_LINK
}
_This PR was created automatically by the Factory container._
EOF

  LABEL_ARGS=("--title" "$PR_TITLE" "--body" "$PR_BODY" "--base" "$BASE_BRANCH" "--head" "$CURRENT_BRANCH")

  maybe_add_label() {
    local label="$1"
    if [ -z "$label" ]; then
      return
    fi
    if gh label view "$label" -R "$REPO_SLUG" >/dev/null 2>&1; then
      LABEL_ARGS+=("--label" "$label")
    else
      echo "‚ö†Ô∏è Label '$label' not found; skipping"
    fi
  }

  maybe_add_label "$TASK_LABEL"
  maybe_add_label "$SERVICE_LABEL"
  maybe_add_label "$RUN_LABEL"

  # Note: Critical guards (PR_NUMBER and WORKFLOW_STAGE checks) are now at the top of this function
  # to prevent duplicate PRs before any PR creation setup occurs

  if gh pr create "${LABEL_ARGS[@]}" 2>&1; then
    echo "‚úÖ Auto-created pull request for $CURRENT_BRANCH"

    # Add PR to GitHub Project (works for all CLIs: Claude, Codex, Cursor, Factory, OpenCode, Blaze, Rex)
    echo "=== Linking PR to GitHub Project ==="

    # Get PR number for this branch
    PR_NUMBER=$(gh pr list --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")

    if [ -n "$PR_NUMBER" ]; then
      # Use organization project number 1 (Task Master / CTO Project)
      # This works across all repos and agents
      PROJECT_NUMBER="1"

      echo "üîó Adding PR #$PR_NUMBER to Project #$PROJECT_NUMBER..."

      # Use gh project item-add command (simpler than GraphQL)
      if gh project item-add "$PROJECT_NUMBER" --owner 5dlabs --url "https://github.com/$REPO_SLUG/pull/$PR_NUMBER" 2>&1 | grep -q "Added\|already"; then
        echo "‚úÖ PR linked to GitHub Project #$PROJECT_NUMBER"
      else
        echo "‚ö†Ô∏è Could not link PR to project (may already be linked or permissions issue)"
      fi
    else
      echo "‚ö†Ô∏è Could not get PR number for project linking"
    fi
  else
    PR_CREATE_EXIT=$?
    echo "‚ö†Ô∏è Failed to create pull request automatically (exit code: $PR_CREATE_EXIT)"
    echo "   Possible reasons:"
    echo "   - PR already exists for this branch (even if closed)"
    echo "   - Authentication failed"
    echo "   - Branch has no commits ahead of base"
    echo "   - Network/API issues"
    # Don't fail the workflow - PR creation is best-effort
    return 0
  fi
}

git config --global --add safe.directory "$TASK_WORKSPACE"

derive_bot_identity() {
  local app_name="$1"

  if [ -z "$app_name" ] || [ "$app_name" = "null" ]; then
    GIT_AUTHOR_NAME="automation[bot]"
    GIT_AUTHOR_EMAIL="automation[bot]@users.noreply.github.com"
    return
  fi

  local slug
  slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-+|-+$//g')
  if [ -z "$slug" ]; then
    slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]')
  fi

  local bot_login="${slug}[bot]"
  local bot_email="${bot_login}@users.noreply.github.com"

  if [ -n "${GITHUB_TOKEN:-}" ]; then
    local encoded_login
    encoded_login=$(printf '%s' "$bot_login" | sed 's/\[/%5B/g; s/\]/%5D/g')
    local bot_response
    bot_response=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/users/${encoded_login}" 2>/dev/null || true)
    local bot_id
    bot_id=$(printf '%s' "$bot_response" | jq -r '.id // empty' 2>/dev/null || echo '')
    if [ -n "$bot_id" ]; then
      bot_email="${bot_id}+${bot_login}@users.noreply.github.com"
    fi
  fi

  GIT_AUTHOR_NAME="$bot_login"
  GIT_AUTHOR_EMAIL="$bot_email"
}

GITHUB_APP="{{github_app}}"
derive_bot_identity "$GITHUB_APP"

# Extract agent name for display (e.g., "5DLabs-Rex" ‚Üí "Rex", "5DLabs-Cipher" ‚Üí "Cipher")
AGENT_NAME=$(echo "$GITHUB_APP" | sed -E 's/.*-([^-]+)$/\1/')

ensure_managed_paths_git_ignore() {
  if [ -z "${REPO_ROOT:-}" ]; then
    return
  fi

  local exclude_file="$REPO_ROOT/.git/info/exclude"
  mkdir -p "$(dirname "$exclude_file")"
  touch "$exclude_file"

  for managed_path in "$@"; do
    if git ls-files --error-unmatch -- "$managed_path" >/dev/null 2>&1; then
      continue
    fi

    local pattern="$managed_path"
    if [ -d "$REPO_ROOT/$pattern" ]; then
      pattern="${pattern%%/}/"
    fi

    case "$pattern" in
      task|task/)
        pattern="task/"
        ;;
      .factory|.factory/)
        pattern=".factory/"
        ;;
    esac

    if ! grep -Fxq "$pattern" "$exclude_file"; then
      echo "$pattern" >> "$exclude_file"
    fi
  done
}

git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"
export GIT_AUTHOR_NAME
export GIT_AUTHOR_EMAIL
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# =========================================================================
# Repository checkout
# =========================================================================

WORK_DIR="{{working_directory}}"
cd "$TASK_WORKSPACE"

REPO_ROOT="$TASK_WORKSPACE/$REPO_NAME"
git config --global --add safe.directory "$REPO_ROOT"

if [ -d "$REPO_NAME/.git" ]; then
  echo "üîÅ Repository already cloned, fetching latest"
  cd "$REPO_NAME"
  refresh_token_if_needed
  git fetch --all --prune
else
  echo "‚¨áÔ∏è  Cloning repository"
  refresh_token_if_needed
  git clone "$REPO_HTTP_URL"
  cd "$REPO_NAME"
fi

cd "$REPO_ROOT"
sync_gh_hosts_to_path "$REPO_ROOT"

echo "=== BRANCH SETUP ==="
# Remove stale automation-managed files that block branch checkout when rerunning
MANAGED_PATHS=(
  ".mcp.json"
  "AGENTS.md"
  "client-config.json"
  "coding-guidelines.md"
  "github-guidelines.md"
  ".factory"
  "task"
)

for managed_path in "${MANAGED_PATHS[@]}"; do
  if git ls-files --error-unmatch -- "$managed_path" >/dev/null 2>&1; then
    status_output=$(git status --short -- "$managed_path" 2>/dev/null || true)
    untracked=false
    while IFS= read -r line; do
      case "$line" in
        "?? "*)
          untracked=true
          break
          ;;
      esac
    done <<EOF
$status_output
EOF

    if [ "$untracked" = true ]; then
      echo "üßπ Removing stale untracked files to allow checkout: $managed_path"
      git clean -fd -- "$managed_path" >/dev/null 2>&1 || rm -rf "$managed_path"
    fi
    continue
  fi

  if [ -e "$managed_path" ]; then
    echo "üßπ Removing stale file to allow checkout: $managed_path"
    rm -rf "$managed_path"
  fi
done

ensure_managed_paths_git_ignore "${MANAGED_PATHS[@]}"

BASE_BRANCH="${PR_BASE_BRANCH:-main}"
REMOTE_BASE="origin/$BASE_BRANCH"

if ! git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
  # Fall back to origin/master or the remote HEAD if main is absent
  if git show-ref --verify --quiet "refs/remotes/origin/master"; then
    BASE_BRANCH="master"
    REMOTE_BASE="origin/$BASE_BRANCH"
  else
    DEFAULT_REMOTE=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    if [ -n "$DEFAULT_REMOTE" ]; then
      BASE_BRANCH="$DEFAULT_REMOTE"
      REMOTE_BASE="origin/$BASE_BRANCH"
    else
      REMOTE_BASE=""
    fi
  fi
fi

if [ -n "$BASE_BRANCH" ]; then
  git fetch origin "$BASE_BRANCH" >/dev/null 2>&1 || true
fi

# === BRANCH DERIVATION FROM PR_NUMBER ===
# If PR_NUMBER is provided, derive the branch from the PR to ensure consistency
FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
DERIVED_FROM_PR=false
if [ -n "${PR_NUMBER:-}" ] && command -v gh >/dev/null 2>&1; then
  echo "üîç Deriving branch from PR #${PR_NUMBER}..."
  DERIVED_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName' 2>/dev/null || echo "")
  if [ -n "$DERIVED_BRANCH" ]; then
    FEATURE_BRANCH="$DERIVED_BRANCH"
    DERIVED_FROM_PR=true
    echo "‚úÖ Using PR branch: $FEATURE_BRANCH (from PR #${PR_NUMBER})"
    # Fetch the branch from remote to ensure it exists locally
    echo "üì• Fetching branch $FEATURE_BRANCH from remote..."
    git fetch origin "$FEATURE_BRANCH:$FEATURE_BRANCH" 2>/dev/null || git fetch origin "$FEATURE_BRANCH" 2>/dev/null || true
  else
    echo "‚ö†Ô∏è Could not derive branch from PR #${PR_NUMBER}; using default"
  fi
fi
if git show-ref --verify --quiet "refs/heads/$FEATURE_BRANCH"; then
  echo "Feature branch '$FEATURE_BRANCH' exists, checking out..."

  # Check for and abort any in-progress merge conflicts before checkout
  if git status --porcelain 2>/dev/null | grep -q "^UU\|^AA\|^DD\|^..U\|^U..\|^DD\|^AU\|^UA\|^DU\|^UD"; then
    echo "‚ö†Ô∏è Detecting unresolved merge conflicts, aborting merge..."
    git merge --abort 2>/dev/null || true
    echo "‚úì Merge conflicts aborted"
  fi

  # Check for and reset any incomplete merge (rebase, cherry-pick, etc.)
  if [ -f ".git/REBASE_HEAD" ] || [ -f ".git/CHERRY_PICK_HEAD" ] || [ -f ".git/MERGE_HEAD" ]; then
    echo "‚ö†Ô∏è Detecting incomplete git operation, resetting..."
    # Try to abort the operation safely
    git rebase --abort 2>/dev/null || true
    git cherry-pick --abort 2>/dev/null || true
    git merge --abort 2>/dev/null || true
    # If abort failed, reset hard to last good state
    if ! git diff-index --quiet HEAD; then
      git reset --hard HEAD 2>/dev/null || true
    fi
    echo "‚úì Git operations reset"
  fi

  # Clean up any local changes from previous runs to avoid checkout conflicts
  # Preserve task/ directory since it was just copied
  if ! git diff-index --quiet HEAD -- || [ -n "$(git ls-files --others --exclude-standard)" ]; then
    echo "üîÑ Cleaning workspace before checkout (preserving task/ directory)"

    # Use unique backup name to avoid PID collisions (PID + timestamp + random)
    BACKUP_DIR="/tmp/task-backup-$$-$(date +%s)-$RANDOM"

    # Save task/ directory if it exists
    if [ -d "task" ]; then
      echo "üì¶ Backing up task/ directory to $BACKUP_DIR"

      # Copy with verification - fail if backup fails
      if ! cp -r task "$BACKUP_DIR" 2>/dev/null; then
        echo "‚ùå CRITICAL: Failed to backup task/ directory!"
        echo "   Aborting workspace cleanup to prevent data loss"
        exit 1
      fi

      # Verify backup succeeded
      if [ ! -d "$BACKUP_DIR" ] || [ -z "$(ls -A "$BACKUP_DIR" 2>/dev/null)" ]; then
        echo "‚ùå CRITICAL: Backup verification failed - directory empty or missing!"
        echo "   Aborting to prevent data loss"
        rm -rf "$BACKUP_DIR" 2>/dev/null || true
        exit 1
      fi

      echo "‚úÖ Backup verified: $(du -sh "$BACKUP_DIR" 2>/dev/null | cut -f1) in $BACKUP_DIR"
    fi

    # NOW safe to wipe workspace (backup verified)
    echo "üßπ Resetting workspace (backup secured)"
    git reset --hard HEAD 2>/dev/null || true
    git clean -fdx -e task/ 2>/dev/null || true

    # Restore task/ directory from verified backup
    if [ -d "$BACKUP_DIR" ]; then
      echo "üì¶ Restoring task/ directory from backup"
      rm -rf task 2>/dev/null || true

      if ! cp -r "$BACKUP_DIR" task 2>/dev/null; then
        echo "‚ùå CRITICAL: Failed to restore task/ directory!"
        echo "   Backup is at: $BACKUP_DIR (preserved for manual recovery)"
        exit 1
      fi

      # Verify restore
      if [ ! -d "task" ]; then
        echo "‚ùå CRITICAL: Restore verification failed!"
        echo "   Backup preserved at: $BACKUP_DIR"
        exit 1
      fi

      # Cleanup backup only after successful restore
      rm -rf "$BACKUP_DIR" 2>/dev/null || true
      echo "‚úÖ Task directory restored successfully"
    fi

    echo "‚úÖ Workspace cleaned and task/ preserved"
  fi

  # Now checkout should work
  git checkout "$FEATURE_BRANCH"

  # Check if upstream branch is gone (deleted after previous PR was closed)
  UPSTREAM_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")
  if [ -n "$UPSTREAM_BRANCH" ]; then
    if ! git show-ref --verify --quiet "refs/remotes/$UPSTREAM_BRANCH"; then
      echo "‚ö†Ô∏è Upstream branch $UPSTREAM_BRANCH is gone (deleted from remote)"
      echo "üîç Checking for closed PRs from previous runs..."

      # Check if there's a CLOSED PR for this branch
      refresh_token_if_needed || true
      CLOSED_PR=$(gh pr list --state closed --head "$FEATURE_BRANCH" --json number --limit 1 2>/dev/null | jq -r '.[0].number // empty')

      if [ -n "$CLOSED_PR" ]; then
        echo "‚úÖ Found CLOSED PR #$CLOSED_PR from previous run"
        echo "üîÑ Deleting stale branch and recreating fresh from $REMOTE_BASE"

        # Switch off the branch before deleting it
        git checkout "$REMOTE_BASE" 2>/dev/null || git checkout -b temp-cleanup-branch "$REMOTE_BASE"
        git branch -D "$FEATURE_BRANCH" 2>/dev/null || true

        # Recreate fresh branch
        git checkout -b "$FEATURE_BRANCH" "$REMOTE_BASE"
        echo "‚úÖ Created fresh branch $FEATURE_BRANCH from $REMOTE_BASE"
        echo "‚ÑπÔ∏è Previous PR was closed - starting with clean slate"
      else
        echo "‚ÑπÔ∏è No closed PRs found - will unset upstream and continue"
        git branch --unset-upstream 2>/dev/null || true
      fi
    fi
  fi

  if [ -n "$REMOTE_BASE" ]; then
    echo "üì• Fast-forwarding $FEATURE_BRANCH with $REMOTE_BASE"
    if ! git merge "$REMOTE_BASE" --ff-only >/dev/null 2>&1; then
      # Skip timestamped fallback if PR_NUMBER is provided - stay on the PR branch
      if [ -n "${PR_NUMBER:-}" ]; then
        echo "‚ö†Ô∏è Unable to fast-forward $FEATURE_BRANCH but PR_NUMBER is set; staying on PR branch"
        echo "‚ÑπÔ∏è Manual conflict resolution may be needed"
      else
        # Check if PR exists for this branch before creating timestamped fallback
        echo "‚ö†Ô∏è Unable to fast-forward $FEATURE_BRANCH; checking for existing PR"
        refresh_token_if_needed || true
        EXISTING_PR=$(gh pr list --state open --head "$FEATURE_BRANCH" --json number --limit 1 2>/dev/null | jq -r '.[0].number // empty')

        if [ -n "$EXISTING_PR" ]; then
          echo "‚úÖ Found existing PR #$EXISTING_PR for branch $FEATURE_BRANCH"
          echo "‚ÑπÔ∏è Continuing with this branch despite merge conflict (will be resolved in PR)"
          # Stay on the current branch and let the PR handle conflicts
        else
          echo "‚ÑπÔ∏è No existing PR found; recreating branch from $REMOTE_BASE"
          # Delete local branch and recreate fresh from base
          # Force discard all local changes since we're recreating from scratch
          git reset --hard HEAD 2>/dev/null || true
          git clean -fd 2>/dev/null || true
          git checkout -f "$REMOTE_BASE" 2>/dev/null || git checkout -b temp-branch "$REMOTE_BASE"
          git branch -D "$FEATURE_BRANCH" 2>/dev/null || true
          git checkout -b "$FEATURE_BRANCH" "$REMOTE_BASE"
          echo "‚úÖ Recreated $FEATURE_BRANCH from $REMOTE_BASE"
        fi
      fi
    fi
  fi
else
  echo "Creating new feature branch '$FEATURE_BRANCH'"

  # Check for and abort any in-progress merge conflicts before checkout
  if git status --porcelain 2>/dev/null | grep -q "^UU\|^AA\|^DD\|^..U\|^U..\|^DD\|^AU\|^UA\|^DU\|^UD"; then
    echo "‚ö†Ô∏è Detecting unresolved merge conflicts, aborting merge..."
    git merge --abort 2>/dev/null || true
    echo "‚úì Merge conflicts aborted"
  fi

  # Check for and reset any incomplete merge (rebase, cherry-pick, etc.)
  if [ -f ".git/REBASE_HEAD" ] || [ -f ".git/CHERRY_PICK_HEAD" ] || [ -f ".git/MERGE_HEAD" ]; then
    echo "‚ö†Ô∏è Detecting incomplete git operation, resetting..."
    # Try to abort the operation safely
    git rebase --abort 2>/dev/null || true
    git cherry-pick --abort 2>/dev/null || true
    git merge --abort 2>/dev/null || true
    # If abort failed, reset hard to last good state
    if ! git diff-index --quiet HEAD; then
      git reset --hard HEAD 2>/dev/null || true
    fi
    echo "‚úì Git operations reset"
  fi

  # Stash any local changes from previous runs to avoid checkout conflicts
  # Exclude task/ directory to preserve task files that were just copied
  if ! git diff-index --quiet HEAD -- || [ -n "$(git ls-files --others --exclude-standard)" ]; then
    echo "üîÑ Stashing local changes and untracked files (excluding task/) before creating new branch"
    git stash push --include-untracked -m "Auto-stash before new branch creation ($(date -u +%Y%m%d-%H%M%S))" -- . ':!task' || true
  fi

  if [ -n "$REMOTE_BASE" ] && git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
    git checkout -b "$FEATURE_BRANCH" "$REMOTE_BASE"
  else
    git checkout -b "$FEATURE_BRANCH"
  fi
fi

git config --local user.name "$GIT_AUTHOR_NAME"
git config --local user.email "$GIT_AUTHOR_EMAIL"
git config --local push.autoSetupRemote true
export IMPLEMENTATION_BRANCH="$FEATURE_BRANCH"
echo "‚úì Using feature branch: $FEATURE_BRANCH (base: ${BASE_BRANCH:-unknown})"

# Set working directory: use repo root if working_directory is "." or empty
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ] || [ "$WORK_DIR" = "null" ]; then
  FACTORY_WORK_DIR="$REPO_ROOT"
else
  FACTORY_WORK_DIR="$REPO_ROOT/$WORK_DIR"
  mkdir -p "$FACTORY_WORK_DIR"
fi

cd "$FACTORY_WORK_DIR"
sync_gh_hosts_to_path "$FACTORY_WORK_DIR"
echo "‚úì Working directory: $FACTORY_WORK_DIR"

echo "üì¶ git status"
refresh_token_if_needed
git status --short || true

# Load resilient task setup functions (mounted from shared ConfigMap)
source /agent-templates/shared_task-setup-functions.sh || {
    echo "‚ö†Ô∏è Warning: Resilient task functions not available, using basic operations"
    # Define minimal fallback functions
    safe_copy_file() { cp "$1" "$2" && echo "‚úì $3 copied" || echo "‚ùå $3 copy failed"; }
    safe_copy_directory() { cp -r "$1" "$2" && echo "‚úì $3 copied" || echo "‚ùå $3 copy failed"; }
    safe_ensure_directory() { mkdir -p "$1"; }
    verify_task_files() {
        if [ -f "$1/prompt.md" ]; then
            echo "‚úÖ Task files verified"
            return 0
        else
            echo "‚ùå Task files missing"
            return 1
        fi
    }
    create_error_report() { echo "‚ùå ERROR: $3"; }
    attempt_task_recovery() { echo "‚ùå Recovery not available"; return 1; }
}

# =========================================================================
# Materialise task context (RESILIENT MODE)
# =========================================================================

echo "üß± Syncing task assets (RESILIENT MODE)"
# Use safe directory creation to avoid overwriting files
if ! safe_ensure_directory "$FACTORY_WORK_DIR/task" "Factory task directory"; then
    echo "‚ùå CRITICAL: Cannot create Factory task directory"
    exit 1
fi
if ! safe_ensure_directory "$FACTORY_WORK_DIR/.factory" "Factory config directory"; then
    echo "‚ùå CRITICAL: Cannot create Factory config directory"
    exit 1
fi
safe_ensure_directory "$HOME/.factory" "Home Factory config directory"

# Safely copy task files from ConfigMap
if [ -d "/task-files/task" ]; then
    echo "üìÇ Copying task files from ConfigMap..."
    if ! safe_copy_directory "/task-files/task" "$FACTORY_WORK_DIR/task" "ConfigMap task files"; then
        echo "‚ö†Ô∏è Warning: Could not copy all task files from ConfigMap"
    fi
else
    echo "‚ÑπÔ∏è No task files in ConfigMap - will rely on docs repository"
fi

DOCS_REPO_URL="{{docs_repository_url}}"
DOCS_BRANCH="{{docs_branch}}"
DOCS_PROJECT_DIRECTORY="{{docs_project_directory}}"

if [ -n "$DOCS_REPO_URL" ] && [ "$DOCS_REPO_URL" != "null" ]; then
  refresh_token_if_needed
  if [ -z "$DOCS_BRANCH" ] || [ "$DOCS_BRANCH" = "null" ]; then
    DOCS_BRANCH="main"
  fi

  echo "üìö Syncing docs repository: $DOCS_REPO_URL (branch: $DOCS_BRANCH)"
  DOCS_CLONE_DIR="/tmp/docs-repo"
  rm -rf "$DOCS_CLONE_DIR"

  read DOCS_OWNER DOCS_NAME <<<"$(parse_repo "$DOCS_REPO_URL")"
  DOCS_HTTP_URL="https://github.com/${DOCS_OWNER}/${DOCS_NAME}.git"

  if git clone --quiet --branch "$DOCS_BRANCH" --single-branch "$DOCS_HTTP_URL" "$DOCS_CLONE_DIR"; then
    echo "‚úì Docs repository cloned"
  else
    echo "‚ö†Ô∏è Failed to clone docs branch '$DOCS_BRANCH'; attempting default branch"
    if git clone --quiet "$DOCS_HTTP_URL" "$DOCS_CLONE_DIR"; then
      echo "‚úì Docs repository cloned using default branch"
    else
      echo "‚ùå Unable to clone docs repository: $DOCS_HTTP_URL"
      DOCS_CLONE_DIR=""
    fi
  fi

  if [ -n "$DOCS_CLONE_DIR" ]; then
    # Handle docs_project_directory: empty/null/"." means look for .taskmaster at repo root
    # Otherwise, prepend the project directory path
    if [ -n "$DOCS_PROJECT_DIRECTORY" ] && [ "$DOCS_PROJECT_DIRECTORY" != "null" ] && [ "$DOCS_PROJECT_DIRECTORY" != "." ]; then
      DOCS_BASE_PATH="$DOCS_CLONE_DIR/$DOCS_PROJECT_DIRECTORY/.taskmaster"
    else
      DOCS_BASE_PATH="$DOCS_CLONE_DIR/.taskmaster"
    fi

    echo "üîç Docs base path: $DOCS_BASE_PATH"

    # Resilient task directory discovery - check regular, tasks/, and .completed locations
    # Check both regular location and .completed location (tasks moved after completion)
    TASK_DIR=""
    if [ -d "$DOCS_BASE_PATH/docs/task-{{task_id}}" ]; then
      TASK_DIR="$DOCS_BASE_PATH/docs/task-{{task_id}}"
      echo "‚úì Found task files in docs/ directory"
    elif [ -d "$DOCS_BASE_PATH/docs/.completed/task-{{task_id}}" ]; then
      TASK_DIR="$DOCS_BASE_PATH/docs/.completed/task-{{task_id}}"
      echo "‚úì Found task files in docs/.completed/ directory"
      echo "‚ÑπÔ∏è Task appears to be completed - using files from .completed folder"
    elif [ -d "$DOCS_BASE_PATH/tasks/task-{{task_id}}" ]; then
      TASK_DIR="$DOCS_BASE_PATH/tasks/task-{{task_id}}"
      echo "‚úì Found task files in tasks/ directory"
    fi

    if [ -n "$TASK_DIR" ] && [ -d "$TASK_DIR" ]; then
      echo "‚úì Copying task definition from $TASK_DIR (RESILIENT MODE)"
      refresh_token_if_needed
      if safe_copy_directory "$TASK_DIR" "$FACTORY_WORK_DIR/task" "docs task files"; then
          echo "‚úÖ Task files copied successfully from docs repository"
      else
          echo "‚ùå CRITICAL: Failed to copy task files from docs repository"
          create_error_report "$FACTORY_WORK_DIR/task" "{{task_id}}" "Failed to copy from docs repository"
      fi
    else
      echo "‚ùå CRITICAL: Task directory not found. Checked:"
      echo "   - $DOCS_BASE_PATH/docs/task-{{task_id}}"
      echo "   - $DOCS_BASE_PATH/docs/.completed/task-{{task_id}}"
      echo "   - $DOCS_BASE_PATH/tasks/task-{{task_id}}"
      create_error_report "$FACTORY_WORK_DIR/task" "{{task_id}}" "Task directory not found in docs repository"
    fi

    if [ -f "$DOCS_BASE_PATH/tasks.json" ]; then
      refresh_token_if_needed
      safe_copy_file "$DOCS_BASE_PATH/tasks.json" "$FACTORY_WORK_DIR/task/tasks.json" "tasks.json"
    fi
  fi
else
  echo "‚ö†Ô∏è Docs repository URL not provided; skipping task docs sync"
fi

if [ -f /task-files/AGENTS.md ]; then
  cp /task-files/AGENTS.md "$FACTORY_WORK_DIR/AGENTS.md"
fi

if [ -f /task-files/coding-guidelines.md ]; then
  cp /task-files/coding-guidelines.md "$FACTORY_WORK_DIR/"
  echo "‚úì Copied coding-guidelines.md to working directory"
fi

if [ -f /task-files/github-guidelines.md ]; then
  cp /task-files/github-guidelines.md "$FACTORY_WORK_DIR/"
  echo "‚úì Copied github-guidelines.md to working directory"
fi

if [ -f /task-files/client-config.json ]; then
  cp /task-files/client-config.json "$FACTORY_WORK_DIR/"
  echo "‚úì Copied client-config.json to working directory"
fi

if declare -F ensure_default_client_config >/dev/null 2>&1; then
  ensure_default_client_config "$FACTORY_WORK_DIR/client-config.json"
fi

if [ -f /task-files/mcp.json ]; then
  cp /task-files/mcp.json "$FACTORY_WORK_DIR/.mcp.json"
fi

if [ -f /task-files/factory-cli.json ]; then
  mkdir -p "$FACTORY_WORK_DIR/.factory"
  cp /task-files/factory-cli.json "$FACTORY_WORK_DIR/.factory/cli.json"
  echo "‚úì Installed project-level factory CLI permissions"
else
  echo "‚ö†Ô∏è factory-cli.json not provided; using default project permissions"
fi

if [ -f /task-files/factory-cli-config.json ]; then
  mkdir -p "$HOME/.factory"
  cp /task-files/factory-cli-config.json "$HOME/.factory/cli-config.json"
  echo "‚úì Installed global factory CLI config"
else
  echo "‚ö†Ô∏è factory-cli-config.json not provided; using existing global Factory config"
fi

if [ ! -f "$FACTORY_WORK_DIR/client-config.json" ]; then
  echo "‚ùå client-config.json missing from workspace; required for MCP/toolman"
  exit 1
fi

cp \$FACTORY_WORK_DIR/client-config.json "$TASK_WORKSPACE/client-config.json" 2>/dev/null || true 2>/dev/null || true

echo "=== MCP PRECHECKS ==="
if ! command -v toolman >/dev/null 2>&1; then
  echo "‚ùå 'toolman' CLI not found in PATH; required for MCP"
  exit 1
fi

TOOLMAN_URL=${TOOLMAN_SERVER_URL:-"http://toolman.agent-platform.svc.cluster.local:3000/mcp"}
TOOLMAN_URL="${TOOLMAN_URL%/}"
echo "üîç Checking Toolman endpoint: $TOOLMAN_URL"
TOOLMAN_RETRIES=3
TOOLMAN_WAIT=2
TOOLMAN_SUCCESS=false
for i in $(seq 1 $TOOLMAN_RETRIES); do
  if curl -sSf --connect-timeout 5 --max-time 10 \
    -X POST "$TOOLMAN_URL" \
    -H 'Content-Type: application/json' \
    -d '{"jsonrpc":"2.0","id":"health","method":"tools/list","params":{}}' >/tmp/toolman-ping.log 2>&1; then
    TOOLMAN_SUCCESS=true
    rm -f /tmp/toolman-ping.log
    break
  fi
  if [ $i -lt $TOOLMAN_RETRIES ]; then
    echo "‚ö†Ô∏è Toolman connectivity check failed (attempt $i/$TOOLMAN_RETRIES), retrying in ${TOOLMAN_WAIT}s..."
    cat /tmp/toolman-ping.log >&2 || true
    rm -f /tmp/toolman-ping.log
    sleep $TOOLMAN_WAIT
    TOOLMAN_WAIT=$((TOOLMAN_WAIT * 2))  # Exponential backoff
  fi
done

if [ "$TOOLMAN_SUCCESS" != "true" ]; then
  echo "‚ùå Unable to reach Toolman server at $TOOLMAN_URL after $TOOLMAN_RETRIES attempts"
  cat /tmp/toolman-ping.log >&2 || true
  rm -f /tmp/toolman-ping.log
  echo "‚ö†Ô∏è This may be an intermittent DNS/network issue. Proceeding anyway, but MCP tools may not work."
  echo "‚ö†Ô∏è If Factory execution fails, check Toolman service health and DNS resolution."
  # Don't exit - allow Factory to proceed in case Toolman comes back online
  # The MCP client will handle connection failures gracefully
fi
echo "‚úì Toolman endpoint check completed"

if command -v jq >/dev/null 2>&1; then
  echo "[client-config] summary:"
  if ! jq -r '"remoteTools=" + ((.remoteTools // []) | length | tostring) + ", localServers=" + ((.localServers // {} | keys) | join(","))' "$FACTORY_WORK_DIR/client-config.json" 2>/dev/null; then
    echo "  (not valid JSON)"
  fi
else
  echo "‚ö†Ô∏è jq not available; skipping client-config summary"
fi

# =========================================================================
# TOOL VERIFICATION (Debug Mode - Remove after Context7 is stable)
# =========================================================================
echo ""
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "‚ïë                    TOOL VERIFICATION                          ‚ïë"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

TOOL_VERIFICATION_FAILED=false

# Verify Context7 is available (if configured as local server)
if grep -q '"context7"' "$FACTORY_WORK_DIR/client-config.json" 2>/dev/null; then
  echo "üîç Context7 configured - verifying availability..."
  
  # Check API key
  if [ -n "${CONTEXT7_API_KEY:-}" ]; then
    echo "  ‚úì CONTEXT7_API_KEY is set"
  else
    echo "  ‚ùå CONTEXT7_API_KEY is missing"
    TOOL_VERIFICATION_FAILED=true
  fi
  
  # Check npx is available
  if command -v npx >/dev/null 2>&1; then
    echo "  ‚úì npx is available"
  else
    echo "  ‚ùå npx not found (required for Context7)"
    TOOL_VERIFICATION_FAILED=true
  fi
  
  # Test Context7 package can be loaded
  if timeout 10 npx -y @upstash/context7-mcp --help >/dev/null 2>&1; then
    echo "  ‚úì Context7 package can be loaded"
  else
    echo "  ‚ö†Ô∏è Context7 package test timed out or failed (may work at runtime)"
  fi
else
  echo "‚ÑπÔ∏è Context7 not configured in client-config.json"
fi

# Verify Toolman connectivity (already checked above, just summarize)
if [ "$TOOLMAN_SUCCESS" = "true" ]; then
  echo "‚úì Toolman connectivity verified"
else
  echo "‚ö†Ô∏è Toolman connectivity check failed (proceeding anyway)"
fi

# Use droid --list-tools to verify MCP tools are available
echo ""
echo "üîç Verifying Factory MCP tools..."
if command -v droid >/dev/null 2>&1; then
  TOOL_LIST=$(droid exec --list-tools 2>&1 || echo "FAILED")
  
  # Check for critical tools based on agent role
  {{#if (eq agent_name "rex")}}
  # Rex needs: Context7, GitHub, Brave Search
  REQUIRED_TOOLS=("Read" "Edit" "Execute")
  {{else if (eq agent_name "blaze")}}
  # Blaze needs: Context7, shadcn, GitHub
  REQUIRED_TOOLS=("Read" "Edit" "Execute")
  {{else if (eq agent_name "cleo")}}
  # Cleo needs: Context7, GitHub
  REQUIRED_TOOLS=("Read" "Execute")
  {{else if (eq agent_name "tess")}}
  # Tess needs: Context7, Kubernetes, GitHub
  REQUIRED_TOOLS=("Read" "Execute")
  {{else}}
  # Default: Basic tools
  REQUIRED_TOOLS=("Read" "Execute")
  {{/if}}
  
  for tool in "${REQUIRED_TOOLS[@]}"; do
    if echo "$TOOL_LIST" | grep -q "$tool"; then
      echo "  ‚úì $tool tool available"
    else
      echo "  ‚ùå $tool tool NOT available"
      TOOL_VERIFICATION_FAILED=true
    fi
  done
  
  # Show tool count
  TOOL_COUNT=$(echo "$TOOL_LIST" | grep -c "status:" || echo "0")
  echo "  üìä Total tools available: $TOOL_COUNT"
  
  # List all available tools for verification
  echo ""
  echo "üìã Available Tools:"
  echo "$TOOL_LIST" | grep -E "^\s+‚Ä¢" | sed 's/^/  /'
  echo ""
else
  echo "  ‚ö†Ô∏è droid CLI not available for tool verification"
fi

echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

if [ "$TOOL_VERIFICATION_FAILED" = "true" ]; then
  echo ""
  echo "‚ùå TOOL VERIFICATION FAILED"
  echo "Critical tools are not available. Cannot proceed with task."
  echo ""
  echo "Common issues:"
  echo "  - CONTEXT7_API_KEY not set (check secret mounting)"
  echo "  - MCP servers not initialized properly"
  echo "  - client-config.json misconfigured"
  echo ""
  echo "Full tool list:"
  droid exec --list-tools 2>&1 || echo "Failed to list tools"
  echo ""
  exit 1
fi

echo "‚úÖ All critical tools verified successfully"
echo ""
# =========================================================================

if [ -z "${FACTORY_API_KEY:-}" ]; then
  echo "‚ùå FACTORY_API_KEY is not set; Factory cannot authenticate"
  exit 1
fi

echo "üîë Using provided FACTORY_API_KEY for authentication"

if [ ! -f "$FACTORY_WORK_DIR/AGENTS.md" ]; then
  echo "‚ö†Ô∏è AGENTS.md missing; creating placeholder"
  cat <<'PLACEHOLDER' > "$FACTORY_WORK_DIR/AGENTS.md"
# Project Guidance

This Factory run was triggered without AGENTS.md content. Provide project context in AGENTS.md to give Factory richer instructions.
PLACEHOLDER
fi

# =========================================================================
# Prompt assembly and Factory execution
# =========================================================================

PROMPT_PREFIX=""
if declare -F ensure_default_toolman_guide >/dev/null 2>&1; then
  ensure_default_toolman_guide "$FACTORY_WORK_DIR/task" "{{task_id}}" "{{service}}"
fi

if [ -f "$FACTORY_WORK_DIR/task/toolman-guide.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}üîß **CRITICAL: Tool Usage Reference**\n\n$(cat "$FACTORY_WORK_DIR/task/toolman-guide.md")\n\n---\n\n"
fi

PR_STAGE="${WORKFLOW_STAGE:-implementation}"
if [ "$PR_STAGE" = "implementation" ]; then
  PR_DIRECTIVE="- **Documentation & PR**: update project docs and open a PR via \`gh pr create\` with labels task-{{task_id}}, service-{{service}}, and run-{{workflow_name}}."
else
  PR_DIRECTIVE="- **Documentation & PR**: update project docs and push commits to the existing PR branch. Implementation agents already created the PR, so never run \`gh pr create\`; focus on reviews and fixes."
fi

PROMPT_PREFIX="${PROMPT_PREFIX}‚ö†Ô∏è **EXECUTION REQUIREMENTS (MANDATORY)**\n\n- **Follow patterns**: reference @coding-guidelines.md and @github-guidelines.md in this workspace.\n- **No mocks or stubs**: integrate with live services, APIs, and configuration; remove all placeholders.\n- **Parameterize everything**: every endpoint, threshold, or trading pair must come from env vars, config, or CLI flags.\n- **GitHub auth ready**: the GitHub App token (\`GH_TOKEN\`) is already configured; skip manual \`gh auth login\` flows and avoid hitting user-only endpoints like \`/user\`.\n- **Feature branch only**: stay on \`feature/task-{{task_id}}-implementation\`; never push directly to main/master or retarget the branch upstream.\n- **Execute without pause**: if you outline a plan, immediately carry it out‚Äîdo not wait for confirmation or additional input.\n- **Quality gates**: run \`cargo fmt --all -- --check\`, \`cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic\`, and \`cargo test --workspace --all-features\` before declaring success.\n${PR_DIRECTIVE}\n- **Preserve workspace**: never delete the repository or run destructive cleanup commands (for example \`rm -rf\`); leave artifacts in place for QA.\n\n---\n\n"

if [ -f "$FACTORY_WORK_DIR/github-guidelines.md" ] || [ -f "$FACTORY_WORK_DIR/coding-guidelines.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}üìö **Reference Materials Available**\n"
  if [ -f "$FACTORY_WORK_DIR/github-guidelines.md" ]; then
    PROMPT_PREFIX="${PROMPT_PREFIX}- @github-guidelines.md\n"
  fi
  if [ -f "$FACTORY_WORK_DIR/coding-guidelines.md" ]; then
    PROMPT_PREFIX="${PROMPT_PREFIX}- @coding-guidelines.md\n"
  fi
  PROMPT_PREFIX="${PROMPT_PREFIX}\n---\n\n"
fi

if [ -f "$FACTORY_WORK_DIR/AGENTS.md" ]; then
  if AGENT_GUIDANCE=$(jq -Rs @json "$FACTORY_WORK_DIR/AGENTS.md" 2>/dev/null); then
    if [ "${#AGENT_GUIDANCE}" -gt 2 ]; then
      AGENT_GUIDANCE=${AGENT_GUIDANCE:1:-1}
      PROMPT_PREFIX="${PROMPT_PREFIX}üß† **Agent Guidance**\n\n${AGENT_GUIDANCE}\n\n---\n\n"
    fi
  fi
fi

# Resilient verification of task files
echo "üîç RESILIENT VERIFICATION: Checking task files at: $FACTORY_WORK_DIR/task/"
if verify_task_files "$FACTORY_WORK_DIR/task" "{{task_id}}"; then
    echo "‚úÖ Task files verification: PASSED"
else
    echo "‚ùå CRITICAL: Task files verification: FAILED"
    create_error_report "$FACTORY_WORK_DIR/task" "{{task_id}}" "Task files missing before agent execution"

    # Attempt recovery
    if attempt_task_recovery "/tmp/docs-repo" "$FACTORY_WORK_DIR/task" "{{task_id}}"; then
        echo "‚úÖ Recovery successful - continuing with execution"
    else
        echo "‚ùå Recovery failed - cannot proceed without prompt.md"
        exit 1
    fi
fi

PROMPT_FILE="$FACTORY_WORK_DIR/task/prompt.md"
echo "üìÑ Using prompt file: $PROMPT_FILE"

echo "startingTask:{{task_id}}"
echo ""

if [ ! -f "$PROMPT_FILE" ]; then
  echo "‚ùå Prompt file not found: $PROMPT_FILE"
  exit 1
fi

PROMPT_CONTENT="${PROMPT_PREFIX}$(cat "$PROMPT_FILE" 2>&1)" || {
  echo "‚ùå Failed to read prompt file: $PROMPT_FILE"
  exit 1
}

PROMPT_BYTES=${#PROMPT_CONTENT}
echo "üìè Prompt size: $PROMPT_BYTES bytes"

if [ "$PROMPT_BYTES" -eq 0 ]; then
  echo "‚ùå Prompt content is empty!"
  exit 1
fi

echo "üßæ Resolved prompt content (first 500 chars):"
# Use parameter expansion instead of pipe to avoid set -e issues
PROMPT_PREVIEW="${PROMPT_CONTENT:0:500}"
printf '%s\n' "$PROMPT_PREVIEW"
echo "..."

MAX_RETRIES=${FACTORY_MAX_RETRIES:-${EXECUTION_MAX_RETRIES:-10}}
ATTEMPT=1
SUCCESS=0
FACTORY_EXIT=1
LAST_MESSAGE_FILE=""
RUN_LOG=""
LAST_COMPLETION_REASON=""

if [ "$MAX_RETRIES" = "0" ]; then
  echo "üîÑ Unlimited retries enabled - Factory will continue until completion criteria are met"
  UNLIMITED_RETRIES=1
else
  UNLIMITED_RETRIES=0
fi

print_attempt_banner() {
  local attempt="$1"
  local max="$2"
  local unlimited="$3"
  local border="‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  local label

  if [ "$unlimited" = "1" ]; then
    label="‚ïë üöÄ EXECUTION ATTEMPT #${attempt} (UNLIMITED MODE)"
  elif [ -n "$max" ] && [ "$max" -gt 0 ]; then
    label="‚ïë üöÄ EXECUTION ATTEMPT ${attempt} / ${max}"
  else
    label="‚ïë üöÄ EXECUTION ATTEMPT #${attempt}"
  fi

  local base_padding=$(( ${#border} - ${#label} - 1 ))
  local extra_width=0

  if [[ "$label" == *"üöÄ"* ]]; then
    extra_width=$((extra_width + 1))
  fi

  local padding=$((base_padding - extra_width))
  if [ $padding -lt 0 ]; then
    padding=0
  fi

  echo ""
  echo "$border"
  printf '%s%*s‚ïë\n' "$label" "$padding" ""
  echo "$border"
  echo ""
}

# Circuit breaker: track repeated command failures
declare -A FAILED_COMMANDS
MAX_SAME_COMMAND_FAILURES=3

FORCE_WRITES="{{#if force_writes}}true{{else}}false{{/if}}"
OUTPUT_FORMAT="{{#if output_format}}{{output_format}}{{else}}text{{/if}}"
OUTPUT_FORMAT="${OUTPUT_FORMAT,,}"

AUTO_LEVEL="{{#if auto_level}}{{auto_level}}{{else}}high{{/if}}"
AUTO_LEVEL="${AUTO_LEVEL,,}"
REASONING_EFFORT="{{#if reasoning_effort}}{{reasoning_effort}}{{/if}}"
REASONING_EFFORT="${REASONING_EFFORT,,}"
DEFAULT_MODEL="{{model}}"
MODEL_ROTATION=()
MODEL_ROTATION_COUNT=0
{{#if model_rotation}}
MODEL_ROTATION=(
{{#each model_rotation}}
"{{this}}"
{{/each}}
)
MODEL_ROTATION_COUNT=${#MODEL_ROTATION[@]}
if [ $MODEL_ROTATION_COUNT -gt 0 ]; then
  echo "üéØ Model rotation enabled (${MODEL_ROTATION_COUNT} models): ${MODEL_ROTATION[*]}"
fi
{{/if}}
if [ -z "$DEFAULT_MODEL" ] && [ $MODEL_ROTATION_COUNT -gt 0 ]; then
  DEFAULT_MODEL="${MODEL_ROTATION[0]}"
fi
if [ -n "$DEFAULT_MODEL" ]; then
  echo "üéØ Default model: $DEFAULT_MODEL"
fi
LIST_TOOLS_ON_START="{{#if list_tools_on_start}}{{list_tools_on_start}}{{else}}false{{/if}}"
if [ -z "$LIST_TOOLS_ON_START" ]; then
  LIST_TOOLS_ON_START="false"
fi
LIST_TOOLS_ON_START="${LIST_TOOLS_ON_START,,}"
if [ "${FORCE_WRITES,,}" = "true" ]; then
  AUTO_LEVEL="high"
fi

SKIP_PERMISSIONS_UNSAFE="{{#if skip_permissions_unsafe}}{{skip_permissions_unsafe}}{{else}}true{{/if}}"
SKIP_PERMISSIONS_UNSAFE="${SKIP_PERMISSIONS_UNSAFE,,}"

if [ "$LIST_TOOLS_ON_START" = "true" ]; then
  echo "üß∞ Listing available Droid tools before execution"
  LIST_CMD=("droid" "exec" "--list-tools" "--output-format" "$OUTPUT_FORMAT")
  if [ -n "$DEFAULT_MODEL" ]; then
    LIST_CMD+=("--model" "$DEFAULT_MODEL")
  fi
  if [ -n "$REASONING_EFFORT" ]; then
    LIST_CMD+=("--reasoning-effort" "$REASONING_EFFORT")
  fi
  echo "üîç Running: ${LIST_CMD[*]}"
  set +e
  "${LIST_CMD[@]}"
  LIST_EXIT=$?
  set -e
  if [ $LIST_EXIT -ne 0 ]; then
    echo "‚ö†Ô∏è Tool listing command exited with status $LIST_EXIT"
  fi
  echo ""
fi

# =========================================================================
# QA Mode Safeguard: Prevent PR creation when in testing mode
# =========================================================================
if [ "${WORKFLOW_STAGE:-implementation}" != "implementation" ]; then
  echo "üõ°Ô∏è  Installing PR creation safeguard for ${WORKFLOW_STAGE:-unknown} stage"

  block_pr_create_stage="${WORKFLOW_STAGE:-unknown}"
  case "$block_pr_create_stage" in
    "quality"|"quality-in-progress")
      block_reason="Cleo reviews existing PRs. You're working on PR #${PR_NUMBER:-unknown}, so never create a new one."
      ;;
    "security"|"security-in-progress")
      block_reason="Cipher performs security scans on the implementation PR. Creating a new PR would bypass Rex/Blaze ownership."
      ;;
    "testing"|"testing-in-progress")
      block_reason="Tess is in QA review mode and must validate PR #${PR_NUMBER:-unknown}; PR creation is forbidden."
      ;;
    *)
      block_reason="Non-implementation stages must only review the branch created by Rex/Blaze. Do not open new PRs."
      ;;
  esac

  gh() {
    if [[ "$1" == "pr" && "$2" == "create" ]]; then
      echo "‚ùå ERROR: 'gh pr create' is blocked for ${block_pr_create_stage:-non-implementation} stage."
      echo "‚ùå ${block_reason}"
      echo "‚ùå Use review commands such as 'gh pr checkout ${PR_NUMBER:-...}' or 'gh pr review ${PR_NUMBER:-...}' instead."
      return 1
    fi
    command gh "$@"
  }
  export -f gh

  echo "‚úÖ Safeguard installed: 'gh pr create' is now blocked for ${WORKFLOW_STAGE:-non-implementation} stage"
fi

# Clean up any leftover completion markers from previous runs (agent-specific)
# This prevents issues with sequential task executions on the same PVC
if [[ "{{github_app}}" =~ [Rr]ex ]] && [ -f /workspace/.rex-complete ]; then
    echo "üßπ Rex cleaning up completion marker from previous run"
    rm -f /workspace/.rex-complete
elif [[ "{{github_app}}" =~ [Cc]leo ]] && [ -f /workspace/.cleo-complete ]; then
    echo "üßπ Cleo cleaning up completion marker from previous run"
    rm -f /workspace/.cleo-complete
elif [[ "{{github_app}}" =~ [Cc]ipher ]] && [ -f /workspace/.cipher-complete ]; then
    echo "üßπ Cipher cleaning up completion marker from previous run"
    rm -f /workspace/.cipher-complete
elif [[ "{{github_app}}" =~ [Tt]ess ]] && [ -f /workspace/.tess-complete ]; then
    echo "üßπ Tess cleaning up completion marker from previous run"
    rm -f /workspace/.tess-complete
fi

COMPLETED_ATTEMPTS=0
while [ "$UNLIMITED_RETRIES" = "1" ] || [ $ATTEMPT -le $MAX_RETRIES ]; do
  print_attempt_banner "$ATTEMPT" "$MAX_RETRIES" "$UNLIMITED_RETRIES"

  # Check for completion markers from previous runs to enable early exit
  if [ "$WORKFLOW_STAGE" = "implementation" ] || [ "$WORKFLOW_STAGE" = "implementation-in-progress" ]; then
    if [ -f "/workspace/.rex-complete" ]; then
      echo "‚úÖ Implementation completion marker found - Rex already completed"
      SUCCESS=1
      COMPLETED_ATTEMPTS=$ATTEMPT
      break
    fi
  elif [ "$WORKFLOW_STAGE" = "quality" ] || [ "$WORKFLOW_STAGE" = "quality-in-progress" ]; then
    if [ -f "/workspace/.cleo-complete" ]; then
      echo "‚úÖ Quality completion marker found - Cleo already completed"
      SUCCESS=1
      COMPLETED_ATTEMPTS=$ATTEMPT
      break
    fi
  elif [ "$WORKFLOW_STAGE" = "security" ] || [ "$WORKFLOW_STAGE" = "security-in-progress" ]; then
    if [ -f "/workspace/.cipher-complete" ]; then
      echo "‚úÖ Security completion marker found - Cipher already completed"
      SUCCESS=1
      COMPLETED_ATTEMPTS=$ATTEMPT
      break
    fi
  elif [ "$WORKFLOW_STAGE" = "testing" ] || [ "$WORKFLOW_STAGE" = "testing-in-progress" ]; then
    if [ -f "/workspace/.tess-complete" ]; then
      echo "‚úÖ Testing completion marker found - Tess already completed"
      SUCCESS=1
      COMPLETED_ATTEMPTS=$ATTEMPT
      break
    fi
  fi

  # Always refresh GitHub credentials at the start of each iteration to prevent stale sessions
  refresh_github_token || true
  ensure_gh_authenticated

  # =========================================================================
  # FAST-PATH: Skip work if PR already approved
  # =========================================================================
  # Only applies to quality and testing agents (Cleo/Tess), not implementation (Rex)
  if [ -n "${PR_NUMBER:-}" ] && [ "$ATTEMPT" -eq 1 ] && [ "${WORKFLOW_STAGE:-}" != "implementation" ]; then
    echo ""
    echo "üîç Checking if PR #${PR_NUMBER} already has approval..."

    # Check for existing approvals
    APPROVAL_COUNT=$(gh pr view "$PR_NUMBER" --json reviews --jq '[.reviews[] | select(.state == "APPROVED")] | length' 2>/dev/null || echo "0")

    if [ "${APPROVAL_COUNT:-0}" -gt 0 ]; then
      echo "‚úÖ PR #${PR_NUMBER} already has ${APPROVAL_COUNT} approval(s)"
      echo "üöÄ FAST-PATH: Skipping ${WORKFLOW_STAGE} checks since PR is already approved"

      # Determine agent name for message
      AGENT_NAME="Quality Agent"
      TIME_SAVED="10-15 minutes"
      if [ "${WORKFLOW_STAGE:-}" = "testing" ]; then
        AGENT_NAME="Testing Agent"
        TIME_SAVED="15-20 minutes"
      fi

      # Post a quick comment explaining the skip
      gh pr comment "$PR_NUMBER" --body "‚úÖ **${AGENT_NAME} - Fast-Path**

PR already has ${APPROVAL_COUNT} approval(s). Skipping redundant ${WORKFLOW_STAGE} checks.

**Fast-Path Benefits:**
- Saves ~${TIME_SAVED} of execution time
- Reduces unnecessary compute and model API calls
- PR already validated by previous quality gate

_${AGENT_NAME} will still run full checks if approval is revoked._" 2>/dev/null || echo "‚ö†Ô∏è Could not post fast-path comment"

      SUCCESS=1
      COMPLETED_ATTEMPTS=1
      break
    else
      echo "‚ÑπÔ∏è No existing approvals found, proceeding with ${WORKFLOW_STAGE} checks"
    fi
  fi
  echo ""

  # =========================================================================
  # INCREMENTAL CONTEXT: Load previous iteration findings
  # =========================================================================
  AGENT_STATE_DIR="$TASK_WORKSPACE/.agent-state"
  mkdir -p "$AGENT_STATE_DIR"

  PREVIOUS_CONTEXT=""
  if [ $ATTEMPT -gt 1 ]; then
    PREV_ATTEMPT=$((ATTEMPT - 1))
    PREV_STATE_FILE="$AGENT_STATE_DIR/${WORKFLOW_STAGE:-agent}-iteration-${PREV_ATTEMPT}.json"

    if [ -f "$PREV_STATE_FILE" ]; then
      echo "üìö Loading context from previous iteration $PREV_ATTEMPT"

      # Extract key findings from previous run
      if command -v jq >/dev/null 2>&1; then
        PREV_FINDINGS=$(jq -r '.findings // "No findings recorded"' "$PREV_STATE_FILE" 2>/dev/null || echo "")
        PREV_STATUS=$(jq -r '.status // "unknown"' "$PREV_STATE_FILE" 2>/dev/null || echo "unknown")

        if [ -n "$PREV_FINDINGS" ] && [ "$PREV_FINDINGS" != "No findings recorded" ]; then
          PREVIOUS_CONTEXT="

## üîÑ Context from Previous Iteration (#$PREV_ATTEMPT)

**Status**: $PREV_STATUS

**Previous Findings**:
$PREV_FINDINGS

**Focus for This Iteration**:
- Address the issues identified above
- Don't repeat the same analysis
- Build on previous progress incrementally

"
          echo "‚úÖ Loaded context: $PREV_STATUS with findings"
        fi
      fi
    else
      echo "‚ÑπÔ∏è No previous iteration state found (first attempt or state cleared)"
    fi
  fi

  # Append previous context to prompt if available
  if [ -n "$PREVIOUS_CONTEXT" ]; then
    PROMPT_CONTENT="${PROMPT_CONTENT}${PREVIOUS_CONTEXT}"
    echo "üìù Enhanced prompt with previous iteration context"
  fi

  CURRENT_ATTEMPT=$ATTEMPT
  LAST_MESSAGE_FILE="/tmp/factory-last-message-${ATTEMPT}.txt"
  RUN_LOG_EXT="log"
  if [ "$OUTPUT_FORMAT" = "json" ] || [ "$OUTPUT_FORMAT" = "debug" ]; then
    RUN_LOG_EXT="jsonl"
  fi
  RUN_LOG="/tmp/factory-run-${ATTEMPT}.${RUN_LOG_EXT}"

  CURRENT_MODEL="$DEFAULT_MODEL"
  if [ $MODEL_ROTATION_COUNT -gt 0 ]; then
    MODEL_INDEX=$(((ATTEMPT - 1) % MODEL_ROTATION_COUNT))
    CURRENT_MODEL="${MODEL_ROTATION[$MODEL_INDEX]}"
  fi
  if [ -n "$CURRENT_MODEL" ]; then
    echo "üéØ Attempt $ATTEMPT will use model: $CURRENT_MODEL"
  fi

  if [ "$SKIP_PERMISSIONS_UNSAFE" = "true" ]; then
    FACTORY_CMD=("droid" "exec" "--skip-permissions-unsafe" "--output-format" "$OUTPUT_FORMAT")
  else
    FACTORY_CMD=("droid" "exec" "--output-format" "$OUTPUT_FORMAT" "--auto" "$AUTO_LEVEL")
  fi
  if [ -n "$CURRENT_MODEL" ]; then
    FACTORY_CMD+=("--model" "$CURRENT_MODEL")
  fi
  if [ -n "$REASONING_EFFORT" ]; then
    FACTORY_CMD+=("--reasoning-effort" "$REASONING_EFFORT")
  fi
  FACTORY_CMD+=("$PROMPT_CONTENT")

  echo "üîß droid exec invocation arguments (${#FACTORY_CMD[@]} entries):"
  for idx in "${!FACTORY_CMD[@]}"; do
    printf '    [%d] %s\n' "$idx" "${FACTORY_CMD[$idx]}"
  done

  # Handle SIGPIPE gracefully to prevent exit 141 (broken pipe)
  # SIGPIPE occurs when a process tries to write to a closed pipe (e.g., log collector closed early)
  set +e
  set -o pipefail
  # Capture both Factory exit code and pipe status
  "${FACTORY_CMD[@]}" 2>&1 | tee "$RUN_LOG" || true
  FACTORY_EXIT=${PIPESTATUS[0]}
  TEE_EXIT=${PIPESTATUS[1]:-0}
  set +o pipefail
  set -e

  # If Factory exit code is 141 (SIGPIPE), check if it was just a pipe issue
  if [ "$FACTORY_EXIT" = "141" ]; then
    echo "‚ö†Ô∏è Factory CLI encountered SIGPIPE (exit code 141) - pipe may have closed early"
    echo "üîç Checking if Factory produced any output before pipe closed..."
    if [ -f "$RUN_LOG" ] && [ -s "$RUN_LOG" ]; then
      LOG_SIZE=$(stat -f%z "$RUN_LOG" 2>/dev/null || stat -c%s "$RUN_LOG" 2>/dev/null || echo "0")
      if [ "$LOG_SIZE" -gt 100 ]; then
        echo "‚úÖ Factory produced ${LOG_SIZE} bytes of output before pipe closed - likely log collection issue"
        echo "‚ÑπÔ∏è Treating as recoverable - Factory may have completed successfully before log pipe closed"
        # Check if the log indicates completion
        if grep -q "‚úÖ\|complete\|finished\|done" "$RUN_LOG" 2>/dev/null; then
          echo "‚úÖ Log shows completion indicators - treating as success"
          FACTORY_EXIT=0
        else
          echo "‚ö†Ô∏è Log shows no clear completion - will retry"
        fi
      else
        echo "‚ùå Minimal or no Factory output detected (${LOG_SIZE} bytes) - treating as failure"
      fi
    else
      echo "‚ùå No Factory output log file found - treating as failure"
    fi
  elif [ "$TEE_EXIT" != "0" ] && [ "$FACTORY_EXIT" = "0" ]; then
    echo "‚ö†Ô∏è Log collection (tee) failed but Factory succeeded - continuing"
  fi

  echo "[factory-debug] Attempt $ATTEMPT finished with exit code $FACTORY_EXIT"

  if [ $FACTORY_EXIT -ne 0 ]; then
    echo "‚ö†Ô∏è Factory exited with status $FACTORY_EXIT on attempt $ATTEMPT"
  fi

  # Circuit breaker: detect repeated failing commands
  if [ -f "$RUN_LOG" ] && command -v jq >/dev/null 2>&1; then
    # Try to extract failed bash commands from JSON log (if using json format)
    if [ "$OUTPUT_FORMAT" = "json" ] || [ "$OUTPUT_FORMAT" = "debug" ]; then
      # Factory/Droid uses Execute tool
      FAILED_CMD=$(jq -r 'select(.type=="tool_use" and .tool=="Execute" and (.result.exit_code // 0) != 0) | .input.command' "$RUN_LOG" 2>/dev/null | tail -n1 | head -c 100)

      if [ -n "$FAILED_CMD" ]; then
        # Track how many times this command has failed
        FAILED_COMMANDS["$FAILED_CMD"]=$((${FAILED_COMMANDS["$FAILED_CMD"]:-0} + 1))
        FAIL_COUNT=${FAILED_COMMANDS["$FAILED_CMD"]}

        if [ $FAIL_COUNT -ge $MAX_SAME_COMMAND_FAILURES ]; then
          echo "üî¥ CIRCUIT BREAKER TRIGGERED: Command has failed $FAIL_COUNT times in a row:"
          echo "   Command: $FAILED_CMD"
          echo "   This indicates the agent is stuck in a loop."

          # Inject intervention prompt for next attempt
          PROMPT_CONTENT="${PROMPT_CONTENT}

‚ö†Ô∏è **LOOP DETECTED**: You tried this command $FAIL_COUNT times:
\`\`\`bash
$FAILED_CMD
\`\`\`

It keeps failing. **STOP REPEATING THIS COMMAND.**

Try instead:
1. Check working directory: \`pwd\`
2. List files: \`ls -la\`
3. Use a completely different approach
4. Create files/directories step-by-step"

          # Reset counter
          FAILED_COMMANDS["$FAILED_CMD"]=0
        fi
      fi
    fi
  fi

  # Extract token usage for cost tracking (JSON format only)
  if [ -f "$RUN_LOG" ] && command -v jq >/dev/null 2>&1; then
    if [ "$OUTPUT_FORMAT" = "json" ] || [ "$OUTPUT_FORMAT" = "debug" ]; then
      TOKENS_IN=$(jq -r 'select(.usage.input_tokens != null) | .usage.input_tokens' "$RUN_LOG" 2>/dev/null | tail -n1)
      TOKENS_OUT=$(jq -r 'select(.usage.output_tokens != null) | .usage.output_tokens' "$RUN_LOG" 2>/dev/null | tail -n1)

      if [[ "$TOKENS_IN" =~ ^[0-9]+$ ]] && [[ "$TOKENS_OUT" =~ ^[0-9]+$ ]]; then
        TOKENS_TOTAL=$((TOKENS_IN + TOKENS_OUT))
        echo "üìä Factory tokens this attempt: input=$TOKENS_IN, output=$TOKENS_OUT, total=$TOKENS_TOTAL"

        # Store for metrics (future: send to backend)
        echo "{\"attempt\":$ATTEMPT,\"task_id\":\"{{task_id}}\",\"service\":\"{{service}}\",\"cli\":\"factory\",\"tokens_in\":$TOKENS_IN,\"tokens_out\":$TOKENS_OUT,\"tokens_total\":$TOKENS_TOTAL}" >> /tmp/factory-metrics.jsonl
      fi
    fi
  fi

  if [ -s "$RUN_LOG" ]; then
    if [ "$OUTPUT_FORMAT" = "json" ] || [ "$OUTPUT_FORMAT" = "debug" ]; then
      if command -v jq >/dev/null 2>&1; then
        RESULT_TEXT=$(jq -r 'select(.type == "result") | .result // empty' "$RUN_LOG" 2>/dev/null | tail -n1)
      else
        RESULT_TEXT=$(tail -n 40 "$RUN_LOG" 2>/dev/null | sed 's/\r$//')
      fi
    else
      RESULT_TEXT=$(tail -n 40 "$RUN_LOG" 2>/dev/null | sed 's/\r$//')
    fi
    printf '%s\n' "$RESULT_TEXT" > "$LAST_MESSAGE_FILE"
  else
    : > "$LAST_MESSAGE_FILE"
  fi

  # Special handling for security stage - check for completion marker file
  if [ "$WORKFLOW_STAGE" = "security" ] || [ "$WORKFLOW_STAGE" = "security-in-progress" ]; then
    if [ -f "/workspace/.cipher-complete" ]; then
      echo "‚úÖ Security completion marker found - Cipher has declared work complete"
      SUCCESS=1
      COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
      break
    else
      echo "‚ö†Ô∏è Security completion marker not found (/workspace/.cipher-complete)"
      echo "   Cipher must create this file when all security checks pass"
      LAST_COMPLETION_REASON="Security scan incomplete - marker file /workspace/.cipher-complete not created by Cipher"
      # Continue to retry
    fi
  elif [[ "{{github_app}}" =~ [Rr]ex ]]; then
    COMPLETION_PROMPT="Task {{task_id}} completion verification ‚Äî Rex Implementation Agent (Factory)

**Your Role**: You are Rex, the IMPLEMENTATION agent. Cleo will handle code quality in the next stage.

**FIRST**: Review the FUNCTIONAL requirements in task/acceptance-criteria.md

**Then answer 'yes' if ALL of these are true:**

1. **FUNCTIONAL acceptance criteria implemented** (features exist and basically work)
2. Code COMPILES successfully (\`cargo build\` passes)
3. All code changes are committed to git
4. Changes are pushed to remote branch feature/task-{{task_id}}-implementation

**Code quality issues are OK for Rex - Cleo will fix:**
- ‚ö†Ô∏è Clippy warnings? OK - Cleo will fix
- ‚ö†Ô∏è Formatting issues? OK - Cleo will fix
- ‚ö†Ô∏è Some tests failing? OK if basic functionality works - Cleo/Tess will fix
- ‚ö†Ô∏è Unused functions/variables? OK - Cleo will clean up

**Focus on**: Does the implementation work? Are the features there?

**Response format:**

If functionally complete (features work, code compiles, changes committed and pushed), respond with:
yes

If features incomplete or code doesn't compile, respond with:
no
REASON: <specific FUNCTIONAL issue>

Example 'yes' response (even with warnings):
yes

Example 'no' response:
no
REASON: Acceptance criteria 2 incomplete - health endpoint not yet implemented. Feature work remains.

Your response:"
  else
    COMPLETION_PROMPT="Task {{task_id}} completion verification.

**FIRST**: Review the acceptance criteria in task/acceptance-criteria.md

**Then answer 'yes' ONLY if ALL of these are true:**

1. **EVERY acceptance criterion is fully implemented** (not just started, but DONE)
2. All code changes are committed to git
3. Changes are pushed to remote branch feature/task-{{task_id}}-implementation
4. An **OPEN** pull request exists (with at least task-{{task_id}} label; other labels are optional)
5. Quality gates passed (cargo fmt, cargo clippy with no warnings, tests pass)

**Be honest**: If ANY acceptance criterion is incomplete or partially implemented, answer 'no' and continue working.

**To verify:**
- Review: \`cat task/acceptance-criteria.md\`
- Git status: \`git status\`
- Commits pushed: \`git log origin/main..HEAD\`
- PR exists and is OPEN: \`gh pr list --state open --head $(git branch --show-current)\`
- Tests pass: Check your test results

**Response format:**

If complete, respond with:
yes

If incomplete, respond with:
no
REASON: <specific reason why not complete>

For 'no' responses, REASON must specify:
- Which acceptance criteria are incomplete (list them by number/name)
- What specific work remains (be concrete)
- Any blockers or issues encountered

Example 'no' response:
no
REASON: Acceptance criteria 2 and 4 incomplete. API endpoint /users created but not yet connected to database. PR created but tests failing due to missing error handling in user_controller.rs.

Your response:"
  fi

  COMPLETION_LAST_MESSAGE="/tmp/factory-completion-${ATTEMPT}.txt"
  COMPLETION_LOG="/tmp/factory-completion-${ATTEMPT}.log"

  if [ "$SKIP_PERMISSIONS_UNSAFE" = "true" ]; then
    COMPLETION_CMD=("droid" "exec" "--skip-permissions-unsafe" "--output-format" "text")
  else
    COMPLETION_CMD=("droid" "exec" "--output-format" "text" "--auto" "$AUTO_LEVEL")
  fi
  if [ -n "$CURRENT_MODEL" ]; then
    COMPLETION_CMD+=("--model" "$CURRENT_MODEL")
  fi
  if [ -n "$REASONING_EFFORT" ]; then
    COMPLETION_CMD+=("--reasoning-effort" "$REASONING_EFFORT")
  fi
  COMPLETION_CMD+=("$COMPLETION_PROMPT")

  set +e
  set -o pipefail
  COMPLETION_OUTPUT=$("${COMPLETION_CMD[@]}" 2>&1 | tee "$COMPLETION_LOG")
  COMPLETION_EXIT=${PIPESTATUS[0]}
  set +o pipefail
  set -e

  printf '%s\n' "$COMPLETION_OUTPUT" > "$COMPLETION_LAST_MESSAGE"
  echo "üß≠ Completion probe response:"
  printf '%s\n' "$COMPLETION_OUTPUT"

  if [ $COMPLETION_EXIT -ne 0 ]; then
    echo "‚ö†Ô∏è Completion probe exited with status $COMPLETION_EXIT"
  fi

  CLEAN_COMPLETION_OUTPUT=$(printf '%s\n' "$COMPLETION_OUTPUT" | tr -d '\r')
  COMPLETION_RESPONSE=$(printf '%s\n' "$CLEAN_COMPLETION_OUTPUT" \
    | awk 'BEGIN { FS="[^A-Za-z]+" } { for (i = 1; i <= NF; i++) { word=tolower($i); if (word == "yes") yes=1; if (word == "no") no=1 } } END { if (yes) { print "yes" } else if (no) { print "no" } }' \
    | head -n1 \
    | tr '[:upper:]' '[:lower:]' \
    | tr -d '[:space:]')
  CURRENT_REASON=""
  if [ "$COMPLETION_RESPONSE" = "no" ]; then
    CURRENT_REASON=$(printf '%s\n' "$CLEAN_COMPLETION_OUTPUT" | awk 'BEGIN{IGNORECASE=1}/^reason:/{sub(/^reason:[[:space:]]*/,"");flag=1} flag{print}')
    if [ -n "$CURRENT_REASON" ]; then
      echo "üìã Incompletion details:"
      echo "$CURRENT_REASON"
      echo ""
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo "‚ïë üîÅ NEXT ITERATION FOCUS (FROM COMPLETION PROBE)              ‚ïë"
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      printf '%s\n' "$CURRENT_REASON"
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo ""
      PROMPT_CONTENT="${PROMPT_CONTENT}

üîÅ **NEXT ITERATION FOCUS (from completion probe attempt $ATTEMPT)**

${CURRENT_REASON}

Address the items above before rerunning checks."
      LAST_COMPLETION_REASON="$CURRENT_REASON"
    else
      echo "‚ö†Ô∏è Completion probe reported 'no' without a reason"
    fi
  fi

  # =========================================================================
  # SAVE ITERATION STATE: Persist findings for next iteration
  # =========================================================================
  STATE_FILE="$AGENT_STATE_DIR/${WORKFLOW_STAGE:-agent}-iteration-${ATTEMPT}.json"

  if [ "$COMPLETION_RESPONSE" = "yes" ]; then
    # Save successful completion state
    cat > "$STATE_FILE" <<EOF
{
  "iteration": $ATTEMPT,
  "status": "completed",
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "findings": "Task completed successfully on iteration $ATTEMPT",
  "completion_response": "yes",
  "issues": []
}
EOF
    echo "üíæ Saved successful completion state to $STATE_FILE"

    SUCCESS=1
    COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
    break
  else
    # Save incomplete state with findings for next iteration
    ISSUES_JSON="[]"
    if [ -n "$CURRENT_REASON" ]; then
      # Escape quotes and newlines for JSON
      ESCAPED_REASON=$(printf '%s' "$CURRENT_REASON" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
      ISSUES_JSON="[\"$ESCAPED_REASON\"]"
    fi

    cat > "$STATE_FILE" <<EOF
{
  "iteration": $ATTEMPT,
  "status": "incomplete",
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "findings": $([ -n "$CURRENT_REASON" ] && echo "\"$ESCAPED_REASON\"" || echo "\"No specific issues identified\""),
  "completion_response": "no",
  "issues": $ISSUES_JSON
}
EOF
    echo "üíæ Saved incomplete state to $STATE_FILE for next iteration"
  fi

  if [ -n "$CURRENT_REASON" ]; then
    echo "‚ö†Ô∏è Factory reported task incomplete; retrying with new guidance..."
  else
    echo "‚ö†Ô∏è Factory reported task incomplete; retrying..."
  fi

  COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
  ATTEMPT=$((ATTEMPT + 1))
done

FINAL_ATTEMPTS=$COMPLETED_ATTEMPTS
if [ "${FINAL_ATTEMPTS:-0}" -le 0 ]; then
  FINAL_ATTEMPTS=$((ATTEMPT - 1))
fi
if [ "$UNLIMITED_RETRIES" != "1" ] && [ $FINAL_ATTEMPTS -gt $MAX_RETRIES ]; then
  FINAL_ATTEMPTS=$MAX_RETRIES
fi

if [ $SUCCESS -ne 1 ]; then
  if [ "$UNLIMITED_RETRIES" = "1" ]; then
    echo "‚ö†Ô∏è Factory did not confirm task completion after $FINAL_ATTEMPTS attempts (unlimited mode)"
  else
    echo "‚ö†Ô∏è Factory did not confirm task completion after $MAX_RETRIES attempts"
  fi
  if [ -n "$LAST_COMPLETION_REASON" ]; then
    echo ""
    echo "üí° Last reported reason for incompletion:"
    echo "$LAST_COMPLETION_REASON"
  fi

  # Document remaining work for downstream agents (Cleo/Tess)
  echo ""
  echo "üìù Creating handoff document for Cleo..."
  HANDOFF_FILE="$FACTORY_WORK_DIR/task/rex-handoff.md"
  mkdir -p "$FACTORY_WORK_DIR/task"

  # Prepare handoff content with proper variable expansion
  HANDOFF_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
  if [ -n "$LAST_COMPLETION_REASON" ]; then
    REMAINING_WORK="$LAST_COMPLETION_REASON"
  else
    REMAINING_WORK="Factory did not provide specific details. Review acceptance criteria and compare against current implementation."
  fi

  cat > "$HANDOFF_FILE" << EOF
# Rex Implementation Handoff

**Status**: Incomplete after $FINAL_ATTEMPTS iterations (max: $MAX_RETRIES)
**Date**: $HANDOFF_DATE
**Task**: {{task_id}}

## What Was Accomplished

Rex made $FINAL_ATTEMPTS attempts to complete this task. Review the PR and commit history for details on what was implemented.

## Remaining Work

$REMAINING_WORK

## Next Steps for Cleo

1. Review the PR created by Rex
2. Identify gaps between current implementation and acceptance criteria
3. Complete any remaining implementation work
4. Ensure all quality checks pass before handing off to Tess

## Acceptance Criteria Reference

See \`task/acceptance-criteria.md\` for complete requirements.

---
*Generated by Rex (Factory) after $FINAL_ATTEMPTS implementation attempts*
EOF

  echo "‚úÖ Handoff document created at task/rex-handoff.md"

  # Commit the handoff document
  if [ -f "$HANDOFF_FILE" ]; then
    git add "$HANDOFF_FILE" 2>/dev/null || true

    # Build commit message with proper variable expansion
    COMMIT_MSG="docs(task-{{task_id}}): add Rex handoff document

Rex completed $FINAL_ATTEMPTS implementation iterations with incomplete status (max: $MAX_RETRIES).
Handoff document created for Cleo to continue work."

    if [ -n "$LAST_COMPLETION_REASON" ]; then
      COMMIT_MSG="$COMMIT_MSG

Reason: $LAST_COMPLETION_REASON"
    fi

    git commit -m "$COMMIT_MSG" 2>/dev/null || echo "‚ö†Ô∏è Could not commit handoff document (may already be committed)"

    # Push the commit if we're on a feature branch
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
    if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "master" ]; then
      git push origin HEAD 2>/dev/null || echo "‚ö†Ô∏è Could not push handoff document"
    fi
  fi

  # Check if agent made any commits before deciding to handoff vs fail
  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
  REMOTE_BASE="origin/${BASE_BRANCH:-main}"
  COMMITS_MADE=0

  if [ -n "$CURRENT_BRANCH" ]; then
    git fetch origin "$BASE_BRANCH" >/dev/null 2>&1 || true
    AHEAD_COUNT=$(git rev-list --left-right "$REMOTE_BASE...$CURRENT_BRANCH" 2>/dev/null | awk '/^>/{c++} END{print c+0}')
    if [ "${AHEAD_COUNT:-0}" -gt 0 ]; then
      COMMITS_MADE=1
      echo "‚úÖ $AGENT_NAME made $AHEAD_COUNT commit(s) - will handoff to next stage"
    else
      echo "‚ö†Ô∏è $AGENT_NAME made NO commits - cannot handoff without progress"
    fi
  fi

  if [ "$COMMITS_MADE" -eq 1 ]; then
    # Agent made progress - BUT check if this is Cipher with security issues
    # Cipher must NOT hand off to Tess if security issues found (even if commits were made)
    if [ "$WORKFLOW_STAGE" = "security" ] || [ "$WORKFLOW_STAGE" = "security-in-progress" ]; then
      echo ""
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo "‚ïë      CIPHER SECURITY GATE: ISSUES FOUND - BLOCKING TESS      ‚ïë"
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo ""
      echo "üõë Security issues detected - Tess handoff BLOCKED"
      echo "   - Cipher found security vulnerabilities or policy violations"
      echo "   - Rex remediation will be triggered to fix issues"
      echo "   - Cipher will re-scan after Rex pushes fixes"
      echo "   - Tess will only start after Cipher approves"
      echo ""
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      
      EXIT_CODE=1  # Exit with failure to block workflow progression
    else
      # Non-security stages can handoff with partial completion
      echo ""
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo "‚ïë          TASK COMPLETION STATUS: PARTIAL - HANDOFF           ‚ïë"
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo ""
      if [ -n "$LAST_COMPLETION_REASON" ]; then
        echo "üìã REASON FOR INCOMPLETION:"
        echo "$LAST_COMPLETION_REASON"
      else
        echo "‚ö†Ô∏è Factory reported task incomplete without providing a reason"
      fi
      echo ""
      echo "üîÑ NEXT STEPS:"
      echo "   - Handoff document created at task/rex-handoff.md"
      echo "   - Workflow will continue to next stage for completion"
      echo "   - Next agent will review PR and finish remaining work"
      echo "   - Check the logs above for Factory's detailed responses"
      echo ""
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo ""
      EXIT_CODE=0  # Exit successfully to allow next stage to continue
    fi
  else
    # Agent made NO progress - this is a failure, should retry
    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "‚ïë          TASK COMPLETION STATUS: FAILED - NO PROGRESS         ‚ïë"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo ""
    echo "‚ùå Rex failed to make any commits after $MAX_RETRIES attempts"
    echo ""
    if [ -n "$LAST_COMPLETION_REASON" ]; then
      echo "üìã LAST COMPLETION REASON:"
      echo "$LAST_COMPLETION_REASON"
    else
      echo "‚ö†Ô∏è Factory did not provide a reason for incompletion"
      echo "   This may indicate an error occurred before Factory could respond"
    fi
    echo ""
    echo "üîÑ NEXT STEPS:"
    echo "   - Check Factory logs above for errors"
    echo "   - CodeRun will retry this task"
    echo "   - If retries exhausted, workflow will fail"
    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo ""
    EXIT_CODE=1  # Exit with failure to trigger retry
  fi
else
  echo "‚úÖ Factory confirmed task completion"
  if [ ${FACTORY_EXIT:-0} -ne 0 ]; then
    echo "‚ö†Ô∏è Factory returned non-zero exit code ${FACTORY_EXIT}, but completion probe passed"
  fi
  EXIT_CODE=0
fi

if [ $SUCCESS -eq 1 ] && [ "$WORKFLOW_STAGE" = "implementation" ]; then
  echo "üîç Verifying pull request status"
  ensure_pr_created
else
  # In single-iteration mode, still try to create PR for inspection (implementation only)
  if [ "$MAX_RETRIES" = "1" ] && [ "$WORKFLOW_STAGE" = "implementation" ]; then
    echo "üîç Single-iteration mode - attempting PR creation for result inspection"
    ensure_pr_created || echo "‚ö†Ô∏è PR creation failed or no PR was created"
  elif [ "$COMMITS_MADE" -eq 1 ] && [ "$WORKFLOW_STAGE" = "implementation" ]; then
    echo "üîç Implementation agent ($AGENT_NAME) made commits - ensuring PR exists"
    ensure_pr_created || echo "‚ö†Ô∏è PR creation failed or no PR was created"
  else
    echo "‚ö†Ô∏è Skipping auto PR enforcement (no commits or non-implementation stage)"
  fi
fi

RESOLVED_PR_URL="$(resolve_pr_url)"

if [ $SUCCESS -eq 1 ]; then
  # Create completion marker for the appropriate agent based on workflow stage
  if [[ "{{github_app}}" =~ [Rr]ex ]] && ([ "$WORKFLOW_STAGE" = "implementation" ] || [ "$WORKFLOW_STAGE" = "implementation-in-progress" ]); then
    echo "rex-implementation-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.rex-complete
    echo "‚úÖ Rex created implementation completion marker at /workspace/.rex-complete"
  elif [[ "{{github_app}}" =~ [Cc]leo ]] && ([ "$WORKFLOW_STAGE" = "quality" ] || [ "$WORKFLOW_STAGE" = "quality-in-progress" ]); then
    echo "cleo-quality-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.cleo-complete
    echo "‚úÖ Cleo created quality completion marker at /workspace/.cleo-complete"
  elif [[ "{{github_app}}" =~ [Cc]ipher ]] && ([ "$WORKFLOW_STAGE" = "security" ] || [ "$WORKFLOW_STAGE" = "security-in-progress" ]); then
    echo "cipher-security-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.cipher-complete
    echo "‚úÖ Cipher created security completion marker at /workspace/.cipher-complete"
  elif [[ "{{github_app}}" =~ [Tt]ess ]] && ([ "$WORKFLOW_STAGE" = "testing" ] || [ "$WORKFLOW_STAGE" = "testing-in-progress" ]); then
    echo "tess-testing-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.tess-complete
    echo "‚úÖ Tess created testing completion marker at /workspace/.tess-complete"
  fi
  
  # Mark as Succeeded to allow workflow progression to Cipher
  patch_coderun_status \
    "Succeeded" \
    "Implementation completed - ready for security review" \
    "ready-for-security" \
    "" \
    "$RESOLVED_PR_URL" \
    "true"
else
  STATUS_NOTE="$LAST_COMPLETION_REASON"
  if [ -z "$STATUS_NOTE" ]; then
    STATUS_NOTE="Implementation requires follow-up"
  fi

  # Mark as Succeeded with needs-fixes to allow workflow to continue to Cleo
  # The remediationStatus indicates follow-up work is needed
  patch_coderun_status \
    "Succeeded" \
    "$STATUS_NOTE" \
    "needs-fixes" \
    "" \
    "$RESOLVED_PR_URL" \
    "false"
fi

# Submit GitHub PR review for Cleo/Tess stages (enables workflow progression)
# Map CodeRun stage values to workflow stage labels expected by container logic
case "${WORKFLOW_STAGE:-}" in
  "quality")
    WORKFLOW_STAGE="quality-in-progress"
    ;;
  "testing")
    WORKFLOW_STAGE="testing-in-progress"
    ;;
  *)
    # Use existing value for other stages (implementation, etc.)
    ;;
esac

if [ "$WORKFLOW_STAGE" = "quality" ] || [ "$WORKFLOW_STAGE" = "security" ] || [ "$WORKFLOW_STAGE" = "testing" ]; then
  PR_NUM="${PR_NUMBER:-}"
  if [ -z "$PR_NUM" ]; then
    # Try to get PR number from current branch
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
    if [ -n "$CURRENT_BRANCH" ]; then
      PR_NUM=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")
    fi
  fi

  if [ -n "$PR_NUM" ]; then
    if [ $SUCCESS -eq 1 ]; then
      STAGE_NAME="Quality"
      STAGE_EMOJI="üõ°Ô∏è"
      CHECKS_PASSED=$'- Code formatting verified
- Linting passed
- Unit tests successful
- Quality standards met'
      NEXT_STAGE="security review by Cipher"

      if [ "$WORKFLOW_STAGE" = "security" ] || [ "$WORKFLOW_STAGE" = "security-in-progress" ]; then
        # Cipher security review
        STAGE_NAME="Security"
        STAGE_EMOJI="üîí"
        CHECKS_PASSED=$'- No vulnerabilities detected
- Dependency audit passed
- Secret scanning completed
- Security best practices verified'
        NEXT_STAGE="QA testing by Tess"

        echo "‚úÖ $STAGE_NAME checks passed - posting status comment (no approval)"
        REVIEW_BODY_FILE=$(mktemp)
        cat <<EOF > "$REVIEW_BODY_FILE"
### $STAGE_EMOJI $STAGE_NAME Review - PASSED (Status Only)
All security checks have passed:
$CHECKS_PASSED

**Status:** Ready for $NEXT_STAGE
**Next Step:** Tess will now perform comprehensive QA validation

---
*Security review by Cipher ‚Äî final approval belongs to Tess*
EOF
        refresh_token_if_needed || true
        timeout 30 gh pr comment "$PR_NUM" --body-file "$REVIEW_BODY_FILE" 2>&1 || echo "‚ö†Ô∏è PR comment command failed"
        rm -f "$REVIEW_BODY_FILE"

        # Add security-approved label
        LABEL_NAME="security-approved"
        LABEL_API_PATH=$(printf '%s' "$LABEL_NAME" | sed 's/ /%20/g')
        echo "üè∑Ô∏è  Ensuring '$LABEL_NAME' label exists"
        if ! gh api -H "Accept: application/vnd.github+json" "repos/$REPO_OWNER/$REPO_NAME/labels/$LABEL_API_PATH" >/dev/null 2>&1; then
          gh api -X POST \
            -H "Accept: application/vnd.github+json" \
            "repos/$REPO_OWNER/$REPO_NAME/labels" \
            -f name="$LABEL_NAME" \
            -f color="0E8A16" \
            -f description="Cipher security gate approval" >/dev/null 2>&1 || echo "‚ö†Ô∏è Unable to create $LABEL_NAME label"
        fi
        echo "üè∑Ô∏è  Adding '$LABEL_NAME' label"
        if ! gh api -X POST \
          -H "Accept: application/vnd.github+json" \
          "repos/$REPO_OWNER/$REPO_NAME/issues/$PR_NUM/labels" \
          -F labels[]="$LABEL_NAME" >/dev/null 2>&1; then
          echo "‚ö†Ô∏è Failed to add $LABEL_NAME label"
        fi

        # Add ready-for-qa label to trigger Tess (DO NOT refresh - causes duplicate runs)
        LABEL_READY_FOR_QA="ready-for-qa"
        echo "üè∑Ô∏è  Adding '$LABEL_READY_FOR_QA' label to signal Tess (if not already present)"
        if ! gh api "repos/$REPO_OWNER/$REPO_NAME/issues/$PR_NUM/labels" --jq '.[].name' 2>/dev/null | grep -q "^${LABEL_READY_FOR_QA}$"; then
          if gh api -X POST \
            -H "Accept: application/vnd.github+json" \
            "repos/$REPO_OWNER/$REPO_NAME/issues/$PR_NUM/labels" \
            -F labels[]="$LABEL_READY_FOR_QA" >/dev/null 2>&1; then
            echo "‚úÖ Added '$LABEL_READY_FOR_QA' label to trigger Tess"
          else
            echo "‚ö†Ô∏è Failed to add $LABEL_READY_FOR_QA label"
          fi
        else
          echo "‚ÑπÔ∏è  Label '$LABEL_READY_FOR_QA' already present - no action needed"
        fi
      elif [ "$WORKFLOW_STAGE" = "testing" ]; then
        # Tess has final approval authority - but ONLY if CI passes
        STAGE_NAME="QA Testing"
        STAGE_EMOJI="üß™"
        CHECKS_PASSED=$'- End-to-end tests passed
- Integration tests successful
- Acceptance criteria validated
- Production readiness confirmed'
        NEXT_STAGE="human review and merge"

        # CRITICAL: Check GitHub CI status before approving
        if [ $SUCCESS -eq 1 ]; then
          echo "üîç Verifying GitHub CI status before Tess approval..."
          CI_CHECK_FAILED=0
          
          CI_TIMEOUT=300
          CI_WAIT=0
          CI_ALL_COMPLETE=false
          
          while [ $CI_WAIT -lt $CI_TIMEOUT ]; do
            PENDING_COUNT=$(gh pr checks "$PR_NUM" --json state --jq '[.[] | select(.state != "COMPLETED")] | length' 2>/dev/null || echo "99")
            
            if [ "${PENDING_COUNT:-99}" -eq 0 ]; then
              CI_ALL_COMPLETE=true
              echo "‚úÖ All CI checks completed"
              break
            fi
            
            echo "‚è≥ Waiting for CI... ${PENDING_COUNT} pending (${CI_WAIT}s / ${CI_TIMEOUT}s)"
            sleep 15
            CI_WAIT=$((CI_WAIT + 15))
          done
          
          if [ "$CI_ALL_COMPLETE" = "false" ]; then
            echo "‚ö†Ô∏è CI still running after ${CI_TIMEOUT}s - NOT approving"
            CI_CHECK_FAILED=1
          else
            FAILED_COUNT=$(gh pr checks "$PR_NUM" --json conclusion --jq '[.[] | select(.conclusion == "FAILURE" or .conclusion == "CANCELLED")] | length' 2>/dev/null || echo "0")
            
            if [ "${FAILED_COUNT:-0}" -gt 0 ]; then
              echo "‚ùå ${FAILED_COUNT} CI check(s) FAILED - NOT approving"
              CI_CHECK_FAILED=1
            else
              echo "‚úÖ All CI checks PASSED"
            fi
          fi
          
          if [ $CI_CHECK_FAILED -eq 1 ]; then
            SUCCESS=0
            CHECKS_PASSED="CI checks must pass before approval"
          fi
        fi

        # Check if this is the final task requiring deployment verification
        DEPLOYMENT_STATUS=""
        if [ "${FINAL_TASK:-false}" = "true" ] && [ $SUCCESS -eq 1 ]; then
          echo "üéØ Final task detected - verifying Kubernetes deployment"

          # Extract service name from repository or use default
          SERVICE_NAME="${SERVICE_NAME:-$(basename "$REPOSITORY" .git)}"
          NAMESPACE="${NAMESPACE:-agent-platform}"

          # Check for deployment
          if kubectl get deployment "$SERVICE_NAME" -n "$NAMESPACE" &>/dev/null; then
            READY_REPLICAS=$(kubectl get deployment "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            DESIRED_REPLICAS=$(kubectl get deployment "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")

            if [ "$READY_REPLICAS" = "$DESIRED_REPLICAS" ] && [ "$READY_REPLICAS" != "0" ]; then
              echo "‚úÖ Deployment verified: $READY_REPLICAS/$DESIRED_REPLICAS replicas ready"

              # Get ingress URLs
              INGRESS_URLS=$(kubectl get ingress -n "$NAMESPACE" -o jsonpath='{range .items[*]}{.spec.rules[*].host}{"\n"}{end}' 2>/dev/null | grep -v "^$" || echo "")

              if [ -n "$INGRESS_URLS" ]; then
                DEPLOYMENT_STATUS="

## üöÄ Deployment Verified
- **Service**: $SERVICE_NAME
- **Namespace**: $NAMESPACE
- **Status**: ‚úÖ $READY_REPLICAS/$DESIRED_REPLICAS replicas ready
- **Live URLs**:
$(echo "$INGRESS_URLS" | sed 's/^/  - https:\/\//')"
              else
                DEPLOYMENT_STATUS="

## üöÄ Deployment Verified
- **Service**: $SERVICE_NAME
- **Namespace**: $NAMESPACE
- **Status**: ‚úÖ $READY_REPLICAS/$DESIRED_REPLICAS replicas ready
- **Access**: Service deployed (no ingress configured)"
              fi
            else
              echo "‚ö†Ô∏è Deployment not ready: $READY_REPLICAS/$DESIRED_REPLICAS replicas"
              DEPLOYMENT_STATUS="

## ‚ö†Ô∏è Deployment Not Ready
- **Service**: $SERVICE_NAME
- **Namespace**: $NAMESPACE
- **Status**: ‚è≥ $READY_REPLICAS/$DESIRED_REPLICAS replicas ready
- **Action Required**: Waiting for deployment to stabilize"
            fi
          else
            echo "‚ö†Ô∏è Deployment not found: $SERVICE_NAME in namespace $NAMESPACE"
            DEPLOYMENT_STATUS="

## ‚ö†Ô∏è Deployment Not Found
- **Service**: $SERVICE_NAME
- **Namespace**: $NAMESPACE
- **Status**: ‚ùå Deployment not detected
- **Action Required**: Ensure deployment manifests are applied"
          fi
        fi

        echo "‚úÖ $STAGE_NAME complete - posting APPROVE review (Tess final approval)"
        REVIEW_BODY_FILE=$(mktemp)
        cat <<EOF > "$REVIEW_BODY_FILE"
### $STAGE_EMOJI $STAGE_NAME Review - APPROVED
All checks have passed:
$CHECKS_PASSED
Ready for $NEXT_STAGE.$DEPLOYMENT_STATUS

**Final Approval:** Tess has verified all acceptance criteria are met.
EOF
        refresh_token_if_needed || true
        timeout 30 gh pr review "$PR_NUM" --approve --body-file "$REVIEW_BODY_FILE" 2>&1 || echo "‚ö†Ô∏è PR review command failed"
        rm -f "$REVIEW_BODY_FILE"

        # Auto-merge if enabled (Tess only)
        if [ "${AUTO_MERGE:-false}" = "true" ]; then
          echo "üîÄ AUTO_MERGE enabled - merging PR automatically"
          if timeout 30 gh pr merge "$PR_NUM" --auto --squash --delete-branch; then
            echo "‚úÖ PR scheduled for auto-merge"
          else
            echo "‚ö†Ô∏è Auto-merge failed - PR may need manual intervention"
          fi
        fi
      else
        # Cleo posts APPROVE review to show up in Reviews tab
        echo "‚úÖ $STAGE_NAME checks passed - posting APPROVE review"
        REVIEW_BODY_FILE=$(mktemp)
        cat <<EOF > "$REVIEW_BODY_FILE"
### $STAGE_EMOJI $STAGE_NAME Review - APPROVED
All quality checks have passed:
$CHECKS_PASSED

**Status:** Ready for $NEXT_STAGE
**Next Step:** Tess will now perform comprehensive QA validation

---
*Quality review by Cleo*
EOF
        refresh_token_if_needed || true
        timeout 30 gh pr review "$PR_NUM" --approve --body-file "$REVIEW_BODY_FILE" 2>&1 || echo "‚ö†Ô∏è PR review command failed"
        rm -f "$REVIEW_BODY_FILE"

        # Add ready-for-security label to signal Cipher
        echo "üè∑Ô∏è  Adding 'ready-for-security' label to trigger Cipher review"
        timeout 30 gh pr edit "$PR_NUM" --add-label "ready-for-security" 2>&1 || echo "‚ö†Ô∏è Failed to add ready-for-security label"
      fi
    else
      STAGE_NAME="Quality"
      STAGE_EMOJI="üõ°Ô∏è"
      ISSUES_DESC=$'- Review code formatting
- Fix linting errors
- Ensure unit tests pass
- Meet quality standards'
      if [ "$WORKFLOW_STAGE" = "security" ]; then
        STAGE_NAME="Security"
        STAGE_EMOJI="üîí"
        ISSUES_DESC=$'- Fix security vulnerabilities
- Update insecure dependencies
- Remove exposed secrets
- Address security best practice violations'
      elif [ "$WORKFLOW_STAGE" = "testing" ]; then
        STAGE_NAME="QA Testing"
        STAGE_EMOJI="üß™"
        ISSUES_DESC=$'- Fix failing end-to-end tests
- Address integration test failures
- Validate acceptance criteria
- Ensure production readiness'
      fi

      echo "‚ùå $STAGE_NAME issues detected - posting REQUEST CHANGES review"
      REVIEW_BODY_FILE=$(mktemp)
      cat <<EOF > "$REVIEW_BODY_FILE"
### üî¥ Required Changes
$STAGE_NAME issues detected. Please address the following:
$ISSUES_DESC
EOF
      refresh_token_if_needed || true
      timeout 30 gh pr review "$PR_NUM" --request-changes --body-file "$REVIEW_BODY_FILE" 2>&1 || echo "‚ö†Ô∏è PR review command failed"
      rm -f "$REVIEW_BODY_FILE"
    fi
  else
    echo "‚ÑπÔ∏è No PR number available for $WORKFLOW_STAGE review submission"
  fi
fi

touch "$TASK_WORKSPACE/.agent_done" 2>/dev/null || true

# Explicitly stop Docker sidecar before exiting
echo "üõë Explicitly stopping Docker sidecar..."
stop_docker_sidecar || true

# Kill any remaining background processes to ensure clean exit
echo "üßπ Cleaning up background processes..."
pkill -P $$ 2>/dev/null || true

if [ $SUCCESS -ne 1 ]; then
  {{#if agent_completion_message}}
echo "{{agent_completion_message}}"
  {{else}}
echo "‚ö†Ô∏è Factory execution incomplete"
  {{/if}}
  # Exit with failure code
  exit $EXIT_CODE
fi

{{#if agent_completion_message}}
echo "{{agent_completion_message}}"
{{else}}
echo "‚úÖ Factory execution complete"
{{/if}}

# Exit cleanly with the actual exit code
echo "üèÅ Terminating container..."
exit $EXIT_CODE
