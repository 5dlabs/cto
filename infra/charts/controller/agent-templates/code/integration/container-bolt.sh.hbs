#!/bin/sh
# Bolt - DevOps & Public Deployment Specialist
# Creates ArgoCD apps, sets up ngrok ingress, ensures public availability

echo "Bolt: Publishing {{service}} to public internet via ngrok"

# Source common setup
source /agent-templates/shared_task-setup-functions.sh 2>/dev/null || true

# Setup authentication
setup_github_auth

# Environment context
NAMESPACE="${NAMESPACE:-agent-platform}"
SERVICE="{{service}}"
TASK_ID="{{task_id}}"
REPOSITORY="{{repository_url}}"
BRANCH="${BRANCH:-main}"

echo "Service: $SERVICE"
echo "Namespace: $NAMESPACE"
echo "Repository: $REPOSITORY"

# Step 1: Create ArgoCD Application if it doesn't exist
create_argocd_app() {
    local app_name="$SERVICE"
    local repo_url="$REPOSITORY"
    local path="${ARGOCD_PATH:-helm}"
    
    echo "===== Creating ArgoCD Application: $app_name ====="
    
    # Check if application already exists
    if kubectl get application "$app_name" -n argocd >/dev/null 2>&1; then
        echo "‚úÖ ArgoCD application '$app_name' already exists"
        return 0
    fi
    
    # Create ArgoCD Application manifest
    cat <<EOF | kubectl apply -f -
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: $app_name
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  project: default
  source:
    repoURL: $repo_url
    targetRevision: $BRANCH
    path: $path
  destination:
    server: https://kubernetes.default.svc
    namespace: $NAMESPACE
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
EOF
    
    echo "‚úÖ Created ArgoCD application: $app_name"
}

# Step 2: Wait for ArgoCD sync and health
wait_for_argocd_sync() {
    local app_name="$SERVICE"
    local max_wait=300  # 5 minutes
    local elapsed=0
    
    echo "===== Waiting for ArgoCD Sync: $app_name ====="
    
    while [ $elapsed -lt $max_wait ]; do
        local sync_status=$(kubectl get application "$app_name" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
        local health_status=$(kubectl get application "$app_name" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
        
        echo "Sync: $sync_status, Health: $health_status"
        
        if [ "$sync_status" = "Synced" ] && [ "$health_status" = "Healthy" ]; then
            echo "‚úÖ ArgoCD application is Synced and Healthy"
            return 0
        fi
        
        sleep 10
        elapsed=$((elapsed + 10))
    done
    
    echo "‚ö†Ô∏è  Timeout waiting for ArgoCD sync"
    kubectl get application "$app_name" -n argocd -o yaml
    return 1
}

# Step 3: Create ngrok ingress
create_ngrok_ingress() {
    local service_name="$SERVICE"
    local service_port="${SERVICE_PORT:-80}"
    
    echo "===== Creating ngrok Ingress for $service_name ====="
    
    # Check if ngrok tunnel already exists
    if kubectl get tunnel "$service_name-ngrok" -n "$NAMESPACE" >/dev/null 2>&1; then
        echo "‚úÖ ngrok tunnel already exists"
    else
        # Create ngrok Tunnel CRD
        cat <<EOF | kubectl apply -f -
apiVersion: ngrok.k8s.ngrok.com/v1alpha1
kind: Tunnel
metadata:
  name: $service_name-ngrok
  namespace: $NAMESPACE
spec:
  forwardsTo: $service_name:$service_port
EOF
        echo "‚úÖ Created ngrok tunnel"
    fi
    
    # Wait for tunnel to be ready
    echo "Waiting for ngrok tunnel to provision..."
    sleep 10
}

# Step 4: Get public URL
get_public_url() {
    local service_name="$SERVICE"
    
    echo "===== Getting Public URL ====="
    
    # Get ngrok tunnel URL
    local public_url=$(kubectl get tunnel "$service_name-ngrok" -n "$NAMESPACE" -o jsonpath='{.status.url}' 2>/dev/null)
    
    if [ -z "$public_url" ]; then
        echo "‚ö†Ô∏è  Could not get ngrok URL, checking ingress..."
        public_url=$(kubectl get ingress -n "$NAMESPACE" -l "app=$service_name" -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
    fi
    
    if [ -n "$public_url" ]; then
        echo "‚úÖ Public URL: $public_url"
        echo "$public_url"
    else
        echo "‚ùå Could not determine public URL"
        return 1
    fi
}

# Step 5: Verify public accessibility
verify_public_access() {
    local url="$1"
    
    echo "===== Verifying Public Access: $url ====="
    
    # Try to curl the URL
    if curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$url" | grep -E "^(200|301|302)$" >/dev/null; then
        echo "‚úÖ Application is publicly accessible"
        return 0
    else
        echo "‚ö†Ô∏è  Application may not be publicly accessible yet"
        return 1
    fi
}

# Main workflow
echo "===== Bolt: Publishing Application ====="

# 1. Create ArgoCD application
create_argocd_app

# 2. Wait for sync and health
wait_for_argocd_sync

# 3. Create ngrok ingress
create_ngrok_ingress

# 4. Get public URL
PUBLIC_URL=$(get_public_url)

# 5. Verify accessibility
if [ -n "$PUBLIC_URL" ]; then
    verify_public_access "$PUBLIC_URL"
fi

# 6. Post results to PR
if [ -n "$PR_NUMBER" ] && [ -n "$PUBLIC_URL" ]; then
    echo "===== Posting Public URL to PR #$PR_NUMBER ====="
    
    gh pr comment "$PR_NUMBER" --body "## üöÄ Bolt: Application Published

**Service:** \`$SERVICE\`  
**Public URL:** $PUBLIC_URL  
**Status:** ‚úÖ Application is live and publicly accessible

üîó **Access your application:** $PUBLIC_URL

---
*Deployed via ArgoCD | Exposed via ngrok*"
else
    echo "‚ö†Ô∏è  Could not post to PR (PR_NUMBER or PUBLIC_URL missing)"
fi

echo "===== Bolt Complete ====="

