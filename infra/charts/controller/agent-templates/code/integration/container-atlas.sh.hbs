#!/bin/sh
# Atlas - Long-Running PR Guardian
# Continuously monitors PR until merged or closed

set -e

MODE="${ATLAS_MODE:-guardian}"
MAX_CYCLES="${ATLAS_MAX_CYCLES:-0}"
CYCLE_COUNT=0

echo "üî± Atlas: Starting PR guardian for task {{task_id}} (mode: $MODE)"

# Source common setup from shared functions
source /agent-templates/shared_task-setup-functions.sh 2>/dev/null || {
    # Minimal fallback if shared functions unavailable
    setup_github_auth() { echo "Setting up GitHub auth..."; }
    clone_repository() { echo "Cloning repository..."; }
}

# Setup GitHub authentication
setup_github_auth

# Get PR from environment or discover via task label
PR_NUMBER="${PR_NUMBER:-}"
if [ -z "$PR_NUMBER" ]; then
    TASK_LABEL="task-{{task_id}}"
    PR_NUMBER=$(gh pr list --label "$TASK_LABEL" --json number --jq '.[0].number' 2>/dev/null || echo "")
fi

if [ -z "$PR_NUMBER" ]; then
    echo "‚ö†Ô∏è No PR found yet - waiting for PR creation..."
    # Wait for PR to be created (up to 10 minutes)
    for i in $(seq 1 60); do
        sleep 10
        PR_NUMBER=$(gh pr list --label "$TASK_LABEL" --json number --jq '.[0].number' 2>/dev/null || echo "")
        if [ -n "$PR_NUMBER" ]; then
            echo "‚úÖ Found PR #$PR_NUMBER"
            break
        fi
    done
    
    if [ -z "$PR_NUMBER" ]; then
        echo "‚ùå No PR created after 10 minutes - exiting"
        exit 1
    fi
fi

echo "üî± Atlas monitoring PR #$PR_NUMBER"

# Clone repo once for the entire session
REPO_DIR="/workspace/repo"
git clone "{{repository_url}}" "$REPO_DIR"
cd "$REPO_DIR"

# Polling interval (seconds)
if [ "$MODE" = "integration-gate" ]; then
    POLL_INTERVAL="${ATLAS_POLL_INTERVAL:-30}"
else
    POLL_INTERVAL="${ATLAS_POLL_INTERVAL:-60}"
fi
LAST_CHECK_TIMESTAMP=$(date +%s)

# Main guardian loop
while true; do
    echo "üîç [$(date -u +%Y-%m-%dT%H:%M:%SZ)] Checking PR #$PR_NUMBER status..."
    
    # Get PR state
    PR_STATE=$(gh pr view "$PR_NUMBER" --json state,merged,mergeable,mergeStateStatus,isDraft,statusCheckRollup --jq '.' 2>/dev/null || echo "{}")
    
    STATE=$(echo "$PR_STATE" | jq -r '.state // "UNKNOWN"')
    MERGED=$(echo "$PR_STATE" | jq -r '.merged // false')
    MERGEABLE=$(echo "$PR_STATE" | jq -r '.mergeable // "UNKNOWN"')
    MERGE_STATE=$(echo "$PR_STATE" | jq -r '.mergeStateStatus // "UNKNOWN"')
    IS_DRAFT=$(echo "$PR_STATE" | jq -r '.isDraft // false')
    
    # Exit conditions
    if [ "$STATE" = "CLOSED" ] || [ "$MERGED" = "true" ]; then
        if [ "$MERGED" = "true" ]; then
            echo "‚úÖ PR #$PR_NUMBER merged successfully - Atlas guardian exiting"
            gh pr comment "$PR_NUMBER" --body "## üî± Atlas: PR Guardian Complete

PR successfully merged at $(date -u +%Y-%m-%dT%H:%M:%SZ)

**Final Status:**
- State: MERGED
- All quality gates: PASSED
- Atlas monitoring duration: $(($(date +%s) - LAST_CHECK_TIMESTAMP))s

Atlas guardian shutting down. üéâ"
        else
            echo "‚ÑπÔ∏è PR #$PR_NUMBER closed without merge - Atlas guardian exiting"
        fi
        exit 0
    fi
    
    # Skip draft PRs
    if [ "$IS_DRAFT" = "true" ]; then
        echo "üìù PR is draft - skipping checks"
        sleep "$POLL_INTERVAL"
        continue
    fi

    
    # 1. Check for merge conflicts
    if [ "$MERGEABLE" = "CONFLICTING" ] || [ "$MERGE_STATE" = "dirty" ]; then
        echo "‚ö†Ô∏è Merge conflicts detected - resolving..."
        
        PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName')
        PR_BASE=$(gh pr view "$PR_NUMBER" --json baseRefName --jq '.baseRefName')
        
        git fetch origin "$PR_BRANCH" "$PR_BASE"
        git checkout "$PR_BRANCH"
        
        # Attempt automatic rebase
        if git rebase "origin/$PR_BASE"; then
            git push --force-with-lease origin "$PR_BRANCH"
            gh pr comment "$PR_NUMBER" --body "## üî± Atlas: Conflicts Resolved

Automatically rebased \`$PR_BRANCH\` onto \`$PR_BASE\` at $(date -u +%Y-%m-%dT%H:%M:%SZ)

All conflicts resolved. PR is now clean and ready for review."
            echo "‚úÖ Conflicts resolved automatically"
        else
            # Manual resolution needed
            echo "‚ö†Ô∏è Manual conflict resolution required"
            CONFLICT_FILES=$(git diff --name-only --diff-filter=U)
            
            gh pr comment "$PR_NUMBER" --body "## üî± Atlas: Manual Conflict Resolution Needed

Automatic rebase failed. Conflicts in:
\`\`\`
$CONFLICT_FILES
\`\`\`

Atlas will attempt intelligent resolution..."
            
            # Abort failed rebase
            git rebase --abort
            
            # TODO: Implement intelligent conflict resolution via Claude
            # For now, just report and continue monitoring
            echo "‚ö†Ô∏è Conflicts require manual intervention - continuing to monitor"
        fi
    fi
    
    # 2. Check for CI failures
    STATUS_CHECKS=$(echo "$PR_STATE" | jq -r '.statusCheckRollup[]? | select(.conclusion == "FAILURE") | .name' 2>/dev/null || echo "")
    if [ -n "$STATUS_CHECKS" ]; then
        echo "‚ö†Ô∏è CI failures detected: $STATUS_CHECKS"
        
        # Get failed workflow runs
        FAILED_RUNS=$(gh api "/repos/{{repository_owner}}/{{repository_name}}/actions/runs?event=pull_request&branch=$PR_BRANCH&status=failure" --jq '.workflow_runs[0:3] | .[] | "\(.id) \(.name)"' 2>/dev/null || echo "")
        
        if [ -n "$FAILED_RUNS" ]; then
            echo "$FAILED_RUNS" | while read -r run_id run_name; do
                echo "üìã Analyzing failure: $run_name (run $run_id)"
                
                # Get logs for failed run
                gh run view "$run_id" --log > "/tmp/ci-failure-$run_id.log" 2>/dev/null || true
                
                # TODO: Implement intelligent CI failure recovery
                # For now, just report
                gh pr comment "$PR_NUMBER" --body "## üî± Atlas: CI Failure Detected

**Failed Check:** $run_name
**Run ID:** $run_id
**Time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)

Logs captured. Investigating root cause..."
            done
        fi
    fi
    
    # 3. Check for ANY new comments (filter for Bugbot in script, not at API level)
    REPO_OWNER="${REPOSITORY_OWNER:-}"
    REPO_NAME="${REPOSITORY_NAME:-}"
    
    if [ -z "$REPO_OWNER" ] || [ -z "$REPO_NAME" ]; then
        echo "‚ö†Ô∏è Repository owner/name not available, skipping comment checks"
    else
        ALL_COMMENTS_JSON=$(gh api "/repos/$REPO_OWNER/$REPO_NAME/issues/$PR_NUMBER/comments?per_page=20" --jq '[.[] | select(.created_at > "'$(date -u -d "@$LAST_CHECK_TIMESTAMP" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -r "$LAST_CHECK_TIMESTAMP" +%Y-%m-%dT%H:%M:%SZ)'")]' 2>/dev/null || echo "[]")
        
        # Filter for Bugbot comments in the script
        BUGBOT_COMMENTS_JSON=$(echo "$ALL_COMMENTS_JSON" | jq '[.[] | select(.user.login == "cursor[bot]" or .user.login == "bugbot[bot]" or (.body | test("üî¥|üü°|üí°")))]')
        BUGBOT_COMMENTS=$(echo "$BUGBOT_COMMENTS_JSON" | jq 'length')
        
        if [ "$BUGBOT_COMMENTS" -gt 0 ]; then
            echo "üêõ New Bugbot/quality feedback detected ($BUGBOT_COMMENTS comments)"
        
        # Process each Bugbot comment
        echo "$BUGBOT_COMMENTS_JSON" | jq -c '.[]' | while read -r comment; do
            COMMENT_ID=$(echo "$comment" | jq -r '.id')
            COMMENT_BODY=$(echo "$comment" | jq -r '.body')
            COMMENT_URL=$(echo "$comment" | jq -r '.html_url')
            
            echo "üìù Processing Bugbot comment ID: $COMMENT_ID"
            
            # Extract issues from Bugbot comment
            HAS_ERRORS=$(echo "$COMMENT_BODY" | grep -c "üî¥" || true)
            HAS_WARNINGS=$(echo "$COMMENT_BODY" | grep -c "üü°" || true)
            HAS_SUGGESTIONS=$(echo "$COMMENT_BODY" | grep -c "üí°" || true)
            
            # Only fix if there are actual issues
            if [ "$HAS_ERRORS" -gt 0 ] || [ "$HAS_WARNINGS" -gt 0 ]; then
                echo "üîß Found $HAS_ERRORS errors and $HAS_WARNINGS warnings - initiating fix"
                
                # Fetch current PR branch
                PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName')
                git fetch origin "$PR_BRANCH"
                git checkout "$PR_BRANCH"
                git pull origin "$PR_BRANCH"
                
                # Extract comment body and create comprehensive prompt file
                cat > /tmp/BUGBOT_PROMPT.md << 'PROMPT_EOF'
# üêõ Quality Feedback Resolution

## Instructions
You are fixing issues identified in automated quality feedback. Your mission:

1. **Read the feedback carefully** - Understand what needs to be fixed
2. **Make targeted fixes** - Address only the specific issues mentioned
3. **Preserve functionality** - Don't break what already works
4. **Test your changes** - Verify the fixes resolve the issues
5. **Commit with clear message** - Explain what you fixed and why

## Quality Feedback

PROMPT_EOF
                # Append actual comment body
                echo "$COMMENT_BODY" >> /tmp/BUGBOT_PROMPT.md
                
                cat >> /tmp/BUGBOT_PROMPT.md << 'FOOTER_EOF'

## Context
- PR #$PR_NUMBER
- Branch: $PR_BRANCH  
- Feedback source: $COMMENT_URL

## Success Criteria
- ‚úÖ All critical errors (üî¥) fixed
- ‚úÖ All warnings (üü°) resolved
- ‚úÖ Existing functionality preserved
- ‚úÖ Tests pass (if applicable)
- ‚úÖ Code follows project standards

Focus on surgical, minimal changes to address the specific feedback.
FOOTER_EOF
                
                # Detect available CLI (try all supported CLIs)
                CLI_CMD=""
                CLI_NAME=""
                
                if command -v claude >/dev/null 2>&1; then
                    CLI_CMD="claude --output-format stream-json --input-format stream-json"
                    CLI_NAME="Claude"
                elif command -v codex >/dev/null 2>&1; then
                    CLI_CMD="codex"
                    CLI_NAME="Codex"
                elif command -v opencode >/dev/null 2>&1; then
                    CLI_CMD="opencode"
                    CLI_NAME="OpenCode"
                elif command -v cursor-agent >/dev/null 2>&1; then
                    CLI_CMD="cursor-agent"
                    CLI_NAME="Cursor"
                elif command -v factory-cli >/dev/null 2>&1; then
                    CLI_CMD="factory-cli"
                    CLI_NAME="Factory"
                else
                    echo "‚ö†Ô∏è No supported CLI found (claude, codex, opencode, cursor-agent, factory-cli)"
                    CLI_CMD=""
                fi
                
                if [ -n "$CLI_CMD" ]; then
                    echo "ü§ñ Using $CLI_NAME CLI to generate fixes..."
                    
                    # Run CLI with the prompt (format depends on CLI type)
                    if [ "$CLI_NAME" = "Claude" ]; then
                        # Claude uses stream-json format
                        $CLI_CMD << CLI_INPUT | tee /tmp/cli-output.log
{
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "type": "text",
        "text": "$(cat /tmp/BUGBOT_PROMPT.md | jq -Rs .)"
      }
    ]
  }
}
CLI_INPUT
                    else
                        # Other CLIs: use standard input with prompt file
                        echo "$(cat /tmp/BUGBOT_PROMPT.md)" | $CLI_CMD 2>&1 | tee /tmp/cli-output.log
                    fi
                    
                    # Check if any files were modified
                    if [ -n "$(git status --porcelain)" ]; then
                        echo "‚úÖ $CLI_NAME applied fixes successfully"
                        
                        # Commit the changes
                        git add -A
                        git commit -m "fix: address quality feedback from comment #$COMMENT_ID

Automated fixes for issues identified in feedback:
- Fixed $HAS_ERRORS critical errors
- Resolved $HAS_WARNINGS warnings

Feedback: $COMMENT_URL
Fixed by Atlas Guardian using $CLI_NAME"
                        
                        # Push the fixes
                        git push origin "$PR_BRANCH"
                        
                        # Post success comment
                        gh pr comment "$PR_NUMBER" --body "## üî± Atlas: Quality Issues Resolved

Successfully addressed feedback from [comment #$COMMENT_ID]($COMMENT_URL):
- ‚úÖ Fixed **$HAS_ERRORS** critical errors
- ‚úÖ Resolved **$HAS_WARNINGS** warnings
${HAS_SUGGESTIONS:+- ‚ÑπÔ∏è Reviewed **$HAS_SUGGESTIONS** suggestions}

Changes have been pushed to branch \`$PR_BRANCH\`.

### Resolution Method
- CLI: **$CLI_NAME**
- Strategy: Targeted fixes for identified issues
- Preserved existing functionality

*Resolved automatically by Atlas Guardian at $(date -u +%Y-%m-%dT%H:%M:%SZ)*"
                        
                    else
                        echo "‚ÑπÔ∏è No changes needed or $CLI_NAME unable to determine fixes"
                        
                        # Post investigation comment
                        gh pr comment "$PR_NUMBER" --body "## üî± Atlas: Quality Feedback Reviewed

Analyzed [feedback]($COMMENT_URL) using $CLI_NAME but no automatic fixes could be applied.

This may require manual intervention for:
- Complex architectural changes
- Issues requiring human judgment
- Problems outside the codebase

*Reviewed by Atlas Guardian at $(date -u +%Y-%m-%dT%H:%M:%SZ)*"
                    fi
                    
                else
                    echo "‚ö†Ô∏è No CLI available - falling back to basic acknowledgment"
                    
                    # Basic acknowledgment without CLI
                    gh pr comment "$PR_NUMBER" --body "## üî± Atlas: Quality Feedback Acknowledged

Detected feedback from [comment #$COMMENT_ID]($COMMENT_URL) with:
- üî¥ $HAS_ERRORS critical errors
- üü° $HAS_WARNINGS warnings
${HAS_SUGGESTIONS:+- üí° $HAS_SUGGESTIONS suggestions}

**Note:** Automatic resolution requires a supported CLI to be available.
Manual intervention may be needed to address these issues.

*Detected by Atlas Guardian at $(date -u +%Y-%m-%dT%H:%M:%SZ)*"
                fi
                
            elif [ "$HAS_SUGGESTIONS" -gt 0 ]; then
                echo "üí° Only suggestions found - acknowledging without changes"
                
                # Just acknowledge suggestions
                gh pr comment "$PR_NUMBER" --body "## üî± Atlas: Quality Suggestions Noted

Received $HAS_SUGGESTIONS suggestion(s) from [comment #$COMMENT_ID]($COMMENT_URL).

These are non-critical improvements that don't block the PR.

*Acknowledged by Atlas Guardian at $(date -u +%Y-%m-%dT%H:%M:%SZ)*"
            fi
        done
        fi
    fi
    
    # 4. Check if ready to merge
    if [ "$MERGEABLE" = "MERGEABLE" ] && [ "$MERGE_STATE" = "clean" ]; then
        # Check if all required checks passed
        ALL_CHECKS_PASSED=$(echo "$PR_STATE" | jq -r '[.statusCheckRollup[]? | select(.conclusion != "SUCCESS" and .conclusion != "SKIPPED")] | length' 2>/dev/null || echo "1")
        
        if [ "$ALL_CHECKS_PASSED" = "0" ]; then
            echo "‚úÖ PR is ready to merge!"
            
            # Check if this is part of a multi-task play
            PLAY_WORKFLOW=$(gh pr view "$PR_NUMBER" --json labels --jq '.labels[]? | select(.name | startswith("workflow-")) | .name' 2>/dev/null || echo "")
            
            if [ -n "$PLAY_WORKFLOW" ] && [ "$MODE" != "integration-gate" ]; then
                echo "üéØ Part of play workflow: $PLAY_WORKFLOW"
                echo "‚è≥ Waiting for final merge coordinator to handle merge order..."
                # Don't auto-merge - let the final coordinator handle it
            else
                echo "üöÄ Auto-merging PR during Atlas integration gate..."
                
                if gh pr merge "$PR_NUMBER" --squash --delete-branch; then
                    echo "‚úÖ PR merged successfully!"
                    exit 0
                else
                    echo "‚ö†Ô∏è Merge failed - will retry on next cycle"
                fi
            fi
        else
            echo "‚è≥ Waiting for checks to pass (failed: $ALL_CHECKS_PASSED)"
        fi
    else
        echo "‚è≥ PR not ready (mergeable: $MERGEABLE, state: $MERGE_STATE)"
    fi
    
    # Update last check timestamp
    LAST_CHECK_TIMESTAMP=$(date +%s)
    
    # Sleep until next poll
    CYCLE_COUNT=$((CYCLE_COUNT + 1))

    if [ "$MODE" = "integration-gate" ] && [ "$MAX_CYCLES" -gt 0 ] && [ "$CYCLE_COUNT" -ge "$MAX_CYCLES" ]; then
        echo "‚è≥ Atlas integration gate timed out after $CYCLE_COUNT cycles"
        exit 1
    fi

    echo "üí§ Sleeping for ${POLL_INTERVAL}s..."
    sleep "$POLL_INTERVAL"
done

