#!/bin/sh
# Atlas - Long-Running PR Guardian
# Continuously monitors PR until merged or closed

set -e

MODE="${ATLAS_MODE:-guardian}"
MAX_CYCLES="${ATLAS_MAX_CYCLES:-0}"
CYCLE_COUNT=0

echo "üî± Atlas: Starting PR guardian for task {{task_id}} (mode: $MODE)"

# Source common setup from shared functions
source /agent-templates/shared_task-setup-functions.sh 2>/dev/null || {
    # Minimal fallback if shared functions unavailable
    setup_github_auth() { echo "Setting up GitHub auth..."; }
    clone_repository() { echo "Cloning repository..."; }
}

# Setup GitHub authentication
setup_github_auth

# Get PR from environment or discover via task label
PR_NUMBER="${PR_NUMBER:-}"
if [ -z "$PR_NUMBER" ]; then
    TASK_LABEL="task-{{task_id}}"
    PR_NUMBER=$(gh pr list --label "$TASK_LABEL" --json number --jq '.[0].number' 2>/dev/null || echo "")
fi

if [ -z "$PR_NUMBER" ]; then
    echo "‚ö†Ô∏è No PR found yet - waiting for PR creation..."
    # Wait for PR to be created (up to 10 minutes)
    for i in $(seq 1 60); do
        sleep 10
        PR_NUMBER=$(gh pr list --label "$TASK_LABEL" --json number --jq '.[0].number' 2>/dev/null || echo "")
        if [ -n "$PR_NUMBER" ]; then
            echo "‚úÖ Found PR #$PR_NUMBER"
            break
        fi
    done
    
    if [ -z "$PR_NUMBER" ]; then
        echo "‚ùå No PR created after 10 minutes - exiting"
        exit 1
    fi
fi

echo "üî± Atlas monitoring PR #$PR_NUMBER"

# Clone repo once for the entire session
REPO_DIR="/workspace/repo"
git clone "{{repository_url}}" "$REPO_DIR"
cd "$REPO_DIR"

# Polling interval (seconds)
if [ "$MODE" = "integration-gate" ]; then
    POLL_INTERVAL="${ATLAS_POLL_INTERVAL:-30}"
else
    POLL_INTERVAL="${ATLAS_POLL_INTERVAL:-60}"
fi
LAST_CHECK_TIMESTAMP=$(date +%s)

# Main guardian loop
while true; do
    echo "üîç [$(date -u +%Y-%m-%dT%H:%M:%SZ)] Checking PR #$PR_NUMBER status..."
    
    # Get PR state
    PR_STATE=$(gh pr view "$PR_NUMBER" --json state,merged,mergeable,mergeStateStatus,isDraft,statusCheckRollup --jq '.' 2>/dev/null || echo "{}")
    
    STATE=$(echo "$PR_STATE" | jq -r '.state // "UNKNOWN"')
    MERGED=$(echo "$PR_STATE" | jq -r '.merged // false')
    MERGEABLE=$(echo "$PR_STATE" | jq -r '.mergeable // "UNKNOWN"')
    MERGE_STATE=$(echo "$PR_STATE" | jq -r '.mergeStateStatus // "UNKNOWN"')
    IS_DRAFT=$(echo "$PR_STATE" | jq -r '.isDraft // false')
    
    # Exit conditions
    if [ "$STATE" = "CLOSED" ] || [ "$MERGED" = "true" ]; then
        if [ "$MERGED" = "true" ]; then
            echo "‚úÖ PR #$PR_NUMBER merged successfully - Atlas guardian exiting"
            gh pr comment "$PR_NUMBER" --body "## üî± Atlas: PR Guardian Complete

PR successfully merged at $(date -u +%Y-%m-%dT%H:%M:%SZ)

**Final Status:**
- State: MERGED
- All quality gates: PASSED
- Atlas monitoring duration: $(($(date +%s) - LAST_CHECK_TIMESTAMP))s

Atlas guardian shutting down. üéâ"
        else
            echo "‚ÑπÔ∏è PR #$PR_NUMBER closed without merge - Atlas guardian exiting"
        fi
        exit 0
    fi
    
    # Skip draft PRs
    if [ "$IS_DRAFT" = "true" ]; then
        echo "üìù PR is draft - skipping checks"
        sleep "$POLL_INTERVAL"
        continue
    fi

    
    # 1. Check for merge conflicts
    if [ "$MERGEABLE" = "CONFLICTING" ] || [ "$MERGE_STATE" = "dirty" ]; then
        echo "‚ö†Ô∏è Merge conflicts detected - resolving..."
        
        PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName')
        PR_BASE=$(gh pr view "$PR_NUMBER" --json baseRefName --jq '.baseRefName')
        
        git fetch origin "$PR_BRANCH" "$PR_BASE"
        git checkout "$PR_BRANCH"
        
        # Attempt automatic rebase
        if git rebase "origin/$PR_BASE"; then
            git push --force-with-lease origin "$PR_BRANCH"
            gh pr comment "$PR_NUMBER" --body "## üî± Atlas: Conflicts Resolved

Automatically rebased \`$PR_BRANCH\` onto \`$PR_BASE\` at $(date -u +%Y-%m-%dT%H:%M:%SZ)

All conflicts resolved. PR is now clean and ready for review."
            echo "‚úÖ Conflicts resolved automatically"
        else
            # Manual resolution needed
            echo "‚ö†Ô∏è Manual conflict resolution required"
            CONFLICT_FILES=$(git diff --name-only --diff-filter=U)
            
            gh pr comment "$PR_NUMBER" --body "## üî± Atlas: Manual Conflict Resolution Needed

Automatic rebase failed. Conflicts in:
\`\`\`
$CONFLICT_FILES
\`\`\`

Atlas will attempt intelligent resolution..."
            
            # Abort failed rebase
            git rebase --abort
            
            # TODO: Implement intelligent conflict resolution via Claude
            # For now, just report and continue monitoring
            echo "‚ö†Ô∏è Conflicts require manual intervention - continuing to monitor"
        fi
    fi
    
    # 2. Check for CI failures
    STATUS_CHECKS=$(echo "$PR_STATE" | jq -r '.statusCheckRollup[]? | select(.conclusion == "FAILURE") | .name' 2>/dev/null || echo "")
    if [ -n "$STATUS_CHECKS" ]; then
        echo "‚ö†Ô∏è CI failures detected: $STATUS_CHECKS"
        
        # Get failed workflow runs
        FAILED_RUNS=$(gh api "/repos/{{repository_owner}}/{{repository_name}}/actions/runs?event=pull_request&branch=$PR_BRANCH&status=failure" --jq '.workflow_runs[0:3] | .[] | "\(.id) \(.name)"' 2>/dev/null || echo "")
        
        if [ -n "$FAILED_RUNS" ]; then
            echo "$FAILED_RUNS" | while read -r run_id run_name; do
                echo "üìã Analyzing failure: $run_name (run $run_id)"
                
                # Get logs for failed run
                gh run view "$run_id" --log > "/tmp/ci-failure-$run_id.log" 2>/dev/null || true
                
                # TODO: Implement intelligent CI failure recovery
                # For now, just report
                gh pr comment "$PR_NUMBER" --body "## üî± Atlas: CI Failure Detected

**Failed Check:** $run_name
**Run ID:** $run_id
**Time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)

Logs captured. Investigating root cause..."
            done
        fi
    fi
    
    # 3. Check for Bugbot feedback
    BUGBOT_COMMENTS_JSON=$(gh api "/repos/{{repository_owner}}/{{repository_name}}/issues/$PR_NUMBER/comments?per_page=10" --jq '[.[] | select(.user.login == "cursor[bot]" or .user.login == "bugbot[bot]") | select(.created_at > "'$(date -u -d "@$LAST_CHECK_TIMESTAMP" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -r "$LAST_CHECK_TIMESTAMP" +%Y-%m-%dT%H:%M:%SZ)'")]' 2>/dev/null || echo "[]")
    BUGBOT_COMMENTS=$(echo "$BUGBOT_COMMENTS_JSON" | jq 'length')
    
    if [ "$BUGBOT_COMMENTS" -gt 0 ]; then
        echo "üêõ New Bugbot feedback detected ($BUGBOT_COMMENTS comments)"
        
        # Process each Bugbot comment
        echo "$BUGBOT_COMMENTS_JSON" | jq -c '.[]' | while read -r comment; do
            COMMENT_ID=$(echo "$comment" | jq -r '.id')
            COMMENT_BODY=$(echo "$comment" | jq -r '.body')
            COMMENT_URL=$(echo "$comment" | jq -r '.html_url')
            
            echo "üìù Processing Bugbot comment ID: $COMMENT_ID"
            
            # Extract issues from Bugbot comment
            HAS_ERRORS=$(echo "$COMMENT_BODY" | grep -c "üî¥" || true)
            HAS_WARNINGS=$(echo "$COMMENT_BODY" | grep -c "üü°" || true)
            HAS_SUGGESTIONS=$(echo "$COMMENT_BODY" | grep -c "üí°" || true)
            
            # Only fix if there are actual issues
            if [ "$HAS_ERRORS" -gt 0 ] || [ "$HAS_WARNINGS" -gt 0 ]; then
                echo "üîß Found $HAS_ERRORS errors and $HAS_WARNINGS warnings - initiating fix"
                
                # Fetch current PR branch
                PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName')
                git fetch origin "$PR_BRANCH"
                git checkout "$PR_BRANCH"
                git pull origin "$PR_BRANCH"
                
                # Create fix context for Claude
                cat > /tmp/bugbot-fix-request.md << EOF
# Bugbot Issue Resolution Request

## PR Information
- PR #$PR_NUMBER
- Branch: $PR_BRANCH
- Comment: $COMMENT_URL

## Bugbot Feedback
$COMMENT_BODY

## Instructions
Please fix the issues identified by Bugbot:
1. Address all üî¥ errors (critical issues that must be fixed)
2. Address all üü° warnings (important issues that should be fixed)
3. Consider üí° suggestions (improvements that could be made)
4. Make minimal, targeted changes to fix only these specific issues
5. Ensure fixes don't break existing functionality
6. Follow the coding standards and patterns already in the codebase

Focus on fixing the actual issues, not refactoring or adding new features.
EOF
                
                # Use Claude to generate the fix
                if command -v claude >/dev/null 2>&1; then
                    echo "ü§ñ Using Claude to generate fixes..."
                    
                    # Run Claude with the fix request
                    claude --output-format stream-json --input-format stream-json << CLAUDE_INPUT | tee /tmp/claude-output.log
{
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "type": "text",
        "text": "$(cat /tmp/bugbot-fix-request.md | jq -Rs .)"
      }
    ]
  }
}
CLAUDE_INPUT
                    
                    # Check if any files were modified
                    if [ -n "$(git status --porcelain)" ]; then
                        echo "‚úÖ Claude has applied fixes"
                        
                        # Commit the changes
                        git add -A
                        git commit -m "fix: address Bugbot feedback from comment #$COMMENT_ID

Automated fixes for issues identified by Bugbot:
- Fixed $HAS_ERRORS critical errors
- Resolved $HAS_WARNINGS warnings

Bugbot comment: $COMMENT_URL
Fixed by Atlas Guardian using Claude"
                        
                        # Push the fixes
                        git push origin "$PR_BRANCH"
                        
                        # Post success comment
                        gh pr comment "$PR_NUMBER" --body "## üî± Atlas: Bugbot Issues Resolved

Successfully addressed feedback from [Bugbot comment]($COMMENT_URL):
- ‚úÖ Fixed **$HAS_ERRORS** critical errors
- ‚úÖ Resolved **$HAS_WARNINGS** warnings
${HAS_SUGGESTIONS:+- ‚ÑπÔ∏è Reviewed **$HAS_SUGGESTIONS** suggestions}

Changes have been pushed to branch \`$PR_BRANCH\`.

### Summary of Changes
- Applied targeted fixes for identified issues
- Maintained existing functionality
- Followed project coding standards

*Resolved automatically by Atlas Guardian at $(date -u +%Y-%m-%dT%H:%M:%SZ)*"
                        
                    else
                        echo "‚ÑπÔ∏è No changes needed or Claude unable to determine fixes"
                        
                        # Post investigation comment
                        gh pr comment "$PR_NUMBER" --body "## üî± Atlas: Bugbot Feedback Reviewed

Analyzed [Bugbot feedback]($COMMENT_URL) but no automatic fixes could be applied.

This may require manual intervention for:
- Complex architectural changes
- Issues requiring human judgment
- Problems outside the codebase

*Reviewed by Atlas Guardian at $(date -u +%Y-%m-%dT%H:%M:%SZ)*"
                    fi
                    
                else
                    echo "‚ö†Ô∏è Claude CLI not available - falling back to basic acknowledgment"
                    
                    # Basic acknowledgment without Claude
                    gh pr comment "$PR_NUMBER" --body "## üî± Atlas: Bugbot Feedback Acknowledged

Detected feedback from [Bugbot]($COMMENT_URL) with:
- üî¥ $HAS_ERRORS critical errors
- üü° $HAS_WARNINGS warnings
${HAS_SUGGESTIONS:+- üí° $HAS_SUGGESTIONS suggestions}

**Note:** Automatic resolution requires Claude CLI to be available.
Manual intervention may be needed to address these issues.

*Detected by Atlas Guardian at $(date -u +%Y-%m-%dT%H:%M:%SZ)*"
                fi
                
            elif [ "$HAS_SUGGESTIONS" -gt 0 ]; then
                echo "üí° Only suggestions found - acknowledging without changes"
                
                # Just acknowledge suggestions
                gh pr comment "$PR_NUMBER" --body "## üî± Atlas: Bugbot Suggestions Noted

Received $HAS_SUGGESTIONS suggestion(s) from [Bugbot]($COMMENT_URL).

These are non-critical improvements that don't block the PR.

*Acknowledged by Atlas Guardian at $(date -u +%Y-%m-%dT%H:%M:%SZ)*"
            fi
        done
    fi
    
    # 4. Check if ready to merge
    if [ "$MERGEABLE" = "MERGEABLE" ] && [ "$MERGE_STATE" = "clean" ]; then
        # Check if all required checks passed
        ALL_CHECKS_PASSED=$(echo "$PR_STATE" | jq -r '[.statusCheckRollup[]? | select(.conclusion != "SUCCESS" and .conclusion != "SKIPPED")] | length' 2>/dev/null || echo "1")
        
        if [ "$ALL_CHECKS_PASSED" = "0" ]; then
            echo "‚úÖ PR is ready to merge!"
            
            # Check if this is part of a multi-task play
            PLAY_WORKFLOW=$(gh pr view "$PR_NUMBER" --json labels --jq '.labels[]? | select(.name | startswith("workflow-")) | .name' 2>/dev/null || echo "")
            
            if [ -n "$PLAY_WORKFLOW" ] && [ "$MODE" != "integration-gate" ]; then
                echo "üéØ Part of play workflow: $PLAY_WORKFLOW"
                echo "‚è≥ Waiting for final merge coordinator to handle merge order..."
                # Don't auto-merge - let the final coordinator handle it
            else
                echo "üöÄ Auto-merging PR during Atlas integration gate..."
                
                if gh pr merge "$PR_NUMBER" --squash --delete-branch; then
                    echo "‚úÖ PR merged successfully!"
                    exit 0
                else
                    echo "‚ö†Ô∏è Merge failed - will retry on next cycle"
                fi
            fi
        else
            echo "‚è≥ Waiting for checks to pass (failed: $ALL_CHECKS_PASSED)"
        fi
    else
        echo "‚è≥ PR not ready (mergeable: $MERGEABLE, state: $MERGE_STATE)"
    fi
    
    # Update last check timestamp
    LAST_CHECK_TIMESTAMP=$(date +%s)
    
    # Sleep until next poll
    CYCLE_COUNT=$((CYCLE_COUNT + 1))

    if [ "$MODE" = "integration-gate" ] && [ "$MAX_CYCLES" -gt 0 ] && [ "$CYCLE_COUNT" -ge "$MAX_CYCLES" ]; then
        echo "‚è≥ Atlas integration gate timed out after $CYCLE_COUNT cycles"
        exit 1
    fi

    echo "üí§ Sleeping for ${POLL_INTERVAL}s..."
    sleep "$POLL_INTERVAL"
done

