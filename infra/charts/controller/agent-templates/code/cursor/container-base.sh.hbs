#!/bin/bash
set -euo pipefail

# =========================================================================
# Environment bootstrapping
# =========================================================================

{{#if agent_banner}}
echo "{{agent_banner}}"
{{else}}
echo "ğŸ”§ Initialising Cursor environment"
{{/if}}

if [ -f "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi

if [ -f "/root/.cargo/env" ]; then
  . "/root/.cargo/env"
fi

if command -v rustup >/dev/null 2>&1; then
  rustup default stable 2>/dev/null || true
fi

if [ -d "$HOME/.rustup/downloads" ]; then
  find "$HOME/.rustup/downloads" -mindepth 1 -delete 2>/dev/null || true
fi

# Ensure Node.js is available at the path expected by cursor-agent
if ! command -v node >/dev/null 2>&1; then
  echo "âŒ Node.js binary not found; cursor-agent cannot run"
  exit 1
fi

CURSOR_RUNTIME_BIN="/tmp/cursor-agent-bin"
CURSOR_AGENT_ROOT="/usr/local/lib/cursor-agent"
CURSOR_AGENT_ENTRY="$CURSOR_AGENT_ROOT/index.js"

mkdir -p "$CURSOR_RUNTIME_BIN"
cat >"$CURSOR_RUNTIME_BIN/cursor-agent" <<'WRAPPER'
#!/bin/bash
set -euo pipefail

if ! command -v node >/dev/null 2>&1; then
  echo "âŒ Node.js binary not found in PATH"
  exit 1
fi

NODE_BIN="$(command -v node)"
CURSOR_AGENT_ROOT="/usr/local/lib/cursor-agent"
CURSOR_AGENT_ENTRY="$CURSOR_AGENT_ROOT/index.js"

if [ ! -f "$CURSOR_AGENT_ENTRY" ]; then
  echo "âŒ Cursor agent entrypoint not found at $CURSOR_AGENT_ENTRY"
  exit 1
fi

exec "$NODE_BIN" "$CURSOR_AGENT_ENTRY" "$@"
WRAPPER
chmod +x "$CURSOR_RUNTIME_BIN/cursor-agent"
export PATH="$CURSOR_RUNTIME_BIN:$PATH"

if [ ! -x "/usr/local/bin/node" ]; then
  echo "â„¹ï¸ Falling back to cursor-agent wrapper; /usr/local/bin/node missing"
fi

echo "PATH: $PATH"

# =========================================================================
# Docker sidecar cleanup function
# =========================================================================
stop_docker_sidecar() {
  if [ ! -S /var/run/docker.sock ]; then
    return
  fi

  echo "ğŸ›‘ Stopping Docker sidecar"

  if command -v pkill >/dev/null 2>&1; then
    pkill dockerd >/dev/null 2>&1 || true
    sleep 1
    if pidof dockerd >/dev/null 2>&1; then
      pkill -9 dockerd >/dev/null 2>&1 || true
    fi
    if pidof docker-init >/dev/null 2>&1; then
      pkill docker-init >/dev/null 2>&1 || true
    fi
  elif command -v killall >/dev/null 2>&1; then
    killall dockerd >/dev/null 2>&1 || true
  else
    PID=$(pidof dockerd 2>/dev/null || true)
    if [ -n "$PID" ]; then
      kill "$PID" >/dev/null 2>&1 || true
    fi
    PID_INIT=$(pidof docker-init 2>/dev/null || true)
    if [ -n "$PID_INIT" ]; then
      kill "$PID_INIT" >/dev/null 2>&1 || true
    fi
  fi

  for _ in 1 2 3 4 5; do
    if ! pidof dockerd >/dev/null 2>&1 && ! pidof docker-init >/dev/null 2>&1; then
      echo "âœ… Docker sidecar stopped"
      return
    fi
    sleep 1
  done

  REMAINING_DOCKER=$(pidof dockerd 2>/dev/null || true)
  REMAINING_INIT=$(pidof docker-init 2>/dev/null || true)
  echo "âš ï¸ Docker sidecar still running (dockerd: ${REMAINING_DOCKER:-none}, docker-init: ${REMAINING_INIT:-none})"
}

# Set up EXIT trap to ensure Docker sidecar cleanup
trap 'stop_docker_sidecar || true' EXIT

# =========================================================================
# RETRY CONFIGURATION
# =========================================================================
MAX_RETRIES_CONFIG=${CURSOR_MAX_RETRIES:-${EXECUTION_MAX_RETRIES:-5}}
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                    RETRY CONFIGURATION                        â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ğŸ¤– CLI: {{cli_type}}"
echo "ğŸ¯ Model: {{model}}"
echo "ğŸ”„ Maximum Iterations: $MAX_RETRIES_CONFIG"
if [ -n "${CURSOR_MAX_RETRIES:-}" ]; then
  echo "ğŸ“ Source: CURSOR_MAX_RETRIES environment variable"
elif [ -n "${EXECUTION_MAX_RETRIES:-}" ]; then
  echo "ğŸ“ Source: EXECUTION_MAX_RETRIES environment variable"
else
  echo "ğŸ“ Source: Default configuration"
fi
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# =========================================================================
# GitHub App authentication
# =========================================================================

REPO_URL="{{repository_url}}"

if [ -z "${GITHUB_APP_PRIVATE_KEY:-}" ] || [ -z "${GITHUB_APP_ID:-}" ]; then
  echo "âŒ Missing GitHub App credentials"
  exit 1
fi

echo "ğŸ” Authenticating with GitHub App"
TEMP_KEY_FILE="/tmp/github-app-key.pem"
printf '%b' "$GITHUB_APP_PRIVATE_KEY" >"$TEMP_KEY_FILE"
chmod 600 "$TEMP_KEY_FILE"

JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
NOW=$(date +%s)
EXP=$((NOW + 600))
JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
rm -f "$TEMP_KEY_FILE"

parse_repo() {
  local input="$1"
  if echo "$input" | grep -qE '^https://github.com/'; then
    echo "$input" | sed -E 's|https://github.com/([^/]+)/([^/]+?)(\.git)?$|\1 \2|'
  elif echo "$input" | grep -qE '^git@github.com:'; then
    echo "$input" | sed -E 's|git@github.com:([^/]+)/([^/]+?)(\.git)?$|\1 \2|'
  else
    echo "$input" | sed -E 's|\.git$||' | sed -E 's|([^/]+)/([^/]+)|\1 \2|'
  fi
}

read REPO_OWNER REPO_NAME <<<"$(parse_repo "$REPO_URL")"
REPO_HTTP_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}.git"

INSTALLATION_ID=$(curl -s -L \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
  INSTALLATION_ID=$(curl -s -L \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
fi

if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
  echo "âŒ Unable to resolve installation ID for $REPO_OWNER/$REPO_NAME"
  exit 1
fi

GITHUB_TOKEN=$(curl -s -X POST \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')

if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
  echo "âŒ Unable to obtain installation token"
  exit 1
fi

export GITHUB_TOKEN
export GH_TOKEN="$GITHUB_TOKEN"
export GH_HOST="github.com"

export GIT_CONFIG_GLOBAL=/workspace/.gitconfig
CREDENTIALS_FILE=/workspace/.git-credentials
mkdir -p /workspace

git config --global --replace-all credential.helper "store --file=$CREDENTIALS_FILE"
echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > "$CREDENTIALS_FILE"

TOKEN_GENERATED_AT=$(date +%s)

refresh_github_token() {
  echo "ğŸ”„ Refreshing GitHub App token..."

  TEMP_KEY_FILE="/tmp/github-app-key-$$"
  printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
  chmod 600 "$TEMP_KEY_FILE"

  JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  NOW=$(date +%s)
  EXP=$((NOW + 600))
  JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

  rm -f "$TEMP_KEY_FILE"

  NEW_INSTALLATION_ID=$(curl -s -L \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

  if [ "$NEW_INSTALLATION_ID" = "null" ] || [ -z "$NEW_INSTALLATION_ID" ]; then
    NEW_INSTALLATION_ID=$(curl -s -L \
      -H "Authorization: Bearer $JWT_TOKEN" \
      -H "Accept: application/vnd.github+json" \
      "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
  fi

  TOKEN_RESPONSE=$(curl -s -X POST \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/app/installations/$NEW_INSTALLATION_ID/access_tokens")

  NEW_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

  if [ "$NEW_TOKEN" != "null" ] && [ -n "$NEW_TOKEN" ]; then
    export GITHUB_TOKEN="$NEW_TOKEN"
    export GH_TOKEN="$NEW_TOKEN"
    TOKEN_GENERATED_AT=$(date +%s)
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > "$CREDENTIALS_FILE"
    echo "âœ… Token refreshed"
    return 0
  fi

  echo "âŒ Failed to refresh token: $TOKEN_RESPONSE"
  return 1
}

refresh_token_if_needed() {
  if [ -z "$TOKEN_GENERATED_AT" ]; then
    refresh_github_token
    return
  fi

  NOW=$(date +%s)
  TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))

  if [ $TOKEN_AGE -gt 3000 ]; then
    echo "ğŸ”„ Token age: $((TOKEN_AGE / 60)) minutes â€” refreshing"
    refresh_github_token
  fi
}

sanitize_status_message() {
  printf '%s' "$1" | tr '\n' ' ' | tr '\r' ' '
}

resolve_pr_url() {
  if [ -n "${PR_URL:-}" ]; then
    printf '%s' "$PR_URL"
    return
  fi

  if [ -n "${PR_NUMBER:-}" ] && [ -n "${REPO_OWNER:-}" ] && [ -n "${REPO_NAME:-}" ]; then
    printf 'https://github.com/%s/%s/pull/%s' "$REPO_OWNER" "$REPO_NAME" "$PR_NUMBER"
    return
  fi

  if command -v gh >/dev/null 2>&1; then
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || printf '')
    if [ -n "$current_branch" ]; then
      local pr_url
      pr_url=$(gh pr list --state all --head "$current_branch" --json url --jq '.[0].url' 2>/dev/null || printf '')
      if [ -n "$pr_url" ]; then
        printf '%s' "$pr_url"
        return
      fi
    fi
  fi

  printf ''
}

patch_coderun_status() {
  local phase="$1"
  local message="$2"
  local remediation_status="${3:-}"
  local qa_status="${4:-}"
  local pr_url="${5:-}"
  local work_completed_flag="${6:-false}"

  if [ -z "${CODERUN_NAME:-}" ] || [ -z "${NAMESPACE:-}" ]; then
    return
  fi

  local token_path="/var/run/secrets/kubernetes.io/serviceaccount/token"
  local ca_path="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"

  if [ ! -f "$token_path" ] || [ ! -f "$ca_path" ]; then
    echo "â„¹ï¸ Service account credentials unavailable; skipping CodeRun status update"
    return
  fi

  if ! command -v jq >/dev/null 2>&1; then
    echo "â„¹ï¸ jq not available; skipping CodeRun status update"
    return
  fi

  local work_completed="false"
  if [ "$work_completed_flag" = "true" ]; then
    work_completed="true"
  fi

  local payload
  payload=$(jq -n \
    --arg phase "$phase" \
    --arg message "$(sanitize_status_message "$message")" \
    --arg remediation "$remediation_status" \
    --arg qa "$qa_status" \
    --arg pr "$pr_url" \
    --arg workCompleted "$work_completed" \
    '{
      status: (
        {
          phase: $phase,
          message: $message,
          workCompleted: ($workCompleted == "true")
        }
        + (if $remediation != "" then {remediationStatus: $remediation} else {} end)
        + (if $qa != "" then {qaStatus: $qa} else {} end)
        + (if $pr != "" then {pullRequestUrl: $pr} else {} end)
      )
    }'
  ) || return

  local api_host="${KUBERNETES_SERVICE_HOST:-}"
  local api_port="${KUBERNETES_SERVICE_PORT_HTTPS:-${KUBERNETES_SERVICE_PORT:-443}}"

  if [ -z "$api_host" ]; then
    echo "â„¹ï¸ Kubernetes API host unavailable; skipping CodeRun status update"
    return
  fi

  local token
  token=$(cat "$token_path")

  curl -sS -X PATCH \
    -H "Authorization: Bearer $token" \
    -H "Content-Type: application/merge-patch+json" \
    --cacert "$ca_path" \
    --data "$payload" \
    "https://${api_host}:${api_port}/apis/agents.platform/v1/namespaces/${NAMESPACE}/coderuns/${CODERUN_NAME}/status" >/dev/null 2>&1 || \
    echo "âš ï¸ Failed to patch CodeRun status"
}

ensure_pr_created() {
  if [ "${SKIP_AUTO_PR:-0}" = "1" ]; then
    echo "â­ï¸  Auto PR creation disabled via SKIP_AUTO_PR=1"
    return
  fi

  if [ ! -d .git ]; then
    echo "âš ï¸ Repository not initialised; skipping auto PR creation"
    return
  fi

  if ! command -v gh >/dev/null 2>&1; then
    echo "âš ï¸ GitHub CLI not available; skipping auto PR creation"
    return
  fi

  if ! command -v jq >/dev/null 2>&1; then
    echo "âš ï¸ jq not available; skipping auto PR creation"
    return
  fi

  if [ -z "${GITHUB_TOKEN:-}" ]; then
    echo "âš ï¸ GITHUB_TOKEN not set; skipping auto PR creation"
    return
  fi

  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || printf '')
  if [ -z "$CURRENT_BRANCH" ]; then
    echo "âš ï¸ Unable to determine current branch; skipping auto PR creation"
    return
  fi

  refresh_token_if_needed || true
  PR_OUTPUT=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number --limit 1 2>&1)
  PR_EXIT_CODE=$?

  if [ $PR_EXIT_CODE -ne 0 ] && printf '%s' "$PR_OUTPUT" | grep -qi "HTTP 401"; then
    echo "âš ï¸ gh pr list returned HTTP 401; refreshing GitHub credentials"
    refresh_github_token || true
    PR_OUTPUT=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number --limit 1 2>&1)
    PR_EXIT_CODE=$?
  fi

  if [ $PR_EXIT_CODE -ne 0 ]; then
    printf '%s\n' "$PR_OUTPUT" >&2
    PR_DATA="[]"
  else
    PR_DATA="$PR_OUTPUT"
  fi

  if [ -z "$PR_DATA" ]; then
    PR_DATA="[]"
  fi

  if [ "$(printf '%s' "$PR_DATA" | jq 'length' 2>/dev/null || echo 0)" -gt 0 ]; then
    echo "âœ… Pull request already exists for branch $CURRENT_BRANCH"
    return
  fi

  BASE_BRANCH="${PR_BASE_BRANCH:-main}"
  REMOTE_BASE="origin/$BASE_BRANCH"
  if ! git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
    if git show-ref --verify --quiet "refs/remotes/origin/master"; then
      BASE_BRANCH="master"
      REMOTE_BASE="origin/$BASE_BRANCH"
    else
      DEFAULT_REMOTE=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
      if [ -n "$DEFAULT_REMOTE" ]; then
        BASE_BRANCH="$DEFAULT_REMOTE"
        REMOTE_BASE="origin/$BASE_BRANCH"
      else
        REMOTE_BASE=""
      fi
    fi
  fi

  refresh_token_if_needed || true
  if [ -n "$BASE_BRANCH" ]; then
    git fetch origin "$BASE_BRANCH" >/dev/null 2>&1 || true
  fi

  if [ "$CURRENT_BRANCH" = "HEAD" ] || [ "$CURRENT_BRANCH" = "$BASE_BRANCH" ]; then
    AUTO_BRANCH="task-{{task_id}}-{{service}}-$(date +%Y%m%d-%H%M%S)"
    echo "âš ï¸ Branch $CURRENT_BRANCH unsuitable for PR; creating $AUTO_BRANCH"
    if ! git checkout -B "$AUTO_BRANCH" >/dev/null 2>&1; then
      echo "âŒ Failed to create fallback branch $AUTO_BRANCH"
      return
    fi
    CURRENT_BRANCH="$AUTO_BRANCH"
  fi

  git add .
  if git diff --cached --quiet --exit-code; then
    echo "â„¹ï¸ No staged changes detected after auto-staging"
  else
    COMMIT_MSG="chore({{service}}): auto-commit for task {{task_id}}"
    if ! git commit -m "$COMMIT_MSG" >/dev/null 2>&1; then
      echo "âš ï¸ Failed to commit staged changes automatically"
    else
      echo "âœ… Auto-committed staged changes"
    fi
  fi

  if git rev-parse --verify --quiet "$CURRENT_BRANCH" >/dev/null 2>&1; then
    refresh_token_if_needed || true
    if ! git push -u origin "$CURRENT_BRANCH" >/dev/null 2>&1; then
      echo "âš ï¸ Failed to push branch $CURRENT_BRANCH; skipping auto PR creation"
      return
    fi
  else
    echo "âš ï¸ Unable to verify branch $CURRENT_BRANCH; skipping auto PR creation"
    return
  fi

  git fetch origin "$CURRENT_BRANCH" >/dev/null 2>&1 || true
  if [ -n "$REMOTE_BASE" ]; then
    AHEAD_COUNT=$(git rev-list --left-right "$REMOTE_BASE...$CURRENT_BRANCH" 2>/dev/null | awk '/^>/{c++} END{print c+0}')
  else
    AHEAD_COUNT=1
  fi
  if [ "${AHEAD_COUNT:-0}" -eq 0 ]; then
    echo "âš ï¸ Branch $CURRENT_BRANCH has no commits ahead of $BASE_BRANCH; skipping PR creation"
    return
  fi

  RUN_LABEL="run-{{workflow_name}}"
  if [ "${RUN_LABEL#run-}" = "" ]; then
    RUN_LABEL="run-unknown"
  fi

  TASK_LABEL="task-{{task_id}}"
  SERVICE_LABEL="service-{{service}}"
  REPO_SLUG="${REPO_OWNER}/${REPO_NAME}"

  echo "ğŸ” Ensuring PR correlation labels exist"
  for label in "$TASK_LABEL" "$SERVICE_LABEL" "$RUN_LABEL"; do
    if [ -z "$label" ]; then
      continue
    fi

    if gh label view "$label" -R "$REPO_SLUG" >/dev/null 2>&1; then
      echo "   âœ“ Label '$label' already exists"
      continue
    fi

    case "$label" in
      task-*) COLOR="f29513"; DESC="Task correlation" ;;
      service-*) COLOR="0e8a16"; DESC="Service correlation" ;;
      run-*) COLOR="0366d6"; DESC="Workflow correlation" ;;
      *) COLOR="ededed"; DESC="Automation label" ;;
    esac

    if gh label create "$label" -R "$REPO_SLUG" --color "$COLOR" --description "$DESC" >/tmp/gh-label-create.log 2>&1; then
      echo "   âœ… Created label '$label'"
    else
      echo "   âŒ Failed to create label '$label'"
      cat /tmp/gh-label-create.log >&2 || true
    fi
    rm -f /tmp/gh-label-create.log
  done

  PR_TITLE="feat({{service}}): complete task {{task_id}}"
  read -r -d '' PR_BODY <<'EOF' || true
## Summary
- Auto-generated fallback PR because the Cursor agent finished without opening one
- Task {{task_id}} for service {{service}} is ready for review

## Metadata
- Agent: {{github_app}}
- Workflow: {{workflow_name}}
- Branch: \\`$CURRENT_BRANCH\\` â†’ \\`$BASE_BRANCH\\`

_This PR was created automatically by the Cursor container._
EOF

  LABEL_ARGS=("--title" "$PR_TITLE" "--body" "$PR_BODY" "--base" "$BASE_BRANCH" "--head" "$CURRENT_BRANCH")

  maybe_add_label() {
    local label="$1"
    if [ -z "$label" ]; then
      return
    fi
    if gh label view "$label" -R "$REPO_SLUG" >/dev/null 2>&1; then
      LABEL_ARGS+=("--label" "$label")
    else
      echo "âš ï¸ Label '$label' not found; skipping"
    fi
  }

  maybe_add_label "$TASK_LABEL"
  maybe_add_label "$SERVICE_LABEL"
  maybe_add_label "$RUN_LABEL"

  if gh pr create "${LABEL_ARGS[@]}"; then
    echo "âœ… Auto-created pull request for $CURRENT_BRANCH"
  else
    echo "âš ï¸ Failed to create pull request automatically (it may already exist or authentication failed)"
  fi
}

git config --global --add safe.directory /workspace

derive_bot_identity() {
  local app_name="$1"

  if [ -z "$app_name" ] || [ "$app_name" = "null" ]; then
    GIT_AUTHOR_NAME="automation[bot]"
    GIT_AUTHOR_EMAIL="automation[bot]@users.noreply.github.com"
    return
  fi

  local slug
  slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-+|-+$//g')
  if [ -z "$slug" ]; then
    slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]')
  fi

  local bot_login="${slug}[bot]"
  local bot_email="${bot_login}@users.noreply.github.com"

  if [ -n "${GITHUB_TOKEN:-}" ]; then
    local encoded_login
    encoded_login=$(printf '%s' "$bot_login" | sed 's/\[/%5B/g; s/\]/%5D/g')
    local bot_response
    bot_response=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/users/${encoded_login}" 2>/dev/null || true)
    local bot_id
    bot_id=$(printf '%s' "$bot_response" | jq -r '.id // empty' 2>/dev/null || echo '')
    if [ -n "$bot_id" ]; then
      bot_email="${bot_id}+${bot_login}@users.noreply.github.com"
    fi
  fi

  GIT_AUTHOR_NAME="$bot_login"
  GIT_AUTHOR_EMAIL="$bot_email"
}

GITHUB_APP="{{github_app}}"
derive_bot_identity "$GITHUB_APP"

git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"
export GIT_AUTHOR_NAME
export GIT_AUTHOR_EMAIL
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# =========================================================================
# Repository checkout
# =========================================================================

WORK_DIR="{{working_directory}}"
cd /workspace

if [ -d "$REPO_NAME/.git" ]; then
  echo "ğŸ” Repository already cloned, fetching latest"
  cd "$REPO_NAME"
  refresh_token_if_needed
  git fetch --all --prune
else
  echo "â¬‡ï¸  Cloning repository"
  refresh_token_if_needed
  git clone "$REPO_HTTP_URL"
  cd "$REPO_NAME"
fi

REPO_ROOT="/workspace/$REPO_NAME"
git config --global --add safe.directory "$REPO_ROOT"
cd "$REPO_ROOT"

echo "=== BRANCH SETUP ==="
# Remove stale automation-managed files that block branch checkout when rerunning
MANAGED_PATHS=(
  ".mcp.json"
  "AGENTS.md"
  "client-config.json"
  "coding-guidelines.md"
  "github-guidelines.md"
  "task"
)

for managed_path in "${MANAGED_PATHS[@]}"; do
  if git ls-files --error-unmatch -- "$managed_path" >/dev/null 2>&1; then
    status_output=$(git status --short -- "$managed_path" 2>/dev/null || true)
    untracked=false
    while IFS= read -r line; do
      case "$line" in
        "?? "*)
          untracked=true
          break
          ;;
      esac
    done <<EOF
$status_output
EOF

    if [ "$untracked" = true ]; then
      echo "ğŸ§¹ Removing stale untracked files to allow checkout: $managed_path"
      git clean -fd -- "$managed_path" >/dev/null 2>&1 || rm -rf "$managed_path"
    fi
    continue
  fi

  if [ -e "$managed_path" ]; then
    echo "ğŸ§¹ Removing stale file to allow checkout: $managed_path"
    rm -rf "$managed_path"
  fi
done

BASE_BRANCH="${PR_BASE_BRANCH:-main}"
REMOTE_BASE="origin/$BASE_BRANCH"

if ! git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
  # Fall back to origin/master or the remote HEAD if main is absent
  if git show-ref --verify --quiet "refs/remotes/origin/master"; then
    BASE_BRANCH="master"
    REMOTE_BASE="origin/$BASE_BRANCH"
  else
    DEFAULT_REMOTE=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    if [ -n "$DEFAULT_REMOTE" ]; then
      BASE_BRANCH="$DEFAULT_REMOTE"
      REMOTE_BASE="origin/$BASE_BRANCH"
    else
      REMOTE_BASE=""
    fi
  fi
fi

if [ -n "$BASE_BRANCH" ]; then
  git fetch origin "$BASE_BRANCH" >/dev/null 2>&1 || true
fi

FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
if git show-ref --verify --quiet "refs/heads/$FEATURE_BRANCH"; then
  echo "Feature branch '$FEATURE_BRANCH' exists, checking out..."
  # Stash any local changes from previous runs to avoid checkout conflicts
  if ! git diff-index --quiet HEAD -- || [ -n "$(git ls-files --others --exclude-standard)" ]; then
    echo "ğŸ”„ Stashing local changes and untracked files before checkout"
    git stash push --include-untracked -m "Auto-stash before checkout ($(date -u +%Y%m%d-%H%M%S))" || true
  fi
  git checkout "$FEATURE_BRANCH"
  if [ -n "$REMOTE_BASE" ]; then
    echo "ğŸ“¥ Fast-forwarding $FEATURE_BRANCH with $REMOTE_BASE"
    if ! git merge "$REMOTE_BASE" --ff-only >/dev/null 2>&1; then
      echo "âš ï¸ Unable to fast-forward $FEATURE_BRANCH; creating fresh branch from $REMOTE_BASE"
      NEW_BRANCH="${FEATURE_BRANCH}-$(date -u +%Y%m%d%H%M%S)"
      git checkout -B "$NEW_BRANCH" "$REMOTE_BASE"
      FEATURE_BRANCH="$NEW_BRANCH"
    fi
  fi
else
  echo "Creating new feature branch '$FEATURE_BRANCH'"
  if [ -n "$REMOTE_BASE" ] && git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
    git checkout -b "$FEATURE_BRANCH" "$REMOTE_BASE"
  else
    git checkout -b "$FEATURE_BRANCH"
  fi
fi

git config --local user.name "$GIT_AUTHOR_NAME"
git config --local user.email "$GIT_AUTHOR_EMAIL"
git config --local push.autoSetupRemote true
export IMPLEMENTATION_BRANCH="$FEATURE_BRANCH"
echo "âœ“ Using feature branch: $FEATURE_BRANCH (base: ${BASE_BRANCH:-unknown})"

# Set working directory: use repo root if working_directory is "." or empty
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ] || [ "$WORK_DIR" = "null" ]; then
  CURSOR_WORK_DIR="$REPO_ROOT"
else
  CURSOR_WORK_DIR="$REPO_ROOT/$WORK_DIR"
  mkdir -p "$CURSOR_WORK_DIR"
fi

cd "$CURSOR_WORK_DIR"
echo "âœ“ Working directory: $CURSOR_WORK_DIR"

echo "ğŸ“¦ git status"
refresh_token_if_needed
git status --short || true

# =========================================================================
# Materialise task context
# =========================================================================

echo "ğŸ§± Syncing task assets"
mkdir -p "$CURSOR_WORK_DIR/task"
mkdir -p "$CURSOR_WORK_DIR/.cursor"
mkdir -p "$HOME/.cursor"
cp -R /task-files/task/* "$CURSOR_WORK_DIR/task/" 2>/dev/null || true

DOCS_REPO_URL="{{docs_repository_url}}"
DOCS_BRANCH="{{docs_branch}}"
DOCS_PROJECT_DIRECTORY="{{docs_project_directory}}"

if [ -n "$DOCS_REPO_URL" ] && [ "$DOCS_REPO_URL" != "null" ]; then
  refresh_token_if_needed
  if [ -z "$DOCS_BRANCH" ] || [ "$DOCS_BRANCH" = "null" ]; then
    DOCS_BRANCH="main"
  fi

  echo "ğŸ“š Syncing docs repository: $DOCS_REPO_URL (branch: $DOCS_BRANCH)"
  DOCS_CLONE_DIR="/tmp/docs-repo"
  rm -rf "$DOCS_CLONE_DIR"

  read DOCS_OWNER DOCS_NAME <<<"$(parse_repo "$DOCS_REPO_URL")"
  DOCS_HTTP_URL="https://github.com/${DOCS_OWNER}/${DOCS_NAME}.git"

  if git clone --quiet --branch "$DOCS_BRANCH" --single-branch "$DOCS_HTTP_URL" "$DOCS_CLONE_DIR"; then
    echo "âœ“ Docs repository cloned"
  else
    echo "âš ï¸ Failed to clone docs branch '$DOCS_BRANCH'; attempting default branch"
    if git clone --quiet "$DOCS_HTTP_URL" "$DOCS_CLONE_DIR"; then
      echo "âœ“ Docs repository cloned using default branch"
    else
      echo "âŒ Unable to clone docs repository: $DOCS_HTTP_URL"
      DOCS_CLONE_DIR=""
    fi
  fi

  if [ -n "$DOCS_CLONE_DIR" ]; then
    DOCS_BASE_PATH="$DOCS_CLONE_DIR/.taskmaster"
    if [ -n "$DOCS_PROJECT_DIRECTORY" ] && [ "$DOCS_PROJECT_DIRECTORY" != "null" ]; then
      DOCS_BASE_PATH="$DOCS_CLONE_DIR/$DOCS_PROJECT_DIRECTORY/.taskmaster"
    fi

    echo "ğŸ” Docs base path: $DOCS_BASE_PATH"
    TASK_DIR="$DOCS_BASE_PATH/docs/task-{{task_id}}"

    if [ -d "$TASK_DIR" ]; then
      echo "âœ“ Copying task definition from $TASK_DIR"
      refresh_token_if_needed
      cp -R "$TASK_DIR"/. "$CURSOR_WORK_DIR/task/" 2>/dev/null || true
    else
      echo "âŒ CRITICAL: Task directory not found at $TASK_DIR"
    fi

    if [ -f "$DOCS_BASE_PATH/tasks.json" ]; then
      refresh_token_if_needed
      cp "$DOCS_BASE_PATH/tasks.json" "$CURSOR_WORK_DIR/task/" 2>/dev/null || true
    fi
  fi
else
  echo "âš ï¸ Docs repository URL not provided; skipping task docs sync"
fi

if [ -f /task-files/AGENTS.md ]; then
  cp -f /task-files/AGENTS.md "$CURSOR_WORK_DIR/AGENTS.md"
fi

if [ -f /task-files/coding-guidelines.md ]; then
  cp -f /task-files/coding-guidelines.md "$CURSOR_WORK_DIR/"
  echo "âœ“ Copied coding-guidelines.md to working directory"
fi

if [ -f /task-files/github-guidelines.md ]; then
  cp -f /task-files/github-guidelines.md "$CURSOR_WORK_DIR/"
  echo "âœ“ Copied github-guidelines.md to working directory"
fi

if [ -f /task-files/client-config.json ]; then
  cp -f /task-files/client-config.json "$CURSOR_WORK_DIR/"
  echo "âœ“ Copied client-config.json to working directory"
fi

if [ -f /task-files/mcp.json ]; then
  cp -f /task-files/mcp.json "$CURSOR_WORK_DIR/.mcp.json"
fi

if [ -f /task-files/cursor-cli.json ]; then
  mkdir -p "$CURSOR_WORK_DIR/.cursor"
  cp -f /task-files/cursor-cli.json "$CURSOR_WORK_DIR/.cursor/cli.json"
  echo "âœ“ Installed project-level cursor CLI permissions"
else
  echo "âš ï¸ cursor-cli.json not provided; using default project permissions"
fi

if [ -f /task-files/cursor-cli-config.json ]; then
  mkdir -p "$HOME/.cursor"
  cp -f /task-files/cursor-cli-config.json "$HOME/.cursor/cli-config.json"
  echo "âœ“ Installed global cursor CLI config"
else
  echo "âš ï¸ cursor-cli-config.json not provided; using existing global Cursor config"
fi

# Check if client-config.json exists in working directory
if [ ! -f "$CURSOR_WORK_DIR/client-config.json" ]; then
  echo "âŒ client-config.json missing from workspace; required for MCP/toolman"
  exit 1
fi

echo "=== MCP PRECHECKS ==="
if ! command -v toolman >/dev/null 2>&1; then
  echo "âŒ 'toolman' CLI not found in PATH; required for MCP"
  exit 1
fi

WORKSPACE_CFG="$MCP_CLIENT_CONFIG"
SOURCE_CFG="/task-files/client-config.json"
TARGET_CFG="${MCP_CLIENT_CONFIG:-/workspace/client-config.json}"

is_valid_cfg() {
  local path="$1"
  [ -f "$path" ] || return 1
  if command -v jq >/dev/null 2>&1; then
    jq -e 'type=="object" and length>=0' "$path" >/dev/null 2>&1
  else
    [ -s "$path" ]
  fi
}

if is_valid_cfg "$WORKSPACE_CFG"; then
  # Only copy if source and destination are different files
  if [ "$WORKSPACE_CFG" != "$TARGET_CFG" ]; then
    cp -f "$WORKSPACE_CFG" "$TARGET_CFG"
  fi
  echo "âœ“ Using MCP client config from workspace: $TARGET_CFG"
elif is_valid_cfg "$SOURCE_CFG"; then
  # Only copy if source and destination are different files
  if [ "$SOURCE_CFG" != "$WORKSPACE_CFG" ]; then
    cp -f "$SOURCE_CFG" "$WORKSPACE_CFG"
  fi
  if [ "$SOURCE_CFG" != "$TARGET_CFG" ]; then
    cp -f "$SOURCE_CFG" "$TARGET_CFG"
  fi
  echo "âœ“ Restored MCP client config from source: $TARGET_CFG"
else
  echo "âŒ No valid client-config.json available (checked $WORKSPACE_CFG and $SOURCE_CFG)"
  if [ -f "$WORKSPACE_CFG" ]; then
    echo "   Workspace contents preview:"; head -c 200 "$WORKSPACE_CFG" 2>/dev/null || echo "   <unreadable>"
  fi
  if [ -f "$SOURCE_CFG" ]; then
    echo "   Source contents preview:"; head -c 200 "$SOURCE_CFG" 2>/dev/null || echo "   <unreadable>"
  fi
  exit 1
fi

MCP_CLIENT_CONFIG="$TARGET_CFG"
export MCP_CLIENT_CONFIG

TOOLMAN_URL=${TOOLMAN_SERVER_URL:-"http://toolman.agent-platform.svc.cluster.local:3000/mcp"}
TOOLMAN_URL="${TOOLMAN_URL%/}"
echo "ğŸ” Checking Toolman endpoint: $TOOLMAN_URL"
if ! curl -sSf --connect-timeout 2 --max-time 6 \
  -X POST "$TOOLMAN_URL" \
  -H 'Content-Type: application/json' \
  -d '{"jsonrpc":"2.0","id":"health","method":"tools/list","params":{}}' >/tmp/toolman-ping.log 2>&1; then
  echo "âŒ Unable to reach Toolman server at $TOOLMAN_URL"
  cat /tmp/toolman-ping.log >&2 || true
  rm -f /tmp/toolman-ping.log
  exit 1
fi
rm -f /tmp/toolman-ping.log
echo "âœ“ Toolman endpoint reachable"

if command -v jq >/dev/null 2>&1; then
  echo "[client-config] summary:"
  if ! jq -r '"remoteTools=" + ((.remoteTools // []) | length | tostring) + ", localServers=" + ((.localServers // {} | keys) | join(","))' "$MCP_CLIENT_CONFIG" 2>/dev/null; then
    echo "  (not valid JSON)"
  fi
else
  echo "âš ï¸ jq not available; skipping client-config summary"
fi

guard_rm() {
  if [ "$#" -ge 2 ]; then
    local flags=()
    local targets=()
    for arg in "$@"; do
      case "$arg" in
        -*) flags+=("$arg") ;;
        *) targets+=("$arg") ;;
      esac
    done

    if printf '%s\n' "${flags[@]}" | grep -Eq -- '--|^-r.*-f|-f.*-r'; then
      local has_recursive=0
      local has_force=0
      for flag in "${flags[@]}"; do
        case "$flag" in
          -*)
            [[ "$flag" == *r* || "$flag" == *R* ]] && has_recursive=1
            [[ "$flag" == *f* || "$flag" == *F* ]] && has_force=1
            ;;
        esac
      done

      if ((has_recursive && has_force)); then
        for target in "${targets[@]}"; do
          [ -z "$target" ] && continue
          local expanded="$target"
          case "$target" in
            ~*) expanded="${target/#\~/$HOME}" ;;
          esac
          local resolved
          resolved=$(realpath -m "$expanded" 2>/dev/null || printf '%s' "$expanded")
          if [ "$resolved" = "$CURSOR_WORK_DIR" ] || [ "$resolved" = "/workspace" ] ||            [ "$resolved" = "$HOME" ] || [[ "$resolved" == "$HOME/.rustup"* ]]; then
            echo "âŒ Guard: destructive rm blocked (target=$target)" >&2
            return 1
          fi
        done
      fi
    fi
  fi

  return 0
}

rm() {
  if guard_rm "$@"; then
    command rm "$@"
  else
    return 1
  fi
}

export -f guard_rm rm

if [ -z "${CURSOR_API_KEY:-}" ]; then
  echo "âŒ CURSOR_API_KEY is not set; Cursor cannot authenticate"
  exit 1
fi

echo "ğŸ”‘ Using provided CURSOR_API_KEY for authentication"

if [ ! -f "$CURSOR_WORK_DIR/AGENTS.md" ]; then
  echo "âš ï¸ AGENTS.md missing; creating placeholder"
  cat <<'PLACEHOLDER' > "$CURSOR_WORK_DIR/AGENTS.md"
# Project Guidance

This Cursor run was triggered without AGENTS.md content. Provide project context in AGENTS.md to give Cursor richer instructions.
PLACEHOLDER
fi

# =========================================================================
# Prompt assembly and Cursor execution
# =========================================================================

PROMPT_PREFIX=""
if [ -f "$CURSOR_WORK_DIR/task/toolman-guide.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}ğŸ”§ **CRITICAL: Tool Usage Reference**\n\n$(cat "$CURSOR_WORK_DIR/task/toolman-guide.md")\n\n---\n\n"
fi

PROMPT_PREFIX="${PROMPT_PREFIX}âš ï¸ **EXECUTION REQUIREMENTS (MANDATORY)**\n\n- **Follow patterns**: reference @coding-guidelines.md and @github-guidelines.md in this workspace.\n- **No mocks or stubs**: integrate with live services, APIs, and configuration; remove all placeholders.\n- **Parameterize everything**: every endpoint, threshold, or trading pair must come from env vars, config, or CLI flags.\n- **Feature branch only**: stay on \`feature/task-{{task_id}}-implementation\`; never push directly to main/master or retarget the branch upstream.\n- **Execute without pause**: if you outline a plan, immediately carry it outâ€”do not wait for confirmation or additional input.\n- **Quality gates** (ALL must pass before declaring success):\n  1. Format check: \`qlty fmt --verify\` OR \`cargo fmt --all -- --check\`\n  2. Linting: \`qlty check --all\` AND \`cargo clippy --workspace --all-targets --all-features -- -D warnings\`\n  3. Security scanning: \`gitleaks detect --no-git\`, \`trivy fs . --severity HIGH,CRITICAL\`, \`cargo deny check\`\n  4. Dockerfile linting (if applicable): \`hadolint Dockerfile\`\n  5. Testing: \`cargo nextest run --workspace --all-features\` OR \`cargo test --workspace --all-features\`\n- **Auto-fix before commit**: run \`qlty fmt\` and \`qlty check --fix\` to automatically resolve formatting and linting issues.\n- **Security first**: NEVER commit code with secrets or HIGH/CRITICAL vulnerabilities.\n- **Documentation & PR**: update project docs and open a PR via \`gh pr create\` with labels task-{{task_id}}, service-{{service}}, and run-{{workflow_name}}.\n- **Preserve workspace**: never delete the repository or run destructive cleanup commands (for example \`rm -rf\`); leave artifacts in place for QA.\n\n---\n\n"

if [ -f "$CURSOR_WORK_DIR/github-guidelines.md" ] || [ -f "$CURSOR_WORK_DIR/coding-guidelines.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}ğŸ“š **Reference Materials Available**\n"
  if [ -f "$CURSOR_WORK_DIR/github-guidelines.md" ]; then
    PROMPT_PREFIX="${PROMPT_PREFIX}- @github-guidelines.md\n"
  fi
  if [ -f "$CURSOR_WORK_DIR/coding-guidelines.md" ]; then
    PROMPT_PREFIX="${PROMPT_PREFIX}- @coding-guidelines.md\n"
  fi
  PROMPT_PREFIX="${PROMPT_PREFIX}\n---\n\n"
fi

if [ -f "$CURSOR_WORK_DIR/AGENTS.md" ]; then
  if AGENT_GUIDANCE=$(jq -Rs @json "$CURSOR_WORK_DIR/AGENTS.md" 2>/dev/null); then
    if [ "${#AGENT_GUIDANCE}" -gt 2 ]; then
      AGENT_GUIDANCE=${AGENT_GUIDANCE:1:-1}
      PROMPT_PREFIX="${PROMPT_PREFIX}ğŸ§  **Agent Guidance**\n\n${AGENT_GUIDANCE}\n\n---\n\n"
    fi
  fi
fi

echo "ğŸ” DEBUG: About to check for prompt.md at: $CURSOR_WORK_DIR/task/prompt.md"
echo "ğŸ” DEBUG: Contents of task directory:"
ls -la "$CURSOR_WORK_DIR/task/" || echo "Task directory not found or empty"
echo "ğŸ” DEBUG: Current working directory contents:"
ls -la "$CURSOR_WORK_DIR/" || echo "Working directory not accessible"

PROMPT_FILE="$CURSOR_WORK_DIR/task/prompt.md"
if [ ! -f "$PROMPT_FILE" ]; then
  echo "âŒ prompt.md not found at $PROMPT_FILE"
  exit 1
fi

echo "startingTask:{{task_id}}"
echo ""

PROMPT_CONTENT="${PROMPT_PREFIX}$(cat "$PROMPT_FILE")"

echo "ğŸ§¾ Resolved prompt content (truncated to 2000 chars for log safety):"
PROMPT_PREVIEW=$(printf '%s' "$PROMPT_CONTENT" | head -c 2000)
printf '%s\n' "$PROMPT_PREVIEW"
PROMPT_BYTES=$(printf '%s' "$PROMPT_CONTENT" | wc -c | tr -d '[:space:]')
echo "ğŸ“ Prompt size: $PROMPT_BYTES bytes"

MAX_RETRIES=${CURSOR_MAX_RETRIES:-${EXECUTION_MAX_RETRIES:-5}}
ATTEMPT=1
SUCCESS=0
CURSOR_EXIT=1
LAST_MESSAGE_FILE=""
RUN_LOG=""
LAST_COMPLETION_REASON=""

# Circuit breaker: track repeated command failures
declare -A FAILED_COMMANDS
MAX_SAME_COMMAND_FAILURES=3

FORCE_WRITES="{{#if force_writes}}true{{else}}false{{/if}}"
OUTPUT_FORMAT="{{#if output_format}}{{output_format}}{{else}}stream-json{{/if}}"

FORCE_FLAG=""
if [ "${FORCE_WRITES,,}" = "true" ]; then
  FORCE_FLAG="--force"
fi

print_attempt_banner() {
  local attempt="$1"
  local max="$2"
  local unlimited="$3"
  local border="â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  local label

  if [ "$unlimited" = "1" ]; then
    label="â•‘ ğŸš€ EXECUTION ATTEMPT #${attempt} (UNLIMITED MODE)"
  elif [ -n "$max" ] && [ "$max" -gt 0 ]; then
    label="â•‘ ğŸš€ EXECUTION ATTEMPT ${attempt} / ${max}"
  else
    label="â•‘ ğŸš€ EXECUTION ATTEMPT #${attempt}"
  fi

  local base_padding=$(( ${#border} - ${#label} - 1 ))
  local extra_width=0

  if [[ "$label" == *"ğŸš€"* ]]; then
    extra_width=$((extra_width + 1))
  fi

  local padding=$((base_padding - extra_width))
  if [ $padding -lt 0 ]; then
    padding=0
  fi

  echo ""
  echo "$border"
  printf '%s%*sâ•‘\n' "$label" "$padding" ""
  echo "$border"
  echo ""
}

# =========================================================================
# Model rotation configuration
# =========================================================================
DEFAULT_MODEL="{{model}}"
MODEL_ROTATION=()
MODEL_ROTATION_COUNT=0
{{#if model_rotation}}
MODEL_ROTATION=(
{{#each model_rotation}}
"{{this}}"
{{/each}}
)
MODEL_ROTATION_COUNT=${#MODEL_ROTATION[@]}
if [ $MODEL_ROTATION_COUNT -gt 0 ]; then
  echo "ğŸ¯ Model rotation enabled (${MODEL_ROTATION_COUNT} models): ${MODEL_ROTATION[*]}"
fi
{{/if}}
if [ -z "$DEFAULT_MODEL" ] && [ $MODEL_ROTATION_COUNT -gt 0 ]; then
  DEFAULT_MODEL="${MODEL_ROTATION[0]}"
fi
if [ -n "$DEFAULT_MODEL" ]; then
  echo "ğŸ¯ Default model: $DEFAULT_MODEL"
fi

COMPLETED_ATTEMPTS=0
while [ $ATTEMPT -le $MAX_RETRIES ]; do
  print_attempt_banner "$ATTEMPT" "$MAX_RETRIES" "0"

  # Calculate which model to use for this attempt
  CURRENT_MODEL="$DEFAULT_MODEL"
  if [ $MODEL_ROTATION_COUNT -gt 0 ]; then
    MODEL_INDEX=$(((ATTEMPT - 1) % MODEL_ROTATION_COUNT))
    CURRENT_MODEL="${MODEL_ROTATION[$MODEL_INDEX]}"
  fi
  if [ -n "$CURRENT_MODEL" ]; then
    echo "ğŸ¯ Attempt $ATTEMPT will use model: $CURRENT_MODEL"
  fi

  # Refresh GitHub token at the start of each iteration to keep gh interactions authenticated
  refresh_github_token || true

  CURRENT_ATTEMPT=$ATTEMPT
  LAST_MESSAGE_FILE="/tmp/cursor-last-message-${ATTEMPT}.txt"
  RUN_LOG="/tmp/cursor-run-${ATTEMPT}.jsonl"

  CURSOR_CMD=("cursor-agent" "--print" "--output-format" "$OUTPUT_FORMAT")
  if [ -n "$CURRENT_MODEL" ]; then
    CURSOR_CMD+=("--model" "$CURRENT_MODEL")
  fi
  if [ -n "$FORCE_FLAG" ]; then
    CURSOR_CMD+=("$FORCE_FLAG")
  fi
  CURSOR_CMD+=("$PROMPT_CONTENT")

  echo "ğŸ”§ cursor-agent invocation arguments (${#CURSOR_CMD[@]} entries):"
  for idx in "${!CURSOR_CMD[@]}"; do
    printf '    [%d] %s\n' "$idx" "${CURSOR_CMD[$idx]}"
  done

  set +e
  set -o pipefail
  "${CURSOR_CMD[@]}" | tee "$RUN_LOG"
  CURSOR_EXIT=${PIPESTATUS[0]}
  set +o pipefail
  set -e

  echo "[cursor-debug] Attempt $ATTEMPT finished with exit code $CURSOR_EXIT"

  if [ $CURSOR_EXIT -ne 0 ]; then
    echo "âš ï¸ Cursor exited with status $CURSOR_EXIT on attempt $ATTEMPT"
  fi

  # Circuit breaker: detect repeated failing bash commands
  if [ -f "$RUN_LOG" ] && command -v jq >/dev/null 2>&1; then
    # Try to extract failed bash/shell commands from JSON log
    # Cursor format: look for shell tool failures
    FAILED_CMD=$(jq -r 'select(.type=="tool_call" and .subtype=="completed" and (.tool_call.shellToolCall.result.exitCode // 0) != 0) | .tool_call.shellToolCall.args.command' "$RUN_LOG" 2>/dev/null | tail -n1 | head -c 100)
    
    if [ -n "$FAILED_CMD" ]; then
      # Track how many times this command has failed
      FAILED_COMMANDS["$FAILED_CMD"]=$((${FAILED_COMMANDS["$FAILED_CMD"]:-0} + 1))
      FAIL_COUNT=${FAILED_COMMANDS["$FAILED_CMD"]}
      
      if [ $FAIL_COUNT -ge $MAX_SAME_COMMAND_FAILURES ]; then
        echo "ğŸ”´ CIRCUIT BREAKER TRIGGERED: Command has failed $FAIL_COUNT times in a row:"
        echo "   Command: $FAILED_CMD"
        echo "   This indicates the agent is stuck in a loop."
        
        # Inject intervention prompt for next attempt
        PROMPT_CONTENT="${PROMPT_CONTENT}

âš ï¸ **LOOP DETECTED**: You tried this command $FAIL_COUNT times:
\`\`\`bash
$FAILED_CMD
\`\`\`

It keeps failing. **STOP REPEATING THIS COMMAND.**

Try instead:
1. Check working directory: \`pwd\`
2. List files: \`ls -la\`
3. Use a completely different approach
4. Create files/directories step-by-step"
        
        # Reset counter
        FAILED_COMMANDS["$FAILED_CMD"]=0
      fi
    fi
  fi

  # Extract token usage for cost tracking
  if [ -f "$RUN_LOG" ] && command -v jq >/dev/null 2>&1; then
    TOKENS_IN=$(jq -r 'select(.metadata.usage.inputTokens != null) | .metadata.usage.inputTokens' "$RUN_LOG" 2>/dev/null | tail -n1)
    TOKENS_OUT=$(jq -r 'select(.metadata.usage.outputTokens != null) | .metadata.usage.outputTokens' "$RUN_LOG" 2>/dev/null | tail -n1)
    
    if [[ "$TOKENS_IN" =~ ^[0-9]+$ ]] && [[ "$TOKENS_OUT" =~ ^[0-9]+$ ]]; then
      TOKENS_TOTAL=$((TOKENS_IN + TOKENS_OUT))
      echo "ğŸ“Š Cursor tokens this attempt: input=$TOKENS_IN, output=$TOKENS_OUT, total=$TOKENS_TOTAL"
      
      # Store for metrics (future: send to backend)
      echo "{\"attempt\":$ATTEMPT,\"task_id\":\"{{task_id}}\",\"service\":\"{{service}}\",\"cli\":\"cursor\",\"tokens_in\":$TOKENS_IN,\"tokens_out\":$TOKENS_OUT,\"tokens_total\":$TOKENS_TOTAL}" >> /tmp/cursor-metrics.jsonl
    fi
  fi

  if [ -s "$RUN_LOG" ]; then
    RESULT_TEXT=$(jq -r 'select(.type == "result") | .result // empty' "$RUN_LOG" 2>/dev/null | tail -n1)
    printf '%s\n' "$RESULT_TEXT" > "$LAST_MESSAGE_FILE"
  else
    : > "$LAST_MESSAGE_FILE"
  fi

  COMPLETION_PROMPT="Task {{task_id}} completion verification.

**FIRST**: Review the acceptance criteria in task/acceptance-criteria.md

**Then answer 'yes' ONLY if ALL of these are true:**

1. **EVERY acceptance criterion is fully implemented** (not just started, but DONE)
2. All code changes are committed to git
3. Changes are pushed to remote branch feature/task-{{task_id}}-implementation
4. A pull request exists (with at least task-{{task_id}} label; other labels are optional)
5. Quality gates passed (cargo fmt, cargo clippy with no warnings, tests pass)

**To verify:**
- Review: cat task/acceptance-criteria.md
- Git status: git status
- Commits pushed: git log origin/main..HEAD
- PR exists: gh pr view
- Tests pass: Check your test results

If incomplete, respond with:
no
REASON: <specific reason why not complete>

For 'no' responses, REASON must specify:
- Which acceptance criteria are incomplete (list them by number/name)
- What specific work remains (be concrete)
- Any blockers or issues encountered

Example 'no' response:
no
REASON: Acceptance criteria 2 and 4 incomplete. API endpoint /users created but not yet connected to database. PR created but tests failing due to missing error handling in user_controller.rs.

Your response:"
  COMPLETION_LAST_MESSAGE="/tmp/cursor-completion-${ATTEMPT}.txt"
  COMPLETION_LOG="/tmp/cursor-completion-${ATTEMPT}.log"

  COMPLETION_CMD=("cursor-agent" "--print" "--output-format" "text")
  {{#if model}}
  COMPLETION_CMD+=("--model" "{{model}}")
  {{/if}}
  COMPLETION_CMD+=("$COMPLETION_PROMPT")

  set +e
  set -o pipefail
  COMPLETION_OUTPUT=$("${COMPLETION_CMD[@]}" 2>&1 | tee "$COMPLETION_LOG")
  COMPLETION_EXIT=${PIPESTATUS[0]}
  set +o pipefail
  set -e

  printf '%s\n' "$COMPLETION_OUTPUT" > "$COMPLETION_LAST_MESSAGE"
  echo "ğŸ§­ Completion probe response:"
  printf '%s\n' "$COMPLETION_OUTPUT"

  if [ $COMPLETION_EXIT -ne 0 ]; then
    echo "âš ï¸ Completion probe exited with status $COMPLETION_EXIT"
  fi

  COMPLETION_RESPONSE=$(printf '%s\n' "$COMPLETION_OUTPUT" | tr -d '\r' | grep -Eio '\\b(yes|no)\\b' | head -n1 | tr '[:upper:]' '[:lower:]')
  CURRENT_REASON=""
  if [ "$COMPLETION_RESPONSE" = "no" ]; then
    CURRENT_REASON=$(printf '%s\n' "$COMPLETION_OUTPUT" | awk 'BEGIN{IGNORECASE=1}/^reason:/{sub(/^reason:[[:space:]]*/,"");flag=1} flag{print}')
    if [ -n "$CURRENT_REASON" ]; then
      echo "ğŸ“‹ Incompletion details:"
      echo "$CURRENT_REASON"
      echo ""
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo "â•‘ ğŸ” NEXT ITERATION FOCUS (FROM COMPLETION PROBE)              â•‘"
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      printf '%s\n' "$CURRENT_REASON"
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo ""
      PROMPT_CONTENT="${PROMPT_CONTENT}

ğŸ” **NEXT ITERATION FOCUS (from completion probe attempt $ATTEMPT)**

${CURRENT_REASON}

Address the items above before rerunning checks."
      LAST_COMPLETION_REASON="$CURRENT_REASON"
    else
      echo "âš ï¸ Completion probe reported 'no' without a reason"
    fi
  fi

  if [ "$COMPLETION_RESPONSE" = "yes" ]; then
    SUCCESS=1
    COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
    break
  fi

  if [ -n "$CURRENT_REASON" ]; then
    echo "âš ï¸ Cursor reported task incomplete; retrying with new guidance..."
  else
    echo "âš ï¸ Cursor reported task incomplete; retrying..."
  fi
  COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
  ATTEMPT=$((ATTEMPT + 1))
done

FINAL_ATTEMPTS=$COMPLETED_ATTEMPTS
if [ "${FINAL_ATTEMPTS:-0}" -le 0 ]; then
  FINAL_ATTEMPTS=$((ATTEMPT - 1))
fi
if [ $FINAL_ATTEMPTS -gt $MAX_RETRIES ]; then
  FINAL_ATTEMPTS=$MAX_RETRIES
fi

if [ $SUCCESS -ne 1 ]; then
  echo "âš ï¸ Cursor did not confirm task completion after $MAX_RETRIES attempts"
  if [ -n "$LAST_COMPLETION_REASON" ]; then
    echo ""
    echo "ğŸ’¡ Last reported reason for incompletion:"
    echo "$LAST_COMPLETION_REASON"
  fi
  
  # Document remaining work for downstream agents (Cleo/Tess)
  echo ""
  echo "ğŸ“ Creating handoff document for Cleo..."
  HANDOFF_FILE="$CURSOR_WORK_DIR/task/rex-handoff.md"
  mkdir -p "$CURSOR_WORK_DIR/task"
  
  # Prepare handoff content with proper variable expansion
  HANDOFF_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
  if [ -n "$LAST_COMPLETION_REASON" ]; then
    REMAINING_WORK_SECTION="$LAST_COMPLETION_REASON"
  else
    REMAINING_WORK_SECTION=$'Review the completion probe responses in the logs above for details on what remains to be done.
Compare current implementation against acceptance criteria in task/acceptance-criteria.md.'
  fi
  
  cat > "$HANDOFF_FILE" << EOF
# Rex Implementation Handoff

**Status**: Incomplete after $FINAL_ATTEMPTS iterations (max: $MAX_RETRIES)
**Date**: $HANDOFF_DATE
**Task**: {{task_id}}

## What Was Accomplished

Rex made $FINAL_ATTEMPTS attempts to complete this task. Review the PR and commit history for details on what was implemented.

## Remaining Work

$REMAINING_WORK_SECTION

## Next Steps for Cleo

1. Review the PR created by Rex
2. Identify gaps between current implementation and acceptance criteria
3. Complete any remaining implementation work
4. Ensure all quality checks pass before handing off to Tess

## Acceptance Criteria Reference

See \`task/acceptance-criteria.md\` for complete requirements.

---
*Generated by Rex (Cursor) after $FINAL_ATTEMPTS implementation attempts*
EOF

  echo "âœ… Handoff document created at task/rex-handoff.md"
  
  # Commit and push the handoff document
  cd "$CURSOR_WORK_DIR"
  git add task/rex-handoff.md 2>/dev/null || true
  git commit -m "docs(task-{{task_id}}): add Rex handoff document

Rex completed $FINAL_ATTEMPTS implementation iterations with incomplete status (max: $MAX_RETRIES).
Handoff document created for Cleo to continue work." 2>/dev/null || echo "âš ï¸ Could not commit handoff document"
  
  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
  if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "master" ]; then
    git push origin HEAD 2>/dev/null || echo "âš ï¸ Could not push handoff document"
  fi
  
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "â•‘          TASK COMPLETION STATUS: PARTIAL - HANDOFF           â•‘"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  echo "ğŸ”„ NEXT STEPS:"
  echo "   - Handoff document created at task/rex-handoff.md"
  echo "   - Workflow will continue to Cleo for completion"
  echo "   - Cleo will review PR and finish remaining work"
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  
  EXIT_CODE=0  # Always exit successfully to allow Cleo to continue
else
  echo "âœ… Cursor confirmed task completion"
  if [ ${CURSOR_EXIT:-0} -ne 0 ]; then
    echo "âš ï¸ Cursor returned non-zero exit code ${CURSOR_EXIT}, but completion probe passed"
  fi
  EXIT_CODE=0
fi

if [ $SUCCESS -eq 1 ]; then
  echo "ğŸ” Verifying pull request status"
  ensure_pr_created
else
  echo "âš ï¸ Skipping auto PR enforcement due to Cursor completion status"
fi

RESOLVED_PR_URL="$(resolve_pr_url)"

if [ $SUCCESS -eq 1 ]; then
  patch_coderun_status \
    "Running" \
    "Implementation completed - ready for quality review" \
    "ready-for-qa" \
    "" \
    "$RESOLVED_PR_URL" \
    "false"
else
  STATUS_NOTE="Cursor reported task incomplete"
  if [ -n "$LAST_COMPLETION_REASON" ]; then
    STATUS_NOTE="$LAST_COMPLETION_REASON"
  fi
  patch_coderun_status \
    "Running" \
    "$STATUS_NOTE" \
    "needs-fixes" \
    "" \
    "$RESOLVED_PR_URL" \
    "false"
fi

# Submit GitHub PR review for Cleo/Tess stages (enables workflow progression)
WORKFLOW_STAGE="${WORKFLOW_STAGE:-}"
if [ "$WORKFLOW_STAGE" = "quality" ] || [ "$WORKFLOW_STAGE" = "testing" ]; then
  PR_NUM="${PR_NUMBER:-}"
  if [ -z "$PR_NUM" ]; then
    # Try to get PR number from current branch
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
    if [ -n "$CURRENT_BRANCH" ]; then
      PR_NUM=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")
    fi
  fi

  if [ -n "$PR_NUM" ]; then
    if [ $SUCCESS -eq 1 ]; then
      STAGE_NAME="Quality"
      STAGE_EMOJI="ğŸ›¡ï¸"
      CHECKS_PASSED=$'- Code formatting verified
- Linting passed
- Unit tests successful
- Quality standards met'
      NEXT_STAGE="end-to-end testing by Tess"
      
      if [ "$WORKFLOW_STAGE" = "testing" ]; then
        # Tess has final approval authority
        STAGE_NAME="QA Testing"
        STAGE_EMOJI="ğŸ§ª"
        CHECKS_PASSED=$'- End-to-end tests passed
- Integration tests successful
- Acceptance criteria validated
- Production readiness confirmed'
        NEXT_STAGE="human review and merge"
        
        echo "âœ… $STAGE_NAME complete - posting APPROVE review (Tess final approval)"
        REVIEW_BODY_FILE=$(mktemp)
        cat <<EOF > "$REVIEW_BODY_FILE"
### $STAGE_EMOJI $STAGE_NAME Review - APPROVED
All checks have passed:
$CHECKS_PASSED
Ready for $NEXT_STAGE.

**Final Approval:** Tess has verified all acceptance criteria are met.
EOF
        refresh_token_if_needed || true
        timeout 30 gh pr review "$PR_NUM" --approve --body-file "$REVIEW_BODY_FILE" 2>&1 || echo "âš ï¸ PR review command failed"
        rm -f "$REVIEW_BODY_FILE"
      else
        # Cleo hands off to Tess via comment and label (NOT approve)
        echo "âœ… $STAGE_NAME checks passed - handing off to Tess"
        REVIEW_BODY_FILE=$(mktemp)
        cat <<EOF > "$REVIEW_BODY_FILE"
### $STAGE_EMOJI $STAGE_NAME Review - PASSED
All checks have passed:
$CHECKS_PASSED

**Status:** Ready for $NEXT_STAGE
**Next Step:** Tess will now perform comprehensive QA validation

---
*Quality review by Cleo*
EOF
        refresh_token_if_needed || true
        timeout 30 gh pr comment "$PR_NUM" --body-file "$REVIEW_BODY_FILE" 2>&1 || echo "âš ï¸ PR comment command failed"
        rm -f "$REVIEW_BODY_FILE"
        
        # Add ready-for-qa label to signal Tess
        echo "ğŸ·ï¸  Adding 'ready-for-qa' label to trigger Tess review"
        timeout 30 gh pr edit "$PR_NUM" --add-label "ready-for-qa" 2>&1 || echo "âš ï¸ Failed to add ready-for-qa label"
      fi
    else
      STAGE_NAME="Quality"
      STAGE_EMOJI="ğŸ›¡ï¸"
      ISSUES_DESC=$'- Review code formatting
- Fix linting errors
- Ensure unit tests pass
- Meet quality standards'
      if [ "$WORKFLOW_STAGE" = "testing" ]; then
        STAGE_NAME="QA Testing"
        STAGE_EMOJI="ğŸ§ª"
        ISSUES_DESC=$'- Fix failing end-to-end tests
- Address integration test failures
- Validate acceptance criteria
- Ensure production readiness'
      fi

      echo "âŒ $STAGE_NAME issues detected - posting REQUEST CHANGES review"
      REVIEW_BODY_FILE=$(mktemp)
      cat <<EOF > "$REVIEW_BODY_FILE"
### ğŸ”´ Required Changes
$STAGE_NAME issues detected. Please address the following:
$ISSUES_DESC
EOF
      refresh_token_if_needed || true
      timeout 30 gh pr review "$PR_NUM" --request-changes --body-file "$REVIEW_BODY_FILE" 2>&1 || echo "âš ï¸ PR review command failed"
      rm -f "$REVIEW_BODY_FILE"
    fi
  else
    echo "â„¹ï¸ No PR number available for $WORKFLOW_STAGE review submission"
  fi
fi

touch /workspace/.agent_done 2>/dev/null || true

if [ $SUCCESS -ne 1 ]; then
  {{#if agent_completion_message}}
echo "{{agent_completion_message}}"
  {{else}}
echo "âš ï¸ Cursor execution incomplete"
  {{/if}}
  exit $EXIT_CODE
fi

{{#if agent_completion_message}}
echo "{{agent_completion_message}}"
{{else}}
echo "âœ… Cursor execution complete"
{{/if}}
exit $EXIT_CODE
