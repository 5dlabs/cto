#!/bin/bash
set -euo pipefail

# =========================================================================
# Environment bootstrapping
# =========================================================================

{{#if agent_banner}}
echo "{{agent_banner}}"
{{else}}
echo "üîß Initialising Codex environment"
{{/if}}

if [ -f "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi

if [ -f "/root/.cargo/env" ]; then
  . "/root/.cargo/env"
fi

if command -v rustup >/dev/null 2>&1; then
  rustup default stable 2>/dev/null || true
fi

echo "PATH: $PATH"

# =========================================================================
# GitHub App authentication
# =========================================================================

REPO_URL="{{repository_url}}"

if [ -z "${GITHUB_APP_PRIVATE_KEY:-}" ] || [ -z "${GITHUB_APP_ID:-}" ]; then
  echo "‚ùå Missing GitHub App credentials"
  exit 1
fi

echo "üîê Authenticating with GitHub App"
TEMP_KEY_FILE="/tmp/github-app-key.pem"
printf '%b' "$GITHUB_APP_PRIVATE_KEY" >"$TEMP_KEY_FILE"
chmod 600 "$TEMP_KEY_FILE"

JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
NOW=$(date +%s)
EXP=$((NOW + 600))
JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
rm -f "$TEMP_KEY_FILE"

parse_repo() {
  local input="$1"
  if echo "$input" | grep -qE '^https://github.com/'; then
    echo "$input" | sed -E 's|https://github.com/([^/]+)/([^/]+?)(\.git)?$|\1 \2|'
  elif echo "$input" | grep -qE '^git@github.com:'; then
    echo "$input" | sed -E 's|git@github.com:([^/]+)/([^/]+?)(\.git)?$|\1 \2|'
  else
    echo "$input" | sed -E 's|\.git$||' | sed -E 's|([^/]+)/([^/]+)|\1 \2|'
  fi
}

read REPO_OWNER REPO_NAME <<<"$(parse_repo "$REPO_URL")"
REPO_HTTP_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}.git"

INSTALLATION_ID=$(curl -s -L \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
  INSTALLATION_ID=$(curl -s -L \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
fi

if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
  echo "‚ùå Unable to resolve installation ID for $REPO_OWNER/$REPO_NAME"
  exit 1
fi

GITHUB_TOKEN=$(curl -s -X POST \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')

if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
  echo "‚ùå Unable to obtain installation token"
  exit 1
fi

export GITHUB_TOKEN
export GH_TOKEN="$GITHUB_TOKEN"
export GH_HOST="github.com"

export GIT_CONFIG_GLOBAL=/workspace/.gitconfig
CREDENTIALS_FILE=/workspace/.git-credentials
mkdir -p /workspace

git config --global --replace-all credential.helper "store --file=$CREDENTIALS_FILE"
echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > "$CREDENTIALS_FILE"

TOKEN_GENERATED_AT=$(date +%s)

refresh_github_token() {
  echo "üîÑ Refreshing GitHub App token..."

  TEMP_KEY_FILE="/tmp/github-app-key-$$"
  printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
  chmod 600 "$TEMP_KEY_FILE"

  JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  NOW=$(date +%s)
  EXP=$((NOW + 600))
  JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

  rm -f "$TEMP_KEY_FILE"

  NEW_INSTALLATION_ID=$(curl -s -L \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

  if [ "$NEW_INSTALLATION_ID" = "null" ] || [ -z "$NEW_INSTALLATION_ID" ]; then
    NEW_INSTALLATION_ID=$(curl -s -L \
      -H "Authorization: Bearer $JWT_TOKEN" \
      -H "Accept: application/vnd.github+json" \
      "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
  fi

  TOKEN_RESPONSE=$(curl -s -X POST \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/app/installations/$NEW_INSTALLATION_ID/access_tokens")

  NEW_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

  if [ "$NEW_TOKEN" != "null" ] && [ -n "$NEW_TOKEN" ]; then
    export GITHUB_TOKEN="$NEW_TOKEN"
    export GH_TOKEN="$NEW_TOKEN"
    TOKEN_GENERATED_AT=$(date +%s)
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > "$CREDENTIALS_FILE"
    echo "‚úÖ Token refreshed"
    return 0
  fi

  echo "‚ùå Failed to refresh token: $TOKEN_RESPONSE"
  return 1
}

refresh_token_if_needed() {
  if [ -z "$TOKEN_GENERATED_AT" ]; then
    refresh_github_token
    return
  fi

  NOW=$(date +%s)
  TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))

  if [ $TOKEN_AGE -gt 3000 ]; then
    echo "üîÑ Token age: $((TOKEN_AGE / 60)) minutes ‚Äî refreshing"
    refresh_github_token
  fi
}

git config --global --add safe.directory /workspace
GITHUB_APP="{{github_app}}"
GIT_AUTHOR_NAME="${GITHUB_APP} Agent (Codex CLI)"
GIT_AUTHOR_EMAIL="${GITHUB_APP}[bot]@users.noreply.github.com"

git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"
export GIT_AUTHOR_NAME
export GIT_AUTHOR_EMAIL
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# =========================================================================
# Repository checkout
# =========================================================================

WORK_DIR="{{working_directory}}"
if [ -z "$WORK_DIR" ] || [ "$WORK_DIR" = "null" ]; then
  WORK_DIR="{{service}}"
fi

TARGET_DIR="/workspace/$WORK_DIR"
mkdir -p "$TARGET_DIR"
cd /workspace

if [ -d "$REPO_NAME/.git" ]; then
  echo "üîÅ Repository already cloned, fetching latest"
  cd "$REPO_NAME"
  refresh_token_if_needed
  git fetch --all --prune
else
  echo "‚¨áÔ∏è  Cloning repository"
  refresh_token_if_needed
  git clone "$REPO_HTTP_URL"
  cd "$REPO_NAME"
fi

CODEX_WORK_DIR="/workspace/$REPO_NAME"
if [ "$WORK_DIR" != "$REPO_NAME" ]; then
  CODEX_WORK_DIR="$CODEX_WORK_DIR/$WORK_DIR"
  mkdir -p "$CODEX_WORK_DIR"
fi

cd "$CODEX_WORK_DIR"
echo "‚úì Working directory: $CODEX_WORK_DIR"

echo "üì¶ git status"
refresh_token_if_needed
git status --short || true

# =========================================================================
# Materialise task context
# =========================================================================

echo "üß± Syncing task assets"
mkdir -p "$CODEX_WORK_DIR/task"
cp -R /task-files/task/* "$CODEX_WORK_DIR/task/" 2>/dev/null || true

DOCS_REPO_URL="{{docs_repository_url}}"
DOCS_BRANCH="{{docs_branch}}"
DOCS_PROJECT_DIRECTORY="{{docs_project_directory}}"

if [ -n "$DOCS_REPO_URL" ] && [ "$DOCS_REPO_URL" != "null" ]; then
  refresh_token_if_needed
  if [ -z "$DOCS_BRANCH" ] || [ "$DOCS_BRANCH" = "null" ]; then
    DOCS_BRANCH="main"
  fi

  echo "üìö Syncing docs repository: $DOCS_REPO_URL (branch: $DOCS_BRANCH)"
  DOCS_CLONE_DIR="/tmp/docs-repo"
  rm -rf "$DOCS_CLONE_DIR"

  read DOCS_OWNER DOCS_NAME <<<"$(parse_repo "$DOCS_REPO_URL")"
  DOCS_HTTP_URL="https://github.com/${DOCS_OWNER}/${DOCS_NAME}.git"

  if git clone --quiet --branch "$DOCS_BRANCH" --single-branch "$DOCS_HTTP_URL" "$DOCS_CLONE_DIR"; then
    echo "‚úì Docs repository cloned"
  else
    echo "‚ö†Ô∏è Failed to clone docs branch '$DOCS_BRANCH'; attempting default branch"
    if git clone --quiet "$DOCS_HTTP_URL" "$DOCS_CLONE_DIR"; then
      echo "‚úì Docs repository cloned using default branch"
    else
      echo "‚ùå Unable to clone docs repository: $DOCS_HTTP_URL"
      DOCS_CLONE_DIR=""
    fi
  fi

  if [ -n "$DOCS_CLONE_DIR" ]; then
    DOCS_BASE_PATH="$DOCS_CLONE_DIR/.taskmaster"
    if [ -n "$DOCS_PROJECT_DIRECTORY" ] && [ "$DOCS_PROJECT_DIRECTORY" != "null" ]; then
      DOCS_BASE_PATH="$DOCS_CLONE_DIR/$DOCS_PROJECT_DIRECTORY/.taskmaster"
    fi

    echo "üîç Docs base path: $DOCS_BASE_PATH"
    TASK_DIR="$DOCS_BASE_PATH/docs/task-{{task_id}}"

  if [ -d "$TASK_DIR" ]; then
    echo "‚úì Copying task definition from $TASK_DIR"
    refresh_token_if_needed
    cp -R "$TASK_DIR"/. "$CODEX_WORK_DIR/task/" 2>/dev/null || true
    else
      echo "‚ùå CRITICAL: Task directory not found at $TASK_DIR"
    fi

    if [ -f "$DOCS_BASE_PATH/tasks.json" ]; then
      refresh_token_if_needed
      cp "$DOCS_BASE_PATH/tasks.json" "$CODEX_WORK_DIR/task/" 2>/dev/null || true
    fi
  fi
else
  echo "‚ö†Ô∏è Docs repository URL not provided; skipping task docs sync"
fi

if [ -f /task-files/AGENTS.md ]; then
  cp /task-files/AGENTS.md "$CODEX_WORK_DIR/AGENTS.md"
fi

if [ -f /task-files/coding-guidelines.md ]; then
  cp /task-files/coding-guidelines.md "$CODEX_WORK_DIR/"
  echo "‚úì Copied coding-guidelines.md to working directory"
fi

if [ -f /task-files/github-guidelines.md ]; then
  cp /task-files/github-guidelines.md "$CODEX_WORK_DIR/"
  echo "‚úì Copied github-guidelines.md to working directory"
fi

if [ -f /task-files/client-config.json ]; then
  cp /task-files/client-config.json "$CODEX_WORK_DIR/"
  echo "‚úì Copied client-config.json to working directory"
fi

if [ -f /task-files/mcp.json ]; then
  cp /task-files/mcp.json "$CODEX_WORK_DIR/.mcp.json"
fi

if [ ! -f "$CODEX_WORK_DIR/client-config.json" ]; then
  echo "‚ùå client-config.json missing from workspace; required for MCP/toolman"
  exit 1
fi

mkdir -p "$HOME/.codex"
if [ -f /task-files/codex-config.toml ]; then
  cp /task-files/codex-config.toml "$HOME/.codex/config.toml"
  echo "‚úì Installed codex-config.toml"
else
  echo "‚ö†Ô∏è codex-config.toml not provided; falling back to defaults"
fi

echo "=== MCP PRECHECKS ==="
if ! command -v toolman >/dev/null 2>&1; then
  echo "‚ùå 'toolman' CLI not found in PATH; required for MCP"
  exit 1
fi

TOOLMAN_URL=${TOOLMAN_SERVER_URL:-"http://toolman.agent-platform.svc.cluster.local:3000/mcp"}
echo "üîç Checking Toolman endpoint: $TOOLMAN_URL"
if ! curl -sS -o /dev/null -w "%{http_code}" --connect-timeout 2 --max-time 4 "$TOOLMAN_URL" >/tmp/toolman-ping.log 2>&1; then
  echo "‚ùå Unable to reach Toolman server at $TOOLMAN_URL"
  cat /tmp/toolman-ping.log >&2 || true
  rm -f /tmp/toolman-ping.log
  exit 1
fi
rm -f /tmp/toolman-ping.log
echo "‚úì Toolman endpoint reachable"

if [ -z "${OPENAI_API_KEY:-}" ]; then
  echo "‚ùå OPENAI_API_KEY is not set; Codex cannot authenticate"
  exit 1
fi

echo "üîë Configuring Codex authentication"
if ! codex login --api-key "$OPENAI_API_KEY" >/tmp/codex-login.log 2>&1; then
  echo "‚ùå Failed to configure Codex API key"
  cat /tmp/codex-login.log >&2 || true
  rm -f /tmp/codex-login.log
  exit 1
fi
rm -f /tmp/codex-login.log

if [ ! -f "$CODEX_WORK_DIR/AGENTS.md" ]; then
  echo "‚ö†Ô∏è AGENTS.md missing; creating placeholder"
  cat <<'PLACEHOLDER' > "$CODEX_WORK_DIR/AGENTS.md"
# Project Guidance

This Codex run was triggered without AGENTS.md content. Provide project context in AGENTS.md to give Codex richer instructions.
PLACEHOLDER
fi

# =========================================================================
# Prompt assembly and Codex execution
# =========================================================================

PROMPT_PREFIX=""
if [ -f "$CODEX_WORK_DIR/task/toolman-guide.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}üîß **CRITICAL: Tool Usage Reference**\n\n$(cat "$CODEX_WORK_DIR/task/toolman-guide.md")\n\n---\n\n"
fi

PROMPT_PREFIX="${PROMPT_PREFIX}‚ö†Ô∏è **EXECUTION REQUIREMENTS (MANDATORY)**\n\n- **Follow patterns**: reference @coding-guidelines.md and @github-guidelines.md in this workspace.\n- **No mocks or stubs**: integrate with live services, APIs, and configuration; remove all placeholders.\n- **Parameterize everything**: every endpoint, threshold, or trading pair must come from env vars, config, or CLI flags.\n- **Quality gates**: run \`cargo fmt --all -- --check\`, \`cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic\`, and \`cargo test --workspace --all-features\` before declaring success.\n- **Documentation & PR**: update project docs and open a PR via \`gh pr create\` with labels task-{{task_id}}, service-{{service}}, and run-{{workflow.name}}.\n\n---\n\n"

if [ -f "$CODEX_WORK_DIR/github-guidelines.md" ] || [ -f "$CODEX_WORK_DIR/coding-guidelines.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}üìö **Reference Materials Available**\n"
  if [ -f "$CODEX_WORK_DIR/github-guidelines.md" ]; then
    PROMPT_PREFIX="${PROMPT_PREFIX}- @github-guidelines.md\n"
  fi
  if [ -f "$CODEX_WORK_DIR/coding-guidelines.md" ]; then
    PROMPT_PREFIX="${PROMPT_PREFIX}- @coding-guidelines.md\n"
  fi
  PROMPT_PREFIX="${PROMPT_PREFIX}\n---\n\n"
fi

echo "üîç DEBUG: About to check for prompt.md at: $CODEX_WORK_DIR/task/prompt.md"
echo "üîç DEBUG: Contents of task directory:"
ls -la "$CODEX_WORK_DIR/task/" || echo "Task directory not found or empty"
echo "üîç DEBUG: Current working directory contents:"
ls -la "$CODEX_WORK_DIR/" || echo "Working directory not accessible"

PROMPT_FILE="$CODEX_WORK_DIR/task/prompt.md"
if [ ! -f "$PROMPT_FILE" ]; then
  echo "‚ùå prompt.md not found at $PROMPT_FILE"
  exit 1
fi

echo "startingTask:{{task_id}}"
echo ""

PROMPT_CONTENT="${PROMPT_PREFIX}$(cat "$PROMPT_FILE")"

set +e
codex exec \
  --dangerously-bypass-approvals-and-sandbox \
  --skip-git-repo-check \
  --cd "$CODEX_WORK_DIR" \
  "$PROMPT_CONTENT"
EXIT_CODE=$?
set -e

if [ $EXIT_CODE -ne 0 ]; then
  echo "‚ö†Ô∏è Codex exited with status $EXIT_CODE"
fi

touch /workspace/.agent_done 2>/dev/null || true

{{#if agent_completion_message}}
echo "{{agent_completion_message}}"
{{else}}
echo "‚úÖ Codex execution complete"
{{/if}}
exit $EXIT_CODE
