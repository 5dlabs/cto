#!/bin/bash
set -euo pipefail

# =========================================================================
# Environment bootstrapping
# =========================================================================

{{#if agent_banner}}
echo "{{agent_banner}}"
{{else}}
echo "üîß Initialising Codex environment"
{{/if}}

if [ -f "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi

if [ -f "/root/.cargo/env" ]; then
  . "/root/.cargo/env"
fi

if command -v rustup >/dev/null 2>&1; then
  rustup default stable 2>/dev/null || true
fi

# Preemptively prune stale Rustup downloads to avoid Codex issuing bulk cleanup commands later
if [ -d "$HOME/.rustup/downloads" ]; then
  find "$HOME/.rustup/downloads" -mindepth 1 -delete 2>/dev/null || true
fi

echo "PATH: $PATH"

# =========================================================================
# RETRY CONFIGURATION
# =========================================================================
MAX_RETRIES_CONFIG=${CODEX_MAX_RETRIES:-${EXECUTION_MAX_RETRIES:-5}}
echo ""
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "‚ïë                    RETRY CONFIGURATION                        ‚ïë"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "ü§ñ CLI: {{cli_type}}"
echo "üéØ Model: {{model}}"
echo "üîÑ Maximum Iterations: $MAX_RETRIES_CONFIG"
if [ -n "${CODEX_MAX_RETRIES:-}" ]; then
  echo "üìç Source: CODEX_MAX_RETRIES environment variable"
elif [ -n "${EXECUTION_MAX_RETRIES:-}" ]; then
  echo "üìç Source: EXECUTION_MAX_RETRIES environment variable"
else
  echo "üìç Source: Default configuration"
fi
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo ""

# =========================================================================
# GitHub App authentication
# =========================================================================

REPO_URL="{{repository_url}}"

if [ -z "${GITHUB_APP_PRIVATE_KEY:-}" ] || [ -z "${GITHUB_APP_ID:-}" ]; then
  echo "‚ùå Missing GitHub App credentials"
  exit 1
fi

echo "üîê Authenticating with GitHub App"
TEMP_KEY_FILE="/tmp/github-app-key.pem"
printf '%b' "$GITHUB_APP_PRIVATE_KEY" >"$TEMP_KEY_FILE"
chmod 600 "$TEMP_KEY_FILE"

JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
NOW=$(date +%s)
EXP=$((NOW + 600))
JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
rm -f "$TEMP_KEY_FILE"

parse_repo() {
  local input="$1"
  if echo "$input" | grep -qE '^https://github.com/'; then
    echo "$input" | sed -E 's|https://github.com/([^/]+)/([^/]+?)(\.git)?$|\1 \2|'
  elif echo "$input" | grep -qE '^git@github.com:'; then
    echo "$input" | sed -E 's|git@github.com:([^/]+)/([^/]+?)(\.git)?$|\1 \2|'
  else
    echo "$input" | sed -E 's|\.git$||' | sed -E 's|([^/]+)/([^/]+)|\1 \2|'
  fi
}

read REPO_OWNER REPO_NAME <<<"$(parse_repo "$REPO_URL")"
REPO_HTTP_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}.git"

INSTALLATION_ID=$(curl -s -L \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
  INSTALLATION_ID=$(curl -s -L \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
fi

if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
  echo "‚ùå Unable to resolve installation ID for $REPO_OWNER/$REPO_NAME"
  exit 1
fi

GITHUB_TOKEN=$(curl -s -X POST \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')

if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
  echo "‚ùå Unable to obtain installation token"
  exit 1
fi

export GITHUB_TOKEN
if [ -z "${GH_TOKEN:-}" ]; then
  export GH_TOKEN="$GITHUB_TOKEN"
else
  echo "‚ÑπÔ∏è Preserving preconfigured GH_TOKEN from environment"
fi
export GH_HOST="github.com"

# Task-specific workspace for parallel execution isolation
TASK_WORKSPACE="/workspace/task-{{task_id}}"
mkdir -p /workspace
mkdir -p "$TASK_WORKSPACE"
export GH_CONFIG_DIR="$TASK_WORKSPACE/.config/gh"
mkdir -p "$GH_CONFIG_DIR"
echo "üìÅ Using task-specific workspace: $TASK_WORKSPACE"

export GIT_CONFIG_GLOBAL="$TASK_WORKSPACE/.gitconfig"
CREDENTIALS_FILE="$TASK_WORKSPACE/.git-credentials"

# Safe git config wrapper with retry logic and lock file cleanup
safe_git_config() {
  local max_attempts=5
  local attempt=1
  local sleep_time=1
  
  while [ $attempt -le $max_attempts ]; do
    # Clean up stale lock files before attempting
    if [ -f "${GIT_CONFIG_GLOBAL}.lock" ]; then
      # Check if lock file is stale (older than 10 seconds)
      # Use find with -mmin for portability (works on Linux and macOS)
      if find "${GIT_CONFIG_GLOBAL}.lock" -mmin +0.17 2>/dev/null | grep -q .; then
        echo "‚ö†Ô∏è  Removing stale git config lock file"
        rm -f "${GIT_CONFIG_GLOBAL}.lock" 2>/dev/null || true
      fi
    fi

    # Attempt the git config operation
    if git config "$@" 2>/dev/null; then
      return 0
    fi

    # Operation failed, retry with exponential backoff
    local exit_code=$?
    if [ $exit_code -ne 0 ] && [ $attempt -lt $max_attempts ]; then
      echo "‚ö†Ô∏è  Git config attempt $attempt/$max_attempts failed (exit $exit_code), retrying in ${sleep_time}s..."
      rm -f "${GIT_CONFIG_GLOBAL}.lock" 2>/dev/null || true
      sleep "$sleep_time"
      attempt=$((attempt + 1))
      sleep_time=$((sleep_time * 2))  # Exponential backoff
    else
      break
    fi
  done
  
  if [ $attempt -gt $max_attempts ]; then
    echo "‚ùå Git config failed after $max_attempts attempts: git config $*"
    return 1
  fi
  
  return 0
}

safe_git_config --global --replace-all credential.helper "store --file=$CREDENTIALS_FILE"

write_gitleaks_allowlist() {
  local config_path="$REPO_ROOT/.gitleaks.toml"
  cat > "$config_path" <<'EOF'
title = "Codex managed gitleaks configuration"

[allowlist]
description = "Ignore gh CLI host cache generated during Codex runs"
paths = [
  '''\.config/gh/hosts\.yml'''
]
EOF

  if [ "${SERVICE_NAME:-}" = "cto-parallel-test" ]; then
    cat >> "$config_path" <<'EOF'

[[allowlist.files]]
description = "Sample JWT strings documented for task instructions"
file = '''IMPLEMENTATION_COMPLETE.md'''
regex = '''eyJ[a-zA-Z0-9_-]{20,}'''

[[allowlist.files]]
description = "Sample JWT strings in acceptance criteria handoff"
file = '''task/task.md'''
regex = '''eyJ[a-zA-Z0-9_-]{20,}'''

[[allowlist.files]]
description = "Sample JWT strings in docs/.taskmaster/docs/task-3/task.md"
file = '''docs/.taskmaster/docs/task-3/task.md'''
regex = '''eyJ[a-zA-Z0-9_-]{20,}'''

[[allowlist.files]]
description = "Sample JWT strings in src/auth/models.rs fixtures"
file = '''src/auth/models.rs'''
regex = '''eyJ[a-zA-Z0-9_-]{20,}'''
EOF
  fi

  echo "‚úì Wrote gitleaks allowlist to $config_path"
}

cleanup_locked_refs_from_log() {
  local log_file="$1"
  local cleaned=0

  if [ ! -f "$log_file" ]; then
    return 1
  fi

  while IFS= read -r ref; do
    if [ -z "$ref" ]; then
      continue
    fi
    local ref_path=".git/$ref"
    echo "‚ö†Ô∏è Removing stale remote ref $ref_path"
    rm -f "$ref_path" "${ref_path}.lock"
    cleaned=1
  done < <(grep -o "refs/remotes/[^']*" "$log_file" 2>/dev/null | sort -u || true)

  if [ $cleaned -eq 1 ]; then
    git remote prune origin >/dev/null 2>&1 || true
    return 0
  fi

  return 1
}

safe_git_fetch() {
  local log_file
  log_file=$(mktemp)

  if git fetch "$@" >"$log_file" 2>&1; then
    rm -f "$log_file"
    return 0
  fi

  if cleanup_locked_refs_from_log "$log_file"; then
    echo "üîß Cleaned stale remote refs; retrying git fetch $*"
    if git fetch "$@" >>"$log_file" 2>&1; then
      rm -f "$log_file"
      return 0
    fi
  fi

  cat "$log_file"
  rm -f "$log_file"
  return 1
}

write_git_credentials() {
  if [ -z "${GITHUB_TOKEN:-}" ]; then
    return
  fi
  printf 'https://x-access-token:%s@github.com\n' "$GITHUB_TOKEN" >"$CREDENTIALS_FILE"
  chmod 600 "$CREDENTIALS_FILE" 2>/dev/null || true
}

write_gh_hosts_config() {
  if [ -z "${GITHUB_TOKEN:-}" ]; then
    return
  fi

  local hosts_dir="${GH_CONFIG_DIR:-$HOME/.config/gh}"
  mkdir -p "$hosts_dir"

  cat >"$hosts_dir/hosts.yml" <<EOF
github.com:
    user: x-access-token
    oauth_token: ${GITHUB_TOKEN}
    git_protocol: https
EOF

  chmod 600 "$hosts_dir/hosts.yml" 2>/dev/null || true
}

gh_hosts_file() {
  if [ -n "${GH_CONFIG_DIR:-}" ] && [ -f "${GH_CONFIG_DIR}/hosts.yml" ]; then
    printf '%s\n' "${GH_CONFIG_DIR}/hosts.yml"
    return
  fi
  if [ -f "$HOME/.config/gh/hosts.yml" ]; then
    printf '%s\n' "$HOME/.config/gh/hosts.yml"
    return
  fi
  printf ''
}

sync_gh_hosts_to_path() {
  local target="$1"
  if [ -z "$target" ]; then
    return
  fi
  local source
  source=$(gh_hosts_file)
  if [ -z "$source" ] || [ ! -f "$source" ]; then
    return
  fi
  local dest_dir="$target/.config/gh"
  mkdir -p "$dest_dir"
  if cp "$source" "$dest_dir/hosts.yml" >/dev/null 2>&1; then
    chmod 600 "$dest_dir/hosts.yml" 2>/dev/null || true
  fi
}

cleanup_git_state() {
  if [ ! -d ".git" ]; then
    return
  fi

  if git status --porcelain 2>/dev/null | grep -q "^UU\|^AA\|^DD\|^..U\|^U..\|^AU\|^UA\|^DU\|^UD"; then
    echo "‚ö†Ô∏è Detecting unresolved merge conflicts, aborting merge..."
    git merge --abort 2>/dev/null || true
    echo "‚úì Merge conflicts aborted"
  fi

  if [ -f ".git/REBASE_HEAD" ] || [ -f ".git/CHERRY_PICK_HEAD" ] || [ -f ".git/MERGE_HEAD" ]; then
    echo "‚ö†Ô∏è Detecting incomplete git operation, resetting..."
    git rebase --abort 2>/dev/null || true
    git cherry-pick --abort 2>/dev/null || true
    git merge --abort 2>/dev/null || true
    if ! git diff-index --quiet HEAD 2>/dev/null; then
      git reset --hard HEAD 2>/dev/null || true
    fi
    echo "‚úì Git operations reset"
  fi
}

write_git_credentials

write_gh_hosts_config

TOKEN_GENERATED_AT=$(date +%s)

refresh_github_token() {
  echo "üîÑ Refreshing GitHub App token..."

  TEMP_KEY_FILE="/tmp/github-app-key-$$"
  printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
  chmod 600 "$TEMP_KEY_FILE"

  JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  NOW=$(date +%s)
  EXP=$((NOW + 600))
  JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
  JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

  rm -f "$TEMP_KEY_FILE"

  NEW_INSTALLATION_ID=$(curl -s -L \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')

  if [ "$NEW_INSTALLATION_ID" = "null" ] || [ -z "$NEW_INSTALLATION_ID" ]; then
    NEW_INSTALLATION_ID=$(curl -s -L \
      -H "Authorization: Bearer $JWT_TOKEN" \
      -H "Accept: application/vnd.github+json" \
      "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
  fi

  TOKEN_RESPONSE=$(curl -s -X POST \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "https://api.github.com/app/installations/$NEW_INSTALLATION_ID/access_tokens")

  NEW_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

  if [ "$NEW_TOKEN" != "null" ] && [ -n "$NEW_TOKEN" ]; then
    export GITHUB_TOKEN="$NEW_TOKEN"
    export GH_TOKEN="$NEW_TOKEN"
    TOKEN_GENERATED_AT=$(date +%s)
    write_git_credentials
    write_gh_hosts_config

    # Update bashrc with refreshed token for Codex login shells
    if [ -f "$HOME/.bashrc" ]; then
      # Remove old token lines and add new ones
      sed -i '/^export GH_TOKEN=/d; /^export GITHUB_TOKEN=/d' "$HOME/.bashrc" 2>/dev/null || true
      {
        echo "export GH_TOKEN='${NEW_TOKEN}'"
        echo "export GITHUB_TOKEN='${NEW_TOKEN}'"
      } >> "$HOME/.bashrc"
    fi

    if command -v gh >/dev/null 2>&1; then
      printf '%s\n' "$NEW_TOKEN" | timeout 10 gh auth login --with-token --hostname "$GH_HOST" --git-protocol https >/dev/null 2>&1 || true
      gh auth setup-git >/dev/null 2>&1 || true
    fi

    echo "‚úÖ Token refreshed"
    return 0
  fi

  echo "‚ùå Failed to refresh token: $TOKEN_RESPONSE"
  return 1
}

refresh_token_if_needed() {
  if [ -z "$TOKEN_GENERATED_AT" ]; then
    refresh_github_token || true
    return
  fi

  NOW=$(date +%s)
  TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))

  if [ $TOKEN_AGE -gt 3000 ]; then
    echo "üîÑ Token age: $((TOKEN_AGE / 60)) minutes ‚Äî refreshing"
    refresh_github_token || true
  fi
}

sanitize_status_message() {
  printf '%s' "$1" | tr '\n' ' ' | tr '\r' ' '
}

resolve_pr_url() {
  if [ -n "${PR_URL:-}" ]; then
    printf '%s' "$PR_URL"
    return
  fi

  if [ -n "${PR_NUMBER:-}" ] && [ -n "${REPO_OWNER:-}" ] && [ -n "${REPO_NAME:-}" ]; then
    printf 'https://github.com/%s/%s/pull/%s' "$REPO_OWNER" "$REPO_NAME" "$PR_NUMBER"
    return
  fi

  if command -v gh >/dev/null 2>&1; then
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || printf '')
    if [ -n "$current_branch" ]; then
      local pr_url
      pr_url=$(gh pr list --state all --head "$current_branch" --json url --jq '.[0].url' 2>/dev/null || printf '')
      if [ -n "$pr_url" ]; then
        printf '%s' "$pr_url"
        return
      fi
    fi
  fi

  printf ''
}

patch_coderun_status() {
  local phase="$1"
  local message="$2"
  local remediation_status="${3:-}"
  local qa_status="${4:-}"
  local pr_url="${5:-}"
  local work_completed_flag="${6:-false}"

  if [ -z "${CODERUN_NAME:-}" ] || [ -z "${NAMESPACE:-}" ]; then
    return
  fi

  local token_path="/var/run/secrets/kubernetes.io/serviceaccount/token"
  local ca_path="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"

  if [ ! -f "$token_path" ] || [ ! -f "$ca_path" ]; then
    echo "‚ÑπÔ∏è Service account credentials unavailable; skipping CodeRun status update"
    return
  fi

  if ! command -v jq >/dev/null 2>&1; then
    echo "‚ÑπÔ∏è jq not available; skipping CodeRun status update"
    return
  fi

  local work_completed="false"
  if [ "$work_completed_flag" = "true" ]; then
    work_completed="true"
  fi

  local payload
  payload=$(jq -n \
    --arg phase "$phase" \
    --arg message "$(sanitize_status_message "$message")" \
    --arg remediation "$remediation_status" \
    --arg qa "$qa_status" \
    --arg pr "$pr_url" \
    --arg workCompleted "$work_completed" \
    '{
      status: (
        {
          phase: $phase,
          message: $message,
          workCompleted: ($workCompleted == "true")
        }
        + (if $remediation != "" then {remediationStatus: $remediation} else {} end)
        + (if $qa != "" then {qaStatus: $qa} else {} end)
        + (if $pr != "" then {pullRequestUrl: $pr} else {} end)
      )
    }'
  ) || return

  local api_host="${KUBERNETES_SERVICE_HOST:-}"
  local api_port="${KUBERNETES_SERVICE_PORT_HTTPS:-${KUBERNETES_SERVICE_PORT:-443}}"

  if [ -z "$api_host" ]; then
    echo "‚ÑπÔ∏è Kubernetes API host unavailable; skipping CodeRun status update"
    return
  fi

  local token
  token=$(cat "$token_path")

  curl -sS -X PATCH \
    -H "Authorization: Bearer $token" \
    -H "Content-Type: application/merge-patch+json" \
    --cacert "$ca_path" \
    --data "$payload" \
    "https://${api_host}:${api_port}/apis/agents.platform/v1/namespaces/${NAMESPACE}/coderuns/${CODERUN_NAME}/status" >/dev/null 2>&1 || \
    echo "‚ö†Ô∏è Failed to patch CodeRun status"
}

stop_docker_sidecar() {
  if [ ! -S /var/run/docker.sock ]; then
    return
  fi

  echo "üõë Stopping Docker sidecar"

  if command -v pkill >/dev/null 2>&1; then
    pkill dockerd >/dev/null 2>&1 || true
  elif command -v killall >/dev/null 2>&1; then
    killall dockerd >/dev/null 2>&1 || true
  else
    PID=$(pidof dockerd 2>/dev/null || true)
    if [ -n "$PID" ]; then
      kill "$PID" >/dev/null 2>&1 || true
    fi
  fi
}

trap 'stop_docker_sidecar || true' EXIT

ensure_gh_authenticated() {
  if ! command -v gh >/dev/null 2>&1; then
    echo "‚ö†Ô∏è GitHub CLI (gh) not found; skipping authentication"
    return 0
  fi

  if ! gh auth status -h "$GH_HOST" >/dev/null 2>&1; then
    echo "üîê Logging in to GitHub CLI for host $GH_HOST"
    refresh_github_token || true
    write_gh_hosts_config
    if ! printf '%s\n' "$GITHUB_TOKEN" | timeout 10 gh auth login --with-token --hostname "$GH_HOST" --git-protocol https >/dev/null 2>&1; then
      echo "‚ö†Ô∏è gh auth login returned non-zero or timed out; continuing with GH_TOKEN env"
    fi
  fi

  refresh_token_if_needed || true
  gh auth setup-git >/dev/null 2>&1 || true

  if gh auth status -h "$GH_HOST" >/dev/null 2>&1; then
    echo "‚úÖ GitHub CLI authenticated for $GH_HOST"
  else
    echo "‚ö†Ô∏è Unable to confirm GitHub CLI auth; GH_TOKEN will still be used for git operations"
  fi
}

ensure_gh_authenticated

# Write GH_TOKEN to bashrc for login shell access (Codex bash -lc compatibility)
write_gh_token_to_bashrc() {
  if [ -n "${GH_TOKEN:-}" ] && [ -n "${GITHUB_TOKEN:-}" ]; then
    {
      echo "# GitHub App token for gh CLI (auto-generated by container script)"
      echo "export GH_TOKEN='${GH_TOKEN}'"
      echo "export GITHUB_TOKEN='${GITHUB_TOKEN}'"
      echo "export GH_HOST='github.com'"
    } >> "$HOME/.bashrc"
  fi
}

write_gh_token_to_bashrc

sync_gh_hosts_to_path "$TASK_WORKSPACE"

ensure_pr_created() {
  if [ "${SKIP_AUTO_PR:-0}" = "1" ]; then
    echo "‚è≠Ô∏è  Auto PR creation disabled via SKIP_AUTO_PR=1"
    return
  fi

  if [ ! -d .git ]; then
    echo "‚ö†Ô∏è Repository not initialised; skipping auto PR creation"
    return
  fi

  if ! command -v gh >/dev/null 2>&1; then
    echo "‚ö†Ô∏è GitHub CLI not available; skipping auto PR creation"
    return
  fi

  if ! command -v jq >/dev/null 2>&1; then
    echo "‚ö†Ô∏è jq not available; skipping auto PR creation"
    return
  fi

  if [ -z "${GITHUB_TOKEN:-}" ]; then
    echo "‚ö†Ô∏è GITHUB_TOKEN not set; skipping auto PR creation"
    return
  fi

  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || printf '')
  if [ -z "$CURRENT_BRANCH" ]; then
    echo "‚ö†Ô∏è Unable to determine current branch; skipping auto PR creation"
    return
  fi

  refresh_token_if_needed || true
  PR_OUTPUT=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number --limit 1 2>&1)
  PR_EXIT_CODE=$?

  if [ $PR_EXIT_CODE -ne 0 ] && printf '%s' "$PR_OUTPUT" | grep -qi "HTTP 401"; then
    echo "‚ö†Ô∏è gh pr list returned HTTP 401; refreshing GitHub credentials"
    refresh_github_token || true
    ensure_gh_authenticated
    PR_OUTPUT=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number --limit 1 2>&1)
    PR_EXIT_CODE=$?
  fi

  if [ $PR_EXIT_CODE -ne 0 ]; then
    printf '%s\n' "$PR_OUTPUT" >&2
    PR_DATA="[]"
  else
    PR_DATA="$PR_OUTPUT"
  fi

  if [ -z "$PR_DATA" ]; then
    PR_DATA="[]"
  fi

  if [ "$(printf '%s' "$PR_DATA" | jq 'length' 2>/dev/null || echo 0)" -gt 0 ]; then
    echo "‚úÖ Pull request already exists for branch $CURRENT_BRANCH"
    return
  fi

  BASE_BRANCH="${PR_BASE_BRANCH:-main}"
  REMOTE_BASE="origin/$BASE_BRANCH"
  if ! git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
    if git show-ref --verify --quiet "refs/remotes/origin/master"; then
      BASE_BRANCH="master"
      REMOTE_BASE="origin/$BASE_BRANCH"
    else
      DEFAULT_REMOTE=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
      if [ -n "$DEFAULT_REMOTE" ]; then
        BASE_BRANCH="$DEFAULT_REMOTE"
        REMOTE_BASE="origin/$BASE_BRANCH"
      else
        REMOTE_BASE=""
      fi
    fi
  fi

  refresh_token_if_needed || true
  if [ -n "$BASE_BRANCH" ]; then
    safe_git_fetch origin "$BASE_BRANCH" || true
  fi

  if [ "$CURRENT_BRANCH" = "HEAD" ] || [ "$CURRENT_BRANCH" = "$BASE_BRANCH" ]; then
    AUTO_BRANCH="task-{{task_id}}-{{service}}-$(date +%Y%m%d-%H%M%S)"
    echo "‚ö†Ô∏è Branch $CURRENT_BRANCH unsuitable for PR; creating $AUTO_BRANCH"
    if ! git checkout -B "$AUTO_BRANCH" >/dev/null 2>&1; then
      echo "‚ùå Failed to create fallback branch $AUTO_BRANCH"
      return
    fi
    CURRENT_BRANCH="$AUTO_BRANCH"
  fi

  git add .
  if git diff --cached --quiet --exit-code; then
    echo "‚ÑπÔ∏è No staged changes detected after auto-staging"
  else
    COMMIT_MSG="chore({{service}}): auto-commit for task {{task_id}}"
    if ! git commit -m "$COMMIT_MSG" >/dev/null 2>&1; then
      echo "‚ö†Ô∏è Failed to commit staged changes automatically"
    else
      echo "‚úÖ Auto-committed staged changes"
    fi
  fi

  if git rev-parse --verify --quiet "$CURRENT_BRANCH" >/dev/null 2>&1; then
    refresh_token_if_needed || true
    if ! git push -u origin "$CURRENT_BRANCH" >/dev/null 2>&1; then
      echo "‚ö†Ô∏è Failed to push branch $CURRENT_BRANCH; skipping auto PR creation"
      return
    fi
  else
    echo "‚ö†Ô∏è Unable to verify branch $CURRENT_BRANCH; skipping auto PR creation"
    return
  fi

  safe_git_fetch origin "$CURRENT_BRANCH" || true
  if [ -n "$REMOTE_BASE" ]; then
    AHEAD_COUNT=$(git rev-list --left-right "$REMOTE_BASE...$CURRENT_BRANCH" 2>/dev/null | awk '/^>/{c++} END{print c+0}')
  else
    AHEAD_COUNT=1
  fi
  if [ "${AHEAD_COUNT:-0}" -eq 0 ]; then
    echo "‚ö†Ô∏è Branch $CURRENT_BRANCH has no commits ahead of $BASE_BRANCH; skipping PR creation"
    return
  fi

  RUN_LABEL="run-{{workflow_name}}"
  if [ "${RUN_LABEL#run-}" = "" ]; then
    RUN_LABEL="run-unknown"
  fi

  TASK_LABEL="task-{{task_id}}"
  SERVICE_LABEL="service-{{service}}"
  REPO_SLUG="${REPO_OWNER}/${REPO_NAME}"

  echo "üîç Ensuring PR correlation labels exist"
  for label in "$TASK_LABEL" "$SERVICE_LABEL" "$RUN_LABEL"; do
    if [ -z "$label" ]; then
      continue
    fi

    if gh label view "$label" -R "$REPO_SLUG" >/dev/null 2>&1; then
      echo "   ‚úì Label '$label' already exists"
      continue
    fi

    case "$label" in
      task-*) COLOR="28a745"; DESC="Task correlation" ;;
      service-*) COLOR="0e8a16"; DESC="Service correlation" ;;
      run-*) COLOR="0366d6"; DESC="Workflow correlation" ;;
      *) COLOR="ededed"; DESC="Automation label" ;;
    esac

    if gh label create "$label" --force -R "$REPO_SLUG" --color "$COLOR" --description "$DESC" >/tmp/gh-label-create.log 2>&1; then
      echo "   ‚úÖ Created label '$label'"
    else
      echo "   ‚ùå Failed to create label '$label'"
      cat /tmp/gh-label-create.log >&2 || true
    fi
    rm -f /tmp/gh-label-create.log
  done

  # VALIDATION: Check for problematic commits before creating PR
  echo "üîç Validating changes before PR creation..."

  # Check total diff size
  TOTAL_ADDITIONS=$(git diff --numstat "$BASE_BRANCH"..."$CURRENT_BRANCH" | awk '{sum+=$1} END {print sum+0}')
  TOTAL_DELETIONS=$(git diff --numstat "$BASE_BRANCH"..."$CURRENT_BRANCH" | awk '{sum+=$2} END {print sum+0}')
  TOTAL_CHANGES=$((TOTAL_ADDITIONS + TOTAL_DELETIONS))

  echo "   üìä Total changes: +$TOTAL_ADDITIONS -$TOTAL_DELETIONS (total: $TOTAL_CHANGES lines)"

  # Warn if commit is suspiciously large
  if [[ $TOTAL_CHANGES -gt 100000 ]]; then
    echo "   ‚ö†Ô∏è  WARNING: Very large commit detected ($TOTAL_CHANGES lines)!"
    echo "   This may include unwanted files like node_modules or build artifacts"
  fi

  # Check for commonly ignored files that shouldn't be committed
  PROBLEMATIC_FILES=$(git diff --name-only "$BASE_BRANCH"..."$CURRENT_BRANCH" | grep -E "(node_modules/|\.next/|dist/|build/|target/debug/|\.pyc$|__pycache__/)" || echo "")

  if [[ -n "$PROBLEMATIC_FILES" ]]; then
    echo "   ‚ùå ERROR: Detected files that should be gitignored!"
    echo "$PROBLEMATIC_FILES" | head -10 | sed 's/^/      /'
    if [[ $(echo "$PROBLEMATIC_FILES" | wc -l) -gt 10 ]]; then
      echo "      ... and $(($(echo "$PROBLEMATIC_FILES" | wc -l) - 10)) more"
    fi
    echo ""
    echo "   üõë BLOCKING PR CREATION"
    echo "   Please add a .gitignore file and remove these files from git"
    echo "   Suggested .gitignore entries:"
    echo "      node_modules/"
    echo "      dist/"
    echo "      build/"
    echo "      target/debug/"
    echo "      __pycache__/"
    return 1
  fi

  # Check file count
  FILE_COUNT=$(git diff --name-only "$BASE_BRANCH"..."$CURRENT_BRANCH" | wc -l)
  echo "   üìÅ Files changed: $FILE_COUNT"

  if [[ $FILE_COUNT -gt 100 ]]; then
    echo "   ‚ö†Ô∏è  WARNING: Large number of files changed ($FILE_COUNT)"
    echo "   Verify this is intentional and not due to dependency/build commits"
  fi

  echo "   ‚úÖ Validation passed"

  PR_TITLE="feat({{service}}): complete task {{task_id}}"
  read -r -d '' PR_BODY <<'EOF' || true
## Summary
- Auto-generated fallback PR because the Codex agent finished without opening one
- Task {{task_id}} for service {{service}} is ready for review

## Metadata
- Agent: {{github_app}}
- Workflow: {{workflow_name}}
- Branch: \\`$CURRENT_BRANCH\\` ‚Üí \\`$BASE_BRANCH\\`

_This PR was created automatically by the Codex container._
EOF

  LABEL_ARGS=("--title" "$PR_TITLE" "--body" "$PR_BODY" "--base" "$BASE_BRANCH" "--head" "$CURRENT_BRANCH")

  github_api_request() {
    local method="$1"
    shift
    if [ -z "${GITHUB_TOKEN:-}" ]; then
      return 1
    fi
    curl -sS -X "$method" \
      -H "Authorization: token $GITHUB_TOKEN" \
      -H "Accept: application/vnd.github+json" \
      "$@"
  }

  fetch_existing_pr_number() {
    local response
    response=$(github_api_request GET "https://api.github.com/repos/$REPO_SLUG/pulls?head=${REPO_OWNER}:${CURRENT_BRANCH}&state=all" 2>/dev/null || true)
    if [ -z "$response" ]; then
      return
    fi
    printf '%s' "$response" | jq -r '.[0].number // empty' 2>/dev/null || true
  }

  apply_labels_via_api() {
    local pr_number="$1"
    shift
    local labels_to_add=()
    for label in "$@"; do
      if [ -z "$label" ]; then
        continue
      fi
      if github_api_request GET "https://api.github.com/repos/$REPO_SLUG/labels/$label" >/dev/null 2>&1; then
        labels_to_add+=("$label")
      else
        echo "‚ö†Ô∏è Label '$label' not found via API fallback; skipping"
      fi
    done
    if [ "${#labels_to_add[@]}" -eq 0 ]; then
      return 0
    fi
    local labels_json
    labels_json=$(printf '%s\n' "${labels_to_add[@]}" | jq -R . | jq -s .)
    github_api_request POST "https://api.github.com/repos/$REPO_SLUG/issues/$pr_number/labels" \
      --data "{\"labels\": $labels_json}" >/dev/null 2>&1 || \
      echo "‚ö†Ô∏è Failed to apply labels via API fallback"
  }

  create_pr_via_api() {
    if [ -z "${GITHUB_TOKEN:-}" ]; then
      echo "‚ö†Ô∏è No GitHub token available for REST fallback"
      return 1
    fi

    local payload
    payload=$(jq -n \
      --arg title "$PR_TITLE" \
      --arg body "$PR_BODY" \
      --arg base "$BASE_BRANCH" \
      --arg head "$CURRENT_BRANCH" \
      '{title:$title, body:$body, base:$base, head:$head, maintainer_can_modify:true}')

    local response pr_number
    response=$(github_api_request POST "https://api.github.com/repos/$REPO_SLUG/pulls" --data "$payload")
    pr_number=$(printf '%s' "$response" | jq -r '.number // empty')

    if [ -z "$pr_number" ]; then
      local errors_message
      errors_message=$(printf '%s' "$response" | jq -r '.errors[0].message // empty')
      if printf '%s' "$errors_message" | grep -qi "already exists"; then
        pr_number=$(fetch_existing_pr_number)
      fi
    fi

    if [ -z "$pr_number" ]; then
      local api_message
      api_message=$(printf '%s' "$response" | jq -r '.message // "unknown error"')
      echo "‚ö†Ô∏è REST fallback failed to create PR: $api_message"
      return 1
    fi

    PR_NUMBER="$pr_number"
    PR_URL="https://github.com/$REPO_SLUG/pull/$PR_NUMBER"
    echo "‚úÖ Created pull request via GitHub REST API fallback (#$PR_NUMBER)"
    apply_labels_via_api "$PR_NUMBER" "$TASK_LABEL" "$SERVICE_LABEL" "$RUN_LABEL"
    return 0
  }

  maybe_add_label() {
    local label="$1"
    if [ -z "$label" ]; then
      return
    fi
    if gh label view "$label" -R "$REPO_SLUG" >/dev/null 2>&1; then
      LABEL_ARGS+=("--label" "$label")
    else
      echo "‚ö†Ô∏è Label '$label' not found; skipping"
    fi
  }

  maybe_add_label "$TASK_LABEL"
  maybe_add_label "$SERVICE_LABEL"
  maybe_add_label "$RUN_LABEL"

  if gh pr create "${LABEL_ARGS[@]}"; then
    echo "‚úÖ Auto-created pull request for $CURRENT_BRANCH"

    # Add PR to GitHub Project (works for all CLIs: Claude, Codex, Cursor, Factory, OpenCode, Blaze, Rex)
    echo "=== Linking PR to GitHub Project ==="

    # Get PR number for this branch
    PR_NUMBER=$(gh pr list --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")

    if [ -n "$PR_NUMBER" ]; then
      # Use organization project number 1 (Task Master / CTO Project)
      # This works across all repos and agents
      PROJECT_NUMBER="1"

      echo "üîó Adding PR #$PR_NUMBER to Project #$PROJECT_NUMBER..."

      # Use gh project item-add command (simpler than GraphQL)
      if gh project item-add "$PROJECT_NUMBER" --owner 5dlabs --url "https://github.com/$REPO_SLUG/pull/$PR_NUMBER" 2>&1 | grep -q "Added\|already"; then
        echo "‚úÖ PR linked to GitHub Project #$PROJECT_NUMBER"
      else
        echo "‚ö†Ô∏è Could not link PR to project (may already be linked or permissions issue)"
      fi
    else
      echo "‚ö†Ô∏è Could not get PR number for project linking"
    fi
  else
    echo "‚ö†Ô∏è gh pr create failed (it may already exist or authentication failed); attempting REST fallback"
    if create_pr_via_api; then
      echo "‚ÑπÔ∏è Skipping GitHub Project linking for REST fallback"
    else
      echo "‚ö†Ô∏è Failed to create pull request automatically (gh CLI and REST fallback both failed)"
    fi
  fi
}

safe_git_config --global --add safe.directory "$TASK_WORKSPACE"

derive_bot_identity() {
  local app_name="$1"

  if [ -z "$app_name" ] || [ "$app_name" = "null" ]; then
    GIT_AUTHOR_NAME="automation[bot]"
    GIT_AUTHOR_EMAIL="automation[bot]@users.noreply.github.com"
    return
  fi

  local slug
  slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-+|-+$//g')
  if [ -z "$slug" ]; then
    slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]')
  fi

  local bot_login="${slug}[bot]"
  local bot_email="${bot_login}@users.noreply.github.com"

  if [ -n "${GITHUB_TOKEN:-}" ]; then
    local encoded_login
    encoded_login=$(printf '%s' "$bot_login" | sed 's/\[/%5B/g; s/\]/%5D/g')
    local bot_response
    bot_response=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/users/${encoded_login}" 2>/dev/null || true)
    local bot_id
    bot_id=$(printf '%s' "$bot_response" | jq -r '.id // empty' 2>/dev/null || echo '')
    if [ -n "$bot_id" ]; then
      bot_email="${bot_id}+${bot_login}@users.noreply.github.com"
    fi
  fi

  GIT_AUTHOR_NAME="$bot_login"
  GIT_AUTHOR_EMAIL="$bot_email"
}

GITHUB_APP="{{github_app}}"
derive_bot_identity "$GITHUB_APP"

# Extract agent name for display (e.g., "5DLabs-Rex" ‚Üí "Rex", "5DLabs-Cipher" ‚Üí "Cipher")
AGENT_NAME=$(echo "$GITHUB_APP" | sed -E 's/.*-([^-]+)$/\1/')

safe_git_config --global user.name "$GIT_AUTHOR_NAME"
safe_git_config --global user.email "$GIT_AUTHOR_EMAIL"
export GIT_AUTHOR_NAME
export GIT_AUTHOR_EMAIL
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# =========================================================================
# Repository checkout
# =========================================================================

WORK_DIR="{{working_directory}}"
cd "$TASK_WORKSPACE"

REPO_ROOT="$TASK_WORKSPACE/$REPO_NAME"
safe_git_config --global --add safe.directory "$REPO_ROOT"

if [ -d "$REPO_NAME/.git" ]; then
  echo "üîÅ Repository already cloned, fetching latest"
  cd "$REPO_NAME"
  refresh_token_if_needed
  safe_git_fetch --all --prune
else
  echo "‚¨áÔ∏è  Cloning repository"
  refresh_token_if_needed
  git clone "$REPO_HTTP_URL"
  cd "$REPO_NAME"
fi

# Ensure credential helper is configured in the repository's local config
# This ensures Codex subshells can access credentials even if GIT_CONFIG_GLOBAL isn't honored
safe_git_config credential.helper "store --file=$CREDENTIALS_FILE"
echo "‚úì Git credential helper configured for repository"

safe_git_config --global --add safe.directory "$REPO_ROOT"
cd "$REPO_ROOT"
sync_gh_hosts_to_path "$REPO_ROOT"
write_gitleaks_allowlist
export GITLEAKS_CONFIG="$REPO_ROOT/.gitleaks.toml"
# gitleaks CLI reads $GITLEAKS_CONFIG automatically, so agents don't need to pass --config
# Remove stale automation-managed files that block branch checkout when rerunning
MANAGED_PATHS=(
  ".mcp.json"
  "AGENTS.md"
  "client-config.json"
  "coding-guidelines.md"
  "github-guidelines.md"
  "task"
)

for managed_path in "${MANAGED_PATHS[@]}"; do
  if git ls-files --error-unmatch -- "$managed_path" >/dev/null 2>&1; then
    status_output=$(git status --short -- "$managed_path" 2>/dev/null || true)
    untracked=false
    while IFS= read -r line; do
      case "$line" in
        "?? "*)
          untracked=true
          break
          ;;
      esac
    done <<EOF
$status_output
EOF

    if [ "$untracked" = true ]; then
      echo "üßπ Removing stale untracked files to allow checkout: $managed_path"
      git clean -fd -- "$managed_path" >/dev/null 2>&1 || rm -rf "$managed_path"
    fi
    continue
  fi

  if [ -e "$managed_path" ]; then
    echo "üßπ Removing stale file to allow checkout: $managed_path"
    rm -rf "$managed_path"
  fi
done

BASE_BRANCH="${PR_BASE_BRANCH:-main}"
REMOTE_BASE="origin/$BASE_BRANCH"

if ! git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
  # Fall back to origin/master or the remote HEAD if main is absent
  if git show-ref --verify --quiet "refs/remotes/origin/master"; then
    BASE_BRANCH="master"
    REMOTE_BASE="origin/$BASE_BRANCH"
  else
    DEFAULT_REMOTE=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    if [ -n "$DEFAULT_REMOTE" ]; then
      BASE_BRANCH="$DEFAULT_REMOTE"
      REMOTE_BASE="origin/$BASE_BRANCH"
    else
      REMOTE_BASE=""
    fi
  fi
fi

if [ -n "$BASE_BRANCH" ]; then
  safe_git_fetch origin "$BASE_BRANCH" || true
fi

FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
if git show-ref --verify --quiet "refs/heads/$FEATURE_BRANCH"; then
  echo "Feature branch '$FEATURE_BRANCH' exists, checking out..."
  cleanup_git_state
  # Stash any local changes from previous runs to avoid checkout conflicts
  # Exclude task/ directory to preserve task files that were just copied
  if ! git diff-index --quiet HEAD -- || [ -n "$(git ls-files --others --exclude-standard)" ]; then
    echo "üîÑ Stashing local changes and untracked files (excluding task/) before checkout"
    git stash push --include-untracked -m "Auto-stash before checkout ($(date -u +%Y%m%d-%H%M%S))" -- . ':!task' || true
  fi
  git checkout "$FEATURE_BRANCH"

  # Check if upstream branch is gone (deleted after previous PR was closed)
  UPSTREAM_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")
  if [ -n "$UPSTREAM_BRANCH" ]; then
    if ! git show-ref --verify --quiet "refs/remotes/$UPSTREAM_BRANCH"; then
      echo "‚ö†Ô∏è Upstream branch $UPSTREAM_BRANCH is gone (deleted from remote)"
      echo "üîç Checking for closed PRs from previous runs..."

      # Check if there's a CLOSED PR for this branch
      refresh_token_if_needed || true
      CLOSED_PR=$(gh pr list --state closed --head "$FEATURE_BRANCH" --json number --limit 1 2>/dev/null | jq -r '.[0].number // empty')

      if [ -n "$CLOSED_PR" ]; then
        echo "‚úÖ Found CLOSED PR #$CLOSED_PR from previous run"
        echo "üîÑ Deleting stale branch and recreating fresh from $REMOTE_BASE"

        # Switch off the branch before deleting it
        git checkout "$REMOTE_BASE" 2>/dev/null || git checkout -b temp-cleanup-branch "$REMOTE_BASE"
        git branch -D "$FEATURE_BRANCH" 2>/dev/null || true

        # Recreate fresh branch
        git checkout -b "$FEATURE_BRANCH" "$REMOTE_BASE"
        echo "‚úÖ Created fresh branch $FEATURE_BRANCH from $REMOTE_BASE"
        echo "‚ÑπÔ∏è Previous PR was closed - starting with clean slate"
      else
        echo "‚ÑπÔ∏è No closed PRs found - will unset upstream and continue"
        git branch --unset-upstream 2>/dev/null || true
      fi
    fi
  fi

  if [ -n "$REMOTE_BASE" ]; then
    echo "üì• Fast-forwarding $FEATURE_BRANCH with $REMOTE_BASE"
    if ! git merge "$REMOTE_BASE" --ff-only >/dev/null 2>&1; then
      # Check if PR exists for this branch before creating timestamped fallback
      echo "‚ö†Ô∏è Unable to fast-forward $FEATURE_BRANCH; checking for existing PR"
      refresh_token_if_needed || true
      EXISTING_PR=$(gh pr list --state open --head "$FEATURE_BRANCH" --json number --limit 1 2>/dev/null | jq -r '.[0].number // empty')

      if [ -n "$EXISTING_PR" ]; then
        echo "‚úÖ Found existing PR #$EXISTING_PR for branch $FEATURE_BRANCH"
        echo "‚ÑπÔ∏è Continuing with this branch despite merge conflict (will be resolved in PR)"
        # Stay on the current branch and let the PR handle conflicts
      else
        echo "‚ÑπÔ∏è No existing PR found; recreating branch from $REMOTE_BASE"
        # Delete local branch and recreate fresh from base
        # Force discard all local changes since we're recreating from scratch
        git reset --hard HEAD 2>/dev/null || true
        git clean -fd 2>/dev/null || true
        git checkout -f "$REMOTE_BASE" 2>/dev/null || git checkout -b temp-branch "$REMOTE_BASE"
        git branch -D "$FEATURE_BRANCH" 2>/dev/null || true
        git checkout -b "$FEATURE_BRANCH" "$REMOTE_BASE"
        echo "‚úÖ Recreated $FEATURE_BRANCH from $REMOTE_BASE"
      fi
    fi
  fi
else
  echo "Creating new feature branch '$FEATURE_BRANCH'"
  cleanup_git_state

  # Stash any local changes from previous runs to avoid checkout conflicts
  # Exclude task/ directory to preserve task files that were just copied
  if ! git diff-index --quiet HEAD -- || [ -n "$(git ls-files --others --exclude-standard)" ]; then
    echo "üîÑ Stashing local changes and untracked files (excluding task/) before creating new branch"
    git stash push --include-untracked -m "Auto-stash before new branch creation ($(date -u +%Y%m%d-%H%M%S))" -- . ':!task' || true
  fi

  if [ -n "$REMOTE_BASE" ] && git show-ref --verify --quiet "refs/remotes/$REMOTE_BASE"; then
    git checkout -b "$FEATURE_BRANCH" "$REMOTE_BASE"
  else
    git checkout -b "$FEATURE_BRANCH"
  fi
fi

safe_git_config --local user.name "$GIT_AUTHOR_NAME"
safe_git_config --local user.email "$GIT_AUTHOR_EMAIL"
safe_git_config --local push.autoSetupRemote true
export IMPLEMENTATION_BRANCH="$FEATURE_BRANCH"
echo "‚úì Using feature branch: $FEATURE_BRANCH (base: ${BASE_BRANCH:-unknown})"

# Set working directory: use repo root if working_directory is "." or empty
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ] || [ "$WORK_DIR" = "null" ]; then
  CODEX_WORK_DIR="$REPO_ROOT"
else
  CODEX_WORK_DIR="$REPO_ROOT/$WORK_DIR"
  mkdir -p "$CODEX_WORK_DIR"
fi

cd "$CODEX_WORK_DIR"
sync_gh_hosts_to_path "$CODEX_WORK_DIR"
echo "‚úì Working directory: $CODEX_WORK_DIR"

echo "üì¶ git status"
refresh_token_if_needed
git status --short || true

# Load resilient task setup functions (mounted from shared ConfigMap)
source /agent-templates/shared_task-setup-functions.sh || {
    echo "‚ö†Ô∏è Warning: Resilient task functions not available, using basic operations"
    # Define minimal fallback functions
    safe_copy_file() {
      if [ ! -f "$1" ]; then
        echo "‚ùå Source file not found: $1"
        return 1
      fi
      if cp "$1" "$2" 2>/dev/null; then
        echo "‚úì $3 copied"
        return 0
      else
        echo "‚ùå $3 copy failed"
        return 1
      fi
    }
    safe_copy_directory() {
      if [ ! -d "$1" ]; then
        echo "‚ùå Source directory not found: $1"
        return 1
      fi
      mkdir -p "$2" 2>/dev/null || true
      if cp -r "$1"/* "$2/" 2>/dev/null; then
        local file_count=$(find "$2" -type f 2>/dev/null | wc -l | tr -d ' ')
        echo "‚úì $3 copied ($file_count files)"
        return 0
      else
        echo "‚ùå $3 copy failed"
        return 1
      fi
    }
    safe_ensure_directory() { mkdir -p "$1"; }
    verify_task_files() {
        if [ -f "$1/prompt.md" ]; then
            echo "‚úÖ Task files verified"
            return 0
        else
            echo "‚ùå Task files missing"
            return 1
        fi
    }
    create_error_report() { echo "‚ùå ERROR: $3"; }
    attempt_task_recovery() { echo "‚ùå Recovery not available"; return 1; }
}

# Optional helper for billing/quota failure detection
if [ -f /agent-templates/helpers_detect-billing-failure.sh ]; then
  # shellcheck disable=SC1091
  source /agent-templates/helpers_detect-billing-failure.sh
else
  echo "‚ö†Ô∏è Billing failure helper not found; skipping quota detection"
fi

# =========================================================================
# Materialise task context (RESILIENT MODE)
# =========================================================================

echo "üß± Syncing task assets (RESILIENT MODE)"
# Use safe directory creation to avoid overwriting files
if ! safe_ensure_directory "$CODEX_WORK_DIR/task" "Codex task directory"; then
    echo "‚ùå CRITICAL: Cannot create Codex task directory"
    exit 1
fi

# Safely copy task files from ConfigMap
if [ -d "/task-files/task" ]; then
    echo "üìÇ Copying task files from ConfigMap..."
    if ! safe_copy_directory "/task-files/task" "$CODEX_WORK_DIR/task" "ConfigMap task files"; then
        echo "‚ö†Ô∏è Warning: Could not copy all task files from ConfigMap"
    fi
else
    echo "‚ÑπÔ∏è No task files in ConfigMap - will rely on docs repository"
fi

DOCS_REPO_URL="{{docs_repository_url}}"
DOCS_BRANCH="{{docs_branch}}"
DOCS_PROJECT_DIRECTORY="{{docs_project_directory}}"

if [ -n "$DOCS_REPO_URL" ] && [ "$DOCS_REPO_URL" != "null" ]; then
  refresh_token_if_needed
  if [ -z "$DOCS_BRANCH" ] || [ "$DOCS_BRANCH" = "null" ]; then
    DOCS_BRANCH="main"
  fi

  echo "üìö Syncing docs repository: $DOCS_REPO_URL (branch: $DOCS_BRANCH)"
  DOCS_CLONE_DIR="/tmp/docs-repo"
  rm -rf "$DOCS_CLONE_DIR"

  read DOCS_OWNER DOCS_NAME <<<"$(parse_repo "$DOCS_REPO_URL")"
  DOCS_HTTP_URL="https://github.com/${DOCS_OWNER}/${DOCS_NAME}.git"

  if git clone --quiet --branch "$DOCS_BRANCH" --single-branch "$DOCS_HTTP_URL" "$DOCS_CLONE_DIR"; then
    echo "‚úì Docs repository cloned"
  else
    echo "‚ö†Ô∏è Failed to clone docs branch '$DOCS_BRANCH'; attempting default branch"
    if git clone --quiet "$DOCS_HTTP_URL" "$DOCS_CLONE_DIR"; then
      echo "‚úì Docs repository cloned using default branch"
    else
      echo "‚ùå Unable to clone docs repository: $DOCS_HTTP_URL"
      DOCS_CLONE_DIR=""
    fi
  fi

  if [ -n "$DOCS_CLONE_DIR" ]; then
    DOCS_BASE_PATH="$DOCS_CLONE_DIR/.taskmaster"
    if [ -n "$DOCS_PROJECT_DIRECTORY" ] && [ "$DOCS_PROJECT_DIRECTORY" != "null" ]; then
      DOCS_BASE_PATH="$DOCS_CLONE_DIR/$DOCS_PROJECT_DIRECTORY/.taskmaster"
    fi

    echo "üîç Docs base path: $DOCS_BASE_PATH"
    
    # Resilient task directory discovery - check regular, tasks/, and .completed locations
    # Check both regular location and .completed location (tasks moved after completion)
    TASK_DIR=""
    if [ -d "$DOCS_BASE_PATH/docs/task-{{task_id}}" ]; then
      TASK_DIR="$DOCS_BASE_PATH/docs/task-{{task_id}}"
      echo "‚úì Found task files in docs/ directory"
    elif [ -d "$DOCS_BASE_PATH/docs/.completed/task-{{task_id}}" ]; then
      TASK_DIR="$DOCS_BASE_PATH/docs/.completed/task-{{task_id}}"
      echo "‚úì Found task files in docs/.completed/ directory"
      echo "‚ÑπÔ∏è Task appears to be completed - using files from .completed folder"
    elif [ -d "$DOCS_BASE_PATH/tasks/task-{{task_id}}" ]; then
      TASK_DIR="$DOCS_BASE_PATH/tasks/task-{{task_id}}"
      echo "‚úì Found task files in tasks/ directory"
    fi

    if [ -n "$TASK_DIR" ] && [ -d "$TASK_DIR" ]; then
      echo "‚úì Copying task definition from $TASK_DIR (RESILIENT MODE)"
      refresh_token_if_needed
      if safe_copy_directory "$TASK_DIR" "$CODEX_WORK_DIR/task" "docs task files"; then
          echo "‚úÖ Task files copied successfully from docs repository"
          # Verify critical files exist after copy
          if [ ! -f "$CODEX_WORK_DIR/task/prompt.md" ]; then
            echo "‚ùå CRITICAL: prompt.md missing after copy"
            create_error_report "$CODEX_WORK_DIR/task" "{{task_id}}" "prompt.md missing after copy"
            exit 1
          fi
      else
          echo "‚ùå CRITICAL: Failed to copy task files from docs repository"
          create_error_report "$CODEX_WORK_DIR/task" "{{task_id}}" "Failed to copy from docs repository"
          exit 1
      fi
    else
      echo "‚ùå CRITICAL: Task directory not found. Checked:"
      echo "   - $DOCS_BASE_PATH/docs/task-{{task_id}}"
      echo "   - $DOCS_BASE_PATH/docs/.completed/task-{{task_id}}"
      echo "   - $DOCS_BASE_PATH/tasks/task-{{task_id}}"
      create_error_report "$CODEX_WORK_DIR/task" "{{task_id}}" "Task directory not found in docs repository"
      exit 1
    fi

    if [ -f "$DOCS_BASE_PATH/tasks.json" ]; then
      refresh_token_if_needed
      safe_copy_file "$DOCS_BASE_PATH/tasks.json" "$CODEX_WORK_DIR/task/tasks.json" "tasks.json"
    fi
  fi
else
  echo "‚ö†Ô∏è Docs repository URL not provided; skipping task docs sync"
fi

if [ -f /task-files/AGENTS.md ]; then
  cp /task-files/AGENTS.md "$CODEX_WORK_DIR/AGENTS.md"
fi

if [ -f /task-files/coding-guidelines.md ]; then
  cp /task-files/coding-guidelines.md "$CODEX_WORK_DIR/"
  echo "‚úì Copied coding-guidelines.md to working directory"
fi

if [ -f /task-files/github-guidelines.md ]; then
  cp /task-files/github-guidelines.md "$CODEX_WORK_DIR/"
  echo "‚úì Copied github-guidelines.md to working directory"
fi

if [ -f /task-files/client-config.json ]; then
  cp /task-files/client-config.json "$CODEX_WORK_DIR/"
  echo "‚úì Copied client-config.json to working directory"
fi

if declare -F ensure_default_client_config >/dev/null 2>&1; then
  ensure_default_client_config "$CODEX_WORK_DIR/client-config.json"
fi

if [ -f /task-files/mcp.json ]; then
  cp /task-files/mcp.json "$CODEX_WORK_DIR/.mcp.json"
fi

# Guard against destructive workspace cleanup (workspace root, repository root, or Rustup cache)
guard_rm() {
  if [ "$#" -ge 2 ]; then
    local flags=()
    local targets=()
    for arg in "$@"; do
      case "$arg" in
        -*) flags+=("$arg") ;;
        *) targets+=("$arg") ;;
      esac
    done

    local has_recursive=0
    local has_force=0
    for flag in "${flags[@]}"; do
      case "$flag" in
        -*)
          [[ "$flag" == *r* || "$flag" == *R* ]] && has_recursive=1
          [[ "$flag" == *f* || "$flag" == *F* ]] && has_force=1
          ;;
      esac
    done

    if ((has_recursive && has_force)); then
      for target in "${targets[@]}"; do
        [ -z "$target" ] && continue
        local expanded="$target"
        case "$target" in
          ~*) expanded="${target/#\~/$HOME}" ;;
        esac
        local resolved
        resolved=$(realpath -m "$expanded" 2>/dev/null || printf '%s' "$expanded")
        if [ "$resolved" = "$CODEX_WORK_DIR" ] || [ "$resolved" = "$TASK_WORKSPACE" ] ||
           [ "$resolved" = "$HOME" ] || [[ "$resolved" == "$HOME/.rustup"* ]]; then
          echo "‚ùå Guard: destructive rm blocked (target=$target)" >&2
          return 1
        fi
      done
    fi
  fi

  return 0
}

rm() {
  if guard_rm "$@"; then
    command rm "$@"
  else
    return 1
  fi
}

export -f guard_rm rm

if [ ! -f "$CODEX_WORK_DIR/client-config.json" ]; then
  echo "‚ùå client-config.json missing from workspace; required for MCP/toolman"
  exit 1
fi

echo "=== MCP CLIENT CONFIG ==="
WORKSPACE_CFG="$CODEX_WORK_DIR/client-config.json"
SOURCE_CFG="/task-files/client-config.json"
TARGET_CFG="${MCP_CLIENT_CONFIG:-$TASK_WORKSPACE/client-config.json}"

is_valid_cfg() {
  local path="$1"
  [ -f "$path" ] || return 1
  if command -v jq >/dev/null 2>&1; then
    jq -e 'type=="object" and length>=0' "$path" >/dev/null 2>&1
  else
    [ -s "$path" ]
  fi
}

if is_valid_cfg "$WORKSPACE_CFG"; then
  cp "$WORKSPACE_CFG" "$TARGET_CFG"
  echo "‚úì Using MCP client config from workspace: $TARGET_CFG"
elif is_valid_cfg "$SOURCE_CFG"; then
  cp "$SOURCE_CFG" "$WORKSPACE_CFG"
  cp "$SOURCE_CFG" "$TARGET_CFG"
  echo "‚úì Restored MCP client config from source: $TARGET_CFG"
else
  echo "‚ùå No valid MCP client config available (checked $WORKSPACE_CFG and $SOURCE_CFG)"
  if [ -f "$WORKSPACE_CFG" ]; then
    echo "   Workspace contents preview:"; head -c 200 "$WORKSPACE_CFG" 2>/dev/null || echo "   <unreadable>"
  fi
  if [ -f "$SOURCE_CFG" ]; then
    echo "   Source contents preview:"; head -c 200 "$SOURCE_CFG" 2>/dev/null || echo "   <unreadable>"
  fi
  exit 1
fi

MCP_CLIENT_CONFIG="$TARGET_CFG"
export MCP_CLIENT_CONFIG

if [ -f "$MCP_CLIENT_CONFIG" ]; then
  if command -v jq >/dev/null 2>&1; then
    echo "[client-config] summary:"
    if ! jq -r '"remoteTools=" + ((.remoteTools // []) | length | tostring) + ", localServers=" + ((.localServers // {} | keys) | join(","))' "$MCP_CLIENT_CONFIG" 2>/dev/null; then
      echo "  (not valid JSON)"
    fi
  fi
fi

echo "=== client-config.json ==="
if command -v jq >/dev/null 2>&1; then
  jq '.' "$MCP_CLIENT_CONFIG" 2>/dev/null || cat "$MCP_CLIENT_CONFIG"
else
  cat "$MCP_CLIENT_CONFIG"
fi
echo "=========================="

mkdir -p "$HOME/.codex"
if [ -f /task-files/codex-config.toml ]; then
  cp /task-files/codex-config.toml "$HOME/.codex/config.toml"
  echo "‚úì Installed codex-config.toml"
else
  echo "‚ö†Ô∏è codex-config.toml not provided; falling back to defaults"
fi

echo "=== MCP PRECHECKS ==="
if ! command -v toolman >/dev/null 2>&1; then
  echo "‚ùå 'toolman' CLI not found in PATH; required for MCP"
  exit 1
fi

TOOLMAN_URL=${TOOLMAN_SERVER_URL:-"http://toolman.agent-platform.svc.cluster.local:3000/mcp"}
TOOLMAN_URL="${TOOLMAN_URL%/}"
echo "üîç Checking Toolman endpoint: $TOOLMAN_URL"
TOOLMAN_RETRIES=3
TOOLMAN_WAIT=2
TOOLMAN_SUCCESS=false
for i in $(seq 1 $TOOLMAN_RETRIES); do
  if curl -sSf --connect-timeout 5 --max-time 10 \
    -X POST "$TOOLMAN_URL" \
    -H 'Content-Type: application/json' \
    -d '{"jsonrpc":"2.0","id":"health","method":"tools/list","params":{}}' >/tmp/toolman-ping.log 2>&1; then
    TOOLMAN_SUCCESS=true
    rm -f /tmp/toolman-ping.log
    break
  fi
  if [ $i -lt $TOOLMAN_RETRIES ]; then
    echo "‚ö†Ô∏è Toolman connectivity check failed (attempt $i/$TOOLMAN_RETRIES), retrying in ${TOOLMAN_WAIT}s..."
    cat /tmp/toolman-ping.log >&2 || true
    rm -f /tmp/toolman-ping.log
    sleep $TOOLMAN_WAIT
    TOOLMAN_WAIT=$((TOOLMAN_WAIT * 2))  # Exponential backoff
  fi
done

if [ "$TOOLMAN_SUCCESS" != "true" ]; then
  echo "‚ùå Unable to reach Toolman server at $TOOLMAN_URL after $TOOLMAN_RETRIES attempts"
  cat /tmp/toolman-ping.log >&2 || true
  rm -f /tmp/toolman-ping.log
  echo "‚ö†Ô∏è This may be an intermittent DNS/network issue. Proceeding anyway, but MCP tools may not work."
  echo "‚ö†Ô∏è If Codex execution fails, check Toolman service health and DNS resolution."
  # Don't exit - allow Codex to proceed in case Toolman comes back online
  # The MCP client will handle connection failures gracefully
fi
echo "‚úì Toolman endpoint check completed"

# Refresh Toolman remote tools so the MCP client sees the full catalog (Codex filters aggressively)
if [ -z "${OPENAI_API_KEY:-}" ]; then
  echo "‚ùå OPENAI_API_KEY is not set; Codex cannot authenticate"
  exit 1
fi

echo "üîë Configuring Codex authentication"
if ! printenv OPENAI_API_KEY | codex login --with-api-key >/tmp/codex-login.log 2>&1; then
  echo "‚ùå Failed to configure Codex API key"
  cat /tmp/codex-login.log >&2 || true
  rm -f /tmp/codex-login.log
  exit 1
fi
rm -f /tmp/codex-login.log

if [ ! -f "$CODEX_WORK_DIR/AGENTS.md" ]; then
  echo "‚ö†Ô∏è AGENTS.md missing; creating placeholder"
  cat <<'PLACEHOLDER' > "$CODEX_WORK_DIR/AGENTS.md"
# Project Guidance

This Codex run was triggered without AGENTS.md content. Provide project context in AGENTS.md to give Codex richer instructions.
PLACEHOLDER
fi

# =========================================================================
# Prompt assembly and Codex execution
# =========================================================================

PROMPT_PREFIX=""
if declare -F ensure_default_toolman_guide >/dev/null 2>&1; then
  ensure_default_toolman_guide "$CODEX_WORK_DIR/task" "{{task_id}}" "{{service}}"
fi

if [ -f "$CODEX_WORK_DIR/task/toolman-guide.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}üîß **CRITICAL: Tool Usage Reference**\n\n$(cat "$CODEX_WORK_DIR/task/toolman-guide.md")\n\n---\n\n"
fi

PROMPT_PREFIX="${PROMPT_PREFIX}‚ö†Ô∏è **EXECUTION REQUIREMENTS (MANDATORY)**\n\n- **Follow patterns**: reference @coding-guidelines.md and @github-guidelines.md in this workspace.\n- **No mocks or stubs**: integrate with live services, APIs, and configuration; remove all placeholders.\n- **Parameterize everything**: every endpoint, threshold, or trading pair must come from env vars, config, or CLI flags.\n- **GitHub auth ready**: the GitHub App token (\`GH_TOKEN\`) is already configured; skip manual \`gh auth login\` flows and avoid hitting user-only endpoints like \`/user\`.\n- **Feature branch only**: stay on \`feature/task-{{task_id}}-implementation\`; never push directly to main/master or retarget the branch upstream.\n- **Execute without pause**: if you outline a plan, immediately carry it out‚Äîdo not wait for confirmation or additional input.\n- **Quality gates**: run \`cargo fmt --all -- --check\`, \`cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic\`, and \`cargo test --workspace --all-features\` before declaring success.\n- **Documentation & PR**: update project docs and open a PR via \`gh pr create\` with labels task-{{task_id}}, service-{{service}}, and run-{{workflow_name}}.\n- **Preserve workspace**: never delete the repository or run destructive cleanup commands (for example \`rm -rf\`); leave artifacts in place for QA.\n\n---\n\n"

if [ -f "$CODEX_WORK_DIR/github-guidelines.md" ] || [ -f "$CODEX_WORK_DIR/coding-guidelines.md" ]; then
  PROMPT_PREFIX="${PROMPT_PREFIX}üìö **Reference Materials Available**\n"
  if [ -f "$CODEX_WORK_DIR/github-guidelines.md" ]; then
    PROMPT_PREFIX="${PROMPT_PREFIX}- @github-guidelines.md\n"
  fi
  if [ -f "$CODEX_WORK_DIR/coding-guidelines.md" ]; then
    PROMPT_PREFIX="${PROMPT_PREFIX}- @coding-guidelines.md\n"
  fi
  PROMPT_PREFIX="${PROMPT_PREFIX}\n---\n\n"
fi

if [ -f "$CODEX_WORK_DIR/AGENTS.md" ]; then
  if AGENT_GUIDANCE=$(jq -Rs @json "$CODEX_WORK_DIR/AGENTS.md" 2>/dev/null); then
    if [ "${#AGENT_GUIDANCE}" -gt 2 ]; then
      AGENT_GUIDANCE=${AGENT_GUIDANCE:1:-1}
      PROMPT_PREFIX="${PROMPT_PREFIX}üß† **Agent Guidance**\n\n${AGENT_GUIDANCE}\n\n---\n\n"
    fi
  fi
fi

# Resilient verification of task files
echo "üîç RESILIENT VERIFICATION: Checking task files at: $CODEX_WORK_DIR/task/"
if verify_task_files "$CODEX_WORK_DIR/task" "{{task_id}}"; then
    echo "‚úÖ Task files verification: PASSED"
else
    echo "‚ùå CRITICAL: Task files verification: FAILED"
    create_error_report "$CODEX_WORK_DIR/task" "{{task_id}}" "Task files missing before agent execution"

    # Attempt recovery
    if attempt_task_recovery "/tmp/docs-repo" "$CODEX_WORK_DIR/task" "{{task_id}}"; then
        echo "‚úÖ Recovery successful - continuing with execution"
    else
        echo "‚ùå Recovery failed - cannot proceed without prompt.md"
        exit 1
    fi
fi

PROMPT_FILE="$CODEX_WORK_DIR/task/prompt.md"
echo "üìÑ Using prompt file: $PROMPT_FILE"

echo "startingTask:{{task_id}}"
echo ""

PROMPT_CONTENT="${PROMPT_PREFIX}$(cat "$PROMPT_FILE")"

ORIGINAL_PROMPT="$PROMPT_CONTENT"
PREVIOUS_MESSAGE_FILE=""
TOKEN_LIMIT=${CODEX_TOKEN_LIMIT:-240000}
CODEX_TIMEOUT=${CODEX_EXEC_TIMEOUT:-1800}
RESET_SESSION_ON_RETRY=${CODEX_RESET_SESSION_ON_RETRY:-1}
CONTINUE_SESSION=${CODEX_CONTINUE_SESSION:-1}

MAX_RETRIES=${CODEX_MAX_RETRIES:-${EXECUTION_MAX_RETRIES:-5}}
ATTEMPT=1
SUCCESS=0
CODEX_EXIT=1
LAST_MESSAGE_FILE=""
RUN_LOG=""
LAST_COMPLETION_REASON=""
NEXT_ITERATION_GUIDANCE=""

BILLING_FAILURE_DETECTED=0
BILLING_FAILURE_REASON=""

SESSION_DIR="$HOME/.codex/sessions"
RESUME_ARGS=()
SESSION_FILE="$CODEX_WORK_DIR/.codex-session"
CURRENT_SESSION_ID=""

# Circuit breaker: track repeated command failures
declare -A FAILED_COMMANDS
MAX_SAME_COMMAND_FAILURES=3

if [ -f "$SESSION_FILE" ]; then
  CURRENT_SESSION_ID=$(tr -d '\r\n ' < "$SESSION_FILE" 2>/dev/null || true)
fi

extract_session_id() {
  local log_file="$1"
  [ -f "$log_file" ] || return 1
  # Match both "codex session <id>" and "session id: <id>" formats
  grep -Eoi '(codex session|session id:)[[:space:]]+[0-9a-fA-F-]{8,}' "$log_file" 2>/dev/null | \
    sed -E 's/(codex session|session id:)[[:space:]]+//i' | \
    tail -n1
}

persist_session_id() {
  local session_id="$1"
  if [ -n "$session_id" ]; then
    printf '%s\n' "$session_id" > "$SESSION_FILE"
  fi
}

print_attempt_banner() {
  local attempt="$1"
  local max="$2"
  local unlimited="$3"
  local border="‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  local label

  if [ "$unlimited" = "1" ]; then
    label="‚ïë üöÄ EXECUTION ATTEMPT #${attempt} (UNLIMITED MODE)"
  elif [ -n "$max" ] && [ "$max" -gt 0 ]; then
    label="‚ïë üöÄ EXECUTION ATTEMPT ${attempt} / ${max}"
  else
    label="‚ïë üöÄ EXECUTION ATTEMPT #${attempt}"
  fi

  local base_padding=$(( ${#border} - ${#label} - 1 ))
  local extra_width=0

  if [[ "$label" == *"üöÄ"* ]]; then
    extra_width=$((extra_width + 1))
  fi

  local padding=$((base_padding - extra_width))
  if [ $padding -lt 0 ]; then
    padding=0
  fi

  echo ""
  echo "$border"
  printf '%s%*s‚ïë\n' "$label" "$padding" ""
  echo "$border"
  echo ""
}

if [ "$CONTINUE_SESSION" = "1" ]; then
  if [ -n "$CURRENT_SESSION_ID" ]; then
    echo "‚ÑπÔ∏è  Resuming Codex session from breadcrumb: $CURRENT_SESSION_ID"
    RESUME_ARGS=("resume" "$CURRENT_SESSION_ID")
  elif [ -d "$SESSION_DIR" ] && [ -n "$(find "$SESSION_DIR" -maxdepth 1 -type f -name '*.json' -print -quit 2>/dev/null)" ]; then
    echo "‚ÑπÔ∏è  Existing Codex sessions found; will resume most recent"
    RESUME_ARGS=("resume" "--last")
  fi
else
  if [ -d "$SESSION_DIR" ]; then
    find "$SESSION_DIR" -maxdepth 1 -type f -name '*.json' -delete 2>/dev/null || true
  fi
  rm -f "$SESSION_FILE"
fi

# =========================================================================
# Model rotation configuration
# =========================================================================
DEFAULT_MODEL="{{model}}"
MODEL_ROTATION=()
MODEL_ROTATION_COUNT=0
{{#if model_rotation}}
MODEL_ROTATION=(
{{#each model_rotation}}
"{{this}}"
{{/each}}
)
MODEL_ROTATION_COUNT=${#MODEL_ROTATION[@]}
if [ $MODEL_ROTATION_COUNT -gt 0 ]; then
  echo "üéØ Model rotation enabled (${MODEL_ROTATION_COUNT} models): ${MODEL_ROTATION[*]}"
fi
{{/if}}
if [ -z "$DEFAULT_MODEL" ] && [ $MODEL_ROTATION_COUNT -gt 0 ]; then
  DEFAULT_MODEL="${MODEL_ROTATION[0]}"
fi
if [ -n "$DEFAULT_MODEL" ]; then
  echo "üéØ Default model: $DEFAULT_MODEL"
fi

# =========================================================================
# QA Mode Safeguard: Prevent PR creation when in testing mode
# =========================================================================
if [ "${WORKFLOW_STAGE:-}" = "testing" ]; then
  echo "üõ°Ô∏è  QA Review Mode: Installing PR creation safeguard"

  # Create a wrapper function that blocks 'gh pr create' in QA mode
  gh() {
    if [[ "$1" == "pr" && "$2" == "create" ]]; then
      echo "‚ùå ERROR: 'gh pr create' is FORBIDDEN in QA review mode (WORKFLOW_STAGE=testing)"
      echo "‚ùå You are reviewing PR #${PR_NUMBER}, not creating a new one"
      echo "‚ùå Use 'gh pr checkout ${PR_NUMBER}' to work on the existing PR"
      echo "‚ùå Use 'gh pr review ${PR_NUMBER}' to approve/reject the PR"
      return 1
    fi
    command gh "$@"
  }
  export -f gh

  echo "‚úÖ Safeguard installed: 'gh pr create' is now blocked"
  echo "‚úÖ You can only review PR #${PR_NUMBER}"
fi

COMPLETED_ATTEMPTS=0
while [ $ATTEMPT -le $MAX_RETRIES ]; do
  print_attempt_banner "$ATTEMPT" "$MAX_RETRIES" "0"

  # Calculate which model to use for this attempt
  CURRENT_MODEL="$DEFAULT_MODEL"
  if [ $MODEL_ROTATION_COUNT -gt 0 ]; then
    MODEL_INDEX=$(((ATTEMPT - 1) % MODEL_ROTATION_COUNT))
    CURRENT_MODEL="${MODEL_ROTATION[$MODEL_INDEX]}"
  fi
  if [ -n "$CURRENT_MODEL" ]; then
    echo "üéØ Attempt $ATTEMPT will use model: $CURRENT_MODEL"
  fi

  # Refresh GitHub token every iteration to avoid expired credentials during long runs
  refresh_github_token || true
  ensure_gh_authenticated

  CURRENT_ATTEMPT=$ATTEMPT
  LAST_MESSAGE_FILE="/tmp/codex-last-message-${ATTEMPT}.txt"
  RUN_LOG="/tmp/codex-run-${ATTEMPT}.jsonl"

  SESSION_FLAGS=()
  if [ $ATTEMPT -eq 1 ] && [ ${#RESUME_ARGS[@]} -gt 0 ]; then
    SESSION_FLAGS=("${RESUME_ARGS[@]}")
  else
    SESSION_FLAGS=()
    if [ "$RESET_SESSION_ON_RETRY" = "1" ] && [ $ATTEMPT -gt 1 ] && [ -d "$SESSION_DIR" ]; then
      find "$SESSION_DIR" -maxdepth 1 -type f -name '*.json' -delete 2>/dev/null || true
      rm -f "$SESSION_FILE"
      CURRENT_SESSION_ID=""
    fi
  fi

  if [ $ATTEMPT -eq 1 ]; then
    PROMPT_PAYLOAD="$ORIGINAL_PROMPT"
  else
    if [ -n "$PREVIOUS_MESSAGE_FILE" ] && [ -s "$PREVIOUS_MESSAGE_FILE" ]; then
      PREVIOUS_SNIPPET=$(tail -n 40 "$PREVIOUS_MESSAGE_FILE" 2>/dev/null | sed 's/^/    /')
    else
      PREVIOUS_SNIPPET="    <no previous Codex summary available>"
    fi
    PROMPT_PAYLOAD="Continuing Task {{task_id}} for service {{service}} (attempt $ATTEMPT).

Previous Codex summary:
$PREVIOUS_SNIPPET

Focus on unresolved work, avoid repeating completed steps, and progress toward completion."
    if [ -n "$NEXT_ITERATION_GUIDANCE" ]; then
      PROMPT_PAYLOAD="${PROMPT_PAYLOAD}

${NEXT_ITERATION_GUIDANCE}"
    fi
  fi

  set +e
  set -o pipefail
  CODEX_CMD=(
    "codex"
    "--ask-for-approval" "never"
    "exec"
    "--dangerously-bypass-approvals-and-sandbox"
    "--skip-git-repo-check"
    "--output-last-message" "$LAST_MESSAGE_FILE"
    "--cd" "$CODEX_WORK_DIR"
    "-c" "shell_environment_policy.inherit=all"
  )
  if [ -n "$CURRENT_MODEL" ]; then
    CODEX_CMD+=("--model" "$CURRENT_MODEL")
  fi
  if [ ${#SESSION_FLAGS[@]} -gt 0 ]; then
    CODEX_CMD+=("${SESSION_FLAGS[@]}")
  fi
  CODEX_CMD+=("$PROMPT_PAYLOAD")

  if command -v timeout >/dev/null 2>&1; then
    timeout "$CODEX_TIMEOUT" "${CODEX_CMD[@]}" 2>&1 | tee "$RUN_LOG"
  else
    "${CODEX_CMD[@]}" 2>&1 | tee "$RUN_LOG"
  fi
  CODEX_EXIT=${PIPESTATUS[0]}
  set +o pipefail
  set -e

  if [ $CODEX_EXIT -eq 124 ]; then
    echo "‚è±Ô∏è Codex command exceeded ${CODEX_TIMEOUT}s timeout; terminating session"
    pkill -f "codex" 2>/dev/null || true
    PREVIOUS_MESSAGE_FILE="$LAST_MESSAGE_FILE"
    COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
    ATTEMPT=$((ATTEMPT + 1))
    continue
  fi

  echo "[codex-debug] Attempt $ATTEMPT finished with exit code $CODEX_EXIT"

  if [ $CODEX_EXIT -ne 0 ]; then
    echo "‚ö†Ô∏è Codex exited with status $CODEX_EXIT on attempt $ATTEMPT"

    if command -v detect_billing_failure >/dev/null 2>&1; then
      CLI_OUTPUT_SNIPPET=""
      if [ -f "$RUN_LOG" ]; then
        CLI_OUTPUT_SNIPPET=$(tail -n 400 "$RUN_LOG" 2>/dev/null || cat "$RUN_LOG" 2>/dev/null || true)
      fi

      if [ -n "$CLI_OUTPUT_SNIPPET" ]; then
        if ! detect_billing_failure "$CLI_OUTPUT_SNIPPET" "$CODEX_EXIT" "${PR_NUMBER:-}" "${REPOSITORY:-}" "$AGENT_NAME" "{{task_id}}" "${WORKFLOW_STAGE:-}" "{{workflow_name}}"; then
          BILLING_DETECT_EXIT=$?
          if [ "$BILLING_DETECT_EXIT" -eq 1 ]; then
            echo "üö´ Billing/quota failure detected - aborting additional Codex retries"
            BILLING_FAILURE_DETECTED=1
            BILLING_FAILURE_REASON="Billing or quota error detected for $AGENT_NAME. Restore provider credits/quota, then rerun task {{task_id}}."
            LAST_COMPLETION_REASON="$BILLING_FAILURE_REASON"
            NEXT_ITERATION_GUIDANCE=""
            break
          elif [ "$BILLING_DETECT_EXIT" -ne 0 ]; then
            echo "‚ö†Ô∏è Billing failure detector exited with status $BILLING_DETECT_EXIT"
          fi
        fi
      fi
    fi
  fi

  # Circuit breaker: detect repeated failing bash commands
  if [ -f "$RUN_LOG" ] && command -v jq >/dev/null 2>&1; then
    # Codex format: look for bash tool failures in JSON log
    # Note: Codex may output text, so this only works if JSON logging is enabled
    FAILED_CMD=$(jq -r 'select(.type=="bash" and (.exit_code // 0) != 0) | .command' "$RUN_LOG" 2>/dev/null | tail -n1 | head -c 100)

    # Fallback: grep for common error patterns in plain text logs
    if [ -z "$FAILED_CMD" ] && [ -f "$RUN_LOG" ]; then
      # Try to extract from text output (less reliable but better than nothing)
      FAILED_CMD=$(grep -oP '(?<=\$ ).*?(?= \(exit)' "$RUN_LOG" 2>/dev/null | tail -n1 | head -c 100 || true)
    fi

    if [ -n "$FAILED_CMD" ]; then
      # Track how many times this command has failed
      FAILED_COMMANDS["$FAILED_CMD"]=$((${FAILED_COMMANDS["$FAILED_CMD"]:-0} + 1))
      FAIL_COUNT=${FAILED_COMMANDS["$FAILED_CMD"]}

      if [ $FAIL_COUNT -ge $MAX_SAME_COMMAND_FAILURES ]; then
        echo "üî¥ CIRCUIT BREAKER TRIGGERED: Command has failed $FAIL_COUNT times in a row:"
        echo "   Command: $FAILED_CMD"
        echo "   This indicates the agent is stuck in a loop."

        # Inject intervention prompt for next attempt
        PROMPT_CONTENT="${PROMPT_CONTENT}

‚ö†Ô∏è **LOOP DETECTED**: You tried this command $FAIL_COUNT times:
\`\`\`bash
$FAILED_CMD
\`\`\`

It keeps failing. **STOP REPEATING THIS COMMAND.**

Try instead:
1. Check working directory: \`pwd\`
2. List files: \`ls -la\`
3. Use a completely different approach
4. Create files/directories step-by-step"

        # Reset counter
        FAILED_COMMANDS["$FAILED_CMD"]=0
      fi
    fi
  fi

  NEW_SESSION_ID=""
  if [ -n "$RUN_LOG" ] && [ -f "$RUN_LOG" ]; then
    # Ensure file is fully written (flush buffers)
    sync || true
    NEW_SESSION_ID=$(extract_session_id "$RUN_LOG" || true)
    echo "[codex-debug] Session extraction from $RUN_LOG: ${NEW_SESSION_ID:-<empty>}"
  else
    echo "[codex-debug] RUN_LOG not found or empty: RUN_LOG=${RUN_LOG:-<unset>}"
  fi
  if [ -n "$NEW_SESSION_ID" ]; then
    if [ "$CURRENT_SESSION_ID" != "$NEW_SESSION_ID" ]; then
      echo "‚ÑπÔ∏è  Captured Codex session ID: $NEW_SESSION_ID"
      CURRENT_SESSION_ID="$NEW_SESSION_ID"
      persist_session_id "$CURRENT_SESSION_ID"
    fi
  else
    echo "[codex-debug] Failed to extract session ID from log (attempt $ATTEMPT)"
  fi

  if [ "$CONTINUE_SESSION" = "1" ] && [ -n "$CURRENT_SESSION_ID" ]; then
    RESUME_ARGS=("resume" "$CURRENT_SESSION_ID")
  else
    RESUME_ARGS=()
  fi

  PREVIOUS_MESSAGE_FILE="$LAST_MESSAGE_FILE"

  # Enhanced token tracking with metrics storage
  if [ -f "$RUN_LOG" ]; then
    # Try multiple extraction methods for robustness
    LAST_TOKENS=$(grep -Eo 'tokens used: [0-9,]+' "$RUN_LOG" 2>/dev/null | tail -n1 | awk '{print $3}' | tr -d ',' | tr -d '\n' || true)

    # Also try JSON format if available
    if [ -z "$LAST_TOKENS" ] && command -v jq >/dev/null 2>&1; then
      TOKENS_IN=$(jq -r 'select(.tokens.input != null) | .tokens.input' "$RUN_LOG" 2>/dev/null | tail -n1)
      TOKENS_OUT=$(jq -r 'select(.tokens.output != null) | .tokens.output' "$RUN_LOG" 2>/dev/null | tail -n1)

      if [[ "$TOKENS_IN" =~ ^[0-9]+$ ]] && [[ "$TOKENS_OUT" =~ ^[0-9]+$ ]]; then
        LAST_TOKENS=$((TOKENS_IN + TOKENS_OUT))
        echo "üìä Codex tokens this attempt: input=$TOKENS_IN, output=$TOKENS_OUT, total=$LAST_TOKENS"

        # Store detailed metrics for cost analysis
        echo "{\"attempt\":$ATTEMPT,\"task_id\":\"{{task_id}}\",\"service\":\"{{service}}\",\"cli\":\"codex\",\"tokens_in\":$TOKENS_IN,\"tokens_out\":$TOKENS_OUT,\"tokens_total\":$LAST_TOKENS}" >> /tmp/codex-metrics.jsonl
      fi
    fi

    if [[ "$LAST_TOKENS" =~ ^[0-9]+$ ]]; then
      if [ -z "$TOKENS_IN" ]; then
        # Only total available from text format
        echo "üìä Codex tokens used this attempt: $LAST_TOKENS"
        echo "{\"attempt\":$ATTEMPT,\"task_id\":\"{{task_id}}\",\"service\":\"{{service}}\",\"cli\":\"codex\",\"tokens_total\":$LAST_TOKENS}" >> /tmp/codex-metrics.jsonl
      fi

      # Check token limit if configured
      if [ "${TOKEN_LIMIT:-0}" -gt 0 ] && [ "$LAST_TOKENS" -gt "$TOKEN_LIMIT" ]; then
        echo "‚ö†Ô∏è Token usage $LAST_TOKENS exceeds limit $TOKEN_LIMIT; forcing clean session before retry"
        if [ -d "$SESSION_DIR" ]; then
          find "$SESSION_DIR" -maxdepth 1 -type f -name '*.json' -delete 2>/dev/null || true
        fi
        PREVIOUS_MESSAGE_FILE="$LAST_MESSAGE_FILE"
        COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
        ATTEMPT=$((ATTEMPT + 1))
        continue
      fi
    fi
  fi

  COMPLETION_PROMPT="Task {{task_id}} completion verification.

**FIRST**: Review the acceptance criteria in task/acceptance-criteria.md

**Then answer 'yes' ONLY if ALL of these are true:**

1. **EVERY acceptance criterion is fully implemented** (not just started, but DONE)
2. All code changes are committed to git
3. Changes are pushed to remote branch feature/task-{{task_id}}-implementation
4. Quality gates passed (cargo fmt, cargo clippy with no warnings, tests pass)

**To verify:**
- Review: cat task/acceptance-criteria.md
- Git status: git status
- Commits pushed: git log origin/main..HEAD
- PR exists: gh pr view
- Tests pass: Check your test results

If incomplete, respond with:
no
REASON: <specific reason why not complete>

For 'no' responses, REASON must specify:
- Which acceptance criteria are incomplete (list them by number/name)
- What specific work remains (be concrete)
- Any blockers or issues encountered

Example 'no' response:
no
REASON: Acceptance criteria 2 and 4 incomplete. API endpoint /users created but not yet connected to database. PR created but tests failing due to missing error handling in user_controller.rs.

Your response:"
  COMPLETION_LAST_MESSAGE="/tmp/codex-completion-${ATTEMPT}.txt"
  COMPLETION_LOG="/tmp/codex-completion-${ATTEMPT}.jsonl"

  # Check if we have a session to resume before attempting completion probe
  if [ -z "$CURRENT_SESSION_ID" ]; then
    # Try to find the most recent session
    if [ -d "$SESSION_DIR" ]; then
      LATEST_SESSION=$(find "$SESSION_DIR" -maxdepth 1 -type f -name '*.json' -printf '%T@ %f\n' 2>/dev/null | sort -rn | head -n1 | awk '{print $2}' | sed 's/\.json$//' || true)
      if [ -n "$LATEST_SESSION" ]; then
        CURRENT_SESSION_ID="$LATEST_SESSION"
        echo "‚ÑπÔ∏è  Found latest session: $CURRENT_SESSION_ID"
      fi
    fi
  fi

  set +e
  set -o pipefail

  # Skip completion probe if no session exists
  if [ -z "$CURRENT_SESSION_ID" ]; then
    echo "‚ö†Ô∏è No Codex session found - skipping completion probe for attempt $ATTEMPT"
    COMPLETION_EXIT=0
    COMPLETION_OUTPUT=""
    COMPLETION_RESPONSE=""
  else
  COMPLETION_CMD=(
    "codex"
    "--ask-for-approval" "never"
    "exec"
    "--dangerously-bypass-approvals-and-sandbox"
    "--skip-git-repo-check"
    "--output-last-message" "$COMPLETION_LAST_MESSAGE"
    "--cd" "$CODEX_WORK_DIR"
    "resume"
      "$CURRENT_SESSION_ID"
      "$COMPLETION_PROMPT"
    )
  COMPLETION_OUTPUT=$("${COMPLETION_CMD[@]}" 2>&1 | tee "$COMPLETION_LOG")
  COMPLETION_EXIT=${PIPESTATUS[0]}

  if [ $COMPLETION_EXIT -ne 0 ]; then
    echo "‚ö†Ô∏è Completion probe exited with status $COMPLETION_EXIT"
  fi

  echo "[codex-debug] Completion probe for attempt $ATTEMPT exited $COMPLETION_EXIT"

  # Look for explicit yes/no, OR common completion phrases
  # Extract yes/no from lines starting with ** (markdown bold) or standalone lines
  # This avoids false matches from phrases like "no warnings" or "no errors"
  COMPLETION_RESPONSE=$(printf '%s\n' "$COMPLETION_OUTPUT" | tr -d '\r' | grep -Eio '^\*\*(yes|no)\*\*|^(yes|no)$' | sed 's/\*//g' | head -n1 | tr '[:upper:]' '[:lower:]')

  # Fallback: detect implicit completion signals if no explicit yes/no
  if [ -z "$COMPLETION_RESPONSE" ]; then
    if printf '%s\n' "$COMPLETION_OUTPUT" | grep -Eiq '(task.*(complete|finished|done)|work.*(complete|finished)|security work complete)'; then
      echo "[codex-debug] Detected implicit completion signal in probe output"
      COMPLETION_RESPONSE="yes"
    fi
  fi
  fi

  set +o pipefail
  set -e

  echo "[codex-debug] Final completion response: ${COMPLETION_RESPONSE:-<none>}"

  CURRENT_REASON=""
  if [ "$COMPLETION_RESPONSE" = "no" ]; then
    CURRENT_REASON=$(printf '%s\n' "$COMPLETION_OUTPUT" | awk 'BEGIN{IGNORECASE=1}/^reason:/{sub(/^reason:[[:space:]]*/,"");flag=1} flag{print}')
    if [ -n "$CURRENT_REASON" ]; then
      echo "üìã Incompletion details:"
      echo "$CURRENT_REASON"
      echo ""
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo "‚ïë üîÅ NEXT ITERATION FOCUS (FROM COMPLETION PROBE)              ‚ïë"
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      printf '%s\n' "$CURRENT_REASON"
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo ""
      NEXT_ITERATION_GUIDANCE="üîÅ **NEXT ITERATION FOCUS (from completion probe attempt $ATTEMPT)**\n\n${CURRENT_REASON}\n\nAddress the items above before rerunning checks."
      LAST_COMPLETION_REASON="$CURRENT_REASON"
    else
      echo "‚ö†Ô∏è Completion probe reported 'no' without a reason"
      NEXT_ITERATION_GUIDANCE=""
    fi
  else
    NEXT_ITERATION_GUIDANCE=""
  fi

  if [ "$COMPLETION_RESPONSE" = "yes" ]; then
    SUCCESS=1
    COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
    break
  fi

  if [ -n "$COMPLETION_RESPONSE" ]; then
    echo "[codex-debug] Completion response on attempt $ATTEMPT: $COMPLETION_RESPONSE"
  else
    echo "[codex-debug] Completion response on attempt $ATTEMPT: <none>"
  fi

  if [ -n "$CURRENT_REASON" ]; then
    echo "‚ö†Ô∏è Codex reported task incomplete; retrying with new guidance..."
  else
    echo "‚ö†Ô∏è Codex reported task incomplete; retrying..."
  fi
  COMPLETED_ATTEMPTS=$CURRENT_ATTEMPT
  ATTEMPT=$((ATTEMPT + 1))
done

if [ "${BILLING_FAILURE_DETECTED:-0}" -eq 1 ]; then
  echo ""
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo "‚ïë      TASK COMPLETION STATUS: BLOCKED - BILLING/QUOTA ISSUE    ‚ïë"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo ""
  echo "‚ùå ${AGENT_NAME} cannot continue until provider billing/quota issues are resolved."
  echo "   A remediation comment has been posted to the PR with details."
  if [ -n "$BILLING_FAILURE_REASON" ]; then
    echo ""
    echo "üìã Reason:"
    echo "$BILLING_FAILURE_REASON"
  fi
  echo ""
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  EXIT_CODE=1
  SUCCESS=0
  FINAL_MESSAGE="$BILLING_FAILURE_REASON"
  exit $EXIT_CODE
fi

FINAL_ATTEMPTS=$COMPLETED_ATTEMPTS
if [ "${FINAL_ATTEMPTS:-0}" -le 0 ]; then
  FINAL_ATTEMPTS=$((ATTEMPT - 1))
fi
if [ $FINAL_ATTEMPTS -gt $MAX_RETRIES ]; then
  FINAL_ATTEMPTS=$MAX_RETRIES
fi

if [ $SUCCESS -ne 1 ]; then
  echo "‚ö†Ô∏è Codex did not confirm task completion after $MAX_RETRIES attempts"

  # Document remaining work for downstream agents (stage-aware)
  echo ""

  # Determine handoff target and agent name based on workflow stage
  HANDOFF_TARGET="Cleo"
  HANDOFF_AGENT="Rex"
  HANDOFF_FILE="$CODEX_WORK_DIR/task/rex-handoff.md"

  case "${WORKFLOW_STAGE:-implementation}" in
    "implementation")
      HANDOFF_TARGET="Cleo"
      HANDOFF_AGENT="Rex"
      HANDOFF_FILE="$CODEX_WORK_DIR/task/rex-handoff.md"
      ;;
    "quality"|"quality-in-progress")
      HANDOFF_TARGET="Tess"
      HANDOFF_AGENT="Cleo"
      HANDOFF_FILE="$CODEX_WORK_DIR/task/cleo-handoff.md"
      ;;
    "security"|"security-in-progress")
      HANDOFF_TARGET="Tess"
      HANDOFF_AGENT="Cipher"
      HANDOFF_FILE="$CODEX_WORK_DIR/task/cipher-handoff.md"
      ;;
    "testing"|"testing-in-progress")
      HANDOFF_TARGET="Human Reviewer"
      HANDOFF_AGENT="Tess"
      HANDOFF_FILE="$CODEX_WORK_DIR/task/tess-handoff.md"
      ;;
    *)
      HANDOFF_TARGET="Next Agent"
      HANDOFF_AGENT="${AGENT_NAME:-Agent}"
      HANDOFF_FILE="$CODEX_WORK_DIR/task/agent-handoff.md"
      ;;
  esac

  echo "üìù Creating handoff document for $HANDOFF_TARGET..."
  mkdir -p "$CODEX_WORK_DIR/task"

  # Prepare handoff content with proper variable expansion
  HANDOFF_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
  if [ -n "$LAST_COMPLETION_REASON" ]; then
    REMAINING_WORK_SECTION="$LAST_COMPLETION_REASON"
  else
    REMAINING_WORK_SECTION=$'Review the completion probe responses in the logs above for details on what remains to be done.
Compare current implementation against acceptance criteria in task/acceptance-criteria.md.'
  fi

  cat > "$HANDOFF_FILE" << EOF
# $HANDOFF_AGENT Handoff to $HANDOFF_TARGET

**Status**: Incomplete after $FINAL_ATTEMPTS iterations (max: $MAX_RETRIES)
**Date**: $HANDOFF_DATE
**Task**: {{task_id}}
**Stage**: ${WORKFLOW_STAGE:-implementation}

## What Was Accomplished

$HANDOFF_AGENT made $FINAL_ATTEMPTS attempts to complete this task. Review the PR and commit history for details on what was done.

## Remaining Work

$REMAINING_WORK_SECTION

## Next Steps for $HANDOFF_TARGET

1. Review the PR and commits made by $HANDOFF_AGENT
2. Identify gaps between current state and acceptance criteria
3. Complete any remaining work
4. Ensure all checks pass before proceeding

## Acceptance Criteria Reference

See \`task/acceptance-criteria.md\` for complete requirements.

---
*Generated by $HANDOFF_AGENT (Codex) after $FINAL_ATTEMPTS attempts*
EOF

  echo "‚úÖ Handoff document created at $(basename "$HANDOFF_FILE")"

  # Commit and push the handoff document
  cd "$CODEX_WORK_DIR"
  git add "task/$(basename "$HANDOFF_FILE")" 2>/dev/null || true
  git commit -m "docs(task-{{task_id}}): add $HANDOFF_AGENT handoff document

$HANDOFF_AGENT completed $FINAL_ATTEMPTS iterations with incomplete status (max: $MAX_RETRIES).
Handoff document created for $HANDOFF_TARGET to continue work." 2>/dev/null || echo "‚ö†Ô∏è Could not commit handoff document"

  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
  if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "master" ]; then
    git push origin HEAD 2>/dev/null || echo "‚ö†Ô∏è Could not push handoff document"
  fi

  # Check if agent made any commits before deciding to handoff vs fail
  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
  REMOTE_BASE="origin/${BASE_BRANCH:-main}"
  COMMITS_MADE=0

  if [ -n "$CURRENT_BRANCH" ]; then
    safe_git_fetch origin "$BASE_BRANCH" || true
    AHEAD_COUNT=$(git rev-list --left-right "$REMOTE_BASE...$CURRENT_BRANCH" 2>/dev/null | awk '/^>/{c++} END{print c+0}')
    if [ "${AHEAD_COUNT:-0}" -gt 0 ]; then
      COMMITS_MADE=1
      echo "‚úÖ $AGENT_NAME made $AHEAD_COUNT commit(s) - will handoff to next stage"
    else
      echo "‚ö†Ô∏è $AGENT_NAME made NO commits - cannot handoff without progress"
    fi
  fi

  if [ "$COMMITS_MADE" -eq 1 ]; then
    # Agent made progress - BUT check if this is Cipher with security issues
    # Cipher must NOT hand off to Tess if security issues found (even if commits were made)
    if [ "$WORKFLOW_STAGE" = "security" ] || [ "$WORKFLOW_STAGE" = "security-in-progress" ]; then
      echo ""
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo "‚ïë      CIPHER SECURITY GATE: ISSUES FOUND - BLOCKING TESS      ‚ïë"
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo ""
      echo "üõë Security issues detected - Tess handoff BLOCKED"
      echo "   - Cipher found security vulnerabilities or policy violations"
      echo "   - Rex remediation will be triggered to fix issues"
      echo "   - Cipher will re-scan after Rex pushes fixes"
      echo "   - Tess will only start after Cipher approves"
      echo ""
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      
      EXIT_CODE=1  # Exit with failure to block workflow progression
    else
      # Non-security stages can handoff with partial completion
      echo ""
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo "‚ïë          TASK COMPLETION STATUS: PARTIAL - HANDOFF           ‚ïë"
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      echo ""
      echo "üîÑ NEXT STEPS:"
      echo "   - Handoff document created at task/rex-handoff.md"
      echo "   - Workflow will continue to next stage for completion"
      echo "   - Next agent will review PR and continue work"
      echo ""
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

      EXIT_CODE=0  # Exit successfully to allow next stage to continue
    fi
  else
    # Agent made NO progress - this is a failure, should retry
    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "‚ïë          TASK COMPLETION STATUS: FAILED - NO PROGRESS         ‚ïë"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo ""
    echo "‚ùå Rex failed to make any commits after $MAX_RETRIES attempts"
    echo ""
    if [ -n "$LAST_COMPLETION_REASON" ]; then
      echo "üìã LAST COMPLETION REASON:"
      echo "$LAST_COMPLETION_REASON"
    else
      echo "‚ö†Ô∏è Codex did not provide a reason for incompletion"
      echo "   This may indicate an error occurred before Codex could respond"
    fi
    echo ""
    echo "üîÑ NEXT STEPS:"
    echo "   - Check Codex logs above for errors"
    echo "   - CodeRun will retry this task"
    echo "   - If retries exhausted, workflow will fail"
    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo ""
    EXIT_CODE=1  # Exit with failure to trigger retry
  fi
else
  echo "‚úÖ Codex confirmed task completion"
  if [ ${CODEX_EXIT:-0} -ne 0 ]; then
    echo "‚ö†Ô∏è Codex returned non-zero exit code ${CODEX_EXIT}, but completion probe passed"
  fi
  EXIT_CODE=0
fi

# Only implementation agents (Rex/Blaze) create PRs; quality/security/testing agents work on existing PRs
if [ "$WORKFLOW_STAGE" = "quality-in-progress" ] || [ "$WORKFLOW_STAGE" = "security-in-progress" ] || [ "$WORKFLOW_STAGE" = "testing-in-progress" ]; then
  echo "‚ÑπÔ∏è Non-implementation stage ($WORKFLOW_STAGE) - working on existing PR from implementation agent"
  # Quality/security/testing agents should NEVER create PRs, only work on existing ones
elif [ "$COMMITS_MADE" -eq 1 ] && [ "$WORKFLOW_STAGE" = "implementation" ]; then
  echo "üîç Implementation agent ($AGENT_NAME) made commits - ensuring PR exists"
  ensure_pr_created || echo "‚ö†Ô∏è PR creation failed or no PR was created"
elif [ $SUCCESS -eq 1 ] && [ "$WORKFLOW_STAGE" = "implementation" ]; then
  echo "üîç Implementation stage complete - verifying pull request status"
  ensure_pr_created
else
  echo "‚ÑπÔ∏è Skipping PR creation (non-implementation stage or no work done)"
fi

# Map CodeRun stage values to workflow stage labels expected by container logic
case "${WORKFLOW_STAGE:-}" in
  "quality")
    WORKFLOW_STAGE="quality-in-progress"
    ;;
  "testing")
    WORKFLOW_STAGE="testing-in-progress"
    ;;
  *)
    # Use existing value for other stages (implementation, etc.)
    ;;
esac

RESOLVED_PR_URL="$(resolve_pr_url)"
FINAL_PHASE="Running"
FINAL_REMEDIATION_STATUS=""
FINAL_QA_STATUS=""
FINAL_MESSAGE=""

if [ "$WORKFLOW_STAGE" != "quality-in-progress" ] && [ "$WORKFLOW_STAGE" != "security-in-progress" ] && [ "$WORKFLOW_STAGE" != "testing-in-progress" ]; then
  if [ $SUCCESS -eq 1 ]; then
    FINAL_REMEDIATION_STATUS="ready-for-security"
    FINAL_MESSAGE="Implementation completed - ready for security review"
  else
    FINAL_REMEDIATION_STATUS="needs-fixes"
    FINAL_MESSAGE="Implementation requires follow-up"
  fi
fi

if [ $SUCCESS -ne 1 ] && [ -n "$LAST_COMPLETION_REASON" ]; then
  FINAL_MESSAGE="$LAST_COMPLETION_REASON"
fi

# Submit GitHub PR review for Cleo/Tess stages (enables workflow progression)
if [ "$WORKFLOW_STAGE" = "quality-in-progress" ] || [ "$WORKFLOW_STAGE" = "security-in-progress" ] || [ "$WORKFLOW_STAGE" = "testing-in-progress" ]; then
  PR_NUM="${PR_NUMBER:-}"
  if [ -z "$PR_NUM" ]; then
    # Try to get PR number from current branch
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
    if [ -n "$CURRENT_BRANCH" ]; then
      PR_NUM=$(gh pr list --state open --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")
    fi
  fi

  if [ -n "$PR_NUM" ]; then
    # Run actual quality gate checks instead of relying on $SUCCESS
    QUALITY_GATES_PASSED=1

    if [ "$WORKFLOW_STAGE" = "quality-in-progress" ]; then
      echo "üîç Running quality gate checks..."

      # Check 1: Code formatting
      echo "  ‚û§ Checking code formatting (cargo fmt)..."
      if ! cargo fmt --all -- --check >/tmp/fmt-check.log 2>&1; then
        echo "    ‚ùå Formatting check failed"
        QUALITY_GATES_PASSED=0
      else
        echo "    ‚úÖ Formatting check passed"
      fi

      # Check 2: Linting with pedantic Clippy
      echo "  ‚û§ Checking lints (cargo clippy)..."
      if ! cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic >/tmp/clippy-check.log 2>&1; then
        echo "    ‚ùå Clippy check failed"
        QUALITY_GATES_PASSED=0
      else
        echo "    ‚úÖ Clippy check passed"
      fi

      # Check 3: Unit tests
      echo "  ‚û§ Running unit tests (cargo test)..."
      if ! cargo test --workspace --all-features >/tmp/test-check.log 2>&1; then
        echo "    ‚ùå Tests failed"
        QUALITY_GATES_PASSED=0
      else
        echo "    ‚úÖ Tests passed"
      fi
    elif [ "$WORKFLOW_STAGE" = "security-in-progress" ]; then
      echo "üîç Running security checks..."

      # Security checks can assume code passed quality gates
      # Focus on security-specific validations
      echo "  ‚û§ Security scan completed by Cipher"
      if [ $SUCCESS -ne 1 ]; then
        echo "    ‚ùå Security issues detected"
        QUALITY_GATES_PASSED=0
      else
        echo "    ‚úÖ Security checks passed"
      fi
    elif [ "$WORKFLOW_STAGE" = "testing-in-progress" ]; then
      echo "üîç Running integration and E2E tests..."

      # Run the same quality gates as quality stage, plus acceptance criteria validation
      echo "  ‚û§ Checking code formatting (cargo fmt)..."
      if ! cargo fmt --all -- --check >/tmp/fmt-check.log 2>&1; then
        echo "    ‚ùå Formatting check failed"
        QUALITY_GATES_PASSED=0
      else
        echo "    ‚úÖ Formatting check passed"
      fi

      echo "  ‚û§ Checking lints (cargo clippy)..."
      if ! cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic >/tmp/clippy-check.log 2>&1; then
        echo "    ‚ùå Clippy check failed"
        QUALITY_GATES_PASSED=0
      else
        echo "    ‚úÖ Clippy check passed"
      fi

      echo "  ‚û§ Running tests (cargo test)..."
      if ! cargo test --workspace --all-features >/tmp/test-check.log 2>&1; then
        echo "    ‚ùå Tests failed"
        QUALITY_GATES_PASSED=0
      else
        echo "    ‚úÖ Tests passed"
      fi

      # Validate acceptance criteria completion
      if [ $SUCCESS -ne 1 ]; then
        echo "    ‚ùå Codex did not confirm acceptance criteria completion"
        QUALITY_GATES_PASSED=0
      else
        echo "    ‚úÖ Acceptance criteria validated by Codex"
      fi
    fi

    if [ $QUALITY_GATES_PASSED -eq 1 ] && [ $SUCCESS -eq 1 ]; then
      STAGE_NAME="Quality"
      STAGE_EMOJI="üõ°Ô∏è"
      CHECKS_PASSED="- Code formatting verified
- Linting passed
- Unit tests successful
- Quality standards met"
      NEXT_STAGE="end-to-end testing by Tess"

      if [ "$WORKFLOW_STAGE" = "security" ] || [ "$WORKFLOW_STAGE" = "security-in-progress" ]; then
        # Cipher security review
        STAGE_NAME="Security"
        STAGE_EMOJI="üîí"
        CHECKS_PASSED="- No vulnerabilities detected
- Dependency audit passed
- Secret scanning completed
- Security best practices verified"
        NEXT_STAGE="QA testing by Tess"

        echo "‚úÖ $STAGE_NAME checks passed - posting APPROVE review"
        REVIEW_BODY_FILE=$(mktemp)
        cat <<EOF > "$REVIEW_BODY_FILE"
### $STAGE_EMOJI $STAGE_NAME Review - APPROVED
All security checks have passed:
$CHECKS_PASSED

**Status:** Ready for $NEXT_STAGE
**Next Step:** Tess will now perform comprehensive QA validation

---
*Security review by Cipher*
EOF
        refresh_token_if_needed || true
        timeout 30 gh pr review "$PR_NUM" --approve --body-file "$REVIEW_BODY_FILE" 2>&1 || echo "‚ö†Ô∏è PR review command failed"
        rm -f "$REVIEW_BODY_FILE"

        # Add security-approved label (create if missing)
        LABEL_NAME="security-approved"
        LABEL_API_PATH=$(printf '%s' "$LABEL_NAME" | sed 's/ /%20/g')
        echo "üè∑Ô∏è  Ensuring '$LABEL_NAME' label exists"
        if ! gh api -H "Accept: application/vnd.github+json" "repos/$REPO_OWNER/$REPO_NAME/labels/$LABEL_API_PATH" >/dev/null 2>&1; then
          gh api -X POST \
            -H "Accept: application/vnd.github+json" \
            "repos/$REPO_OWNER/$REPO_NAME/labels" \
            -f name="$LABEL_NAME" \
            -f color="0E8A16" \
            -f description="Cipher security gate approval" >/dev/null 2>&1 || echo "‚ö†Ô∏è Unable to create $LABEL_NAME label"
        fi
        echo "üè∑Ô∏è  Adding '$LABEL_NAME' label"
        if ! gh api -X POST \
          -H "Accept: application/vnd.github+json" \
          "repos/$REPO_OWNER/$REPO_NAME/issues/$PR_NUM/labels" \
          -F labels[]="$LABEL_NAME" >/dev/null 2>&1; then
          echo "‚ö†Ô∏è Failed to add $LABEL_NAME label"
        fi

        LABEL_READY_FOR_SECURITY="ready-for-security"
        LABEL_READY_FOR_QA="ready-for-qa"
        echo "üßπ Removing '$LABEL_READY_FOR_SECURITY' label after security approval"
        gh api -X DELETE \
          -H "Accept: application/vnd.github+json" \
          "repos/$REPO_OWNER/$REPO_NAME/issues/$PR_NUM/labels/$LABEL_READY_FOR_SECURITY" >/dev/null 2>&1 || echo "‚ÑπÔ∏è '$LABEL_READY_FOR_SECURITY' label already absent"

        # Add ready-for-qa label to trigger Tess (DO NOT refresh - causes duplicate runs)
        LABEL_READY_FOR_QA="ready-for-qa"
        echo "üè∑Ô∏è  Adding '$LABEL_READY_FOR_QA' label to signal Tess (if not already present)"
        if ! gh api "repos/$REPO_OWNER/$REPO_NAME/issues/$PR_NUM/labels" --jq '.[].name' 2>/dev/null | grep -q "^${LABEL_READY_FOR_QA}$"; then
          if gh api -X POST \
            -H "Accept: application/vnd.github+json" \
            "repos/$REPO_OWNER/$REPO_NAME/issues/$PR_NUM/labels" \
            -F labels[]="$LABEL_READY_FOR_QA" >/dev/null 2>&1; then
            echo "‚úÖ Added '$LABEL_READY_FOR_QA' label to trigger Tess"
          else
            echo "‚ö†Ô∏è Failed to add $LABEL_READY_FOR_QA label"
          fi
        else
          echo "‚ÑπÔ∏è  Label '$LABEL_READY_FOR_QA' already present - no action needed"
        fi
      elif [ "$WORKFLOW_STAGE" = "testing-in-progress" ]; then
        # Tess has final approval authority - but ONLY if CI passes
        STAGE_NAME="QA Testing"
        STAGE_EMOJI="üß™"
        CHECKS_PASSED="- End-to-end tests passed
- Integration tests successful
- Acceptance criteria validated
- Production readiness confirmed"
        NEXT_STAGE="human review and merge"

        # CRITICAL: Check GitHub CI status before approving
        if [ $SUCCESS -eq 1 ]; then
          echo "üîç Verifying GitHub CI status before Tess approval..."
          CI_CHECK_FAILED=0
          
          CI_TIMEOUT=300
          CI_WAIT=0
          CI_ALL_COMPLETE=false
          
          while [ $CI_WAIT -lt $CI_TIMEOUT ]; do
            PENDING_COUNT=$(gh pr checks "$PR_NUM" --json state --jq '[.[] | select(.state != "COMPLETED")] | length' 2>/dev/null || echo "99")
            
            if [ "${PENDING_COUNT:-99}" -eq 0 ]; then
              CI_ALL_COMPLETE=true
              echo "‚úÖ All CI checks completed"
              break
            fi
            
            echo "‚è≥ Waiting for CI... ${PENDING_COUNT} pending (${CI_WAIT}s / ${CI_TIMEOUT}s)"
            sleep 15
            CI_WAIT=$((CI_WAIT + 15))
          done
          
          if [ "$CI_ALL_COMPLETE" = "false" ]; then
            echo "‚ö†Ô∏è CI still running after ${CI_TIMEOUT}s - NOT approving"
            CI_CHECK_FAILED=1
          else
            FAILED_COUNT=$(gh pr checks "$PR_NUM" --json conclusion --jq '[.[] | select(.conclusion == "FAILURE" or .conclusion == "CANCELLED")] | length' 2>/dev/null || echo "0")
            
            if [ "${FAILED_COUNT:-0}" -gt 0 ]; then
              echo "‚ùå ${FAILED_COUNT} CI check(s) FAILED - NOT approving"
              CI_CHECK_FAILED=1
            else
              echo "‚úÖ All CI checks PASSED"
            fi
          fi
          
          if [ $CI_CHECK_FAILED -eq 1 ]; then
            SUCCESS=0
            CHECKS_PASSED="CI checks must pass before approval"
          fi
        fi

        # Check if this is the final task requiring deployment verification
        DEPLOYMENT_STATUS=""
        if [ "${FINAL_TASK:-false}" = "true" ] && [ $SUCCESS -eq 1 ]; then
          echo "üéØ Final task detected - verifying Kubernetes deployment"

          # Extract service name from repository or use default
          SERVICE_NAME="${SERVICE_NAME:-$(basename "$REPOSITORY" .git)}"
          NAMESPACE="${NAMESPACE:-agent-platform}"

          # Check for deployment
          if kubectl get deployment "$SERVICE_NAME" -n "$NAMESPACE" &>/dev/null; then
            READY_REPLICAS=$(kubectl get deployment "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            DESIRED_REPLICAS=$(kubectl get deployment "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")

            if [ "$READY_REPLICAS" = "$DESIRED_REPLICAS" ] && [ "$READY_REPLICAS" != "0" ]; then
              echo "‚úÖ Deployment verified: $READY_REPLICAS/$DESIRED_REPLICAS replicas ready"

              # Get ingress URLs
              INGRESS_URLS=$(kubectl get ingress -n "$NAMESPACE" -o jsonpath='{range .items[*]}{.spec.rules[*].host}{"\n"}{end}' 2>/dev/null | grep -v "^$" || echo "")

              if [ -n "$INGRESS_URLS" ]; then
                DEPLOYMENT_STATUS="

## üöÄ Deployment Verified
- **Service**: $SERVICE_NAME
- **Namespace**: $NAMESPACE
- **Status**: ‚úÖ $READY_REPLICAS/$DESIRED_REPLICAS replicas ready
- **Live URLs**:
$(echo "$INGRESS_URLS" | sed 's/^/  - https:\/\//')"
              else
                DEPLOYMENT_STATUS="

## üöÄ Deployment Verified
- **Service**: $SERVICE_NAME
- **Namespace**: $NAMESPACE
- **Status**: ‚úÖ $READY_REPLICAS/$DESIRED_REPLICAS replicas ready
- **Access**: Service deployed (no ingress configured)"
              fi
            else
              echo "‚ö†Ô∏è Deployment not ready: $READY_REPLICAS/$DESIRED_REPLICAS replicas"
              DEPLOYMENT_STATUS="

## ‚ö†Ô∏è Deployment Not Ready
- **Service**: $SERVICE_NAME
- **Namespace**: $NAMESPACE
- **Status**: ‚è≥ $READY_REPLICAS/$DESIRED_REPLICAS replicas ready
- **Action Required**: Waiting for deployment to stabilize"
            fi
          else
            echo "‚ö†Ô∏è Deployment not found: $SERVICE_NAME in namespace $NAMESPACE"
            DEPLOYMENT_STATUS="

## ‚ö†Ô∏è Deployment Not Found
- **Service**: $SERVICE_NAME
- **Namespace**: $NAMESPACE
- **Status**: ‚ùå Deployment not detected
- **Action Required**: Ensure deployment manifests are applied"
          fi
        fi

        echo "‚úÖ $STAGE_NAME complete - posting APPROVE review (Tess final approval)"
        REVIEW_BODY=$(cat <<EOF
### $STAGE_EMOJI $STAGE_NAME Review - APPROVED
All checks have passed:
$CHECKS_PASSED
Ready for $NEXT_STAGE.$DEPLOYMENT_STATUS

**Final Approval:** Tess has verified all acceptance criteria are met.
EOF
)
        refresh_token_if_needed || true
        timeout 30 gh pr review "$PR_NUM" --approve --body "$REVIEW_BODY" 2>&1 || echo "‚ö†Ô∏è PR review command failed"

        # Auto-merge if enabled (Tess only)
        if [ "${AUTO_MERGE:-false}" = "true" ]; then
          echo "üîÄ AUTO_MERGE enabled - merging PR automatically"
          if timeout 30 gh pr merge "$PR_NUM" --auto --squash --delete-branch; then
            echo "‚úÖ PR scheduled for auto-merge"
          else
            echo "‚ö†Ô∏è Auto-merge failed - PR may need manual intervention"
          fi
        fi
      else
        # Cleo hands off to Tess via comment and label (NOT approve)
        echo "‚úÖ $STAGE_NAME checks passed - handing off to Tess"
        REVIEW_BODY=$(cat <<EOF
### $STAGE_EMOJI $STAGE_NAME Review - PASSED
All checks have passed:
$CHECKS_PASSED

**Status:** Ready for $NEXT_STAGE
**Next Step:** Tess will now perform comprehensive QA validation

---
*Quality review by Cleo*
EOF
)
        refresh_token_if_needed || true
        timeout 30 gh pr comment "$PR_NUM" --body "$REVIEW_BODY" 2>&1 || echo "‚ö†Ô∏è PR comment command failed"

        # Add ready-for-security label to signal Cipher
        echo "üè∑Ô∏è  Adding 'ready-for-security' label to trigger Cipher review"
        timeout 30 gh pr edit "$PR_NUM" --add-label "ready-for-security" 2>&1 || echo "‚ö†Ô∏è Failed to add ready-for-security label"
      fi

      if [ "$WORKFLOW_STAGE" = "quality-in-progress" ]; then
        FINAL_REMEDIATION_STATUS="ready-for-security"
        FINAL_QA_STATUS="quality-passed"
        FINAL_MESSAGE="Quality review passed - ready for security testing"
      elif [ "$WORKFLOW_STAGE" = "security-in-progress" ]; then
        FINAL_REMEDIATION_STATUS="security-approved"
        FINAL_QA_STATUS="security-passed"
        FINAL_MESSAGE="Security review passed - ready for QA testing"
      else
        FINAL_REMEDIATION_STATUS="approved"
        FINAL_QA_STATUS="approved"
        FINAL_MESSAGE="QA testing approved"
      fi
    else
      STAGE_NAME="Quality"
      STAGE_EMOJI="üõ°Ô∏è"
      ISSUES_DESC="- Review code formatting
- Fix linting errors
- Ensure unit tests pass
- Meet quality standards"
      FAILURE_LOGS=""

      if [ "$WORKFLOW_STAGE" = "quality-in-progress" ]; then
        # Collect failure details from logs
        if [ -f /tmp/fmt-check.log ]; then
          FAILURE_LOGS="${FAILURE_LOGS}\n\n<details><summary>Formatting Issues</summary>\n\n\n```
$(cat /tmp/fmt-check.log | head -n 50)
```
</details>"
        fi
        if [ -f /tmp/clippy-check.log ]; then
          FAILURE_LOGS="${FAILURE_LOGS}\n\n<details><summary>Clippy Warnings</summary>\n\n\n```
$(cat /tmp/clippy-check.log | head -n 50)
```
</details>"
        fi
        if [ -f /tmp/test-check.log ]; then
          FAILURE_LOGS="${FAILURE_LOGS}\n\n<details><summary>Test Failures</summary>\n\n\n```
$(cat /tmp/test-check.log | tail -n 100)
```
</details>"
        fi
      elif [ "$WORKFLOW_STAGE" = "security-in-progress" ]; then
        STAGE_NAME="Security"
        STAGE_EMOJI="üîí"
        ISSUES_DESC="- Fix security vulnerabilities
- Update insecure dependencies
- Remove exposed secrets
- Address security best practice violations"
      elif [ "$WORKFLOW_STAGE" = "testing-in-progress" ]; then
        STAGE_NAME="QA Testing"
        STAGE_EMOJI="üß™"
        ISSUES_DESC="- Fix failing end-to-end tests
- Address integration test failures
- Validate acceptance criteria
- Ensure production readiness"
      fi

      echo "‚ùå $STAGE_NAME issues detected - posting REQUEST CHANGES review"
      REVIEW_BODY=$(cat <<EOF
### üî¥ Required Changes
$STAGE_NAME issues detected. Please address the following:
$ISSUES_DESC
$FAILURE_LOGS
EOF
)
      refresh_token_if_needed || true
      timeout 30 gh pr review "$PR_NUM" --request-changes --body "$REVIEW_BODY" 2>&1 || echo "‚ö†Ô∏è PR review command failed"

      FINAL_REMEDIATION_STATUS="needs-fixes"
      FINAL_QA_STATUS="changes_requested"
      if [ "$WORKFLOW_STAGE" = "quality-in-progress" ]; then
        FINAL_MESSAGE="Quality review requested changes"
      elif [ "$WORKFLOW_STAGE" = "security-in-progress" ]; then
        FINAL_MESSAGE="Security review requested changes"
      else
        FINAL_MESSAGE="Testing requested changes"
      fi
    fi
  fi
fi

if [ -z "$FINAL_MESSAGE" ]; then
  if [ $SUCCESS -eq 1 ]; then
    FINAL_MESSAGE="Task execution completed"
    if [ -z "$FINAL_REMEDIATION_STATUS" ]; then
      FINAL_REMEDIATION_STATUS="ready-for-qa"
    fi
  else
    FINAL_MESSAGE="Task execution incomplete"
    if [ -z "$FINAL_REMEDIATION_STATUS" ]; then
      FINAL_REMEDIATION_STATUS="needs-fixes"
    fi
  fi
fi

patch_coderun_status \
  "$FINAL_PHASE" \
  "$FINAL_MESSAGE" \
  "$FINAL_REMEDIATION_STATUS" \
  "$FINAL_QA_STATUS" \
  "$RESOLVED_PR_URL" \
  "false"

# Explicitly stop Docker sidecar before exiting
echo "üõë Explicitly stopping Docker sidecar..."
stop_docker_sidecar || true

echo "‚úÖ Codex execution complete"
exit $EXIT_CODE
