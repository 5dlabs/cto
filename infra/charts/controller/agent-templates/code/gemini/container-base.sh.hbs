#!/bin/sh

# Task-specific workspace for parallel execution isolation
# Define BEFORE cleanup function so cleanup uses correct path
TASK_WORKSPACE="/workspace/task-{{task_id}}"

# Signal docker-daemon to shut down on ANY exit (success or failure)
# This prevents docker-daemon from running indefinitely when Gemini crashes
cleanup_docker() {
    echo "ğŸ§¹ Cleanup: Signaling docker-daemon to shut down..."
    touch "$TASK_WORKSPACE/.agent_done" 2>/dev/null || true
}
trap cleanup_docker EXIT

# Ensure Rust environment is always properly set up
echo "ğŸ”§ Setting up Rust environment..."

# Source Rust environment if available (fixes cargo not found issues)
if [ -f "$HOME/.cargo/env" ]; then
    . "$HOME/.cargo/env"
    echo "âœ“ Sourced Rust environment from $HOME/.cargo/env"
fi

# Also try root cargo env as fallback
if [ -f "/root/.cargo/env" ]; then
    . "/root/.cargo/env"
    echo "âœ“ Sourced Rust environment from /root/.cargo/env"
fi

# Ensure rustup has a default toolchain set
if command -v rustup >/dev/null 2>&1; then
    rustup default stable 2>/dev/null || true
    echo "âœ“ Ensured stable Rust toolchain is default"
else
    echo "âš ï¸ rustup not found in PATH"
fi

# Verify Rust is available
if command -v cargo >/dev/null 2>&1; then
    echo "âœ“ Cargo is available: $(cargo --version)"
else
    echo "âŒ Cargo not found in PATH"
    echo "Current PATH: $PATH"
    echo "Attempting to find cargo..."
    find /usr -name cargo 2>/dev/null | head -5 || echo "No cargo found in /usr"
    find /home -name cargo 2>/dev/null | head -5 || echo "No cargo found in /home"
fi

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
printf 'â•‘  ğŸ¤– AGENT: %-50sâ•‘\n' '{{github_app}}'
echo 'â•‘  IMPLEMENTATION TASK STARTING                                â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'

# Ensure workspace directories exist (TASK_WORKSPACE already defined above)
mkdir -p /workspace
mkdir -p "$TASK_WORKSPACE"
export GH_CONFIG_DIR="$TASK_WORKSPACE/.config/gh"
mkdir -p "$GH_CONFIG_DIR"
echo "ğŸ“ Using task-specific workspace: $TASK_WORKSPACE"

# Clean up any leftover sentinel file from previous runs
# This prevents premature sidecar shutdown on sequential task executions
if [ -f "$TASK_WORKSPACE/.agent_done" ]; then
    echo "ğŸ§¹ Cleaning up sentinel file from previous run at $TASK_WORKSPACE/.agent_done"
    rm -f "$TASK_WORKSPACE/.agent_done"
fi

gh_hosts_file() {
    if [ -n "${GH_CONFIG_DIR:-}" ] && [ -f "${GH_CONFIG_DIR}/hosts.yml" ]; then
        printf '%s\n' "${GH_CONFIG_DIR}/hosts.yml"
        return
    fi
    if [ -f "$HOME/.config/gh/hosts.yml" ]; then
        printf '%s\n' "$HOME/.config/gh/hosts.yml"
        return
    fi
    printf ''
}

sync_gh_hosts_to_path() {
    target="$1"
    if [ -z "$target" ]; then
        return
    fi
    source_file=$(gh_hosts_file)
    if [ -z "$source_file" ] || [ ! -f "$source_file" ]; then
        return
    fi
    dest_dir="$target/.config/gh"
    mkdir -p "$dest_dir"
    if cp "$source_file" "$dest_dir/hosts.yml" >/dev/null 2>&1; then
        chmod 600 "$dest_dir/hosts.yml" 2>/dev/null || true
    fi
}

# Load shared task utilities (with safe fallback)
if [ -f /agent-templates/shared_task-setup-functions.sh ]; then
    # shellcheck disable=SC1091
    . /agent-templates/shared_task-setup-functions.sh
else
    echo "âš ï¸ shared_task-setup-functions.sh not found; defining minimal fallbacks"
    ensure_default_client_config() { :; }
    ensure_default_toolman_guide() { :; }
fi

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."

    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"

    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"

    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."

    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âš ï¸ Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âŒ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    echo "Installation ID: $INSTALLATION_ID"

    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "âŒ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"

    # Export the token for git to use
    export GITHUB_TOKEN

    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials

    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token

    sync_gh_hosts_to_path "$TASK_WORKSPACE"

    echo "âœ“ GitHub App authenticated successfully"

else
    echo "âŒ GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
    exit 1
fi

# Git configuration with proper GitHub App attribution
git config --global --add safe.directory "$TASK_WORKSPACE"

# Set GitHub App attribution - use generic format for all agents
derive_bot_identity() {
    local app_name="$1"

    if [ -z "$app_name" ] || [ "$app_name" = "null" ]; then
        GIT_AUTHOR_NAME="automation[bot]"
        GIT_AUTHOR_EMAIL="automation[bot]@users.noreply.github.com"
        return
    fi

    local slug
    slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-+|-+$//g')
    if [ -z "$slug" ]; then
        slug=$(printf '%s' "$app_name" | tr '[:upper:]' '[:lower:]')
    fi

    local bot_login="${slug}[bot]"
    local bot_email="${bot_login}@users.noreply.github.com"

    if [ -n "${GITHUB_TOKEN:-}" ]; then
        local encoded_login
        encoded_login=$(printf '%s' "$bot_login" | sed 's/\[/%5B/g; s/\]/%5D/g')
        local bot_response
        bot_response=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/users/${encoded_login}" 2>/dev/null || true)
        local bot_id
        bot_id=$(printf '%s' "$bot_response" | jq -r '.id // empty' 2>/dev/null || echo '')
        if [ -n "$bot_id" ]; then
            bot_email="${bot_id}+${bot_login}@users.noreply.github.com"
        fi
    fi

    GIT_AUTHOR_NAME="$bot_login"
    GIT_AUTHOR_EMAIL="$bot_email"
}

GITHUB_APP="{{github_app}}"
derive_bot_identity "$GITHUB_APP"

# Configure git with proper GitHub App attribution
git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

# Set environment variables for Gemini Code to use
export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
echo "âœ“ Git configured"

# =============================================================================
# AUTHENTICATION VERIFICATION
# =============================================================================
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ğŸ” AUTHENTICATION VERIFICATION"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Repository URLs - Handle both full URLs and org/repo format
# Check if repository_url already contains https://github.com/
if echo "{{repository_url}}" | grep -q "^https://github.com/"; then
    REPO_HTTP_URL="{{repository_url}}"
    if ! echo "{{repository_url}}" | grep -q "\.git$"; then
        REPO_HTTP_URL="${REPO_HTTP_URL}.git"
    fi
else
    REPO_HTTP_URL="https://github.com/{{repository_url}}.git"
fi

# Same for docs repository
if echo "{{docs_repository_url}}" | grep -q "^https://github.com/"; then
    DOCS_HTTP_URL="{{docs_repository_url}}"
    if ! echo "{{docs_repository_url}}" | grep -q "\.git$"; then
        DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
    fi
else
    DOCS_HTTP_URL="https://github.com/{{docs_repository_url}}.git"
fi

# DEBUG: Show what URLs are being constructed
echo "ğŸ” DEBUG: URL Construction & Parameters"
echo "  Input repository_url: '{{repository_url}}'"
echo "  Input docs_repository_url: '{{docs_repository_url}}'"
echo "  Input docs_project_directory: '{{docs_project_directory}}'"
echo "  Input working_directory: '{{working_directory}}'"
echo "  Input docs_branch: '{{docs_branch}}'"
echo "  Input github_app: '{{github_app}}'"
echo "  Input task_id: '{{task_id}}'"
echo "  Input service: '{{service}}'"
echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
echo "  Current working directory: $(pwd)"
echo "  Available environment variables:"
env | grep -E "(GITHUB|GEMINI|ANTHROPIC)" | sort

# Test HTTPS access to repository
echo "ğŸ” DEBUG: Testing HTTPS repository access..."
echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
  echo "âœ“ HTTPS repository access successful"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Output: $(cat /tmp/repo_test.out | head -1)"
else
  echo "âŒ HTTPS repository access failed"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Error output: $(cat /tmp/repo_test.out)"
  echo "  Git credential helper status:"
  git config --list | grep credential || echo "  No credential helpers configured"
  echo ""
  echo "ğŸš« ABORTING: Cannot access repository via HTTPS"
  exit 1
fi

# Test docs repository access
echo "ğŸ” DEBUG: Testing docs repository access..."
echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
  echo "âœ“ Docs repository access successful"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Output: $(cat /tmp/docs_test.out | head -1)"
else
  echo "âŒ Docs repository access failed"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Error output: $(cat /tmp/docs_test.out)"
  echo ""
  echo "ğŸš« ABORTING: Cannot access docs repository via HTTPS"
  exit 1
fi

# Dual Repository Setup - Platform repo for docs, Target repo for implementation
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                 DUAL REPOSITORY SETUP                        â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Repository Information
DOCS_BRANCH="{{docs_branch}}"
GITHUB_APP="{{github_app}}"

# Helper: derive safe workspace directory name from repo input (URL, SSH, or slug)
sanitize_repo_dir() {
    input="$1"
    if echo "$input" | grep -qE '^https://github.com/'; then
        owner=$(echo "$input" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        name=$(echo "$input" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
        printf '%s-%s' "$owner" "$name"
    elif echo "$input" | grep -qE '^git@github.com:'; then
        owner=$(echo "$input" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        name=$(echo "$input" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
        printf '%s-%s' "$owner" "$name"
    else
        # Assume owner/repo (optionally with .git)
        slug=$(echo "$input" | sed -E 's|\.git$||')
        echo "$slug" | tr '/' '-'
    fi
}

# Derive workspace directory names (owner-repo)
DOCS_REPO_DIR=$(sanitize_repo_dir "{{docs_repository_url}}")
TARGET_REPO_DIR=$(sanitize_repo_dir "{{repository_url}}")

echo "=== REPOSITORY SETUP ==="
echo "Docs repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
echo "Target repository: {{repository_url}} ($REPO_HTTP_URL)"
echo "Docs branch: $DOCS_BRANCH"
echo "GitHub App: $GITHUB_APP"

# Determine workflow type
echo "ğŸ” DEBUG: Workflow type detection"
echo "  docs_repository_url: '{{docs_repository_url}}'"
echo "  repository_url: '{{repository_url}}'"
echo "  Comparison result: $( [ "{{docs_repository_url}}" = "{{repository_url}}" ] && echo 'EQUAL' || echo 'DIFFERENT' )"

if [ "{{docs_repository_url}}" = "{{repository_url}}" ]; then
    echo "âœ“ Single-repo workflow detected (same repository for docs and implementation)"
    WORKFLOW_TYPE="single-repo"
    echo "  â””â”€ TaskMaster files expected at repository root"
else
    echo "âœ“ Multi-repo workflow detected (separate docs and target repositories)"
    WORKFLOW_TYPE="multi-repo"
    echo "  â””â”€ TaskMaster files expected in docs repo at: {{docs_project_directory}}"
fi
echo "ğŸ” DEBUG: WORKFLOW_TYPE set to: $WORKFLOW_TYPE"

# Repository Setup Based on Workflow Type
if [ "$WORKFLOW_TYPE" = "single-repo" ]; then
    echo "=== SINGLE-REPO WORKFLOW ==="
    # Check if repository already exists (retry scenario)
    echo "ğŸ” DEBUG: Checking for existing repository directory: /workspace/$TARGET_REPO_DIR"
    echo "  Workspace contents: $(ls -la /workspace/ | grep -v '^total')"

    if [ -d "/workspace/$TARGET_REPO_DIR/.git" ]; then
        echo "ğŸ”„ REPOSITORY: UPDATE - valid git repository exists"
        echo "ğŸ“ Found existing repository '/workspace/$TARGET_REPO_DIR', updating..."
        echo "  Directory contents: $(ls -la /workspace/$TARGET_REPO_DIR | head -5)"
        # Fix dubious ownership before git operations
        git config --global --add safe.directory "/workspace/$TARGET_REPO_DIR"
        cd "/workspace/$TARGET_REPO_DIR"
        echo "  Current branch: $(git branch --show-current 2>/dev/null || echo 'unknown')"
        echo "  Git status before update: $(git status --porcelain | wc -l) files changed"
        git fetch origin
        git checkout "$DOCS_BRANCH"
        git reset --hard "origin/$DOCS_BRANCH"
        cd "$TASK_WORKSPACE"
        echo "âœ“ Repository updated successfully to $DOCS_BRANCH"
    elif [ -d "/workspace/$TARGET_REPO_DIR" ]; then
        echo "âš ï¸ REPOSITORY: INVALID - directory exists but not a git repository"
        echo "ğŸ§¹ Removing invalid directory and re-cloning..."
        rm -rf "/workspace/$TARGET_REPO_DIR"
        echo "ğŸ“¥ REPOSITORY: CLONING - after cleanup"
        echo "  Clone command: git clone \"$REPO_HTTP_URL\" \"/workspace/$TARGET_REPO_DIR\""
        if ! git clone "$REPO_HTTP_URL" "/workspace/$TARGET_REPO_DIR"; then
            echo "âŒ Failed to clone repository: {{repository_url}} ($REPO_HTTP_URL)"
            echo "  Last git error: $(git config --get-regexp 'credential|remote')"
            exit 1
        fi
        echo "  Clone successful, changing to directory and checking out $DOCS_BRANCH"
        cd "/workspace/$TARGET_REPO_DIR" && git checkout "$DOCS_BRANCH" && cd "$TASK_WORKSPACE"
        echo "âœ“ Repository cloned successfully to /workspace/$TARGET_REPO_DIR"
        echo "  Final directory structure: $(ls -la /workspace/$TARGET_REPO_DIR | head -5)"
    else
        echo "ğŸ“¥ REPOSITORY: CLONING - first time setup"
        echo "  Clone command: git clone \"$REPO_HTTP_URL\" \"/workspace/$TARGET_REPO_DIR\""
        if ! git clone "$REPO_HTTP_URL" "/workspace/$TARGET_REPO_DIR"; then
            echo "âŒ Failed to clone repository: {{repository_url}} ($REPO_HTTP_URL)"
            echo "  Last git error: $(git config --get-regexp 'credential|remote')"
            exit 1
        fi
        echo "  Clone successful, changing to directory and checking out $DOCS_BRANCH"
        cd "/workspace/$TARGET_REPO_DIR" && git checkout "$DOCS_BRANCH" && cd "$TASK_WORKSPACE"
        echo "âœ“ Repository cloned successfully to /workspace/$TARGET_REPO_DIR"
        echo "  Final directory structure: $(ls -la /workspace/$TARGET_REPO_DIR | head -5)"
    fi

    # Preserve Task Master files before branch switching (single-repo workflow)
    echo "ğŸ”„ Preserving Task Master files from docs branch before switching to feature branch..."
    TEMP_TASK_DIR="/tmp/taskmaster-preserve"
    rm -rf "$TEMP_TASK_DIR"
    mkdir -p "$TEMP_TASK_DIR"

    cd "/workspace/$TARGET_REPO_DIR"
    sync_gh_hosts_to_path "/workspace/$TARGET_REPO_DIR"
    echo "ğŸ” DEBUG: TaskMaster file preservation"
    echo "  docs_project_directory: '{{docs_project_directory}}'"
    echo "  task_id: '{{task_id}}'"

    # Copy Task Master files from docs branch to temporary location
    {{#if docs_project_directory}}
    if [ "{{docs_project_directory}}" = "." ]; then
        PRESERVE_FROM="/workspace/$TARGET_REPO_DIR/.taskmaster/docs/task-{{task_id}}"
        echo "  â””â”€ Using root taskmaster path (docs_project_directory='.')"
    else
        PRESERVE_FROM="/workspace/$TARGET_REPO_DIR/{{docs_project_directory}}/.taskmaster/docs/task-{{task_id}}"
        echo "  â””â”€ Using project subdirectory: {{docs_project_directory}}"
    fi
    {{else}}
    PRESERVE_FROM="/workspace/$TARGET_REPO_DIR/.taskmaster/docs/task-{{task_id}}"
    echo "  â””â”€ Using default root taskmaster path (no docs_project_directory)"
    {{/if}}

    echo "  PRESERVE_FROM resolved to: $PRESERVE_FROM"

    echo "ğŸ” DEBUG: Attempting to preserve Task Master files from: $PRESERVE_FROM"
    echo "  Checking if directory exists..."
    if [ -d "$PRESERVE_FROM" ]; then
        echo "  âœ“ TaskMaster directory found!"
        echo "  Directory contents: $(ls -la "$PRESERVE_FROM" | wc -l) items"
        ls -la "$PRESERVE_FROM"
        cp -r "$PRESERVE_FROM"/* "$TEMP_TASK_DIR/" 2>/dev/null && echo "âœ“ Task Master files preserved to temporary location" || echo "âš ï¸ Some files may not have been preserved"

        # Also preserve architecture.md from docs directory (one level up from task directory)
        {{#if docs_project_directory}}
        if [ "{{docs_project_directory}}" = "." ]; then
            ARCH_SOURCE="/workspace/$TARGET_REPO_DIR/.taskmaster/docs/architecture.md"
        else
            ARCH_SOURCE="/workspace/$TARGET_REPO_DIR/{{docs_project_directory}}/.taskmaster/docs/architecture.md"
        fi
        {{else}}
        ARCH_SOURCE="/workspace/$TARGET_REPO_DIR/.taskmaster/docs/architecture.md"
        {{/if}}

        if [ -f "$ARCH_SOURCE" ]; then
            cp "$ARCH_SOURCE" "$TEMP_TASK_DIR/" && echo "âœ“ architecture.md preserved from docs branch" || echo "âš ï¸ Failed to preserve architecture.md"
        else
            echo "âš ï¸ architecture.md not found at: $ARCH_SOURCE"
        fi

        echo "ğŸ” DEBUG: Preserved files:"
        ls -la "$TEMP_TASK_DIR/" || echo "No files in temp directory"
    else
        # Special case: taskId 0 is used for non-TaskMaster workflows (e.g., Atlas PR Guardian)
        if [ "{{task_id}}" = "0" ]; then
            echo "â„¹ï¸ TaskId 0 detected - skipping TaskMaster file requirements"
            echo "  This is a non-TaskMaster workflow (e.g., PR Guardian, standalone agent)"
            echo "  Proceeding without TaskMaster files..."
        else
            echo "âŒ Task Master directory not found at: $PRESERVE_FROM"
            echo "âŒ CRITICAL: TaskMaster files must exist at the specified location"
            echo "âŒ Expected location: $PRESERVE_FROM"
            echo "âŒ This job cannot continue without the specified TaskMaster files"
            echo "âŒ Verify that:"
            echo "   1. The docs-project-directory parameter is correct"
            echo "   2. The task-id exists in the TaskMaster directory"
            echo "   3. The docs-branch contains the TaskMaster files"
            exit 1
        fi
    fi
    cd "$TASK_WORKSPACE"

    # Set working directory to the repository root
    REPO_NAME="$TARGET_REPO_DIR"
    echo "âœ“ Working directory: /workspace/$REPO_NAME"
    echo "âœ“ Task files preserved from docs branch"

else
    echo "=== MULTI-REPO WORKFLOW ==="

    # Step 1: Clone or update docs repository temporarily
    if [ -d "/tmp/docs-repo" ]; then
        echo "ğŸ”„ DOCS REPOSITORY: UPDATE - temporary directory exists"
        cd /tmp/docs-repo
        git fetch origin
        git checkout "$DOCS_BRANCH"
        git reset --hard "origin/$DOCS_BRANCH"
        cd "$TASK_WORKSPACE"
        echo "âœ“ Docs repository updated"
    else
        echo "ğŸ“¥ DOCS REPOSITORY: CLONING - extracting task files"
        if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
            echo "âŒ Failed to clone docs repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
            exit 1
        fi
        cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd "$TASK_WORKSPACE"
        echo "âœ“ Docs repository cloned to temporary location"
    fi

    # Step 2: Clone or update target repository
    if [ -d "/workspace/$TARGET_REPO_DIR/.git" ]; then
        echo "ğŸ”„ TARGET REPOSITORY: UPDATE - valid git repository exists"
        echo "ğŸ“ Found existing target repository '/workspace/$TARGET_REPO_DIR', updating..."
        # Fix dubious ownership before git operations
        git config --global --add safe.directory "/workspace/$TARGET_REPO_DIR"
        cd "/workspace/$TARGET_REPO_DIR"
        git fetch origin main
        git reset --hard origin/main
        cd "$TASK_WORKSPACE"
        echo "âœ“ Target repository updated successfully"
    elif [ -d "/workspace/$TARGET_REPO_DIR" ]; then
        echo "âš ï¸ TARGET REPOSITORY: INVALID - directory exists but not a git repository"
        echo "ğŸ§¹ Removing invalid directory and re-cloning..."
        rm -rf "/workspace/$TARGET_REPO_DIR"
        if ! git clone "$REPO_HTTP_URL" "/workspace/$TARGET_REPO_DIR"; then
            echo "âŒ Failed to clone target repository: {{repository_url}} ($REPO_HTTP_URL)"
            exit 1
        fi
        echo "âœ“ Target repository cloned successfully to /workspace/$TARGET_REPO_DIR"
    else
        echo "ğŸ“¥ TARGET REPOSITORY: CLONING - first time setup"
        if ! git clone "$REPO_HTTP_URL" "/workspace/$TARGET_REPO_DIR"; then
            echo "âŒ Failed to clone target repository: {{repository_url}} ($REPO_HTTP_URL)"
            exit 1
        fi
        echo "âœ“ Target repository cloned successfully to /workspace/$TARGET_REPO_DIR"
    fi

    # Step 3: Copy task files from docs repo to target repo
    echo "ğŸ“‹ TASK FILES: COPYING from docs to target repository"
    mkdir -p "/workspace/$TARGET_REPO_DIR/task"

    # Determine docs project directory path
    {{#if docs_project_directory}}
    if [ "{{docs_project_directory}}" = "." ]; then
        DOCS_PATH="/tmp/docs-repo/.taskmaster"
    else
        DOCS_PATH="/tmp/docs-repo/{{docs_project_directory}}/.taskmaster"
    fi
    {{else}}
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
    {{/if}}

    # Copy specific task files
    TASK_DIR="$DOCS_PATH/docs/task-{{task_id}}"
    echo "ğŸ” DEBUG: Looking for task files at: $TASK_DIR"
    echo "ğŸ” DEBUG: Docs path is: $DOCS_PATH"
    echo "ğŸ” DEBUG: Contents of docs temp directory:"
    ls -la /tmp/docs-repo/.taskmaster/ || echo "No .taskmaster found"
    echo "ğŸ” DEBUG: Contents of docs directory:"
    ls -la /tmp/docs-repo/.taskmaster/docs/ || echo "No docs directory found"

    if [ -d "$TASK_DIR" ]; then
        echo "ğŸ” DEBUG: Task directory found, contents:"
        ls -la "$TASK_DIR"

        # Ensure target task directory exists before copying
        mkdir -p "/workspace/$TARGET_REPO_DIR/task"
        echo "âœ“ Created target task directory"

        echo "âœ… Copying task.md..."
        cp "$TASK_DIR/task.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "âœ“ task.md copied" || echo "âŒ task.md copy failed"

        echo "âœ… Copying acceptance-criteria.md..."
        cp "$TASK_DIR/acceptance-criteria.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "âœ“ acceptance-criteria.md copied" || echo "âŒ acceptance-criteria.md copy failed"

        echo "âœ… Copying prompt.md..."
        cp "$TASK_DIR/prompt.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "âœ“ prompt.md copied" || echo "âŒ prompt.md copy failed"

        echo "âœ… Copying client-config.json..."
        if [ -f "$TASK_DIR/client-config.json" ]; then
            cp "$TASK_DIR/client-config.json" "$TASK_WORKSPACE/client-config.json" && echo "âœ“ client-config.json copied to task workspace" || echo "âŒ client-config.json copy failed"
        else
            echo "âš ï¸ client-config.json not found - MCP client may not be configured"
        fi

        echo "âœ… Copying toolman-guide.md..."
        if [ -f "$TASK_DIR/toolman-guide.md" ]; then
            cp "$TASK_DIR/toolman-guide.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "âœ“ toolman-guide.md copied" || echo "âŒ toolman-guide.md copy failed"
        else
            echo "âš ï¸ toolman-guide.md not found - code agent won't have tool usage guidance"
        fi

        echo "âœ“ Task {{task_id}} files copied from $TASK_DIR"
    else
        # Special case: taskId 0 is used for non-TaskMaster workflows (e.g., Atlas PR Guardian)
        if [ "{{task_id}}" = "0" ]; then
            echo "â„¹ï¸ TaskId 0 detected - skipping TaskMaster file requirements"
            echo "  This is a non-TaskMaster workflow (e.g., PR Guardian, standalone agent)"
            echo "  Proceeding without TaskMaster files..."
        else
            echo "âŒ CRITICAL: Task {{task_id}} directory not found at: $TASK_DIR"
            echo "ğŸ” DEBUG: Available directories in docs:"
            find /tmp/docs-repo -name "task-*" -type d || echo "No task directories found"
        fi
    fi

    # Copy architecture.md from docs root
    ARCH_FILE="$DOCS_PATH/docs/architecture.md"
    if [ -f "$ARCH_FILE" ]; then
        cp "$ARCH_FILE" "/workspace/$TARGET_REPO_DIR/task/"
        echo "âœ“ Architecture documentation copied"
    else
        echo "âš ï¸ architecture.md not found at: $ARCH_FILE"
    fi

    # Copy tasks.json if it exists
    if [ -f "$DOCS_PATH/tasks.json" ]; then
        cp "$DOCS_PATH/tasks.json" "/workspace/$TARGET_REPO_DIR/task/"
        echo "âœ“ tasks.json copied"
    fi

    echo "âœ“ Task files copied to target repository"

    # DEBUG: Verify files were copied successfully
    echo "ğŸ” DEBUG: Contents of target task directory after copy:"
    ls -la "/workspace/$TARGET_REPO_DIR/task/" || echo "Task directory not found"
    echo "ğŸ” DEBUG: Checking if prompt.md exists:"
    [ -f "/workspace/$TARGET_REPO_DIR/task/prompt.md" ] && echo "âœ… prompt.md exists" || echo "âŒ prompt.md missing"

    # Step 4: Clean up docs repository
    echo "ğŸ§¹ CLEANUP: Removing temporary docs repository"
    rm -rf /tmp/docs-repo
    echo "âœ“ Docs repository cleaned up"

    # Set working directory to the target repository root
    REPO_NAME="$TARGET_REPO_DIR"
    echo "âœ“ Working directory: /workspace/$REPO_NAME"
fi

# Setup feature branch for implementation
echo "=== BRANCH SETUP ==="
cd "/workspace/$REPO_NAME"

# Fix git dubious ownership before any git operations
git config --global --add safe.directory "/workspace/$REPO_NAME"
echo "âœ“ Added repository to git safe directories"

# Sync with latest main to prevent conflicts
echo "ğŸ”„ Syncing with latest main to prevent conflicts..."
git fetch origin main 2>/dev/null || git fetch origin master 2>/dev/null || echo "âš ï¸ Could not fetch main/master branch"

# Create or checkout feature branch
FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
BRANCH_EXISTS="false"

    if git show-ref --verify --quiet refs/heads/$FEATURE_BRANCH; then
        BRANCH_EXISTS="true"
        echo "Feature branch '$FEATURE_BRANCH' exists, checking out..."
        git checkout $FEATURE_BRANCH

        echo "ğŸ“¥ Merging latest main into $FEATURE_BRANCH..."
        if git merge origin/main --no-edit; then
            echo "âœ“ Successfully merged latest main into feature branch"
        else
            echo "âš ï¸ MERGE CONFLICT: Cannot auto-merge main into $FEATURE_BRANCH"
            echo "â— Manual conflict resolution required by Gemini agent"
            echo ""
            echo "ğŸ“‹ Conflict files:"
            git status --porcelain | grep "^UU\|^AA\|^DD" || echo "   (Use 'git status' to see details)"
            echo ""
            echo "ğŸ”§ Gemini will need to resolve conflicts manually before proceeding"
            # Don't exit - let Gemini handle the conflicts
        fi
    else
        # Create new feature branch from latest main
        echo "Creating new feature branch '$FEATURE_BRANCH' from latest main..."
        
        # Stash any local changes to avoid checkout conflicts
        # Exclude task/ directory to preserve task files that were just copied
        if ! git diff-index --quiet HEAD -- || [ -n "$(git ls-files --others --exclude-standard)" ]; then
          echo "ğŸ”„ Stashing local changes and untracked files (excluding task/) before creating new branch"
          git stash push --include-untracked -m "Auto-stash before new branch creation ($(date -u +%Y%m%d-%H%M%S))" -- . ':!task' || true
        fi
        
        git checkout -b $FEATURE_BRANCH origin/main
        echo "âœ“ Created feature branch: $FEATURE_BRANCH"
    fi

# 5. Set Working Directory (Critical for Gemini Execution)
WORKSPACE_DIR="$TARGET_REPO_DIR"
WORK_DIR="{{working_directory}}"
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
  GEMINI_WORK_DIR="/workspace/$WORKSPACE_DIR"
else
  GEMINI_WORK_DIR="/workspace/$WORKSPACE_DIR/$WORK_DIR"
fi
mkdir -p "$GEMINI_WORK_DIR" && cd "$GEMINI_WORK_DIR"
sync_gh_hosts_to_path "$GEMINI_WORK_DIR"
echo "âœ“ Set working directory: $GEMINI_WORK_DIR"
echo "ğŸ”‘ CRITICAL: Gemini will be launched from this directory"

# Ensure client-config fallback is available now that GEMINI_WORK_DIR is known
if declare -F ensure_default_client_config >/dev/null 2>&1; then
    ensure_default_client_config \
        "$GEMINI_WORK_DIR/client-config.json" \
        "$TASK_WORKSPACE/client-config.json" \
        "/workspace/$WORKSPACE_DIR/client-config.json"
fi

# Working directory setup completed above

# Configure git user after successful clone
echo "=== POST-CLONE GIT CONFIGURATION ==="
# Fix dubious ownership issues
git config --global --add safe.directory "/workspace/$REPO_NAME"
echo "âœ“ Added repository to safe directories"

# Set git config locally in the working repository (persistent on PVC)
if [ -d "/workspace/$REPO_NAME/.git" ]; then
    cd "/workspace/$REPO_NAME"
    git config --local user.name "$GIT_AUTHOR_NAME"
    git config --local user.email "$GIT_AUTHOR_EMAIL"
    # Set up automatic upstream for new branches
    git config --local push.autoSetupRemote true
    echo "âœ“ Configured git user in target repository: $GIT_AUTHOR_NAME"
    echo "âœ“ Enabled automatic upstream setup for new branches"
fi

cd "$TASK_WORKSPACE"

# Copy ConfigMap files to working directory (AFTER repository clone)
echo "=== CONFIGMAP FILE SETUP ==="

# Gemini working directory already set above during repository setup

echo "Setting up files in Gemini working directory: $GEMINI_WORK_DIR"
cd "$GEMINI_WORK_DIR"

# Copy all files from ConfigMap to working directory
if [ -d "/task-files" ]; then
  echo "Copying ConfigMap files to working directory..."

  # GEMINI.md Memory Persistence Logic (controlled by overwriteMemory CRD field)
        OVERWRITE_MEMORY="{{overwrite_memory}}"

  # Handle GEMINI.md based on overwriteMemory setting
        if [ "$OVERWRITE_MEMORY" = "true" ]; then
          # Overwrite mode: Always replace GEMINI.md with fresh template
    cp "/task-files/CLAUDE.md" "$GEMINI_WORK_DIR/GEMINI.md" 2>/dev/null || cp "/task-files/GEMINI.md" "$GEMINI_WORK_DIR/GEMINI.md" 2>/dev/null
    cp "$GEMINI_WORK_DIR/GEMINI.md" "/workspace/GEMINI.md"
          echo "âœ“ Overwrote GEMINI.md memory file (fresh start requested)"
          echo "âœ“ Copied GEMINI.md to workspace root for easy access"
        else
          # Preserve mode (default): Only copy if doesn't exist
          if [ ! -f "$GEMINI_WORK_DIR/GEMINI.md" ]; then
      # Initial creation - copy from ConfigMap
      cp "/task-files/GEMINI.md" "$GEMINI_WORK_DIR/GEMINI.md" 2>/dev/null || cp "/task-files/CLAUDE.md" "$GEMINI_WORK_DIR/GEMINI.md" 2>/dev/null
      cp "$GEMINI_WORK_DIR/GEMINI.md" "/workspace/GEMINI.md"
            echo "âœ“ Created initial GEMINI.md memory file"
            echo "âœ“ Copied GEMINI.md to workspace root for easy access"
          else
            echo "âœ“ Preserved existing GEMINI.md memory file (maintaining accumulated context)"
            # Still copy to workspace root for consistency
            cp "$GEMINI_WORK_DIR/GEMINI.md" "/workspace/GEMINI.md"
            echo "âœ“ Synced GEMINI.md to workspace root"
          fi
        fi

  # Copy client-config.json to workspace root for MCP configuration
  if [ -f "/task-files/client-config.json" ]; then
    cp /task-files/client-config.json "$TASK_WORKSPACE/client-config.json" 2>/dev/null || true
    echo "âœ“ Copied client-config.json to workspace root for MCP configuration"
  else
    echo "âš ï¸ client-config.json not found in task-files, using defaults"
  fi

  # Copy all other markdown files (excluding GEMINI.md and CLAUDE.md)
  for md_file in /task-files/*.md; do
    if [ -f "$md_file" ]; then
      basename_file=$(basename "$md_file")
      # Skip memory files since we handled it above
      if [ "$basename_file" != "GEMINI.md" ] && [ "$basename_file" != "CLAUDE.md" ]; then
        cp "$md_file" "$GEMINI_WORK_DIR/"
        echo "âœ“ Updated $basename_file"
      fi
    fi
  done

  # Copy guidelines files to working directory
  if [ -f "/task-files/coding-guidelines.md" ]; then
    cp /task-files/coding-guidelines.md "$GEMINI_WORK_DIR/"
    echo "âœ“ Copied coding-guidelines.md to working directory"
  fi

  if [ -f "/task-files/github-guidelines.md" ]; then
    cp /task-files/github-guidelines.md "$GEMINI_WORK_DIR/"
    echo "âœ“ Copied github-guidelines.md to working directory"
  fi

  # System prompt will be rendered inline (no file copying needed)
  echo "âœ“ System prompt template will be rendered inline"

  # Hook copying disabled
  echo "! Hook scripts disabled - no hooks will be copied"

  # Set up MCP configuration
  echo "Setting up MCP configuration..."

  # Copy MCP configuration from ConfigMap to project root (project scope)
  if [ -f "/task-files/mcp.json" ]; then
    cp /task-files/mcp.json "$GEMINI_WORK_DIR/.mcp.json"
    echo "âœ“ Copied mcp.json to .mcp.json (project scope)"
    # Also copy to /workspace for Gemini's MCP loader (if it uses it)
    cp /task-files/mcp.json "/workspace/.mcp.json"
    echo "âœ“ Copied mcp.json to /workspace/.mcp.json"
  else
    echo "âš ï¸  mcp.json template not found"
  fi

  echo "âœ“ ConfigMap files copied to $GEMINI_WORK_DIR"
else
  echo "âš ï¸  Warning: /task-files directory not found (ConfigMap not mounted?)"
fi


# Copy Current Task Documentation to Working Directory
echo "=== TASK DOCUMENTATION SETUP ==="
echo "ğŸ” DEBUG: WORKFLOW_TYPE is: $WORKFLOW_TYPE"
echo "ğŸ” DEBUG: REPO_NAME is: $REPO_NAME"
echo "ğŸ” DEBUG: GEMINI_WORK_DIR is: $GEMINI_WORK_DIR"
echo "ğŸ” DEBUG: Task ID is: {{task_id}}"

# Task directory should already exist from multi-repo workflow or be created as needed
mkdir -p "$GEMINI_WORK_DIR/task"
echo "âœ“ Created task directory at: $GEMINI_WORK_DIR/task"

# Task documentation should already be available in the task/ directory
if [ "$WORKFLOW_TYPE" = "single-repo" ]; then
    # Special case: taskId 0 is used for non-TaskMaster workflows (e.g., Atlas PR Guardian)
    if [ "{{task_id}}" = "0" ]; then
        echo "â„¹ï¸ TaskId 0 detected - skipping TaskMaster file restoration"
        echo "  This is a non-TaskMaster workflow (e.g., PR Guardian, standalone agent)"
        echo "  Proceeding without TaskMaster files..."
    else
        echo "âœ“ Restoring task documentation from preserved temporary location"

        # Use the preserved Task Master files from temporary location
        TEMP_TASK_DIR="/tmp/taskmaster-preserve"
        echo "ğŸ” DEBUG: Restoring task files from: $TEMP_TASK_DIR"

        if [ -d "$TEMP_TASK_DIR" ] && [ "$(ls -A $TEMP_TASK_DIR 2>/dev/null)" ]; then
            echo "âœ“ Preserved Task Master files found"
            echo "ğŸ” DEBUG: Preserved task files:"
            ls -la "$TEMP_TASK_DIR/"

            echo "âœ… Copying all preserved files to task directory..."

            # Copy all files from preserved directory to task directory
            if cp -r "$TEMP_TASK_DIR"/* "$GEMINI_WORK_DIR/task/" 2>/dev/null; then
                echo "âœ“ All task files copied from preserved temporary location"
            else
                echo "âŒ Failed to copy task files from preserved location"
                exit 1
            fi

            # Copy task.txt as task.md if it exists (specific rename needed)
            if [ -f "$GEMINI_WORK_DIR/task/task.txt" ]; then
                cp "$GEMINI_WORK_DIR/task/task.txt" "$GEMINI_WORK_DIR/task/task.md" && echo "âœ“ task.txt copied as task.md" || echo "âŒ task.txt copy failed"
            fi

            # Move client-config.json to Gemini working directory (not in task/ subdirectory)
            if [ -f "$GEMINI_WORK_DIR/task/client-config.json" ]; then
                mv "$GEMINI_WORK_DIR/task/client-config.json" "$GEMINI_WORK_DIR/client-config.json" && echo "âœ“ client-config.json moved to Gemini working directory" || echo "âŒ client-config.json move failed"
            else
                echo "âš ï¸ client-config.json not found - MCP client may not be configured"
            fi

            echo "âœ“ Task {{task_id}} files copied from preserved temporary location"

            # Clean up temporary directory
            rm -rf "$TEMP_TASK_DIR"
            echo "âœ“ Cleaned up temporary preservation directory"
        else
            echo "âŒ CRITICAL: No preserved Task Master files found at: $TEMP_TASK_DIR"
            echo "ğŸ” DEBUG: This indicates the Task Master preservation step failed earlier"
            echo "âŒ Task {{task_id}} files are not available for this job"
            exit 1
        fi
    fi

    # DEBUG: Verify files were copied successfully
    echo "ğŸ” DEBUG: Contents of target task directory after copy:"
    ls -la "$GEMINI_WORK_DIR/task/" || echo "Task directory not found"
    echo "ğŸ” DEBUG: Checking if prompt.md exists:"
    [ -f "$GEMINI_WORK_DIR/task/prompt.md" ] && echo "âœ… prompt.md exists" || echo "âŒ prompt.md missing"

else
    echo "âœ“ Task documentation copied from docs repository during multi-repo setup"
fi

# Verify client-config.json is available in Gemini's working directory
echo "=== TOOLMAN CONFIG SETUP ==="
WORKSPACE_CFG="$GEMINI_WORK_DIR/client-config.json"
SOURCE_CFG="/task-files/client-config.json"

# Helper to check non-empty JSON object
is_valid_cfg() {
  local p="$1"
  [ -f "$p" ] || return 1
  jq -e 'type=="object" and length>0' "$p" >/dev/null 2>&1
}

SRC_OK=false
WS_OK=false
if is_valid_cfg "$SOURCE_CFG"; then SRC_OK=true; fi
if is_valid_cfg "$WORKSPACE_CFG"; then WS_OK=true; fi

if $SRC_OK; then
  export MCP_CLIENT_CONFIG="$SOURCE_CFG"
  echo "âœ“ Selected MCP_CLIENT_CONFIG from source ConfigMap: $MCP_CLIENT_CONFIG"
elif $WS_OK; then
  export MCP_CLIENT_CONFIG="$WORKSPACE_CFG"
  echo "âœ“ Selected MCP_CLIENT_CONFIG from workspace copy: $MCP_CLIENT_CONFIG"
else
  echo "âŒ No valid client-config.json found (both source and workspace empty/invalid). Aborting."
  if [ -f "$SOURCE_CFG" ]; then
    echo "   Source summary:"; (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' "$SOURCE_CFG" 2>/dev/null || { echo -n "   raw="; head -c 200 "$SOURCE_CFG"; echo; })
  else
    echo "   Source missing: $SOURCE_CFG"
  fi
  if [ -f "$WORKSPACE_CFG" ]; then
    echo "   Workspace summary:"; (jq -c '{remoteTools: (.remoteTools // []), localServers: (.localServers // {})}' "$WORKSPACE_CFG" 2>/dev/null || { echo -n "   raw="; head -c 200 "$WORKSPACE_CFG"; echo; })
  else
    echo "   Workspace missing: $WORKSPACE_CFG"
  fi
  exit 1
fi

echo '=== WORKSPACE VALIDATION ==='

# Check for required files in Gemini's working directory
MISSING_FILES=""
REQUIRED_FILES="GEMINI.md"

echo "Checking for required files..."
for file in $REQUIRED_FILES; do
  if [ ! -f "$GEMINI_WORK_DIR/$file" ]; then
    echo "ERROR: Missing required file: $GEMINI_WORK_DIR/$file"
    MISSING_FILES="$MISSING_FILES $file"
  else
    echo "âœ“ Found: $GEMINI_WORK_DIR/$file"
    # Show file size for verification
    size=$(wc -c < "$GEMINI_WORK_DIR/$file" 2>/dev/null || echo "0")
    echo "  File size: $size bytes"
  fi
done

# Check git repository (REQUIRED for implementation tasks)
if [ ! -d "/workspace/$TARGET_REPO_DIR/.git" ]; then
  echo "âœ— CRITICAL ERROR: No target git repository found!"
  MISSING_FILES="$MISSING_FILES git-repository"
else
  echo "âœ“ Found: target git repository"
fi

# If any files are missing, abort
if [ -n "$MISSING_FILES" ]; then
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "â•‘                 WORKSPACE VALIDATION FAILED                  â•‘"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  echo "The following required files are missing:"
  for missing in $MISSING_FILES; do
    case "$missing" in
      "GEMINI.md")
        echo "  âŒ $missing - Main task instructions for Gemini"
        ;;
      "git-repository")
        echo "  âŒ $missing - Required for committing implementation changes"
        ;;
      *)
        echo "  âŒ $missing"
        ;;
    esac
  done
  echo ""
  echo "These files should have been created by the ConfigMap setup process."
  echo "Gemini will NOT be started to avoid wasting API credits."
  echo ""
  exit 1
fi

echo "âœ“ All required files present. Workspace is valid."

echo '=== IMPLEMENTATION TASK DIAGNOSTICS ==='
echo "Project directory: $GEMINI_WORK_DIR"
echo "Project directory contents:"
ls -la "$GEMINI_WORK_DIR"
echo ""

# Show git status
echo "Git status:"
git status 2>/dev/null || echo "Git status unavailable"
echo ""

echo '=== GEMINI EXECUTION ==='

# Export necessary variables
export SERVICE_NAME="{{service}}"
export TASK_ID="{{task_id}}"
export GITHUB_APP="{{github_app}}"

# Change to project directory before running Gemini
cd "$GEMINI_WORK_DIR"
echo "Changed to directory: $(pwd)"

# Verify we're in the correct directory and have required files
echo "=== WORKING DIRECTORY VERIFICATION ==="
echo "Current working directory: $(pwd)"
echo "Expected directory: $GEMINI_WORK_DIR"
if [ "$(pwd)" != "$GEMINI_WORK_DIR" ]; then
  echo "âŒ ERROR: Failed to change to correct working directory!"
  echo "Attempting to change directory again..."
  cd "$GEMINI_WORK_DIR" || exit 1
  echo "âœ“ Successfully changed to: $(pwd)"
fi

# Verify setup
echo "âœ“ Code implementation environment ready"

# Build Gemini command
# Using headless mode with stream-json output as requested
GEMINI_CMD="gemini --output-format stream-json"

# Add MCP configuration if available
if [ -f "/workspace/.mcp.json" ]; then
    echo "âœ“ Adding MCP configuration from /workspace/.mcp.json to Gemini command"
    # Note: Assuming Gemini supports --mcp-config or picks it up automatically.
    # Docs say it supports MCP Servers. We'll try passing it or relying on default locations.
    # If it doesn't support the flag, we might remove it.
    # GEMINI_CMD="$GEMINI_CMD --mcp-config /workspace/.mcp.json"
    echo "âš ï¸ Check Gemini documentation for explicit MCP config flag if it doesn't pick it up automatically."
else
    echo "âš ï¸ No MCP configuration file found at /workspace/.mcp.json"
fi

# Add continue flag if this is a retry attempt or user requested continuation
{{#if continue_session}}
# GEMINI_CMD="$GEMINI_CMD --continue"
# echo 'Adding --continue flag (attempt {{attempts}}{{#if user_requested}} - user requested{{/if}})'
echo "â„¹ï¸ Continue session requested but commented out for Gemini pending flag verification"
{{/if}}

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                    STARTING GEMINI EXECUTION                  â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "Command: $GEMINI_CMD"
echo "Note: Gemini should automatically read GEMINI.md from the working directory if configured to do so."

# Prepare prompt prefix for toolman guidance
PROMPT_PREFIX=""
ensure_default_toolman_guide "$GEMINI_WORK_DIR/task" "{{task_id}}" "{{service}}"
if [ -f "$GEMINI_WORK_DIR/task/toolman-guide.md" ]; then
    PROMPT_PREFIX="ğŸ”§ **CRITICAL: Tool Usage Reference**

Before starting implementation, you MUST read and follow the task-specific tool guidance in the file \`task/toolman-guide.md\`. This file contains:
- Selected tools for this specific task
- When and how to use each tool
- Tool arguments, parameters, and configuration options
- Implementation workflow and best practices
- Tool relationships and sequencing

**The toolman-guide.md is your authoritative reference for tool usage in this task.**

---

"
    echo "âœ“ Including toolman guidance prefix"
else
    echo "âš ï¸ No toolman-guide.md found - proceeding without tool guidance"
fi

# Execution
if [ "{{task_id}}" = "0" ]; then
    echo "â„¹ï¸ Task ID 0 detected - launching Gemini without task prompt"
    echo "  This is a non-TaskMaster workflow (e.g., PR Guardian, standalone agent)"
    
    # For task ID 0, we just run it.
    $GEMINI_CMD &
    GEMINI_PID=$!
    wait $GEMINI_PID

elif [ -f "$GEMINI_WORK_DIR/task/prompt.md" ]; then
    echo "âœ“ Using task-specific prompt from docs service: task/prompt.md"

    echo "startingTask:{{task_id}}"
    echo ""

    # Combine prompt
    FULL_PROMPT="${PROMPT_PREFIX}$(cat "$GEMINI_WORK_DIR/task/prompt.md")"
    
    # Run Gemini with prompt piped to stdin
    # This matches "echo 'Explain this code' | gemini" pattern
    echo "$FULL_PROMPT" | $GEMINI_CMD &
    GEMINI_PID=$!

    wait $GEMINI_PID

else
    echo "âŒ ERROR: No prompt.md found from docs service"
    echo "The docs service should always provide task/prompt.md"
    exit 1
fi

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘                 IMPLEMENTATION TASK COMPLETE                 â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'

# Gemini execution completed
echo "Gemini has completed successfully."

# Write sentinel file to signal sidecar to stop
touch "$TASK_WORKSPACE/.agent_done" 2>/dev/null || true

# Exit to terminate the pod
exit 0

