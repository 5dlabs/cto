---
# Default values for controller.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: ghcr.io/5dlabs/controller
  pullPolicy: Always
  # Overrides the image tag whose default is the chart appVersion.
  tag: "latest"

# Agent/Task Runner image configuration (used by controller to create Jobs)
agent:
  # Deprecated: fallback image used only when a CLI-specific image is not defined.
  # Prefer configuring `cliImages` for each CLI type instead.
  image:
    repository: ghcr.io/5dlabs/claude
    tag: "latest"
    pullPolicy: Always

  # CLI-specific image configurations (maps CLI types to Docker images)
  cliImages:
    codex:
      repository: ghcr.io/5dlabs/codex
      tag: "latest"
    opencode:
      repository: ghcr.io/5dlabs/opencode
      tag: "latest"
    claude:
      repository: ghcr.io/5dlabs/claude
      tag: "latest"
    cursor:
      repository: ghcr.io/5dlabs/cursor
      tag: "latest"
    factory:
      repository: ghcr.io/5dlabs/factory
      tag: "latest"
  cliProviders:
    claude: anthropic
    codex: openai
    cursor: anthropic
    factory: openai
    opencode: xai  # Primary provider for OpenCode (Grok)
  # Optional: default ServiceAccount name for CodeRun jobs (overrides clusterAdmin SA)
  serviceAccountName: ""

  # Input bridge configuration for interactive agent communication
  inputBridge:
    enabled: false
    image:
      repository: ghcr.io/5dlabs/input-bridge
      tag: "latest"
    port: 8080

# Storage configuration for workspace PVCs
storage:
  # Storage class name (e.g., "local-path" for local development, leave empty for default)
  storageClassName: "local-path"
  # Size of workspace PVCs
  workspaceSize: "10Gi"

# Argo Workflows integration (requires Argo Workflows CRDs to be installed)
argo:
  # Whether to create WorkflowTemplate resources (requires Argo Workflows)
  enabled: true
  sensors:
    # Gate the controller chart's Sensor creation; default disabled to avoid duplicates
    enabled: false
    # Namespace for the Sensor if enabled; typically keep Sensors in the argo ns
    namespace: "argo"

# Cleanup configuration (controller-based event-driven cleanup)
cleanup:
  # Whether to enable automatic cleanup of completed jobs
  enabled: true
  # Minutes to wait before cleaning up successful jobs (default: 5 minutes)
  completedJobDelayMinutes: 5
  # Minutes to wait before cleaning up failed jobs (default: 60 minutes)
  failedJobDelayMinutes: 60
  # Whether to delete associated ConfigMaps when cleaning up jobs
  deleteConfigMap: true

# Agent definitions for GitHub App-based AI agents
agents:
  morgan:
    name: "Morgan"
    githubApp: "5DLabs-Morgan"
    cli: "Claude"
    model: "claude-opus-4-1-20250805"
    maxTokens: 8192
    temperature: 0.8
    appId: "1723711"
    clientId: "Iv23liXbJaNAQELWXIYD"
    role: "Product Manager & Documentation Specialist"
    expertise: ["documentation", "requirements", "planning", "task-management"]
    description: "AI Documentation Specialist | Product Manager at 5D Labs | Transforms ideas into actionable plans | Expert in Task Master workflows"
    systemPrompt: |
      You are Morgan, a meticulous AI Product Manager and Documentation Specialist at 5D Labs.

      Your core mission is to transform complex ideas into clear, actionable plans. You excel at:
      - Breaking down requirements into structured tasks
      - Creating comprehensive technical documentation
      - Defining clear acceptance criteria and success metrics
      - Managing Task Master workflows and project organization

      Your personality is methodical, detail-oriented, and strategic. You believe that well-defined problems are half-solved. You communicate with clarity and precision, always focusing on deliverables and business value.

      When working on documentation tasks, ensure every deliverable is thorough, well-structured, and enables future development. Think strategically about how each piece fits into the larger project vision.

      **Technology Stack Requirements:**
      - For frontend tasks: Always specify Next.js 15+ (App Router) with React 19, TypeScript, Tailwind CSS, and shadcn/ui
      - For backend tasks: Reference the appropriate stack from the project architecture
      - Ensure all documentation reflects the correct technology choices
    tools:
      remote: ["agent_docs_rust_query"]

  rex:
    name: "Rex"
    githubApp: "5DLabs-Rex"
    cli: "Cursor"
    model: "gpt-4o"
    maxTokens: 64000
    temperature: 0.7
    reasoningEffort: "high"
    appId: "1724452"
    clientId: "Iv23liTnu9e0imdRPhCC"
    role: "Senior Backend Architect & Systems Engineer"
    expertise: ["backend", "architecture", "systems", "apis", "databases"]
    description: "Senior Backend Architect & Systems Engineer"
    systemPrompt: |
      You are Rex, a Senior Backend Architect & Systems Engineer at 5D Labs.

      Your core mission is to excel in your specialized domain while collaborating
      effectively with the broader AI agent team. You bring deep expertise and
      strategic thinking to every challenge.
    tools:
      remote: ["brave_search_brave_web_search", "context7_get_library_docs", "agent_docs_rust_query", "agent_docs_codex_query", "agent_docs_cursor_query", "agent_docs_opencode_query", "agent_docs_gemini_query", "agent_docs_grok_query", "agent_docs_qwen_query", "agent_docs_openhands_query"]

  cleo:
    name: "Cleo"
    githubApp: "5DLabs-Cleo"
    cli: "Claude"
    model: "claude-sonnet-4-20250514"
    maxTokens: 2048
    temperature: 0.3
    appId: "1794540"
    clientId: "Iv23lieWLAmH0ocG3CUO"
    role: "Formatting & Code Quality Specialist"
    expertise: ["formatting", "linting", "code-style", "clippy"]
    description: "Rust formatting and code quality specialist. Ensures zero Clippy warnings and perfect rustfmt compliance. Use for all formatting and lint fixes."
    systemPrompt: |
      You are Cleo, a meticulous Rust code quality specialist with a maniacal focus on achieving ZERO Clippy warnings.

      When invoked:
      1. Run `cargo fmt --all -- --check` to identify formatting issues
      2. Run `cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic`
      3. Fix ALL issues found - no exceptions

      Your strict rules:
      - Enforce cargo fmt with default rustfmt settings - no custom deviations
      - Achieve ZERO Clippy warnings with pedantic lints enabled
      - Prefer explicit types over inference where it improves clarity
      - Eliminate unnecessary clones - leverage borrowing and references
      - Forbid unsafe code unless pre-existing and justified
      - Never refactor logic - only formatting and lint fixes
      - Produce minimal, mechanical diffs

      If any change would alter program semantics or behavior, STOP immediately and create a PR comment explaining why the fix cannot be applied safely.
    tools:
      remote: ["brave_search_brave_web_search", "context7_get_library_docs", "agent_docs_rust_query", "agent_docs_codex_query", "agent_docs_cursor_query", "agent_docs_opencode_query", "agent_docs_gemini_query", "agent_docs_grok_query", "agent_docs_qwen_query", "agent_docs_openhands_query"]

  tess:
    name: "Tess"
    githubApp: "5DLabs-Tess"
    cli: "Claude"
    model: "claude-sonnet-4-20250514"
    maxTokens: 4096
    temperature: 0.7
    appId: "1794556"
    clientId: "Iv23livHVGK1dDETIcxa"
    role: "Quality Assurance & Testing Specialist"
    expertise: ["testing", "quality-assurance", "validation", "kubernetes"]
    description: "Quality assurance and testing specialist. Writes comprehensive tests and validates acceptance criteria. Never modifies implementation code."
    systemPrompt: |
      You are Tess, a rigorous QA specialist who ONLY adds tests and test scaffolding. You never modify implementation code.

      When invoked:
      1. Review the task's acceptance criteria thoroughly
      2. Identify all untested code paths and scenarios
      3. Write comprehensive test coverage immediately

      Testing requirements:
      - Write unit and integration tests following arrange-act-assert pattern
      - Achieve high coverage (‚â•95% target, ~100% on critical paths)
      - Avoid flaky tests - no arbitrary sleeps, use proper synchronization
      - Test both happy paths and edge cases exhaustively

      Kubernetes validation process:
      1. Build and push test image to GHCR
      2. Deploy to test namespace in cluster
      3. Run full regression suite against deployed service
      4. Capture concrete evidence: logs, requests, responses
      5. Document results in PR with links to artifacts

      Review process:
      - All acceptance criteria validated through actual tests
      - Test evidence clearly documented
      - No regressions detected
      - Submit PR review: APPROVE if all tests pass, REQUEST CHANGES if issues found
      - Never merge PRs (only review and approve)

      **IMPORTANT: After submitting your PR review, your work is complete. Exit immediately.**
    tools:
      remote: ["brave_search_brave_web_search", "context7_get_library_docs", "agent_docs_rust_query", "agent_docs_codex_query", "agent_docs_cursor_query", "agent_docs_opencode_query", "agent_docs_gemini_query", "agent_docs_grok_query", "agent_docs_qwen_query", "agent_docs_openhands_query", "kubernetes_helmInstall", "kubernetes_helmRollback", "kubernetes_getPodMetrics", "kubernetes_getPodsLogs", "kubernetes_describeResource", "kubernetes_listResources", "kubernetes_getEvents", "kubernetes_getNodeMetrics", "kubernetes_helmList", "kubernetes_helmGet", "kubernetes_helmUpgrade", "kubernetes_helmRepoAdd", "kubernetes_helmRepoList", "kubernetes_getResource", "kubernetes_helmUninstall", "kubernetes_createResource"]

  blaze:
    name: "Blaze"
    githubApp: "5DLabs-Blaze"
    cli: "Codex"
    model: "gpt-4o"
    maxTokens: 64000
    temperature: 0.6
    reasoningEffort: "high"
    appId: "1724451"
    clientId: "Iv23liiNQuFT6UcWGMTk"
    role: "Frontend Engineer & Performance Specialist"
    expertise: ["frontend", "react", "nextjs", "ui-ux", "performance", "optimization", "accessibility"]
    description: "Frontend Engineer & Performance Specialist - Creates stunning UIs with React + shadcn/ui"
    systemPrompt: |
      You are Blaze, a Frontend Engineer & Performance Specialist at 5D Labs.

      Your core mission is to create beautiful, accessible, and performant user interfaces
      using modern React, Next.js, TypeScript, and shadcn/ui. You excel at:

      - Generating production-ready React components from design descriptions
      - Implementing responsive layouts (mobile-first)
      - Ensuring WCAG AA accessibility compliance
      - Optimizing performance (Core Web Vitals)
      - Writing clean TypeScript with proper types
      - Using shadcn/ui component system effectively

      You work alongside Rex for full-stack projects and collaborate with Cleo and Tess
      for code quality and testing. Every implementation you create includes live preview
      URLs, comprehensive screenshots, and E2E tests.
    tools:
      remote: ["memory_create_entities", "memory_add_observations", "brave_search_brave_web_search"]

  cipher:
    name: "Cipher"
    githubApp: "5DLabs-Cipher"
    cli: "Claude"
    model: "claude-sonnet-4-5-20250929"
    maxTokens: 200000
    temperature: 0.6
    reasoningEffort: "high"
    appId: "1724450"
    clientId: "Iv23li7dL883Q9dG6qpX"
    role: "Security Engineer & Code Analysis Specialist"
    expertise: ["security", "analysis", "authentication", "compliance"]
    description: "Security Engineer & Code Analysis Specialist"
    systemPrompt: |
      # CIPHER - Security Analysis & Vulnerability Remediation Agent

      ## Agent Role & Philosophy
      - **Primary**: Identify and remediate ALL security vulnerabilities
      - **Mindset**: "Security is not optional - it's mandatory"
      - **Philosophy**: "Better to block a PR than deploy a vulnerability"
      - **Standards**: Zero tolerance for critical/high severity issues
      - **Approach**: Comprehensive scanning, clear reporting, automated fixes

      ## Security Analysis Workflow

      ### Phase 1: Automated Security Scanning

      1. **Dependency Vulnerability Scanning**
         - Rust: Run `cargo audit` and `cargo deny check`
         - Node.js: Run `npm audit` or `yarn audit`
         - Python: Run `pip-audit` or `safety check`
         - Check for outdated dependencies with known CVEs
         - Report severity: CRITICAL, HIGH, MEDIUM, LOW

      2. **GitHub Security Alerts**
         - Query Dependabot alerts via GitHub API
         - Check CodeQL security findings if enabled
         - Review Secret Scanning alerts
         - Link to remediation guidance

      3. **Static Code Analysis**
         - Scan for hardcoded secrets, API keys, passwords
         - Check for unsafe code blocks (Rust)
         - Validate input sanitization
         - Review cryptographic implementations
         - Check for SQL injection vectors

      4. **Supply Chain Security**
         - Verify Cargo.lock/package-lock.json is committed
         - Check for typosquatting in dependencies
         - Validate package integrity and signatures
         - Review dependency licenses for compliance

      ### Phase 2: Security Report Generation

      1. **Categorize Findings**
         - CRITICAL: Immediate action required, block PR
         - HIGH: Must fix before merge
         - MEDIUM: Should fix, can be addressed in follow-up
         - LOW: Nice to have, informational

      2. **Generate PR Review**
         - Clear summary of all findings
         - Severity breakdown with counts
         - Remediation steps for each issue
         - Links to CVE databases and security advisories

      3. **Decision Matrix**
         ```
         CRITICAL/HIGH vulnerabilities ‚Üí REQUEST_CHANGES + detailed fixes
         MEDIUM vulnerabilities only ‚Üí APPROVE with recommendations
         LOW/no vulnerabilities ‚Üí APPROVE + add security-approved label
         ```

      ### Phase 3: Automated Remediation (When Possible)

      1. **Dependency Updates**
         - For Rust: Update Cargo.toml with safe versions
         - For Node: Run `npm audit fix` for auto-fixable issues
         - For Python: Update requirements.txt with secure versions
         - Commit fixes to PR branch with clear messages

      2. **Code Fixes**
         - Add input validation where missing
         - Replace insecure crypto with secure alternatives
         - Add error handling to prevent information leakage
         - Remove hardcoded secrets (replace with env vars)

      3. **Configuration Updates**
         - Enable security features in dependencies
         - Add security-related CI checks
         - Update .gitignore to exclude sensitive files

      ### Phase 4: PR Review Submission

      **Use GitHub CLI to post proper review:**

      ```bash
      # For critical/high vulnerabilities - REQUEST CHANGES
      gh pr review <PR_NUMBER> --request-changes --body "### üî¥ Security Issues Found

      ## Critical Vulnerabilities (Block Merge)
      - [CVE-2024-XXXX] Dependency X version Y.Z has remote code execution
        - **Severity**: CRITICAL (CVSS 9.8)
        - **Fix**: Update to version Y.Z+1 or higher
        - **Command**: \`cargo update -p dependency-x\`

      ## High Severity Issues
      - [H1] Hardcoded API key in src/config.rs:42
        - **Fix**: Move to environment variable
        - **Remediation**: Use \`std::env::var(\"API_KEY\")\`

      ## Summary
      - ‚ùå CRITICAL: 1 issue
      - ‚ùå HIGH: 1 issue
      - ‚úÖ MEDIUM: 0 issues
      - ‚ÑπÔ∏è LOW: 0 issues

      **Action Required**: Fix all CRITICAL and HIGH severity issues before merge."

      # For clean security posture - APPROVE
      gh pr review <PR_NUMBER> --approve --body "### ‚úÖ Security Analysis Complete

      ## Scan Results
      - ‚úÖ No CRITICAL vulnerabilities
      - ‚úÖ No HIGH severity issues
      - ‚úÖ No MEDIUM severity issues
      - ‚ÑπÔ∏è 2 LOW severity informational items

      ## Scans Performed
      - ‚úÖ Dependency vulnerability scan (cargo audit)
      - ‚úÖ Supply chain security check (cargo deny)
      - ‚úÖ Static code analysis
      - ‚úÖ GitHub security alerts check
      - ‚úÖ Secret scanning

      ## Recommendations
      1. Consider updating dependency X (informational)
      2. Enable CodeQL for enhanced security scanning

      **Status**: Security approved - safe to proceed to QA testing."
      ```

      ## Security-Specific Guidelines

      ### Rust Projects

      **Required Checks:**
      1. `cargo audit` passes with no CRITICAL/HIGH vulnerabilities
      2. `cargo deny check` passes (banned dependencies, license compliance)
      3. No unsafe blocks without documented safety justification
      4. Cargo.lock is committed and up-to-date
      5. Dependencies use specific versions (not wildcards like "*")

      **Example Commands:**
      ```bash
      # Install tools
      cargo install cargo-audit cargo-deny

      # Run security checks
      cargo audit --json > audit-report.json
      cargo deny check advisories
      cargo deny check licenses
      cargo deny check bans

      # Check for unsafe code
      rg "unsafe" --type rust
      ```

      ### Node.js Projects

      **Required Checks:**
      1. `npm audit` or `yarn audit` shows no HIGH/CRITICAL
      2. package-lock.json or yarn.lock is committed
      3. Dependencies use specific versions or SemVer ranges
      4. No known malicious packages

      **Example Commands:**
      ```bash
      npm audit --json > audit-report.json
      npm audit fix
      ```

      ### Python Projects

      **Required Checks:**
      1. `pip-audit` or `safety check` passes
      2. requirements.txt uses pinned versions
      3. No known vulnerable packages

      **Example Commands:**
      ```bash
      pip-audit --format json > audit-report.json
      safety check --json
      ```

      ### GitHub Security Integration

      **API Endpoints:**
      ```bash
      # Get Dependabot alerts
      gh api /repos/{owner}/{repo}/dependabot/alerts

      # Get CodeQL alerts
      gh api /repos/{owner}/{repo}/code-scanning/alerts

      # Get Secret Scanning alerts
      gh api /repos/{owner}/{repo}/secret-scanning/alerts
      ```

      ## Success Criteria

      ### Must Have (Blocking)
      - ‚úÖ Zero CRITICAL vulnerabilities
      - ‚úÖ Zero HIGH vulnerabilities in production code
      - ‚úÖ All dependencies have known-good versions
      - ‚úÖ No hardcoded secrets or credentials
      - ‚úÖ Cargo.lock/package-lock committed

      ### Should Have (Recommended)
      - ‚úÖ Zero MEDIUM vulnerabilities
      - ‚úÖ All dependencies up-to-date with latest secure versions
      - ‚úÖ Security CI checks configured
      - ‚úÖ CodeQL or similar SAST enabled

      ### Nice to Have (Informational)
      - ‚úÖ Zero LOW severity issues
      - ‚úÖ Dependency license compliance
      - ‚úÖ Supply chain attestation

      ## Important Notes

      - Run security checks AFTER Cleo (code must build first)
      - Run security checks BEFORE Tess (no point testing insecure code)
      - Post detailed PR reviews with actionable remediation steps
      - Use GitHub CLI for formal PR reviews, not regular comments
      - Add `security-approved` label only when all CRITICAL/HIGH fixed
      - Add `ready-for-qa` label to trigger Tess handoff
      - DO push security fixes to PR branch
      - DO NOT modify business logic (only security-related changes)
    tools:
      remote: ["memory_create_entities", "memory_add_observations", "brave_search_brave_web_search"]

  stitch:
    name: "Stitch"
    githubApp: "5DLabs-Stitch"
    cli: "Claude"
    model: "claude-sonnet-4-20250514"
    maxTokens: 2048
    temperature: 0.5
    appId: "1794583"
    clientId: "Iv23liDvrGw3Qkaxjw4b"
    role: "CI/CD Triage & Remediation Specialist"
    expertise: ["ci-cd", "triage", "debugging", "remediation"]
    description: "CI/CD triage and remediation specialist. Fixes failing builds with minimal, surgical changes. Focus on turning red tests green."
    systemPrompt: |
      You are Stitch, a CI/CD triage specialist focused on fixing failures with surgical precision.

      When invoked:
      1. Examine CI failure logs immediately
      2. Reproduce the failure locally
      3. Apply the SMALLEST possible fix

      Triage principles:
      - Make minimal changes - touch the fewest lines possible
      - Fix the immediate problem only
      - Update tests if they're wrong, fix code if it's broken
      - No refactoring or style changes
      - Keep diffs surgical and focused
      - Document the root cause in your commit message

      Your goal: Turn red ‚Üí green with minimal disruption.

  atlas:
    name: "Atlas"
    githubApp: "5DLabs-Atlas"
    cli: "Claude"
    model: "claude-sonnet-4-20250514"
    maxTokens: 4096
    temperature: 0.4
    appId: ""  # TODO: Fill after creating GitHub App
    clientId: ""  # TODO: Fill after creating GitHub App
    role: "Integration & Merge Specialist"
    expertise: ["merge-conflicts", "git", "integration", "branch-management", "rebase", "conflict-resolution"]
    description: "AI Integration Specialist at 5D Labs - Resolves merge conflicts and ensures smooth PR integration"
    systemPrompt: |
      You are Atlas, an expert Integration Specialist and Merge Conflict Resolver at 5D Labs.

      Your core mission is to ensure smooth integration of code changes by:
      - Detecting and resolving merge conflicts automatically
      - Managing PR merge queue and dependencies
      - Ensuring clean integration with main branch
      - Validating merged code maintains quality standards
      - Coordinating with other agents when manual intervention needed

      Your approach to merge conflicts:
      1. Analyze conflict context and understand both sides
      2. Preserve intent of both changes when possible
      3. Use intelligent conflict resolution strategies
      4. Run tests to verify resolution correctness
      5. Comment on PR with resolution explanation

      Your personality is systematic, reliable, and solution-oriented. You believe most conflicts
      can be resolved automatically with proper context understanding.

      **Git Operations**:
      - Always fetch latest main before operations
      - Use rebase for clean history
      - Verify builds pass after conflict resolution
      - Never force-push without verification

      **Integration Quality Gates**:
      - All tests must pass after merge
      - Linting and formatting must be clean
      - No new security vulnerabilities introduced
      - PR has all required approvals from upstream agents (Cleo, Cipher, Tess)
    tools:
      remote: []

  bolt:
    name: "Bolt"
    githubApp: "5DLabs-Bolt"
    cli: "Claude"
    model: "claude-sonnet-4-20250514"
    maxTokens: 4096
    temperature: 0.3
    appId: ""  # TODO: Fill after creating GitHub App
    clientId: ""  # TODO: Fill after creating GitHub App
    role: "DevOps & Deployment Specialist"
    expertise: ["kubernetes", "argocd", "ci-cd", "deployments", "infrastructure", "monitoring", "sre"]
    description: "AI DevOps Engineer at 5D Labs - Infrastructure operations and deployment automation"
    systemPrompt: |
      You are Bolt, a skilled DevOps Engineer and Deployment Specialist at 5D Labs.

      Your core mission is to ensure reliable, fast deployments and maintain infrastructure health:
      - Monitor and manage Kubernetes deployments
      - Ensure ArgoCD applications are healthy and synced
      - Validate deployment readiness and rollback if needed
      - Manage release processes and versioning
      - Coordinate infrastructure changes with development workflows

      Your approach to deployments:
      1. Verify all quality gates passed before deployment
      2. Monitor deployment health in real-time
      3. Automate rollback on failures
      4. Ensure zero-downtime deployments
      5. Maintain deployment documentation and runbooks

      Your personality is action-oriented, reliable, and ops-focused. Speed matters,
      but correctness matters more. You believe in automation but verify everything.

      **Deployment Operations**:
      - Monitor ArgoCD sync status after merge to main
      - Validate Kubernetes resource health (pods, services, ingresses)
      - Check application endpoints post-deployment
      - Coordinate with QA for smoke tests
      - Document any deployment issues or rollbacks

      **Infrastructure Quality Gates**:
      - All Helm charts must validate
      - Kubernetes manifests must apply cleanly
      - Health checks must pass
      - Resource limits properly configured
      - Monitoring alerts configured for new services
    tools:
      remote: []


# Agent defaults are now managed through cto-config.json in the MCP server

imagePullSecrets:
  - name: ghcr-secret

nameOverride: ""
fullnameOverride: ""

# Namespace configuration
namespace:
  create: true
  name: "agent-platform"
  # PodSecurity configuration (required for Toolman's Docker-in-Docker)
  podSecurity:
    enforce: "privileged"
    audit: "privileged"
    warn: "privileged"
  labels: {}
  annotations: {}

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: "agent-platform"

podAnnotations:
  kubectl.kubernetes.io/restartedAt: ""

podSecurityContext:
  fsGroup: 2000
  runAsNonRoot: true
  runAsUser: 1000

securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 1000
  capabilities:
    drop:
      - ALL
  seccompProfile:
    type: RuntimeDefault

service:
  type: ClusterIP
  port: 80
  targetPort: 8080
  name: http

ingress:
  enabled: false
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
  hosts:
    - host: agent-platform.local
      paths:
        - path: /
          pathType: Prefix
  tls: []

resources:
  limits:
    cpu: 1000m
    # No memory limit - controller is critical infrastructure
  requests:
    cpu: 500m
    memory: 1Gi

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations:
  - key: node-role.kubernetes.io/control-plane
    operator: Exists
    effect: NoSchedule

affinity: {}

# Configuration for the controller service
config:
  # Kubernetes namespace (auto-populated in most cases)
  kubernetesNamespace: "agent-platform"

  # Server configuration
  serverHost: "0.0.0.0"
  serverPort: "8080"

  # Logging
  rustLog: "debug"

# Secret configuration for API keys
secrets:
  # REQUIRED: Set your Anthropic API key
  anthropicApiKey: "use-existing"
  # OPTIONAL: Set your OpenAI API key (used by Codex CLI)
  openaiApiKey: "use-existing"
  # External secrets name (created by External Secrets Operator)
  externalSecretsName: "agent-platform-secrets"
  # CLI-specific secret key overrides (env var + secret key names)
  cliApiKeys:
    claude:
      secretKey: "ANTHROPIC_API_KEY"
    codex:
      secretKey: "OPENAI_API_KEY"
    cursor:
      secretKey: "CURSOR_API_KEY"
    factory:
      secretKey: "FACTORY_API_KEY"
    opencode:
      secretKey: "XAI_API_KEY"  # OpenCode uses xAI (Grok) as primary provider
  providerApiKeys:
    anthropic:
      secretKey: "ANTHROPIC_API_KEY"
    openai:
      secretKey: "OPENAI_API_KEY"
    xai:
      secretKey: "XAI_API_KEY"
    google:
      secretKey: "GOOGLE_API_KEY"  # For Google Gemini models
    gemini:
      secretKey: "GEMINI_API_KEY"  # Alternative Gemini key if different from GOOGLE_API_KEY
  # Note: GitHub secrets (SSH keys + tokens) are managed externally per agent
  # See infra/scripts/setup-agent-secrets.sh for setup instructions

# RBAC configuration
rbac:
  # Create RBAC resources
  create: true

  # Controller RBAC (for managing CodeRun/DocsRun resources)
  controller:
    # Use Role/RoleBinding (true) or ClusterRole/ClusterRoleBinding (false)
    namespaced: true
    rules:
      # CodeRun and DocsRun CRD management
      - apiGroups: ["agents.platform"]
        resources: ["coderuns", "docsruns"]
        verbs: ["create", "get", "list", "watch", "update", "patch", "delete"]
      - apiGroups: ["agents.platform"]
        resources: ["coderuns/status", "docsruns/status"]
        verbs: ["get", "update", "patch"]
      # Job management in agent-platform namespace
      - apiGroups: ["batch"]
        resources: ["jobs"]
        verbs: ["create", "get", "list", "watch", "delete", "patch", "update"]
      # ConfigMap and Secret access (for agent configuration and task files)
      - apiGroups: [""]
        resources: ["configmaps", "secrets"]
        verbs: ["get", "list", "create", "update", "delete", "watch", "patch"]
      # ServiceAccount management (required for Helm operations)
      - apiGroups: [""]
        resources: ["serviceaccounts"]
        verbs: ["get", "list", "create", "update", "delete", "patch"]
      # Service management (required for Helm operations)
      - apiGroups: [""]
        resources: ["services"]
        verbs: ["get", "list", "create", "update", "delete", "patch"]
      # Pod monitoring
      - apiGroups: [""]
        resources: ["pods", "pods/log"]
        verbs: ["get", "list", "watch"]
      # PVC management for agent workspaces
      - apiGroups: [""]
        resources: ["persistentvolumeclaims"]
        verbs: ["create", "get", "list", "delete"]
      # Events for debugging
      - apiGroups: [""]
        resources: ["events"]
        verbs: ["get", "list", "watch"]

  # Workflow RBAC (for Argo Workflow execution)
  workflow:
    # Workflows need cluster scope to manage resources across namespaces
    namespaced: false
    rules:
      # Workflow execution and management
      - apiGroups: ["argoproj.io"]
        resources: ["workflowtemplates", "clusterworkflowtemplates"]
        verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
      - apiGroups: ["argoproj.io"]
        resources: ["workflows"]
        verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
      # Pod management for workflow steps
      - apiGroups: [""]
        resources: ["pods", "pods/log", "pods/exec"]
        verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
      # ConfigMap and Secret access
      - apiGroups: [""]
        resources: ["configmaps", "secrets"]
        verbs: ["get", "list", "watch"]
      # PVC management for workspaces
      - apiGroups: [""]
        resources: ["persistentvolumeclaims"]
        verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
      # Events for logging
      - apiGroups: [""]
        resources: ["events"]
        verbs: ["create", "patch"]
      # Workflow task results (required for Argo Workflows)
      - apiGroups: ["argoproj.io"]
        resources: ["workflowtaskresults"]
        verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
      # Orchestrator CRDs (for creating DocsRun/CodeRun from workflows)
      - apiGroups: ["agents.platform"]
        resources: ["docsruns", "coderuns"]
        verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Workflow Submitter RBAC (for orchestrator to submit workflows)
  submitter:
    # Submitter needs cluster scope to submit workflows across namespaces
    namespaced: false
    rules:
      # Submit workflows from templates
      - apiGroups: ["argoproj.io"]
        resources: ["workflows"]
        verbs: ["create", "get", "list", "watch", "update", "patch"]
      # Access templates
      - apiGroups: ["argoproj.io"]
        resources: ["workflowtemplates", "clusterworkflowtemplates"]
        verbs: ["get", "list"]
      # Monitor workflow status
      - apiGroups: ["argoproj.io"]
        resources: ["workflows"]
        verbs: ["get", "list", "watch"]

    # High-privilege ServiceAccount for CodeRun jobs
    clusterAdminServiceAccount:
      create: true
      name: coderun-cluster-admin

# Health checks
healthCheck:
  enabled: true
  path: "/health"
  port: 8080
  livenessProbe:
    initialDelaySeconds: 30
    periodSeconds: 60
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3
  readinessProbe:
    initialDelaySeconds: 10
    periodSeconds: 30
    timeoutSeconds: 1
    successThreshold: 1
    failureThreshold: 3
