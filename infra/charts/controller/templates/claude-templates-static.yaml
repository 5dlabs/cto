# This file is auto-generated by scripts/generate-templates-configmap.sh
# DO NOT EDIT MANUALLY - edit the source files in claude-templates/ instead
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "controller.fullname" . }}-claude-templates
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "controller.labels" . | nindent 4 }}
  annotations:
    generated-at: "2025-08-31T03:58:51Z"
data:
  agents_system-prompt.md.hbs: |
    ---
    name: {{`{{`{{`}}`}}agent_name{{`}}`}}
    description: {{`{{`{{`}}`}}agent_description{{`}}`}}
    # tools: omitted to inherit all available tools
    ---
    
    {{`{{`{{`}}`}}system_prompt{{`}}`}}
  code_claude.md.hbs: |
    # Claude Code Project Memory
    
    ## Project Information
    - **Repository**: {{`{{`{{`}}`}}repository_url{{`}}`}}
    - **Source Branch**: {{`{{`{{`}}`}}docs_branch{{`}}`}}
    - **GitHub App**: {{`{{`{{`}}`}}github_app{{`}}`}}
    - **Working Directory**: {{`{{`{{`}}`}}working_directory{{`}}`}}
    - **Implementation Target**: task {{`{{`{{`}}`}}task_id{{`}}`}}
    
    ## Tool Capabilities
    
    See @mcp-tools.md for your available tools and usage guidelines
    
    ## Project Guidelines & Standards
    
    See @coding-guidelines.md for project coding standards and best practices
    See @github-guidelines.md for git workflow and commit message standards
    
    ### Pre-PR Quality Gates (MUST PASS BEFORE PR)
    
    You may NOT create a PR until ALL of the following succeed locally:
    - Formatting check: `cargo fmt --all -- --check`
    - Clippy with pedantic lints and zero warnings: `cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic`
    - Tests passing and high coverage (target ≥95%, strive for ~100% on critical paths):
      - Recommended: `cargo llvm-cov --workspace --all-features --fail-under-lines 95`
      - Alternative: `cargo tarpaulin --all --fail-under 95`
    
    ## Current Task Documentation
    
    {{`{{`{{`}}`}}#if task_id{{`}}`}}
    **Your current task ({{`{{`{{`}}`}}task_id{{`}}`}}) documentation:**
    - See @task/task.md for requirements and description
    - See @task/acceptance-criteria.md for success criteria
    - See @task/architecture.md for technical approach and guidance
    {{`{{`{{`}}`}}else{{`}}`}}
    **General project documentation:**
    - See @README.md for project overview and setup instructions
    - See @.taskmaster/docs/architecture.md for system design patterns
    - See @.taskmaster/docs/prd.txt for product requirements
    {{`{{`{{`}}`}}/if{{`}}`}}
    
    ## System Architecture & Context
    
    See @.taskmaster/docs/architecture.md for system design patterns and architectural decisions
    {{`{{`{{`}}`}}#if docsRepositoryUrl{{`}}`}}See @.taskmaster/docs/prd.txt for complete product requirements{{`{{`{{`}}`}}/if{{`}}`}}
    
    ## Implementation Workflow
    
    {{`{{`{{`}}`}}#if task_id{{`}}`}}
    ### Current Task Process
    1. **Understand**: Read @task/task.md for requirements
    2. **Plan**: Review @task/architecture.md for technical approach
    3. **Validate**: Check @task/acceptance-criteria.md for success criteria
    4. **Code**: Follow patterns in @coding-guidelines.md
    5. **Commit**: Use standards from @github-guidelines.md
    6. **Test**: Verify all acceptance criteria are met
    
    ### Task Context
    - **Task ID**: {{`{{`{{`}}`}}task_id{{`}}`}}
    - **Repository**: {{`{{`{{`}}`}}repository_url{{`}}`}}
    - **Branch**: {{`{{`{{`}}`}}docs_branch{{`}}`}}
    - **Working Directory**: {{`{{`{{`}}`}}working_directory{{`}}`}}
    {{`{{`{{`}}`}}else{{`}}`}}
    ### General Development Process
    1. **Explore**: Understand existing codebase structure
    2. **Plan**: Follow established patterns and conventions
    3. **Implement**: Adhere to @coding-guidelines.md standards
    4. **Test**: Ensure changes meet project quality standards
    5. **Commit**: Follow @github-guidelines.md workflow
    {{`{{`{{`}}`}}/if{{`}}`}}
    
    ## Quick Command Reference
    
    ### Testing & Quality
    ```bash
    # Rust: run tests
    cargo test --workspace --all-features
    
    # Rust: formatting (must pass before PR)
    cargo fmt --all -- --check
    
    # Rust: clippy with pedantic and deny warnings (must pass before PR)
    cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic
    
    # Optional: coverage targets (recommended ≥95%)
    cargo llvm-cov --workspace --all-features --fail-under-lines 95 || \
      cargo tarpaulin --all --fail-under 95
    
    # Build verification
    cargo build --workspace --all-features
    ```
    
    ### Git Workflow
    ```bash
    {{`{{`{{`}}`}}#if task_id{{`}}`}}
    # Commit with task-specific message (see @github-guidelines.md for details)
    git commit -m "feat(task-{{`{{`{{`}}`}}task_id{{`}}`}}): implement [brief description]
    
    - [specific changes made]
    - [tests added/updated]
    - [meets acceptance criteria: X, Y, Z]"
    {{`{{`{{`}}`}}else{{`}}`}}
    # Standard commit message (see @github-guidelines.md for format)
    git commit -m "feat: implement [brief description]"
    {{`{{`{{`}}`}}/if{{`}}`}}
    ```
    
    ## Pull Request Requirements
    
    **CRITICAL**: After completing implementation, create `PR_DESCRIPTION.md` in the working directory root with:
    
    1. Concise implementation summary (2-3 sentences)
    2. Key changes made (bullet points)
    3. Important reviewer notes
    4. Testing recommendations
    
    This file enables automatic pull request creation.
    
    **IMPORTANT PR HANDLING**:
    - Always check if a PR already exists for this task before creating PR_DESCRIPTION.md
    - Use `gh pr list --state all --label "task-{{`{{`{{`}}`}}task_id{{`}}`}}"` to find existing PRs for your task
    - If a PR exists and is OPEN: do NOT create PR_DESCRIPTION.md (continue working on the existing PR)
    - If a PR exists and is MERGED: the task is complete - do NOT create a new PR
    - If a PR exists and is CLOSED (not merged): create a new PR with PR_DESCRIPTION.md
    - Only create PR_DESCRIPTION.md when there's no open PR or when reopening after a closed (unmerged) PR
    
    Additional PR gating rules:
    - Do NOT open a PR unless: `cargo fmt --all -- --check` passes, `cargo clippy ... -D warnings -W clippy::pedantic` passes, and all tests pass
    - Aim for ≥95% coverage; target ~100% on critical code paths before PR
    
    ## Development Tools & Patterns
    
    ### Claude Code Integration
    - Use `LS` and `Glob` to explore codebase structure
    - Use `Read` to examine existing code patterns
    - Use `Grep` to find similar implementations
    - Use `Edit` for targeted changes, `MultiEdit` for related changes
    - Validate with `Bash` commands after each change
    
    ### Implementation Guidelines
    {{`{{`{{`}}`}}#if task_id{{`}}`}}
    - Focus on current task requirements in `task/` directory
    - Follow architectural guidance provided in @task/architecture.md
    - Ensure all acceptance criteria are met before completion
    - Use established patterns from @coding-guidelines.md
    {{`{{`{{`}}`}}else{{`}}`}}
    - Explore existing codebase structure before making changes
    - Follow established patterns and conventions
    - Ensure changes align with project architecture
    - Maintain backward compatibility unless explicitly changing interfaces
    {{`{{`{{`}}`}}/if{{`}}`}}
    
    ---
    
  code_client-config.json.hbs: |
    {
      {{`{{`{{`}}`}}#if remote_tools{{`}}`}}
      "remoteTools": [
        {{`{{`{{`}}`}}#each remote_tools{{`}}`}}
        "{{`{{`{{`}}`}}this{{`}}`}}"{{`{{`{{`}}`}}#unless @last{{`}}`}},{{`{{`{{`}}`}}/unless{{`}}`}}
        {{`{{`{{`}}`}}/each{{`}}`}}
      ]{{`{{`{{`}}`}}#if (eq tool_config "advanced"){{`}}`}},{{`{{`{{`}}`}}/if{{`}}`}}
      {{`{{`{{`}}`}}else{{`}}`}}
      {{`{{`{{`}}`}}#if (eq tool_config "minimal"){{`}}`}}
      "remoteTools": []{{`{{`{{`}}`}}#if (eq tool_config "advanced"){{`}}`}},{{`{{`{{`}}`}}/if{{`}}`}}
      {{`{{`{{`}}`}}else if (eq tool_config "default"){{`}}`}}
      "remoteTools": [
        "brave-search_brave_web_search",
        "memory_create_entities",
        "rustdocs_query_rust_docs"
      ]{{`{{`{{`}}`}}#if (eq tool_config "advanced"){{`}}`}},{{`{{`{{`}}`}}/if{{`}}`}}
      {{`{{`{{`}}`}}else if (eq tool_config "advanced"){{`}}`}}
      "remoteTools": [
        "brave-search_brave_web_search",
        "memory_create_entities",
        "rustdocs_query_rust_docs",
        "github_create_issue",
        "kubernetes_listResources",
        "terraform_list_providers"
      ],
      {{`{{`{{`}}`}}else{{`}}`}}
      "remoteTools": [
        "brave-search_brave_web_search",
        "memory_create_entities",
        "rustdocs_query_rust_docs"
      ]{{`{{`{{`}}`}}#if (eq tool_config "advanced"){{`}}`}},{{`{{`{{`}}`}}/if{{`}}`}}
      {{`{{`{{`}}`}}/if{{`}}`}}
      {{`{{`{{`}}`}}/if{{`}}`}}
      {{`{{`{{`}}`}}#if (eq tool_config "advanced"){{`}}`}}
      "localServers": {
        "filesystem": {
          "command": "npx",
          "args": ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"],
          "tools": [
            {{`{{`{{`}}`}}#if local_tools{{`}}`}}
            {{`{{`{{`}}`}}#each local_tools{{`}}`}}
            "{{`{{`{{`}}`}}this{{`}}`}}"{{`{{`{{`}}`}}#unless @last{{`}}`}},{{`{{`{{`}}`}}/unless{{`}}`}}
            {{`{{`{{`}}`}}/each{{`}}`}}
            {{`{{`{{`}}`}}else{{`}}`}}
            "read_file",
            "write_file",
            "list_directory",
            "create_directory"
            {{`{{`{{`}}`}}/if{{`}}`}}
          ],
          "workingDirectory": "project_root"
        }
      }
      {{`{{`{{`}}`}}/if{{`}}`}}
  code_coding-guidelines.md.hbs: |
    # Rust Coding Guidelines
    
    This document provides coding standards and best practices for Rust development in this project.
    
    ## Pre-PR Quality Gates (MANDATORY)
    
    Before opening any pull request or requesting merge:
    
    - Ensure formatting passes:
      - Run: `cargo fmt --all -- --check`
    - Ensure Clippy passes with pedantic lints and no warnings:
      - Run: `cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic`
      - If a pedantic lint must be allowed, use the narrowest scope with `#[allow(clippy::lint_name)]` and include a short justification above the code. Avoid crate-wide allows.
    - Ensure tests pass and coverage is very high (strive for ~100% on critical code paths):
      - Run: `cargo test --workspace --all-features`
      - Recommended coverage tools:
        - If available: `cargo llvm-cov --workspace --all-features --fail-under-lines 95`
        - Alternatively: `cargo tarpaulin --all --fail-under 95`
    - Do not create a PR until all gates above are green locally.
    
    ## Code Quality Standards
    
    ### Error Handling
    - Use `Result<T, E>` for fallible operations
    - Use `anyhow::Result` for application-level errors
    - Use `thiserror` for library-level custom errors
    - Always handle errors explicitly - avoid `unwrap()` in production code
    - Use `?` operator for error propagation
    - Provide meaningful error messages with context
    
    ### Memory Management
    - Prefer owned types (`String`, `Vec<T>`) over borrowed types for struct fields
    - Use `Cow<str>` when you need flexibility between owned and borrowed strings
    - Minimize `clone()` calls - consider borrowing or moving when possible
    - Use `Arc<T>` for shared immutable data across threads
    - Use `Rc<T>` for shared data within single-threaded contexts
    
    ### Async Programming
    - Use `async`/`await` for I/O-bound operations
    - Use `tokio` runtime for async execution
    - Prefer `async fn` over `impl Future`
    - Use `tokio::spawn` for concurrent tasks
    - Handle cancellation with `tokio::select!` when appropriate
    
    ## Code Organization
    
    ### Module Structure
    ```rust
    // Public API at the top
    pub use self::public_types::*;
    
    // Private modules
    mod private_implementation;
    mod public_types;
    
    // Re-exports for convenience
    pub mod prelude {
        pub use super::{PublicType, PublicTrait};
    }
    ```
    
    ### Naming Conventions
    - Use `snake_case` for variables, functions, and modules
    - Use `PascalCase` for types, traits, and enum variants
    - Use `SCREAMING_SNAKE_CASE` for constants
    - Use descriptive names - avoid abbreviations
    - Prefix boolean functions with `is_`, `has_`, or `can_`
    
    ### Documentation
    - Document all public APIs with `///` comments
    - Include examples in documentation when helpful
    - Use `//!` for module-level documentation
    - Keep documentation up-to-date with code changes
    
    ## Performance Guidelines
    
    ### Allocations
    - Minimize heap allocations in hot paths
    - Use `Vec::with_capacity()` when size is known
    - Consider `SmallVec` for collections that are usually small
    - Use string formatting (`format!`) judiciously
    
    ### Collections
    - Use `HashMap` for general key-value storage
    - Use `BTreeMap` when ordering matters
    - Use `HashSet` for unique values
    - Use `VecDeque` for FIFO/LIFO operations
    
    ### Iterators
    - Prefer iterator chains over explicit loops when readable
    - Use `collect()` only when necessary
    - Consider `fold()` and `reduce()` for aggregations
    - Use `Iterator::find()` instead of filtering then taking first
    
    ## Testing Guidelines
    
    ### Unit Tests
    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;
    
        #[test]
        fn test_function_name() {
            // Given
            let input = setup_test_data();
    
            // When
            let result = function_under_test(input);
    
            // Then
            assert_eq!(result, expected_value);
        }
    
        #[test]
        #[should_panic(expected = "specific error message")]
        fn test_error_conditions() {
            // Test error conditions
        }
    }
    ```
    
    ### Integration Tests
    - Place integration tests in `tests/` directory
    - Test public API only
    - Use realistic data and scenarios
    - Test error conditions and edge cases
    
    ## Security Guidelines
    
    ### Input Validation
    - Validate all external input
    - Use type-safe parsing (`str::parse()`)
    - Sanitize data before storage or transmission
    - Use prepared statements for database queries
    
    ### Secrets Management
    - Never hardcode secrets in source code
    - Use environment variables for configuration
    - Use secure random number generation (`rand::thread_rng()`)
    - Clear sensitive data from memory when possible
    
    ## Rust-Specific Best Practices
    
    ### Pattern Matching
    ```rust
    // Prefer exhaustive matching
    match value {
        Some(x) => handle_some(x),
        None => handle_none(),
    }
    
    // Use if-let for single pattern
    if let Some(value) = optional_value {
        process_value(value);
    }
    ```
    
    ### Ownership
    - Pass by reference (`&T`) for read-only access
    - Pass by mutable reference (`&mut T`) for modification
    - Pass by value (`T`) for ownership transfer
    - Use `Clone` when multiple ownership is needed
    
    ### Traits
    - Implement common traits (`Debug`, `Clone`, `PartialEq`)
    - Use trait bounds instead of concrete types in generics
    - Prefer composition over inheritance (use traits)
    
    ## Service Architecture Guidelines
    
    ### Project Structure
    ```
    src/
    ├── bin/           # Binary targets
    ├── lib.rs         # Library root
    ├── config/        # Configuration management
    ├── handlers/      # Request handlers
    ├── models/        # Data models
    ├── services/      # Business logic
    └── utils/         # Utility functions
    ```
    
    ### Configuration
    - Use `serde` for configuration deserialization
    - Support both file-based and environment-based config
    - Provide sensible defaults
    - Validate configuration on startup
    
    ### Logging
    - Use `tracing` for structured logging
    - Include relevant context in log messages
    - Use appropriate log levels (error, warn, info, debug, trace)
    - Avoid logging sensitive information
    
    ## Common Patterns
    
    ### Builder Pattern
    ```rust
    pub struct ConfigBuilder {
        host: Option<String>,
        port: Option<u16>,
    }
    
    impl ConfigBuilder {
        pub fn new() -> Self {
            Self { host: None, port: None }
        }
    
        pub fn host(mut self, host: impl Into<String>) -> Self {
            self.host = Some(host.into());
            self
        }
    
        pub fn port(mut self, port: u16) -> Self {
            self.port = Some(port);
            self
        }
    
        pub fn build(self) -> Result<Config> {
            Ok(Config {
                host: self.host.unwrap_or_else(|| "localhost".to_string()),
                port: self.port.unwrap_or(8080),
            })
        }
    }
    ```
    
    ### Resource Management
    ```rust
    // Use RAII for resource cleanup
    pub struct Database {
        connection: DatabaseConnection,
    }
    
    impl Database {
        pub fn new(url: &str) -> Result<Self> {
            let connection = DatabaseConnection::open(url)?;
            Ok(Self { connection })
        }
    }
    
    impl Drop for Database {
        fn drop(&mut self) {
            // Cleanup happens automatically
            self.connection.close();
        }
    }
    ```
    
    Remember: These guidelines promote code that is safe, performant, and maintainable. When in doubt, choose clarity over cleverness.
    
    ## Documentation-Driven Implementation
    
    When implementing or modifying code covered by these guidelines and when an internal document server is available:
    
    - Always query the document server for the recommended, best-practice approach before significant implementation work.
    - Prefer patterns and examples from the document server to reduce rework and testing iteration.
    - If a divergence from the recommended approach is necessary, document the rationale in the PR description and in code comments above the relevant implementation.
  code_container-cleo.sh.hbs: |
    #!/bin/sh
    
    # Ensure Rust environment is always properly set up
    echo "🔧 Setting up Rust environment..."
    
    # Source Rust environment if available (fixes cargo not found issues)
    if [ -f "$HOME/.cargo/env" ]; then
        . "$HOME/.cargo/env"
        echo "✓ Sourced Rust environment from $HOME/.cargo/env"
    fi
    
    # Also try root cargo env as fallback
    if [ -f "/root/.cargo/env" ]; then
        . "/root/.cargo/env"
        echo "✓ Sourced Rust environment from /root/.cargo/env"
    fi
    
    # Ensure rustup has a default toolchain set
    if command -v rustup >/dev/null 2>&1; then
        rustup default stable 2>/dev/null || true
        echo "✓ Ensured stable Rust toolchain is default"
    else
        echo "⚠️ rustup not found in PATH"
    fi
    
    # Verify Rust is available
    if command -v cargo >/dev/null 2>&1; then
        echo "✓ Cargo is available: $(cargo --version)"
    else
        echo "❌ Cargo not found in PATH"
        echo "Current PATH: $PATH"
        echo "Attempting to find cargo..."
        find /usr -name cargo 2>/dev/null | head -5 || echo "No cargo found in /usr"
        find /home -name cargo 2>/dev/null | head -5 || echo "No cargo found in /home"
    fi
    
    echo '════════════════════════════════════════════════════════════════'
    echo '║              CLEO CODE QUALITY WORKFLOW STARTING             ║'
    echo '║     Code Quality & CI/CD Pipeline Enforcement Agent          ║'
    echo '════════════════════════════════════════════════════════════════'
    echo "🎯 Agent: {{`{{`{{`}}`}}github_app{{`}}`}}"
    echo "🔍 Focus: Code quality, CI/CD setup, and Docker image building"
    echo "📋 Task ID: {{`{{`{{`}}`}}task_id{{`}}`}}"
    echo "✅ Mission: Perfect code quality AND working CI/CD pipeline with Docker builds"
    
    # Clean up any leftover completion marker from previous runs
    # This prevents issues with sequential task executions on the same PVC
    if [ -f /workspace/.cleo-complete ]; then
        echo "🧹 Cleaning up completion marker from previous run"
        rm -f /workspace/.cleo-complete
    fi
    
    # Disable interactive Git prompts globally
    export GIT_TERMINAL_PROMPT=0
    export GIT_ASKPASS=/bin/true
    export SSH_ASKPASS=/bin/true
    
    # Repository URL
    REPO_URL="{{`{{`{{`}}`}}repository_url{{`}}`}}"
    
    # GitHub App authentication is configured via environment variables
    echo "Using GitHub App authentication for code quality checks"
    
    # Authenticate with GitHub App
    if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
        echo "Authenticating with GitHub App..."
    
        # Create temporary private key file (support escaped newlines)
        TEMP_KEY_FILE="/tmp/github-app-key.pem"
        printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
        chmod 600 "$TEMP_KEY_FILE"
    
        # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
        # JWT header
        JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
        # JWT payload with current time and expiration (10 minutes)
        NOW=$(date +%s)
        EXP=$((NOW + 600))
        JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
        # Sign the JWT
        JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
        JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
        # Get installation ID for the repository (robust parsing of owner/repo)
        INPUT_REPO="{{`{{`{{`}}`}}repository_url{{`}}`}}"
        REPO_OWNER=""
        REPO_NAME=""
    
        if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
            REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
            REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
        elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
            # SSH format git@github.com:owner/repo(.git)
            REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
            REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
        else
            # Fallback: assume slug owner/repo (possibly with .git)
            SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
            REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
            REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
        fi
    
        echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"
    
        echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
        # Get the installation ID (retry and follow redirects). Fallback to org installation.
        INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")
    
        INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')
    
        if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
            echo "⚠️ Repo installation not found, trying org installation..."
            ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
                --connect-timeout 5 --max-time 12 \
                -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/orgs/$REPO_OWNER/installation")
            INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
        fi
    
        if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
            echo "❌ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
            echo "Response (repo): $INSTALLATION_RESPONSE"
            echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
            rm -f "$TEMP_KEY_FILE"
            exit 1
        fi
    
        echo "Installation ID: $INSTALLATION_ID"
    
        # Get installation access token
        TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
        GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
        TOKEN_GENERATED_AT=$(date +%s)  # Track when token was generated for refresh logic
    
        if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
            echo "❌ Failed to get installation access token"
            echo "Response: $TOKEN_RESPONSE"
            rm -f "$TEMP_KEY_FILE"
            exit 1
        fi
    
        echo "✅ Successfully authenticated with GitHub App"
    
        # Clean up temporary key file
        rm -f "$TEMP_KEY_FILE"
    
        # Export the token for git to use
        export GITHUB_TOKEN
    
        # Configure git to use the token (use --replace-all to handle multiple existing helpers)
        git config --global --replace-all credential.helper store
        echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    
        # Also authenticate gh CLI with the token
        echo "$GITHUB_TOKEN" | gh auth login --with-token
    
        # Token refresh functions for long-running jobs
        refresh_github_token() {
            echo "🔄 Refreshing GitHub App token..."
    
            # Create temporary key file
            TEMP_KEY_FILE="/tmp/github-app-key-$$"
            echo "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
            chmod 600 "$TEMP_KEY_FILE"
    
            # Generate new JWT
            JWT_TOKEN=$(ruby -r openssl -r json -r base64 -e "
            key = OpenSSL::PKey::RSA.new(File.read('$TEMP_KEY_FILE'))
            payload = {
                iat: Time.now.to_i - 60,
                exp: Time.now.to_i + (10 * 60),
                iss: '$GITHUB_APP_ID'
            }
            header = { alg: 'RS256', typ: 'JWT' }
    
            header_enc = Base64.urlsafe_encode64(header.to_json).gsub('=', '')
            payload_enc = Base64.urlsafe_encode64(payload.to_json).gsub('=', '')
            signature = Base64.urlsafe_encode64(key.sign(OpenSSL::Digest::SHA256.new, \"#{header_enc}.#{payload_enc}\")).gsub('=', '')
    
            puts \"#{header_enc}.#{payload_enc}.#{signature}\"
            ")
    
            # Get installation ID (reuse logic from initial auth)
            INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')
    
            if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
                INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
                    -H "Accept: application/vnd.github+json" \
                    "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
            fi
    
            # Get new installation token
            TOKEN_RESPONSE=$(curl -s -X POST \
                -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
            NEW_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
            if [ "$NEW_TOKEN" != "null" ] && [ -n "$NEW_TOKEN" ]; then
                export GITHUB_TOKEN="$NEW_TOKEN"
                export TOKEN_GENERATED_AT=$(date +%s)
    
                # Update git credentials
                echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
                echo "$GITHUB_TOKEN" | gh auth login --with-token 2>/dev/null
    
                echo "✅ Token refreshed successfully"
                rm -f "$TEMP_KEY_FILE"
                return 0
            else
                echo "❌ Failed to refresh token: $TOKEN_RESPONSE"
                rm -f "$TEMP_KEY_FILE"
                return 1
            fi
        }
    
        # Check if token needs refresh (call before git operations)
        refresh_token_if_needed() {
            if [ -z "$TOKEN_GENERATED_AT" ]; then
                echo "⚠️ No token timestamp found, refreshing token..."
                refresh_github_token
                return
            fi
    
            NOW=$(date +%s)
            TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))
    
            # Refresh if token is older than 50 minutes (tokens last 1 hour, refresh at 50 min to be safe)
            if [ $TOKEN_AGE -gt 3000 ]; then
                echo "🔄 Token is $(($TOKEN_AGE / 60)) minutes old, refreshing..."
                refresh_github_token
            fi
        }
    
    else
        echo "❌ GitHub App credentials not found"
        exit 1
    fi
    
    # Target repository directory name - this is where the git repo will be
    TARGET_REPO_DIR="{{`{{`{{`}}`}}#if working_directory{{`}}`}}{{`{{`{{`}}`}}working_directory{{`}}`}}{{`{{`{{`}}`}}else{{`}}`}}{{`{{`{{`}}`}}service{{`}}`}}{{`{{`{{`}}`}}/if{{`}}`}}"
    
    # Set working directory for the agent - should match the repository location
    CLAUDE_WORK_DIR="/workspace/$TARGET_REPO_DIR"
    mkdir -p "$CLAUDE_WORK_DIR"
    cd "$CLAUDE_WORK_DIR"
    echo "🔧 Working directory set to: $CLAUDE_WORK_DIR"
    
    # Prepare environment for QA checks
    echo "════════════════════════════════════════════════════════════════"
    echo "📊 PREPARING CODE QUALITY ENVIRONMENT"
    echo "════════════════════════════════════════════════════════════════"
    
    # Configure Git identity
    git config --global user.email "cleo@5dlabs.com"
    git config --global user.name "5DLabs-Cleo"
    git config --global init.defaultBranch main
    
    # =============================================================================
    # AUTHENTICATION VERIFICATION
    # =============================================================================
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "🔐 AUTHENTICATION VERIFICATION"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""
    
    # Repository URLs - Handle both full URLs and org/repo format
    # Check if repository_url already contains https://github.com/
    if echo "{{`{{`{{`}}`}}repository_url{{`}}`}}" | grep -q "^https://github.com/"; then
        REPO_HTTP_URL="{{`{{`{{`}}`}}repository_url{{`}}`}}"
        if ! echo "{{`{{`{{`}}`}}repository_url{{`}}`}}" | grep -q "\.git$"; then
            REPO_HTTP_URL="${REPO_HTTP_URL}.git"
        fi
    else
        REPO_HTTP_URL="https://github.com/{{`{{`{{`}}`}}repository_url{{`}}`}}.git"
    fi
    
    # Same for docs repository
    if echo "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" | grep -q "^https://github.com/"; then
        DOCS_HTTP_URL="{{`{{`{{`}}`}}docs_repository_url{{`}}`}}"
        if ! echo "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" | grep -q "\.git$"; then
            DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
        fi
    else
        DOCS_HTTP_URL="https://github.com/{{`{{`{{`}}`}}docs_repository_url{{`}}`}}.git"
    fi
    
    # DEBUG: Show what URLs are being constructed
    echo "🔍 DEBUG: URL Construction & Parameters"
    echo "  Input repository_url: '{{`{{`{{`}}`}}repository_url{{`}}`}}'"
    echo "  Input docs_repository_url: '{{`{{`{{`}}`}}docs_repository_url{{`}}`}}'"
    echo "  Input docs_project_directory: '{{`{{`{{`}}`}}docs_project_directory{{`}}`}}'"
    echo "  Input working_directory: '{{`{{`{{`}}`}}working_directory{{`}}`}}'"
    echo "  Input docs_branch: '{{`{{`{{`}}`}}docs_branch{{`}}`}}'"
    echo "  Input github_app: '{{`{{`{{`}}`}}github_app{{`}}`}}'"
    echo "  Input task_id: '{{`{{`{{`}}`}}task_id{{`}}`}}'"
    echo "  Input service: '{{`{{`{{`}}`}}service{{`}}`}}'"
    echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
    echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
    echo "  Current working directory: $(pwd)"
    echo "  Available environment variables:"
    env | grep -E "(GITHUB|ANTHROPIC)" | sort
    
    # Test HTTPS access to repository
    echo "🔍 DEBUG: Testing HTTPS repository access..."
    echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
    if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
      echo "✓ HTTPS repository access successful"
      echo "  Repository: {{`{{`{{`}}`}}repository_url{{`}}`}} ($REPO_HTTP_URL)"
      echo "  Output: $(cat /tmp/repo_test.out | head -1)"
    else
      echo "❌ HTTPS repository access failed"
      echo "  Repository: {{`{{`{{`}}`}}repository_url{{`}}`}} ($REPO_HTTP_URL)"
      echo "  Error output: $(cat /tmp/repo_test.out)"
      echo "  Git credential helper status:"
      git config --list | grep credential || echo "  No credential helpers configured"
      echo ""
      echo "🚫 ABORTING: Cannot access repository via HTTPS"
      exit 1
    fi
    
    # Test docs repository access
    echo "🔍 DEBUG: Testing docs repository access..."
    echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
    if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
      echo "✓ Docs repository access successful"
      echo "  Repository: {{`{{`{{`}}`}}docs_repository_url{{`}}`}} ($DOCS_HTTP_URL)"
      echo "  Output: $(cat /tmp/docs_test.out | head -1)"
    else
      echo "❌ Docs repository access failed"
      echo "  Repository: {{`{{`{{`}}`}}docs_repository_url{{`}}`}} ($DOCS_HTTP_URL)"
      echo "  Error output: $(cat /tmp/docs_test.out)"
      echo ""
      echo "🚫 ABORTING: Cannot access docs repository via HTTPS"
      exit 1
    fi
    
    # Clone or update repository
    if [ -d "$CLAUDE_WORK_DIR" ] && [ -d "$CLAUDE_WORK_DIR/.git" ]; then
        echo "📁 Found existing repository at '$CLAUDE_WORK_DIR', updating..."
        cd "$CLAUDE_WORK_DIR"
        git fetch origin
    else
        echo "📥 Cloning repository to '$CLAUDE_WORK_DIR'..."
        # Use the REPO_HTTP_URL constructed in authentication verification section
        if ! git clone "$REPO_HTTP_URL" "$CLAUDE_WORK_DIR"; then
            echo "❌ Failed to clone repository"
            exit 1
        fi
        cd "$CLAUDE_WORK_DIR"
    fi
    
    # Checkout PR branch for quality review
    if [ -n "$PR_NUMBER" ] && [ -n "$PR_URL" ]; then
        echo "🔄 Checking out PR #$PR_NUMBER for quality review..."
        cd "$CLAUDE_WORK_DIR"
    
        # Fetch all latest changes including PR branches
        git fetch origin --prune
    
        # Get PR branch information and checkout
        PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName' 2>/dev/null || echo "")
        if [ -n "$PR_BRANCH" ]; then
            echo "📦 Checking out PR branch: $PR_BRANCH"
            if git checkout "$PR_BRANCH" 2>/dev/null; then
                echo "📥 Pulling latest changes from $PR_BRANCH..."
                git pull origin "$PR_BRANCH" || echo "⚠️  Could not pull latest changes"
            elif git checkout -b "$PR_BRANCH" "origin/$PR_BRANCH" 2>/dev/null; then
                echo "✅ Created and checked out tracking branch for $PR_BRANCH"
            else
                echo "⚠️  Branch checkout failed, trying GitHub CLI method..."
                gh pr checkout "$PR_NUMBER" || echo "❌ Failed to checkout PR via gh CLI"
            fi
        else
            echo "⚠️  Could not determine PR branch name, using GitHub CLI to checkout PR directly"
            gh pr checkout "$PR_NUMBER" || echo "❌ Failed to checkout PR"
        fi
    
        # Verify we're on the right commit
        CURRENT_SHA=$(git rev-parse HEAD)
        echo "📍 Current commit: $CURRENT_SHA"
    
        # Don't change directory yet - we'll cd to CLAUDE_WORK_DIR at the end
        echo "✅ Repository positioned at PR #$PR_NUMBER with latest changes"
    else
        echo "⚠️  No PR context found (PR_NUMBER=$PR_NUMBER, PR_URL=$PR_URL)"
        echo "📋 Will perform quality review on current repository state"
    fi
    
    echo "════════════════════════════════════════════════════════════════"
    echo "🔍 CODE QUALITY ANALYSIS PREPARATION"
    echo "════════════════════════════════════════════════════════════════"
    echo ""
    echo "MISSION: Enforce rigorous code quality standards:"
    echo "1. Run Clippy pedantic checks on all Rust code changes"
    echo "2. Verify code formatting with cargo fmt --check"
    echo "3. Execute all tests with cargo test"
    echo "4. Lint YAML files when YAML changes are detected"
    echo "5. Add 'ready-for-qa' label only when all quality checks pass"
    echo ""
    echo "Quality Standards:"
    echo "- Zero clippy warnings (pedantic level)"
    echo "- Perfect code formatting"
    echo "- 100% test passing rate"
    echo "- Clean YAML syntax and structure"
    echo ""
    echo "════════════════════════════════════════════════════════════════"
    
    # Task files should already be present in the project repository at /task
    echo "📋 Checking for task files in project repository..."
    if [ -d "$CLAUDE_WORK_DIR/task" ]; then
        echo "✓ Found task directory in project repository"
        ls -la "$CLAUDE_WORK_DIR/task/"
    else
        echo "⚠️ No /task directory found in project repository"
    fi
    
    # Ensure we're in the git repository working directory
    echo "✓ Working directly in git repository at: $CLAUDE_WORK_DIR"
    
    # Check if we should continue previous session
    {{`{{`{{`}}`}}#if continue_session{{`}}`}}
    echo "📂 Continuing from previous session..."
    # Preserve existing CLAUDE.md if it exists
    if [ -f "/workspace/CLAUDE.md" ]; then
        echo "✓ Found existing CLAUDE.md, preserving session memory"
    fi
    {{`{{`{{`}}`}}else{{`}}`}}
    {{`{{`{{`}}`}}#if overwrite_memory{{`}}`}}
    echo "🔄 Overwriting session memory as requested..."
    rm -f /workspace/CLAUDE.md
    {{`{{`{{`}}`}}/if{{`}}`}}
    {{`{{`{{`}}`}}/if{{`}}`}}
    
    # Generate configuration files from templates
    echo "🔧 Generating Cleo-specific configuration files..."
    
    # Enterprise managed settings are mounted directly from ConfigMap
    echo "=== ENTERPRISE MANAGED SETTINGS ==="
    echo "✓ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
    echo "✓ No copying needed - mount automatically reflects latest ConfigMap changes"
    
    # Copy MCP client configuration from task files
    if [ -f "/task-files/client-config.json" ]; then
      cp /task-files/client-config.json "$CLAUDE_WORK_DIR/client-config.json"
      echo "✓ client-config.json copied from ConfigMap"
      export MCP_CLIENT_CONFIG="$CLAUDE_WORK_DIR/client-config.json"
      echo "✓ MCP_CLIENT_CONFIG set to: $MCP_CLIENT_CONFIG"
    else
      echo "⚠️ client-config.json not found in task-files - MCP client may not work correctly"
    fi
    
    # Check if CLAUDE.md already exists (created by controller)
    if [ -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
        echo "✓ CLAUDE.md already exists (from controller), using existing file"
    elif [ -f "/workspace/CLAUDE.md" ]; then
        echo "✓ Found CLAUDE.md in workspace, copying to working directory"
        cp "/workspace/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
    else
        echo "📝 Creating Cleo-specific CLAUDE.md memory file"
        cat > "$CLAUDE_WORK_DIR/CLAUDE.md" << 'EOF'
    # CLEO - Code Quality Enforcement Agent
    
    ## Agent Role
    - **Primary**: Rigorous code quality enforcement and CI/CD maintenance
    - **Focus**: Fix CI failures, resolve merge conflicts, enforce quality standards
    - **Secondary**: YAML linting for infrastructure changes
    - **Critical**: Add "ready-for-qa" label only when ALL quality checks pass
    
    ## PRIORITY TASKS
    
    ### 1. Merge Conflict Resolution (DO FIRST!)
    Check for merge conflicts and resolve them immediately:
    \\\`\\\`\\\`bash
    # Check if PR has conflicts
    gh pr view $PR_NUM --json mergeable,mergeStateStatus
    
    # If conflicts exist:
    git fetch origin main
    git merge origin/main
    # Resolve conflicts intelligently, preserving functionality
    git add -A
    git commit -m "fix: resolve merge conflicts with main"
    git push
    \\\`\\\`\\\`
    
    ### 2. CI/CD Failure Fixes (HIGH PRIORITY)
    Monitor CI status and fix any failures OR stuck jobs:
    \\\`\\\`\\\`bash
    # Check if repository has workflows before checking CI status
    if [ -d ".github/workflows" ] && [ "\\\$(ls .github/workflows/*.yml .github/workflows/*.yaml 2>/dev/null | wc -l)" -gt 0 ]; then
      # Check CI status - look for BOTH failures AND stuck jobs
      gh pr checks $PR_NUM
      # Get PR branch dynamically
      PR_BRANCH=\\\$(gh pr view $PR_NUM --json headRefName -q .headRefName)
      gh run list --branch="\\\$PR_BRANCH" --limit 5
    else
      echo "ℹ️  No GitHub Actions workflows found in repository"
      echo "   CI/CD checks will be skipped for this repository"
    fi
    
    # If jobs are stuck/not starting:
    # 1. Check workflow syntax:
    cat .github/workflows/*.yml | head -50
    # 2. Verify runner labels exist
    # 3. Check for workflow errors in GitHub UI
    
    # Common fixes for stuck jobs:
    # - Fix 'runs-on:' to use valid runner (ubuntu-latest, ubuntu-22.04, etc.)
    # - Fix action versions (e.g., actions/checkout@v4)
    # - Ensure workflow triggers match (push, pull_request)
    # - Remove or fix invalid workflow syntax
    
    # Common fixes for failed jobs:
    # - Fix linting errors (cargo fmt, black, eslint --fix)
    # - Fix type errors
    # - Update dependencies if needed
    # - Fix test failures
    # - Adjust CI configuration if needed
    \\\`\\\`\\\`
    
    ## Code Quality Requirements
    
    ### Change Detection Logic
    Analyze git diff to determine appropriate quality checks:
    \\\`\\\`\\\`bash
    RUST_CHANGES=\\\$(git diff --name-only origin/main...HEAD | grep -E '\\\.(rs|toml)\\\$' || true)
    YAML_CHANGES=\\\$(git diff --name-only origin/main...HEAD | grep -E '\\\.(yaml|yml)\\\$' || true)
    \\\`\\\`\\\`
    
    ### Quality Check Execution
    **For Rust Changes:**
    1. \\\`cargo clippy -- -D warnings -D clippy::pedantic\\\` (zero tolerance)
    2. \\\`cargo fmt\\\` (auto-fix formatting)
    3. \\\`cargo test\\\` (all tests must pass)
    
    **For YAML Changes:**
    1. YAML syntax validation with yamllint
    2. Auto-fix trailing spaces and formatting issues
    
    ### Error Handling
    - Automatically fix formatting and linting issues
    - Fix compilation errors if straightforward
    - Update outdated dependencies if causing CI failures
    - Never approve when quality checks fail after fixes
    
    ### GitHub Integration
    - Monitor PR for CI failures and merge conflicts
    - Fix issues proactively without waiting
    - Post PR comments about fixes made
    - Add "ready-for-qa" label only when CI is green
    - Use GitHub CLI for all PR operations
    
    ## Success Criteria
    - PR has no merge conflicts
    - All CI checks passing (green)
    - Zero clippy warnings at pedantic level
    - Perfect code formatting consistency
    - 100% test pass rate
    - Clean YAML syntax and structure
    EOF
    
        # Append base CLAUDE.md from ConfigMap if it exists
        if [ -f "/task-files/CLAUDE.md" ]; then
            echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md"
            cat "/task-files/CLAUDE.md" >> "$CLAUDE_WORK_DIR/CLAUDE.md"
            echo "✓ Appended base CLAUDE.md content from ConfigMap"
        fi
    fi
    
    # Copy guidelines files to working directory (match Rex pattern)
    if [ -f "/task-files/coding-guidelines.md" ]; then
      cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
      echo "✓ Copied coding-guidelines.md to working directory"
    fi
    
    if [ -f "/task-files/github-guidelines.md" ]; then
      cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
      echo "✓ Copied github-guidelines.md to working directory"
    fi
    
    # Copy MCP configuration from ConfigMap to project root (project scope)
    if [ -f "/task-files/mcp.json" ]; then
      cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
      echo "✓ Copied mcp.json to .mcp.json (project scope)"
    else
      echo "⚠️ mcp.json template not found"
    fi
    
    # Setup hook scripts
    echo "🔧 Setting up Cleo-specific hook scripts..."
    mkdir -p "$CLAUDE_WORK_DIR/hooks"
    
    {{`{{`{{`}}`}}#each hook_scripts{{`}}`}}
    cat > "$CLAUDE_WORK_DIR/hooks/{{`{{`{{`}}`}}@key{{`}}`}}" << 'EOF'
    {{`{{`{{`}}`}}{this{{`}}`}}}
    EOF
    chmod +x "$CLAUDE_WORK_DIR/hooks/{{`{{`{{`}}`}}@key{{`}}`}}"
    {{`{{`{{`}}`}}/each{{`}}`}}
    
    # Export environment for Claude
    export CLAUDE_WORK_DIR
    export GITHUB_TOKEN
    export REPO_OWNER
    export REPO_NAME
    export TARGET_REPO_DIR
    
    echo "════════════════════════════════════════════════════════════════"
    echo "✅ CLEO CODE QUALITY AGENT READY"
    echo "════════════════════════════════════════════════════════════════"
    echo "📁 Working Directory: $CLAUDE_WORK_DIR"
    echo "📦 Repository: $REPO_OWNER/$REPO_NAME"
    echo "📋 Task: {{`{{`{{`}}`}}task_id{{`}}`}}"
    echo "🎯 Focus: Rigorous code quality enforcement"
    echo "⚠️  CRITICAL: Must pass all quality checks before adding 'ready-for-qa' label"
    echo "════════════════════════════════════════════════════════════════"
    
    # Export necessary variables for Claude execution
    export SERVICE_NAME="{{`{{`{{`}}`}}service{{`}}`}}"
    export TASK_ID="{{`{{`{{`}}`}}task_id{{`}}`}}"
    export GITHUB_APP="{{`{{`{{`}}`}}github_app{{`}}`}}"
    
    # Start Claude with Cleo-specific configuration
    cd "$CLAUDE_WORK_DIR"
    
    # Build Claude command
    CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"
    
    # Create Cleo's static prompt
    echo "✓ Creating Cleo's static code quality enforcement prompt"
    
    # Build static prompt with task context
    CLEO_PROMPT="# Code Quality Review Assignment
    
    You are Cleo, a rigorous code quality enforcement agent. Your mission is to ensure zero-tolerance quality standards for this pull request.
    
    ## Your Role
    - **Primary Focus**: Code quality enforcement AND CI/CD pipeline setup
    - **Quality Tools**: Clippy (pedantic), cargo fmt, cargo test, YAML linting
    - **DevOps Setup**: GitHub Actions workflows, Docker image building, CI verification
    - **Decision Authority**: Add 'ready-for-qa' label only when ALL quality checks AND CI builds pass
    - **Standards**: Zero warnings, perfect formatting, 100% test pass rate, working Docker builds
    
    ## Current Context
    
    ### Pull Request Information
    - **PR Number**: ${PR_NUMBER:-"Not specified"}
    - **PR URL**: ${PR_URL:-"Not specified"}
    - **Repository**: $REPO_OWNER/$REPO_NAME
    - **Working Directory**: $CLAUDE_WORK_DIR"
    
    # Add task context if available
    if [ -f "$CLAUDE_WORK_DIR/task/task.md" ]; then
        CLEO_PROMPT="$CLEO_PROMPT
    
    ### Task Information (for context)
    $(cat "$CLAUDE_WORK_DIR/task/task.md")
    
    ### Task Requirements (Rex was asked to implement)
    $(cat "$CLAUDE_WORK_DIR/task/prompt.md" 2>/dev/null || echo "No prompt.md found")
    
    ### Acceptance Criteria (what Rex needed to achieve)
    $(cat "$CLAUDE_WORK_DIR/task/acceptance-criteria.md" 2>/dev/null || echo "No acceptance-criteria.md found")
    
    ### Architecture Reference (if available)
    $(cat "$CLAUDE_WORK_DIR/task/architecture.md" 2>/dev/null || echo "No architecture.md found")"
    else
        CLEO_PROMPT="$CLEO_PROMPT
    
    ### Task Information
    No task files found in /task directory - proceeding with general code quality review."
    fi
    
    # Complete the prompt
    CLEO_PROMPT="$CLEO_PROMPT
    
    ## Your Instructions
    1. **Analyze the PR changes**: The repository has been automatically positioned at the PR branch with latest changes
    2. **Detect change types**: Identify Rust files (.rs, .toml) and YAML files (.yml, .yaml)
    3. **Run quality checks**:
       - For Rust: cargo clippy -- -D warnings -W clippy::pedantic
       - Run cargo fmt to fix any formatting issues
       - For YAML: YAML linting and validation
       - IMPORTANT: Commit and push ALL fixes immediately (don't wait until the end)
       - NOTE: Do NOT write tests - Tess handles all testing
    4. **Set up CI/CD Pipeline (CRITICAL - Use These EXACT Patterns)**:
       - Check if .github/workflows/ci.yml exists (or similar CI workflow)
       - If not, create using these PROVEN TEMPLATES:
    
       **a) Dockerfile (Runtime-only, expects pre-built binary):**
       \\\`\\\`\\\`dockerfile
       FROM debian:bookworm-slim
       RUN apt-get update && apt-get install -y \\\\
           ca-certificates libssl3 wget --no-install-recommends \\\\
           && rm -rf /var/lib/apt/lists/* && apt-get clean
       RUN useradd -r -u 1000 -m -d /app -s /bin/bash app
       WORKDIR /app
       COPY <binary-name> /app/<binary-name>
       RUN chmod +x /app/<binary-name> && chown -R app:app /app
       USER app
       EXPOSE 8080
       HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\\
           CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1
       CMD ["./<binary-name>"]
       \\\`\\\`\\\`
    
       **b) CI Workflow (.github/workflows/ci.yml):**
       \\\`\\\`\\\`yaml
       name: Continuous Integration
       on:
         push:
           branches: [main]
         pull_request:
           branches: [main]
    
       jobs:
         lint-rust:
           runs-on: ubuntu-22.04
           steps:
             - uses: actions/checkout@v4
             - uses: actions-rust-lang/setup-rust-toolchain@v1
               with:
                 toolchain: stable
                 components: rustfmt, clippy
             - uses: Swatinem/rust-cache@v2
               with:
                 workspaces: . -> target
                 shared-key: "rust-cache-ci"
             - name: Format check
               run: cargo fmt --all -- --check
             - name: Clippy
               run: cargo clippy --all-targets --all-features -- -D warnings -W clippy::pedantic
    
         test-rust:
           runs-on: ubuntu-22.04
           steps:
             - uses: actions/checkout@v4
             - uses: actions-rust-lang/setup-rust-toolchain@v1
               with:
                 toolchain: stable
             - uses: Swatinem/rust-cache@v2
               with:
                 workspaces: . -> target
                 shared-key: "rust-cache-ci"
             - name: Run tests
               run: cargo test --all-features --all-targets
       \\\`\\\`\\\`
    
       **c) Deploy Workflow (.github/workflows/deploy.yml) for k8s-runner:**
       \\\`\\\`\\\`yaml
       name: Deploy
       on:
         push:
           branches: [main, develop, feature/*, feat/*, fix/*]
    
       env:
         REGISTRY: ghcr.io
         IMAGE_BASE: ${{`{{`{{`}}`}} github.repository_owner {{`}}`}}
    
       jobs:
         build:
           runs-on: [k8s-runner]  # Use self-hosted runner for speed
           permissions:
             contents: read
             packages: write
           steps:
             - uses: actions/checkout@v4
             - name: Build binary
               env:
                 RUSTC_WRAPPER: "sccache"
                 CARGO_TARGET_DIR: "\$HOME/cache/target"
               run: |
                 cargo build --release
                 cp \$HOME/cache/target/release/<binary> ./<binary>
             - uses: docker/setup-buildx-action@v3
             - uses: docker/login-action@v3
               with:
                 registry: ghcr.io
                 username: ${{`{{`{{`}}`}} github.actor {{`}}`}}
                 password: ${{`{{`{{`}}`}} secrets.GITHUB_TOKEN {{`}}`}}
             - uses: docker/build-push-action@v5
               with:
                 context: .
                 file: ./Dockerfile
                 platforms: linux/amd64,linux/arm64
                 push: true
                 tags: |
                   ghcr.io/${{`{{`{{`}}`}} github.repository {{`}}`}}:latest
                   ghcr.io/${{`{{`{{`}}`}} github.repository {{`}}`}}:${{`{{`{{`}}`}} github.sha {{`}}`}}
                 cache-from: type=gha
                 cache-to: type=gha,mode=max
       \\\`\\\`\\\`
    
       - Commit and push the CI configuration
       - Push any code fixes you made locally
       - Use 'gh workflow run' to trigger the build if needed
       - Use 'gh run list' and 'gh run view' to monitor status
       - **WATCH FOR STUCK JOBS**: If jobs show "Waiting" > 2 min:
         * Check runner availability and labels
         * Verify workflow syntax is correct
         * Fix any workflow configuration issues
       - KEEP ITERATING: Fix issues, push, check CI, repeat until ALL JOBS RUN AND PASS
    5. **Verify CI Success (THE ONLY MEASURE OF SUCCESS)**:
       - **If repository has workflows**: Use 'gh pr checks {{`{{`{{`}}`}}pr_number{{`}}`}}' to confirm ALL checks are passing
       - **If no workflows**: Skip CI validation and proceed to code quality checks
       - **CRITICAL: Check for stuck/pending jobs** (only if workflows exist):
         * Look for jobs showing "Waiting" or "Pending" for > 2 minutes
         * Check 'gh run list --branch=$(gh pr view {{`{{`{{`}}`}}pr_number{{`}}`}} --json headRefName -q .headRefName)' for workflow status
         * If jobs aren't starting, investigate:
           - Missing runner labels? Check 'runs-on:' in workflow
           - Workflow syntax errors? Validate with 'actionlint' or GitHub UI
           - Missing workflow triggers? Check 'on:' section
           - Concurrency limits? Check workflow 'concurrency:' settings
       - **Common fixes for stuck jobs** (only if workflows exist):
         * Add/fix 'runs-on: ubuntu-latest' (or appropriate runner)
         * Remove invalid actions or fix version tags
         * Ensure workflow file is in .github/workflows/
         * Check if workflow needs to be enabled in Actions settings
       - Specifically verify 'cargo clippy -- -D warnings -W clippy::pedantic' passes in CI (when workflows exist)
       - SUCCESS = Code quality checks pass + CI passes (if workflows exist) OR code quality checks pass (if no workflows)
       - Do NOT proceed until quality standards are met
    6. **Review against task requirements**: Verify implementation matches acceptance criteria
    7. **Report results**: Provide detailed summary of checks performed, CI setup, and any fixes applied
    8. **Success criteria**: Quality checks must pass for approval. CI/CD validation required only when workflows exist.
    
    ## Quality Standards (MUST PASS IN GITHUB ACTIONS WHEN WORKFLOWS EXIST, OTHERWISE LOCALLY!)
    - **Zero tolerance** for clippy warnings at pedantic level (in CI if workflows exist, locally otherwise)
    - **Perfect formatting** required (cargo fmt --check must pass in CI if workflows exist, locally otherwise)
    - **All tests pass** (cargo test must succeed in CI if workflows exist, locally otherwise)
    - **Clean YAML** syntax and structure
    - **CI/CD Pipeline** SHOULD be working with successful Docker image build (when workflows exist)
    - **GitHub Actions** SHOULD show green checks for ALL quality gates (when workflows exist)
    - **Task compliance** (implementation should meet acceptance criteria)
    
    ## CRITICAL REMINDER
    Your success is measured by:
    - **If workflows exist**: GitHub Actions CI status, NOT local checks
      - You MUST push your changes to see them tested in CI
      - You MUST iterate: fix locally → push → check CI → repeat until green
      - Clippy pedantic MUST pass in GitHub Actions before you can add 'ready-for-qa' label
      - **ALL CI JOBS MUST ACTUALLY RUN** - stuck/pending jobs = FAILURE
    - **If no workflows**: Local quality checks and task compliance
      - Run quality checks locally: cargo clippy, cargo fmt, cargo test
      - Ensure code meets quality standards before approval
    
    ## TROUBLESHOOTING STUCK CI JOBS
    If CI jobs won't start (showing \"Waiting\" or \"Pending\" indefinitely):
    1. **Check runner labels**: Ensure 'runs-on:' uses valid runners
       - Common: ubuntu-latest, ubuntu-22.04, ubuntu-20.04
       - Self-hosted: [self-hosted], [k8s-runner]
    2. **Validate workflow syntax**: Run locally or check GitHub UI for errors
    3. **Check workflow triggers**: Ensure 'on:' section includes your event
    4. **Fix common issues**:
       - Missing or misspelled action names
       - Invalid YAML syntax (use yamllint)
       - Workflow file not in .github/workflows/
       - Workflow disabled in repo settings
    - The PR checks page on GitHub is your source of truth
    
    Begin your code quality review now."
    
    # Debug: Print the actual prompt and CLAUDE.md content
    echo "════════════════════════════════════════════════════════════════"
    echo "🔍 DEBUG: CLEO PROMPT CONTENT"
    echo "════════════════════════════════════════════════════════════════"
    echo "$CLEO_PROMPT"
    echo "════════════════════════════════════════════════════════════════"
    
    echo "════════════════════════════════════════════════════════════════"
    echo "🔍 DEBUG: CLAUDE.md MEMORY CONTENT"
    echo "════════════════════════════════════════════════════════════════"
    if [ -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
        cat "$CLAUDE_WORK_DIR/CLAUDE.md"
    else
        echo "❌ No CLAUDE.md found at $CLAUDE_WORK_DIR/CLAUDE.md"
    fi
    echo "════════════════════════════════════════════════════════════════"
    
    # Send the static prompt to Claude
    FIFO_PATH="/workspace/agent-input.jsonl"
    rm -f "$FIFO_PATH" 2>/dev/null || true
    mkfifo "$FIFO_PATH"
    chmod 666 "$FIFO_PATH" || true
    
    # Start Claude (reader) first in background
    $CLAUDE_CMD < "$FIFO_PATH" &
    CLAUDE_PID=$!
    
    # Start background token refresh for long-running jobs
    (
        while kill -0 $CLAUDE_PID 2>/dev/null; do
            sleep 2700  # Check every 45 minutes
    
            if [ -n "$TOKEN_GENERATED_AT" ] && [ -n "$GITHUB_APP_PRIVATE_KEY" ]; then
                NOW=$(date +%s)
                TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))
    
                if [ $TOKEN_AGE -gt 2700 ]; then
                    echo "[Background] Token is $(($TOKEN_AGE / 60)) minutes old, refreshing..."
                    refresh_github_token
                fi
            fi
        done
    ) &
    TOKEN_REFRESH_PID=$!
    echo "✓ Started background token refresh (PID: $TOKEN_REFRESH_PID)"
    
    # Compose initial user turn with the static prompt
    USER_COMBINED=$(printf "%s" "$CLEO_PROMPT" | jq -Rs .)
    
    # Send via sidecar HTTP endpoint
    if printf '{"text":%s}\n' "$USER_COMBINED" | \
         curl -fsS -X POST http://127.0.0.1:8080/input \
           -H 'Content-Type: application/json' \
           --data-binary @- >/dev/null 2>&1; then
      echo "✓ Static Cleo prompt sent via sidecar /input"
    else
      echo "⚠️ Sidecar /input failed, falling back to direct FIFO write"
      exec 9>"$FIFO_PATH"
      printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]{{`}}`}}\n' "$USER_COMBINED" >&9
      exec 9>&- 2>/dev/null || true  # Close immediately
    fi
    
    # Wait for Claude process to complete
    wait "$CLAUDE_PID"
    CLAUDE_EXIT_CODE=$?
    
    # Stop token refresh background process
    if [ -n "$TOKEN_REFRESH_PID" ]; then
        kill $TOKEN_REFRESH_PID 2>/dev/null || true
        echo "✓ Stopped token refresh process"
    fi
    
    # Always attempt to complete quality review - don't exit on Claude failures
    echo "🔄 Processing quality review results..."
    if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
      echo "✅ Claude quality review completed successfully"
    fi
    
    # Always attempt to post PR comment and add label regardless of Claude exit status
    # Determine OWNER/REPO slug for gh -R
    REPO_INPUT="{{`{{`{{`}}`}}repository_url{{`}}`}}"
    if echo "$REPO_INPUT" | grep -q "^https://github.com/"; then
      REPO_SLUG=$(echo "$REPO_INPUT" | sed -E 's|https://github.com/([^/]+/[^/.]+)(\.git)?$|\1|')
    else
      REPO_SLUG="$REPO_INPUT"
    fi
    
    # Post quality review comment to PR
    if [ -n "$PR_NUMBER" ] || [ -n "$PR_URL" ]; then
      echo "💬 Posting quality review comment to PR..."
    
      # Create comment body based on Claude exit status
      if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
        COMMENT_BODY="## 🔍 Code Quality Review by Cleo
    
    ✅ **Quality checks completed successfully**
    
    ### Review Summary
    - Code has been reviewed for quality standards
    - All required checks have passed
    - Ready for QA testing
    
    ---
    *Reviewed by Cleo - 5DLabs Code Quality Agent*"
      else
        COMMENT_BODY="## 🔍 Code Quality Review by Cleo
    
    ⚠️ **Quality review encountered issues**
    
    ### Current Status
    - Quality checks are being processed
    - Some issues may need to be resolved
    - Review will continue until standards are met
    
    ### Next Steps
    - Monitor CI/CD pipeline status
    - Address any failing quality checks
    - Iterate until all standards are met
    
    ---
    *Reviewed by Cleo - 5DLabs Code Quality Agent*"
      fi
    
      # Post comment using PR number or URL
      if [ -n "$PR_NUMBER" ]; then
        if echo "$COMMENT_BODY" | gh pr comment "$PR_NUMBER" -R "$REPO_SLUG" --body-file - 2>/dev/null; then
          echo "✅ Successfully posted quality review comment"
        else
          echo "⚠️ Failed to post comment using PR number"
        fi
      elif [ -n "$PR_URL" ]; then
        if echo "$COMMENT_BODY" | gh pr comment "$PR_URL" --body-file - 2>/dev/null; then
          echo "✅ Successfully posted quality review comment"
        else
          echo "⚠️ Failed to post comment"
        fi
      fi
    fi
    
    # Always attempt to add the ready-for-qa label
    if [ -n "$PR_NUMBER" ]; then
      echo "🏷️ Adding 'ready-for-qa' label to PR #$PR_NUMBER..."
      echo "🔍 DEBUG: PR_NUMBER='$PR_NUMBER', REPO_SLUG='$REPO_SLUG'"
    
      # Capture error output for debugging
      LABEL_ERROR=$(gh pr edit "$PR_NUMBER" -R "$REPO_SLUG" --add-label "ready-for-qa" 2>&1)
      LABEL_EXIT=$?
    
      if [ $LABEL_EXIT -eq 0 ]; then
        echo "✅ Successfully added 'ready-for-qa' label"
      else
        echo "⚠️ Failed to add label using PR number (exit code: $LABEL_EXIT)"
        echo "🔍 DEBUG: Error: $LABEL_ERROR"
    
        # Check if the label exists
        echo "🔍 DEBUG: Checking if 'ready-for-qa' label exists..."
        if gh label list -R "$REPO_SLUG" --search "ready-for-qa" | grep -q "ready-for-qa"; then
          echo "   ✓ Label 'ready-for-qa' exists in repository"
        else
          echo "   ✗ Label 'ready-for-qa' does not exist - attempting to create it..."
          CREATE_ERROR=$(gh label create "ready-for-qa" -R "$REPO_SLUG" --color "0e8a16" --description "Ready for QA testing" 2>&1)
          CREATE_EXIT=$?
          if [ $CREATE_EXIT -eq 0 ]; then
            echo "   ✅ Created 'ready-for-qa' label"
            # Retry adding the label
            RETRY_ERROR=$(gh pr edit "$PR_NUMBER" -R "$REPO_SLUG" --add-label "ready-for-qa" 2>&1)
            RETRY_EXIT=$?
            if [ $RETRY_EXIT -eq 0 ]; then
              echo "   ✅ Successfully added label after creating it"
            else
              echo "   ❌ Still failed to add label: $RETRY_ERROR"
            fi
          else
            echo "   ❌ Failed to create label: $CREATE_ERROR"
          fi
        fi
    
        # Try with PR URL as fallback
        if [ -n "$PR_URL" ] && [ $LABEL_EXIT -ne 0 ]; then
          echo "⚠️ Attempting with PR URL as fallback..."
          URL_ERROR=$(gh pr edit "$PR_URL" --add-label "ready-for-qa" 2>&1)
          URL_EXIT=$?
          if [ $URL_EXIT -eq 0 ]; then
            echo "✅ Successfully added 'ready-for-qa' label using PR URL"
          else
            echo "❌ Failed to add 'ready-for-qa' label using PR URL: $URL_ERROR"
          fi
        fi
      fi
    elif [ -n "$PR_URL" ]; then
      echo "🏷️ Adding 'ready-for-qa' label using PR URL..."
      URL_ERROR=$(gh pr edit "$PR_URL" --add-label "ready-for-qa" 2>&1)
      URL_EXIT=$?
      if [ $URL_EXIT -eq 0 ]; then
        echo "✅ Successfully added 'ready-for-qa' label"
      else
        echo "❌ Failed to add 'ready-for-qa' label: $URL_ERROR"
      fi
    else
      echo "⚠️ No PR_NUMBER or PR_URL available, cannot add label"
    fi
    
    # Gracefully stop sidecar (with enhanced debugging and retries)
    echo "🔧 Attempting sidecar shutdown..."
    shutdown_attempts=0
    max_shutdown_attempts=3
    
    while [ $shutdown_attempts -lt $max_shutdown_attempts ]; do
      if curl -fsS -X POST http://127.0.0.1:8080/shutdown -m 5 2>/dev/null; then
        echo "✓ Sidecar shutdown request successful (attempt $((shutdown_attempts + 1)))"
        break
      else
        shutdown_attempts=$((shutdown_attempts + 1))
        echo "⚠️ Sidecar shutdown request failed (attempt $shutdown_attempts/$max_shutdown_attempts)"
        if [ $shutdown_attempts -lt $max_shutdown_attempts ]; then
          echo "Retrying in 2 seconds..."
          sleep 2
        fi
      fi
    done
    
    if [ $shutdown_attempts -eq $max_shutdown_attempts ]; then
      echo "❌ Failed to shutdown sidecar after $max_shutdown_attempts attempts"
      echo "🔧 Force terminating sidecar processes..."
      pkill -f "sidecar" || echo "No sidecar processes found to kill"
    fi
    
    # Wait for sidecar to actually terminate
    echo "⏳ Waiting for sidecar termination..."
    timeout=10
    while [ $timeout -gt 0 ]; do
      if ! pgrep -f "sidecar" > /dev/null 2>&1; then
        echo "✅ Sidecar terminated successfully"
        break
      fi
      sleep 1
      timeout=$((timeout - 1))
    done
    
    if [ $timeout -eq 0 ]; then
      echo "⚠️ Sidecar still running after wait period"
    fi
    
    # Cleanup and exit
    echo "════════════════════════════════════════════════════════════════"
    echo "║                  CLEO CODE QUALITY COMPLETE                  ║"
    echo "════════════════════════════════════════════════════════════════"
    echo "📋 Task: {{`{{`{{`}}`}}task_id{{`}}`}}"
    echo "✅ Code quality checks completed"
    echo "════════════════════════════════════════════════════════════════"
    
    # Final termination sequence
    echo "════════════════════════════════════════════════════════════════"
    echo "🔚 TERMINATING CLEO CONTAINER"
    echo "════════════════════════════════════════════════════════════════"
    echo "Claude Exit Code: $CLAUDE_EXIT_CODE"
    echo "Container PID: $$"
    echo "Final Process Check:"
    ps aux | head -5
    
    # Write completion marker for workflow tracking
    echo "cleo-quality-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.cleo-complete
    
    # Cleanup FIFO
    rm -f "$FIFO_PATH" 2>/dev/null || true
    
    # Always exit successfully to keep workflow running
    echo "🔚 Force terminating container..."
    echo "📝 Note: Container always exits with code 0 to allow workflow continuation"
  code_container-rex-remediation.sh.hbs: |
    #!/bin/sh
    
    # Ensure Rust environment is always properly set up
    echo "🔧 Setting up Rust environment..."
    
    # Source Rust environment if available (fixes cargo not found issues)
    if [ -f "$HOME/.cargo/env" ]; then
        . "$HOME/.cargo/env"
        echo "✓ Sourced Rust environment from $HOME/.cargo/env"
    fi
    
    # Also try root cargo env as fallback
    if [ -f "/root/.cargo/env" ]; then
        . "/root/.cargo/env"
        echo "✓ Sourced Rust environment from /root/.cargo/env"
    fi
    
    # Ensure rustup has a default toolchain set
    if command -v rustup >/dev/null 2>&1; then
        rustup default stable 2>/dev/null || true
        echo "✓ Ensured stable Rust toolchain is default"
    else
        echo "⚠️ rustup not found in PATH"
    fi
    
    # Verify Rust is available
    if command -v cargo >/dev/null 2>&1; then
        echo "✓ Cargo is available: $(cargo --version)"
    else
        echo "❌ Cargo not found in PATH"
        echo "Current PATH: $PATH"
        echo "Attempting to find cargo..."
        find /usr -name cargo 2>/dev/null | head -5 || echo "No cargo found in /usr"
        find /home -name cargo 2>/dev/null | head -5 || echo "No cargo found in /home"
    fi
    
    echo '════════════════════════════════════════════════════════════════'
    echo '║               🔧 REX REMEDIATION WORKFLOW STARTING             ║'
    echo '║                  Remediation Agent Active                      ║'
    echo '║            ⚠️  FIXING FEEDBACK - NO NEW IMPLEMENTATION ⚠️         ║'
    echo '════════════════════════════════════════════════════════════════'
    echo "🎯 Agent: {{`{{`{{`}}`}}github_app{{`}}`}}"
    echo "🔧 Mode: Remediation - Fix Only"
    echo "📋 Task ID: {{`{{`{{`}}`}}task_id{{`}}`}}"
    echo "🚨 CRITICAL: ONLY fix the issues identified in feedback"
    
    # Disable interactive Git prompts globally
    export GIT_TERMINAL_PROMPT=0
    export GIT_ASKPASS=/bin/true
    export SSH_ASKPASS=/bin/true
    
    # Repository URL
    REPO_URL="{{`{{`{{`}}`}}repository_url{{`}}`}}"
    
    # GitHub App authentication is configured via environment variables
    echo "Using GitHub App authentication"
    
    # Authenticate with GitHub App
    if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
        echo "Authenticating with GitHub App..."
    
        # Create temporary private key file (support escaped newlines)
        TEMP_KEY_FILE="/tmp/github-app-key.pem"
        printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
        chmod 600 "$TEMP_KEY_FILE"
    
        # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
        # JWT header
        JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
        # JWT payload with current time and expiration (10 minutes)
        NOW=$(date +%s)
        EXP=$((NOW + 600))
        JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
        # Sign the JWT
        JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
        JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
        # Get installation ID for the repository (robust parsing of owner/repo)
        INPUT_REPO="{{`{{`{{`}}`}}repository_url{{`}}`}}"
        REPO_OWNER=""
        REPO_NAME=""
    
        if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
            REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
            REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
        elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
            # SSH format git@github.com:owner/repo(.git)
            REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
            REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
        else
            # Fallback: assume slug owner/repo (possibly with .git)
            SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
            REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
            REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
        fi
    
        echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"
    
        echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
        # Get the installation ID (retry and follow redirects). Fallback to org installation.
        INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")
    
        INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')
    
        if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
            echo "⚠️ Repo installation not found, trying org installation..."
            ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
                --connect-timeout 5 --max-time 12 \
                -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/orgs/$REPO_OWNER/installation")
            INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
        fi
    
        if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
            echo "❌ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
            echo "Response (repo): $INSTALLATION_RESPONSE"
            echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
            rm -f "$TEMP_KEY_FILE"
            exit 1
        fi
    
        echo "Installation ID: $INSTALLATION_ID"
    
        # Get installation access token
        TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
        GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
        if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
            echo "❌ Failed to get installation access token"
            echo "Response: $TOKEN_RESPONSE"
            rm -f "$TEMP_KEY_FILE"
            exit 1
        fi
    
        # Clean up temporary key file
        rm -f "$TEMP_KEY_FILE"
    
        # Export the token for git to use
        export GITHUB_TOKEN
    
        # Configure git to use the token (use --replace-all to handle multiple existing helpers)
        git config --global --replace-all credential.helper store
        echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    
        # Also authenticate gh CLI with the token
        echo "$GITHUB_TOKEN" | gh auth login --with-token
    
        echo "✓ GitHub App authenticated successfully"
    
    else
        echo "❌ GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
        exit 1
    fi
    
    # Git configuration with proper GitHub App attribution
    git config --global --add safe.directory /workspace
    
    # Set GitHub App attribution - use generic format for all agents
    GITHUB_APP="{{`{{`{{`}}`}}github_app{{`}}`}}"
    # Generic attribution that works for any agent
    GIT_AUTHOR_NAME="${GITHUB_APP} Agent (Claude Code)"
    GIT_AUTHOR_EMAIL="${GITHUB_APP}[bot]@users.noreply.github.com"
    
    # Configure git with proper GitHub App attribution
    git config --global user.name "$GIT_AUTHOR_NAME"
    git config --global user.email "$GIT_AUTHOR_EMAIL"
    
    # Set environment variables for Claude Code to use
    export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
    export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
    export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
    export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
    echo "✓ Git configured"
    
    # =============================================================================
    # REMEDIATION MODE VALIDATION
    # =============================================================================
    
    # Validate remediation environment variables
    echo ""
    echo "🔧 REMEDIATION MODE VALIDATION"
    
    if [ -z "${FEEDBACK_COMMENT_ID:-}" ]; then
        echo "❌ ERROR: FEEDBACK_COMMENT_ID is required in remediation mode"
        exit 1
    fi
    
    if [ -z "${ITERATION_COUNT:-}" ]; then
        echo "❌ ERROR: ITERATION_COUNT is required in remediation mode"
        exit 1
    fi
    
    echo "🔧 Remediation Mode Configuration:"
    echo "   Task ID: ${TASK_ID:-"Not specified"}"
    echo "   PR Number: ${PR_NUMBER:-"Not specified"}"
    echo "   Feedback Comment ID: ${FEEDBACK_COMMENT_ID}"
    echo "   Iteration: ${ITERATION_COUNT}"
    echo "   Feedback Author: ${FEEDBACK_AUTHOR:-"Unknown"}"
    
    # Check iteration limits
    MAX_ITERATIONS=10
    if [ "${ITERATION_COUNT}" -gt "${MAX_ITERATIONS}" ]; then
        echo "❌ ERROR: Maximum iterations (${MAX_ITERATIONS}) exceeded (current: ${ITERATION_COUNT})"
        echo "🚨 Triggering escalation..."
    
        # Post escalation comment
        ESCALATION_BODY=$(cat <<EOF
    ## 🚨 Remediation Escalation Required
    
    **Iteration Limit Reached**: ${ITERATION_COUNT}/10
    
    The automated remediation process has reached its maximum iteration limit and requires human intervention.
    
    ### Next Steps:
    1. **Review the feedback history** in this PR for all attempted fixes
    2. **Manually address** the remaining issues identified in the feedback
    3. **Consider** if the original requirements need clarification or adjustment
    4. **Merge or close** this PR based on the remediation outcome
    
    ### Context:
    - **Task ID**: ${TASK_ID:-"Unknown"}
    - **PR**: #${PR_NUMBER:-"Unknown"}
    - **Last Attempt**: Iteration ${ITERATION_COUNT}
    - **Feedback Source**: Comment ID ${FEEDBACK_COMMENT_ID}
    
    @platform-team @cto - Manual intervention required for this remediation.
    
    ---
    *Posted by Rex Remediation Agent*
    EOF
        )
    
        if [ -n "${PR_NUMBER:-}" ] && [ -n "${GITHUB_TOKEN:-}" ]; then
            if gh pr comment "${PR_NUMBER}" --body "${ESCALATION_BODY}" 2>/dev/null; then
                echo "✅ Escalation comment posted successfully"
            else
                echo "⚠️ Failed to post escalation comment"
            fi
        fi
    
        exit 1
    fi
    
    if [ "${ITERATION_COUNT}" -eq "${MAX_ITERATIONS}" ]; then
        echo "⚠️ WARNING: Final iteration (${ITERATION_COUNT}/${MAX_ITERATIONS}) - this is the last attempt"
    fi
    
    echo "✅ Iteration check passed: ${ITERATION_COUNT}/${MAX_ITERATIONS}"
    
    # Fetch feedback comment
    echo ""
    echo "📥 Fetching feedback comment ${FEEDBACK_COMMENT_ID}..."
    MAX_RETRIES=3
    RETRY_COUNT=0
    FEEDBACK_COMMENT=""
    
    while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
        if FEEDBACK_COMMENT=$(gh api "/repos/{{`{{`{{`}}`}}repository_url{{`}}`}}/issues/comments/${FEEDBACK_COMMENT_ID}" --jq '.body' 2>/dev/null); then
            echo "✅ Feedback comment fetched successfully (${#FEEDBACK_COMMENT} characters)"
            break
        else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "⚠️ Failed to fetch comment (attempt ${RETRY_COUNT}/${MAX_RETRIES})"
    
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                sleep $((2 ** RETRY_COUNT))  # Exponential backoff
            fi
        fi
    done
    
    if [ -z "${FEEDBACK_COMMENT}" ]; then
        echo "❌ Failed to fetch feedback comment after ${MAX_RETRIES} attempts"
        echo "Cannot proceed with remediation without feedback context"
        exit 1
    fi
    
    # Parse feedback metadata
    echo ""
    echo "🔍 Parsing feedback metadata..."
    SEVERITY="medium"
    ISSUE_TYPES=""
    
    if echo "${FEEDBACK_COMMENT}" | grep -q "🔴"; then
        SEVERITY="critical"
    elif echo "${FEEDBACK_COMMENT}" | grep -q "🟡"; then
        SEVERITY="high"
    elif echo "${FEEDBACK_COMMENT}" | grep -q "🟢"; then
        SEVERITY="low"
    fi
    
    if echo "${FEEDBACK_COMMENT}" | grep -qi "security\|vulnerability\|exploit"; then
        ISSUE_TYPES="${ISSUE_TYPES}security,"
    fi
    if echo "${FEEDBACK_COMMENT}" | grep -qi "performance\|slow\|optimization"; then
        ISSUE_TYPES="${ISSUE_TYPES}performance,"
    fi
    if echo "${FEEDBACK_COMMENT}" | grep -qi "bug\|error\|exception\|crash"; then
        ISSUE_TYPES="${ISSUE_TYPES}bug,"
    fi
    if echo "${FEEDBACK_COMMENT}" | grep -qi "test\|testing\|coverage"; then
        ISSUE_TYPES="${ISSUE_TYPES}testing,"
    fi
    if echo "${FEEDBACK_COMMENT}" | grep -qi "documentation\|docs\|readme"; then
        ISSUE_TYPES="${ISSUE_TYPES}documentation,"
    fi
    
    ISSUE_TYPES="${ISSUE_TYPES%,}"
    if [ -z "${ISSUE_TYPES}" ]; then
        ISSUE_TYPES="general"
    fi
    
    echo "📊 Detected severity: ${SEVERITY}"
    echo "🏷️ Detected issue types: ${ISSUE_TYPES}"
    
    # Fetch original task context for reference (not as main prompt)
    echo ""
    echo "📋 Fetching original task context..."
    TASK_CONTENT=""
    
    TASK_FILE="/tmp/docs-repo/{{`{{`{{`}}`}}docs_project_directory{{`}}`}}/.taskmaster/docs/task-${TASK_ID}/task.md"
    if [ -f "${TASK_FILE}" ]; then
        TASK_CONTENT=$(cat "${TASK_FILE}")
        echo "✅ Found task file: ${TASK_FILE}"
    else
        echo "⚠️ Task file not found, using default context"
        TASK_CONTENT="Task ${TASK_ID}: Implement the required functionality with proper error handling and testing."
    fi
    
    # Create remediation-specific CLAUDE.md
    echo ""
    echo "📝 Preparing remediation context for Claude..."
    
    cat > /workspace/CLAUDE.md << EOF
    # 🔧 REMEDIATION MODE - Fix Required Issues
    
    **Iteration ${ITERATION_COUNT}/10** | **Severity: ${SEVERITY^^}** | **Task: ${TASK_ID}**
    
    You are operating in **REX REMEDIATION MODE**. Your mission is to fix specific issues identified in QA feedback while preserving all working functionality. This is NOT a reimplementation - focus on surgical, targeted fixes.
    
    ---
    
    ## 🎯 ORIGINAL TASK REQUIREMENTS (Reference Only)
    
    ${TASK_CONTENT}
    
    ---
    
    ## 🚨 ISSUES TO FIX (Priority: ${SEVERITY^^})
    
    **Issue Categories:** ${ISSUE_TYPES}
    
    ${FEEDBACK_COMMENT}
    
    ---
    
    ## 📋 REMEDIATION INSTRUCTIONS
    
    ### Your Mission:
    1. **PRESERVE** all working functionality - do NOT break anything that currently works
    2. **FIX** only the specific issues mentioned in the feedback above
    3. **FOCUS** on surgical changes, not broad reimplementation
    4. **VERIFY** each fix addresses the exact problem described
    5. **TEST** that your changes solve the issues without introducing new problems
    
    ### Key Principles:
    - **Targeted Fixes**: Address specific problems, not general improvements
    - **Minimal Changes**: Make the smallest possible changes to fix issues
    - **Preserve Architecture**: Keep existing patterns and structures intact
    - **Risk Management**: Avoid changes that could break other features
    
    ### What to Avoid:
    - ❌ Reimplementing working features
    - ❌ Major refactoring unless specifically requested
    - ❌ Adding new features or capabilities
    - ❌ Changing established patterns or conventions
    
    ---
    
    ## 🔍 FEEDBACK ANALYSIS
    
    **PR Number:** ${PR_NUMBER:-"Unknown"}
    **Comment ID:** ${FEEDBACK_COMMENT_ID}
    **Author:** ${FEEDBACK_AUTHOR:-"Unknown"}
    **Iteration:** ${ITERATION_COUNT} of 10
    
    **Metadata:**
    - Severity: ${SEVERITY}
    - Categories: ${ISSUE_TYPES}
    - Source: GitHub PR Comment
    
    ---
    
    ## ✅ SUCCESS CRITERIA
    
    Your remediation is successful when:
    1. All issues mentioned in the feedback are resolved
    2. No existing functionality is broken
    3. Changes are minimal and targeted
    4. Code quality is maintained
    5. Tests (if present) continue to pass
    
    ---
    
    ## 🚨 ESCALATION WARNING
    
    If you cannot fix these issues within this iteration:
    - Be explicit about what cannot be fixed and why
    - Document any blockers or limitations encountered
    - Suggest alternative approaches for human review
    - This is iteration ${ITERATION_COUNT}/10 - use it wisely
    
    ---
    
    *Generated by Rex Remediation Agent v1.0.0*
    EOF
    
    echo "✅ Remediation context prepared at /workspace/CLAUDE.md"
    
    # =============================================================================
    # AUTHENTICATION VERIFICATION
    # =============================================================================
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "🔐 AUTHENTICATION VERIFICATION"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""
    
    # Repository URLs - Handle both full URLs and org/repo format
    # Check if repository_url already contains https://github.com/
    if echo "{{`{{`{{`}}`}}repository_url{{`}}`}}" | grep -q "^https://github.com/"; then
        REPO_HTTP_URL="{{`{{`{{`}}`}}repository_url{{`}}`}}"
        if ! echo "{{`{{`{{`}}`}}repository_url{{`}}`}}" | grep -q "\.git$"; then
            REPO_HTTP_URL="${REPO_HTTP_URL}.git"
        fi
    else
        REPO_HTTP_URL="https://github.com/{{`{{`{{`}}`}}repository_url{{`}}`}}.git"
    fi
    
    # Same for docs repository
    if echo "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" | grep -q "^https://github.com/"; then
        DOCS_HTTP_URL="{{`{{`{{`}}`}}docs_repository_url{{`}}`}}"
        if ! echo "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" | grep -q "\.git$"; then
            DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
        fi
    else
        DOCS_HTTP_URL="https://github.com/{{`{{`{{`}}`}}docs_repository_url{{`}}`}}.git"
    fi
    
    # DEBUG: Show what URLs are being constructed
    echo "🔍 DEBUG: URL Construction & Parameters"
    echo "  Input repository_url: '{{`{{`{{`}}`}}repository_url{{`}}`}}'"
    echo "  Input docs_repository_url: '{{`{{`{{`}}`}}docs_repository_url{{`}}`}}'"
    echo "  Input docs_project_directory: '{{`{{`{{`}}`}}docs_project_directory{{`}}`}}'"
    echo "  Input working_directory: '{{`{{`{{`}}`}}working_directory{{`}}`}}'"
    echo "  Input docs_branch: '{{`{{`{{`}}`}}docs_branch{{`}}`}}'"
    echo "  Input github_app: '{{`{{`{{`}}`}}github_app{{`}}`}}'"
    echo "  Input task_id: '{{`{{`{{`}}`}}task_id{{`}}`}}'"
    echo "  Input service: '{{`{{`{{`}}`}}service{{`}}`}}'"
    echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
    echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
    echo "  Current working directory: $(pwd)"
    echo "  Available environment variables:"
    env | grep -E "(GITHUB|ANTHROPIC)" | sort
    
    # Test HTTPS access to repository
    echo "🔍 DEBUG: Testing HTTPS repository access..."
    echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
    if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
      echo "✓ HTTPS repository access successful"
      echo "  Repository: {{`{{`{{`}}`}}repository_url{{`}}`}} ($REPO_HTTP_URL)"
      echo "  Output: $(cat /tmp/repo_test.out | head -1)"
    else
      echo "❌ HTTPS repository access failed"
      echo "  Repository: {{`{{`{{`}}`}}repository_url{{`}}`}} ($REPO_HTTP_URL)"
      echo "  Error output: $(cat /tmp/repo_test.out)"
      echo "  Git credential helper status:"
      git config --list | grep credential || echo "  No credential helpers configured"
      echo ""
      echo "🚫 ABORTING: Cannot access repository via HTTPS"
      exit 1
    fi
    
    # Test docs repository access
    echo "🔍 DEBUG: Testing docs repository access..."
    echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
    if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
      echo "✓ Docs repository access successful"
      echo "  Repository: {{`{{`{{`}}`}}docs_repository_url{{`}}`}} ($DOCS_HTTP_URL)"
      echo "  Output: $(cat /tmp/docs_test.out | head -1)"
    else
      echo "❌ Docs repository access failed"
      echo "  Repository: {{`{{`{{`}}`}}docs_repository_url{{`}}`}} ($DOCS_HTTP_URL)"
      echo "  Error output: $(cat /tmp/docs_test.out)"
      echo ""
      echo "🚫 ABORTING: Cannot access docs repository via HTTPS"
      exit 1
    fi
    
    # Dual Repository Setup - Platform repo for docs, Target repo for implementation
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "║                 DUAL REPOSITORY SETUP                        ║"
    echo "═══════════════════════════════════════════════════════════════"
    
    # Repository Information
    DOCS_BRANCH="{{`{{`{{`}}`}}docs_branch{{`}}`}}"
    GITHUB_APP="{{`{{`{{`}}`}}github_app{{`}}`}}"
    
    # Helper: derive safe workspace directory name from repo input (URL, SSH, or slug)
    sanitize_repo_dir() {
        input="$1"
        if echo "$input" | grep -qE '^https://github.com/'; then
            owner=$(echo "$input" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
            name=$(echo "$input" | sed -E 's|https://github.com/[^/]+/([^/]+)(\\.git)?|\1|')
            printf '%s-%s' "$owner" "$name"
        elif echo "$input" | grep -qE '^git@github.com:'; then
            owner=$(echo "$input" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
            name=$(echo "$input" | sed -E 's|git@github.com:[^/]+/([^/]+)(\\.git)?|\1|')
            printf '%s-%s' "$owner" "$name"
        else
            # Assume owner/repo (optionally with .git)
            slug=$(echo "$input" | sed -E 's|\\.git$||')
            echo "$slug" | tr '/' '-'
        fi
    }
    
    # Derive workspace directory names (owner-repo)
    DOCS_REPO_DIR=$(sanitize_repo_dir "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}")
    TARGET_REPO_DIR=$(sanitize_repo_dir "{{`{{`{{`}}`}}repository_url{{`}}`}}")
    
    echo "=== REPOSITORY SETUP ==="
    echo "Docs repository: {{`{{`{{`}}`}}docs_repository_url{{`}}`}} ($DOCS_HTTP_URL)"
    echo "Target repository: {{`{{`{{`}}`}}repository_url{{`}}`}} ($REPO_HTTP_URL)"
    echo "Docs branch: $DOCS_BRANCH"
    echo "GitHub App: $GITHUB_APP"
    
    # Always use consistent workflow approach
    # Even if docs and target are the same repo, we clone them separately
    # This avoids complex branch switching and file preservation issues
    echo "=== UNIFIED WORKFLOW APPROACH ==="
    echo "  docs_repository_url: '{{`{{`{{`}}`}}docs_repository_url{{`}}`}}'"
    echo "  repository_url: '{{`{{`{{`}}`}}repository_url{{`}}`}}'"
    echo "  └─ TaskMaster files will be copied from docs repo at: {{`{{`{{`}}`}}docs_project_directory{{`}}`}}"
    
    # Repository Setup - Always use consistent approach
    echo "=== REPOSITORY SETUP ==="
    
    # Step 1: Clone or update docs repository temporarily
    if [ -d "/tmp/docs-repo" ]; then
        echo "🔄 DOCS REPOSITORY: UPDATE - temporary directory exists"
        cd /tmp/docs-repo
        git fetch origin
        git checkout "$DOCS_BRANCH"
        git reset --hard "origin/$DOCS_BRANCH"
        cd /workspace
        echo "✓ Docs repository updated"
    else
        echo "📥 DOCS REPOSITORY: CLONING - extracting task files"
        if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
            echo "❌ Failed to clone docs repository: {{`{{`{{`}}`}}docs_repository_url{{`}}`}} ($DOCS_HTTP_URL)"
            exit 1
        fi
        cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd /workspace
        echo "✓ Docs repository cloned to temporary location"
    fi
    
    # Step 2: Clone or update target repository
    if [ -d "$TARGET_REPO_DIR" ]; then
        echo "🔄 TARGET REPOSITORY: UPDATE - directory already exists"
        echo "📁 Found existing target repository '$TARGET_REPO_DIR', updating..."
        cd "$TARGET_REPO_DIR"
        git fetch origin main
        git reset --hard origin/main
        cd /workspace
        echo "✓ Target repository updated successfully"
    else
        echo "📥 TARGET REPOSITORY: CLONING - first time setup"
        if ! git clone "$REPO_HTTP_URL" "$TARGET_REPO_DIR"; then
            echo "❌ Failed to clone target repository: {{`{{`{{`}}`}}repository_url{{`}}`}} ($REPO_HTTP_URL)"
            exit 1
        fi
        echo "✓ Target repository cloned successfully"
    fi
    
    # Step 3: Copy task files from docs repo to target repo
    echo "📋 TASK FILES: COPYING from docs to target repository"
    mkdir -p "/workspace/$TARGET_REPO_DIR/task"
    
    # Determine docs project directory path
    {{`{{`{{`}}`}}#if docs_project_directory{{`}}`}}
    if [ "{{`{{`{{`}}`}}docs_project_directory{{`}}`}}" = "." ]; then
        DOCS_PATH="/tmp/docs-repo/.taskmaster"
    else
        DOCS_PATH="/tmp/docs-repo/{{`{{`{{`}}`}}docs_project_directory{{`}}`}}/.taskmaster"
    fi
    {{`{{`{{`}}`}}else{{`}}`}}
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
    {{`{{`{{`}}`}}/if{{`}}`}}
    
    # Copy specific task files
    TASK_DIR="$DOCS_PATH/docs/task-{{`{{`{{`}}`}}task_id{{`}}`}}"
    echo "🔍 DEBUG: Looking for task files at: $TASK_DIR"
    echo "🔍 DEBUG: Docs path is: $DOCS_PATH"
    echo "🔍 DEBUG: Contents of docs temp directory:"
    ls -la /tmp/docs-repo/.taskmaster/ || echo "No .taskmaster found"
    echo "🔍 DEBUG: Contents of docs directory:"
    ls -la /tmp/docs-repo/.taskmaster/docs/ || echo "No docs directory found"
    
    if [ -d "$TASK_DIR" ]; then
        echo "🔍 DEBUG: Task directory found, contents:"
        ls -la "$TASK_DIR"
    
        echo "✅ Copying task.md..."
        cp "$TASK_DIR/task.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "✓ task.md copied" || echo "❌ task.md copy failed"
    
        echo "✅ Copying acceptance-criteria.md..."
        cp "$TASK_DIR/acceptance-criteria.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "✓ acceptance-criteria.md copied" || echo "❌ acceptance-criteria.md copy failed"
    
        echo "✅ Copying prompt.md..."
        cp "$TASK_DIR/prompt.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "✓ prompt.md copied" || echo "❌ prompt.md copy failed"
    
        echo "✅ Copying client-config.json..."
        if [ -f "$TASK_DIR/client-config.json" ]; then
            cp "$TASK_DIR/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" && echo "✓ client-config.json copied to Claude working directory" || echo "❌ client-config.json copy failed"
        else
            echo "⚠️ client-config.json not found - MCP client may not be configured"
        fi
    
        echo "✅ Copying toolman-guide.md..."
        if [ -f "$TASK_DIR/toolman-guide.md" ]; then
            cp "$TASK_DIR/toolman-guide.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "✓ toolman-guide.md copied" || echo "❌ toolman-guide.md copy failed"
        else
            echo "⚠️ toolman-guide.md not found - code agent won't have tool usage guidance"
        fi
    
        echo "✓ Task {{`{{`{{`}}`}}task_id{{`}}`}} files copied from $TASK_DIR"
    else
        echo "❌ CRITICAL: Task {{`{{`{{`}}`}}task_id{{`}}`}} directory not found at: $TASK_DIR"
        echo "🔍 DEBUG: Available directories in docs:"
        find /tmp/docs-repo -name "task-*" -type d || echo "No task directories found"
    fi
    
    # Copy architecture.md from docs root
    ARCH_FILE="$DOCS_PATH/docs/architecture.md"
    if [ -f "$ARCH_FILE" ]; then
        cp "$ARCH_FILE" "/workspace/$TARGET_REPO_DIR/task/"
        echo "✓ Architecture documentation copied"
    else
        echo "⚠️ architecture.md not found at: $ARCH_FILE"
    fi
    
    # Copy tasks.json if it exists
    if [ -f "$DOCS_PATH/tasks.json" ]; then
        cp "$DOCS_PATH/tasks.json" "/workspace/$TARGET_REPO_DIR/task/"
        echo "✓ tasks.json copied"
    fi
    
    echo "✓ Task files copied to target repository"
    
    # DEBUG: Verify files were copied successfully
    echo "🔍 DEBUG: Contents of target task directory after copy:"
    ls -la "/workspace/$TARGET_REPO_DIR/task/" || echo "Task directory not found"
    echo "🔍 DEBUG: Checking if prompt.md exists:"
    [ -f "/workspace/$TARGET_REPO_DIR/task/prompt.md" ] && echo "✅ prompt.md exists" || echo "❌ prompt.md missing"
    
    # Step 4: Clean up docs repository
    echo "🧹 CLEANUP: Removing temporary docs repository"
    rm -rf /tmp/docs-repo
    echo "✓ Docs repository cleaned up"
    
    # Set working directory to the target repository root
    REPO_NAME="$TARGET_REPO_DIR"
    echo "✓ Working directory: /workspace/$REPO_NAME"
    
    # Set Claude working directory early (needed for client-config.json copy)
    WORK_DIR="{{`{{`{{`}}`}}working_directory{{`}}`}}"
    if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
      CLAUDE_WORK_DIR="/workspace/$REPO_NAME"
    else
      CLAUDE_WORK_DIR="/workspace/$REPO_NAME/$WORK_DIR"
    fi
    mkdir -p "$CLAUDE_WORK_DIR"
    echo "✓ Set Claude working directory: $CLAUDE_WORK_DIR"
    
    # Setup feature branch for implementation
    echo "=== BRANCH SETUP ==="
    cd "/workspace/$REPO_NAME"
    
    # Sync with latest main to prevent conflicts
    echo "🔄 Syncing with latest main to prevent conflicts..."
    git fetch origin main 2>/dev/null || git fetch origin master 2>/dev/null || echo "⚠️ Could not fetch main/master branch"
    
    # Create or checkout feature branch (with conflict-safe fallback)
    FEATURE_BRANCH="feature/task-{{`{{`{{`}}`}}task_id{{`}}`}}-implementation"
    BRANCH_EXISTS="false"
    
    if git show-ref --verify --quiet refs/heads/$FEATURE_BRANCH; then
        BRANCH_EXISTS="true"
        echo "Feature branch '$FEATURE_BRANCH' exists, checking out..."
        git checkout $FEATURE_BRANCH
    
        echo "📥 Merging latest main into $FEATURE_BRANCH..."
        if git merge origin/main --no-edit; then
            echo "✓ Successfully merged latest main into feature branch"
        else
            echo "⚠️ MERGE CONFLICT: Cannot auto-merge main into $FEATURE_BRANCH"
            echo "🔄 Auto-aborting merge and creating a fresh branch from origin/main"
            # Abort merge if in progress
            git merge --abort 2>/dev/null || true
            # Create a unique fresh branch to avoid reuse conflicts
            NEW_BRANCH="${FEATURE_BRANCH}-$(date -u +%Y%m%d%H%M%S)"
            git checkout -B "$NEW_BRANCH" origin/main
            FEATURE_BRANCH="$NEW_BRANCH"
            echo "✓ Switched to fresh branch: $FEATURE_BRANCH"
        fi
    else
        # Create new feature branch from latest main
        echo "Creating new feature branch '$FEATURE_BRANCH' from latest main..."
        git checkout -b $FEATURE_BRANCH origin/main
        echo "✓ Created feature branch: $FEATURE_BRANCH"
    fi
    
    # 5. Change to Claude Working Directory (already set up earlier)
    cd "$CLAUDE_WORK_DIR"
    echo "✓ Changed to Claude working directory: $CLAUDE_WORK_DIR"
    echo "🔑 CRITICAL: Claude will be launched from this directory"
    
    # Working directory setup completed above
    
    # Configure git user after successful clone
    echo "=== POST-CLONE GIT CONFIGURATION ==="
    # Fix dubious ownership issues
    git config --global --add safe.directory "/workspace/$REPO_NAME"
    echo "✓ Added repository to safe directories"
    
    # Set git config locally in the working repository (persistent on PVC)
    if [ -d "/workspace/$REPO_NAME/.git" ]; then
        cd "/workspace/$REPO_NAME"
        git config --local user.name "$GIT_AUTHOR_NAME"
        git config --local user.email "$GIT_AUTHOR_EMAIL"
        # Set up automatic upstream for new branches
        git config --local push.autoSetupRemote true
        echo "✓ Configured git user in target repository: $GIT_AUTHOR_NAME"
        echo "✓ Enabled automatic upstream setup for new branches"
    fi
    
    cd /workspace
    
    # Copy ConfigMap files to working directory (AFTER repository clone)
    echo "=== CONFIGMAP FILE SETUP ==="
    
    # Claude working directory already set above during repository setup
    
    echo "Setting up files in Claude working directory: $CLAUDE_WORK_DIR"
    cd "$CLAUDE_WORK_DIR"
    
    # Copy all files from ConfigMap to working directory
    if [ -d "/task-files" ]; then
      echo "Copying ConfigMap files to working directory..."
    
      # CLAUDE.md Memory Persistence Logic (controlled by overwriteMemory CRD field)
            OVERWRITE_MEMORY="{{`{{`{{`}}`}}overwrite_memory{{`}}`}}"
    
      # Handle CLAUDE.md based on overwriteMemory setting
            if [ "$OVERWRITE_MEMORY" = "true" ]; then
              # Overwrite mode: Always replace CLAUDE.md with fresh template
        cp "/task-files/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
        cp "/task-files/CLAUDE.md" "/workspace/CLAUDE.md"
              echo "✓ Overwrote CLAUDE.md memory file (fresh start requested)"
              echo "✓ Copied CLAUDE.md to workspace root for easy access"
            else
              # Preserve mode (default): Only copy if doesn't exist
              if [ ! -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
          # Initial creation - copy from ConfigMap
          cp "/task-files/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
          cp "/task-files/CLAUDE.md" "/workspace/CLAUDE.md"
                echo "✓ Created initial CLAUDE.md memory file"
                echo "✓ Copied CLAUDE.md to workspace root for easy access"
              else
                echo "✓ Preserved existing CLAUDE.md memory file (maintaining accumulated context)"
                # Still copy to workspace root for consistency
                cp "$CLAUDE_WORK_DIR/CLAUDE.md" "/workspace/CLAUDE.md"
                echo "✓ Synced CLAUDE.md to workspace root"
              fi
            fi
    
      # Copy all other markdown files (excluding CLAUDE.md)
      for md_file in /task-files/*.md; do
        if [ -f "$md_file" ]; then
          basename_file=$(basename "$md_file")
          # Skip CLAUDE.md since we handled it above
          if [ "$basename_file" != "CLAUDE.md" ]; then
            cp "$md_file" "$CLAUDE_WORK_DIR/"
            echo "✓ Updated $basename_file"
          fi
        fi
      done
    
      # Verify enterprise settings (mounted directly from ConfigMap)
      if [ -f "/etc/claude-code/managed-settings.json" ]; then
        echo "✓ Enterprise settings verified"
        if ! jq empty /etc/claude-code/managed-settings.json 2>/dev/null; then
          echo "❌ Invalid enterprise settings JSON"
          exit 1
        fi
      else
        echo "❌ Enterprise settings not found"
        exit 1
      fi
    
      # Copy guidelines files to working directory
      if [ -f "/task-files/coding-guidelines.md" ]; then
        cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
        echo "✓ Copied coding-guidelines.md to working directory"
      fi
    
      if [ -f "/task-files/github-guidelines.md" ]; then
        cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
        echo "✓ Copied github-guidelines.md to working directory"
      fi
    
      # System prompt will be rendered inline (no file copying needed)
      echo "✓ System prompt template will be rendered inline"
    
      # Hook copying disabled
      echo "! Hook scripts disabled - no hooks will be copied"
    
      # Set up MCP configuration
      echo "Setting up MCP configuration..."
    
      # Copy MCP configuration from ConfigMap to project root (project scope)
      if [ -f "/task-files/mcp.json" ]; then
        cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
        echo "✓ Copied mcp.json to .mcp.json (project scope)"
      else
        echo "⚠️  mcp.json template not found"
      fi
    
      # Enterprise managed settings are mounted directly from ConfigMap
      echo "=== ENTERPRISE MANAGED SETTINGS ==="
      echo "✓ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
      echo "✓ No copying needed - mount automatically reflects latest ConfigMap changes"
    
      echo "✓ ConfigMap files copied to $CLAUDE_WORK_DIR"
    else
      echo "⚠️  Warning: /task-files directory not found (ConfigMap not mounted?)"
    fi
    
    
    # Move client-config.json if it exists in task directory
    if [ -f "$CLAUDE_WORK_DIR/task/client-config.json" ]; then
        mv "$CLAUDE_WORK_DIR/task/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" && echo "✓ client-config.json moved to Claude working directory" || echo "❌ client-config.json move failed"
    fi
    
    # Verify client-config.json is available in Claude's working directory
    echo "=== TOOLMAN CONFIG SETUP ==="
    CLAUDE_CONFIG="$CLAUDE_WORK_DIR/client-config.json"
    
    if [ -f "$CLAUDE_CONFIG" ]; then
      echo "✓ client-config.json found in Claude working directory"
      # Set MCP_CLIENT_CONFIG environment variable for MCP server/bridge
      export MCP_CLIENT_CONFIG="$CLAUDE_CONFIG"
      echo "✓ MCP_CLIENT_CONFIG set to: $MCP_CLIENT_CONFIG"
    else
      echo "⚠️ client-config.json not found in Claude working directory - MCP client may not work correctly"
    fi
    
    echo '=== WORKSPACE VALIDATION ==='
    
    # Check for required files in Claude's working directory
    MISSING_FILES=""
    REQUIRED_FILES="CLAUDE.md"
    
    echo "Checking for required files..."
    for file in $REQUIRED_FILES; do
      if [ ! -f "$CLAUDE_WORK_DIR/$file" ]; then
        echo "ERROR: Missing required file: $CLAUDE_WORK_DIR/$file"
        MISSING_FILES="$MISSING_FILES $file"
      else
        echo "✓ Found: $CLAUDE_WORK_DIR/$file"
        # Show file size for verification
        size=$(wc -c < "$CLAUDE_WORK_DIR/$file" 2>/dev/null || echo "0")
        echo "  File size: $size bytes"
      fi
    done
    
    # Check git repository (REQUIRED for implementation tasks)
    if [ ! -d "/workspace/$REPO_NAME/.git" ]; then
      echo "✗ CRITICAL ERROR: No target git repository found!"
      MISSING_FILES="$MISSING_FILES git-repository"
    else
      echo "✓ Found: target git repository"
    fi
    
    # If any files are missing, abort
    if [ -n "$MISSING_FILES" ]; then
      echo ""
      echo "═══════════════════════════════════════════════════════════════"
      echo "║                 WORKSPACE VALIDATION FAILED                  ║"
      echo "═══════════════════════════════════════════════════════════════"
      echo ""
      echo "The following required files are missing:"
      for missing in $MISSING_FILES; do
        case "$missing" in
          "CLAUDE.md")
            echo "  ❌ $missing - Main task instructions for Claude"
            ;;
          "git-repository")
            echo "  ❌ $missing - Required for committing implementation changes"
            ;;
          *)
            echo "  ❌ $missing"
            ;;
        esac
      done
      echo ""
      echo "These files should have been created by the ConfigMap setup process."
      echo "Claude will NOT be started to avoid wasting API credits."
      echo ""
      exit 1
    fi
    
    echo "✓ All required files present. Workspace is valid."
    
    echo '=== IMPLEMENTATION TASK DIAGNOSTICS ==='
    echo "Project directory: $CLAUDE_WORK_DIR"
    echo "Project directory contents:"
    ls -la "$CLAUDE_WORK_DIR"
    echo ""
    
    # Show git status
    echo "Git status:"
    git status 2>/dev/null || echo "Git status unavailable"
    echo ""
    
    echo '=== CLAUDE EXECUTION ==='
    
    # Export necessary variables
    export SERVICE_NAME="{{`{{`{{`}}`}}service{{`}}`}}"
    export TASK_ID="{{`{{`{{`}}`}}task_id{{`}}`}}"
    export GITHUB_APP="{{`{{`{{`}}`}}github_app{{`}}`}}"
    
    # Change to project directory before running Claude
    cd "$CLAUDE_WORK_DIR"
    echo "Changed to directory: $(pwd)"
    
    # Verify we're in the correct directory and have required files
    echo "=== WORKING DIRECTORY VERIFICATION ==="
    echo "Current working directory: $(pwd)"
    echo "Expected directory: $CLAUDE_WORK_DIR"
    if [ "$(pwd)" != "$CLAUDE_WORK_DIR" ]; then
      echo "❌ ERROR: Failed to change to correct working directory!"
      echo "Attempting to change directory again..."
      cd "$CLAUDE_WORK_DIR" || exit 1
      echo "✓ Successfully changed to: $(pwd)"
    fi
    
    # Verify git repository is accessible from Claude working directory
    echo "=== GIT REPOSITORY VERIFICATION ==="
    if [ ! -d ".git" ]; then
      echo "❌ ERROR: No .git directory found in Claude working directory: $(pwd)"
      echo "📂 Checking parent directory structure:"
      echo "  Current: $(pwd)"
      echo "  Contents: $(ls -la . | head -5)"
      if [ -d "/workspace/$REPO_NAME/.git" ]; then
        echo "  Found .git at: /workspace/$REPO_NAME/"
        echo "🔧 This indicates a working directory path mismatch"
        echo "🔧 CLAUDE_WORK_DIR: $CLAUDE_WORK_DIR"
        echo "🔧 Expected git repo: /workspace/$REPO_NAME"
      fi
      exit 1
    else
      echo "✅ Git repository verified at: $(pwd)/.git"
      echo "✅ Repository status: $(git status --porcelain | wc -l) modified files"
      echo "✅ Current branch: $(git branch --show-current 2>/dev/null || echo 'detached')"
    fi
    
    # Verify setup
    echo "✓ Code implementation environment ready"
    
    # Build Claude command
    CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"
    
    # Look for agent-specific system prompt file from agents ConfigMap
    # The system prompt should be in the agents ConfigMap if configured
    if [ -f "/config/agents/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md" ]; then
        echo "✓ Found system prompt file for {{`{{`{{`}}`}}github_app{{`}}`}}, adding to Claude command"
        CLAUDE_CMD="$CLAUDE_CMD --system-prompt /config/agents/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md"
        if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
            echo "[DEBUG] System prompt path: /config/agents/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md"
            echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "/config/agents/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md" | sed 's/^/[DEBUG] /'
            echo "[DEBUG] ----"
        fi
    elif [ -f "/task-files/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md" ]; then
        # Fallback to task-files if included inline
        echo "✓ Found system prompt in task ConfigMap for {{`{{`{{`}}`}}github_app{{`}}`}}"
        CLAUDE_CMD="$CLAUDE_CMD --system-prompt /task-files/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md"
        if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
            echo "[DEBUG] System prompt path: /task-files/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md"
            echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "/task-files/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md" | sed 's/^/[DEBUG] /'
            echo "[DEBUG] ----"
        fi
    else
        echo "ℹ️ No system prompt file found for agent {{`{{`{{`}}`}}github_app{{`}}`}}, using defaults"
    fi
    
    # Model is set via settings.json template, not CLI flag
    
    # Add continue flag if this is a retry attempt or user requested continuation
    {{`{{`{{`}}`}}#if continue_session{{`}}`}}
    CLAUDE_CMD="$CLAUDE_CMD --continue"
    echo 'Adding --continue flag (attempt {{`{{`{{`}}`}}attempts{{`}}`}}{{`{{`{{`}}`}}#if user_requested{{`}}`}} - user requested{{`{{`{{`}}`}}/if{{`}}`}})'
    {{`{{`{{`}}`}}/if{{`}}`}}
    
    echo "════════════════════════════════════════════════════════════════"
    echo "║                    STARTING CLAUDE EXECUTION                  ║"
    echo "════════════════════════════════════════════════════════════════"
    echo "Command: $CLAUDE_CMD"
    echo "Note: Claude will automatically read CLAUDE.md from the working directory"
    
    # Inline system prompt (static content)
    SYSTEM_PROMPT='## 🚨 CRITICAL SYSTEM REQUIREMENTS 🚨
    
    **⛔ OVERCONFIDENCE MITIGATION - MANDATORY VERIFICATION ⛔**
    
    You have a DANGEROUS tendency to declare task completion before actually verifying everything works. This is ABSOLUTELY UNACCEPTABLE.
    
    **MANDATORY VERIFICATION REQUIREMENTS:**
    - ✅ **MUST** actually run and test your code - never assume it works
    - ✅ **MUST** verify ALL acceptance criteria through actual testing
    - ✅ **MUST** confirm your changes don'\''t break existing functionality
    - ✅ **MUST** test end-to-end workflows and edge cases
    - ✅ **MUST** run all linters and build checks successfully
    - ✅ **CANNOT** claim completion based on code appearance alone
    
    **YOU ARE PROHIBITED FROM CLAIMING SUCCESS UNTIL:**
    1. You have executed and verified every piece of functionality
    2. You have tested integration with existing systems
    3. You have confirmed all acceptance criteria pass through testing
    4. All automated tests pass (linting, builds, unit tests)
    5. You have verified the solution works end-to-end in practice
    
    **IF YOU DECLARE SUCCESS WITHOUT VERIFICATION, YOU HAVE FAILED.**
    
    ## 🔧 ORCHESTRATOR EXECUTION CONTEXT
    
    - **Service**: {{`{{`{{`}}`}}service{{`}}`}}
    - **Task ID**: {{`{{`{{`}}`}}task_id{{`}}`}}
    - **Repository**: {{`{{`{{`}}`}}repository_url{{`}}`}}
    - **Docs Repository**: {{`{{`{{`}}`}}docs_repository_url{{`}}`}}
    - **Working Directory**: {{`{{`{{`}}`}}working_directory{{`}}`}}
    - **GitHub App**: {{`{{`{{`}}`}}github_app{{`}}`}}
    
    {{`{{`{{`}}`}}#if continue_session{{`}}`}}
    ## 🔄 CONTINUE SESSION - PR COMMENT RESOLUTION PRIORITY
    
    **⚠️ MANDATORY FIRST STEP: Before proceeding with any other work, you MUST:**
    
    1. **Check for unresolved PR comments**: Use `gh pr view --json reviews` or check the PR directly
    2. **Resolve ALL pending comments first**: Address reviewer feedback, fix issues, respond to questions
    3. **Push comment resolutions**: Commit and push any fixes for reviewer concerns
    4. **Only then proceed**: After ALL PR comments are resolved, continue with the main task
    
    **This ensures reviewer feedback takes priority and maintains collaborative workflow quality.**
    
    {{`{{`{{`}}`}}/if{{`}}`}}
    ## ⚠️ EXECUTION REQUIREMENTS
    
    - **Follow patterns**: Use @coding-guidelines.md and @github-guidelines.md
    - **Pre-PR quality gates (MANDATORY)**: Do NOT open a PR unless all of these pass locally:
      - `cargo fmt --all -- --check`
      - `cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic`
      - `cargo test --workspace --all-features` and high coverage (aim ≥95%, target ~100% on critical paths)
    - **GitHub workflow**: Read @github-guidelines.md for commit standards
    - **Verify continuously**: Run tests and checks after each significant change
    - **Commit incrementally**: Don'\''t save all changes for the end
    - **Test thoroughly**: Validate against acceptance criteria before completion
    
    ## 🚨 NON-NEGOTIABLE PULL REQUEST REQUIREMENT 🚨
    
    **⛔ CRITICAL: YOU MUST CREATE A PULL REQUEST - NO EXCEPTIONS ⛔**
    
    **MANDATORY FINAL STEP:**
    - **MUST** create a pull request using `gh pr create` command
    - **MUST** include proper labels (task-{{`{{`{{`}}`}}task_id{{`}}`}}, run-{{`{{`{{`}}`}}workflow.name{{`}}`}}, service-{{`{{`{{`}}`}}service{{`}}`}})
    - **MUST** verify PR creation succeeded before claiming task completion
    - **THE TASK IS INCOMPLETE AND FAILED IF NO PR IS CREATED**
    
    **YOU CANNOT COMPLETE THIS TASK WITHOUT CREATING A PULL REQUEST.**
    **IF YOU DO NOT CREATE A PR, YOU HAVE FAILED THE TASK COMPLETELY.**
    
    **Remember**: Focus on thorough implementation and verification.'
    
    echo "Starting Claude execution (stream-json via FIFO)..."
    echo "=========================="
    
    # Safe mode toggle for debugging (prevents token consumption)
    SAFE_MODE="false"  # Set to "false" for full task execution
    
    if [ "$SAFE_MODE" = "true" ]; then
        echo "🛡️ SAFE MODE ENABLED - Running simple test instead of full task"
        FIFO_PATH="/workspace/agent-input.jsonl"
        rm -f "$FIFO_PATH" 2>/dev/null || true
        mkfifo "$FIFO_PATH"
        chmod 666 "$FIFO_PATH" || true
        # Keep a persistent writer open and start Claude in background to avoid EOF race
        exec 9>"$FIFO_PATH"
        $CLAUDE_CMD < "$FIFO_PATH" &
        CLAUDE_PID=$!
        printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":"What time is it? Please answer this simple question and exit immediately."}]{{`}}`}}\n' >&9
        # Close writer so reader can exit cleanly
        exec 9>&-
        wait $CLAUDE_PID
    else
        # For remediation, we use the CLAUDE.md we created earlier
        # No need to read prompt.md - remediation context is already prepared
        echo "✓ Using remediation context from CLAUDE.md"
    
        echo "startingRemediation:{{`{{`{{`}}`}}task_id{{`}}`}}"
        echo ""
    
            # DEBUG: Print MCP_CLIENT_CONFIG for troubleshooting client config issues
            echo "🔍 DEBUG: MCP_CLIENT_CONFIG is set to: '$MCP_CLIENT_CONFIG'"
            if [ -f "$MCP_CLIENT_CONFIG" ]; then
                echo "🔍 DEBUG: MCP_CLIENT_CONFIG file exists and is readable"
                echo "🔍 DEBUG: First few lines of client config:"
                head -10 "$MCP_CLIENT_CONFIG" 2>/dev/null || echo "Could not read client config file"
            else
                echo "🔍 DEBUG: MCP_CLIENT_CONFIG file does NOT exist or is not readable"
            fi
            echo ""
    
            # For remediation, we don't need complex prompt composition
            # The CLAUDE.md file contains all the necessary context and instructions
            echo "🔧 Starting Claude with remediation context..."
    
    
    
    
            # Seed initial user turn via a FIFO (system prompts are set via CLI flags, not streamed)
            FIFO_PATH="/workspace/agent-input.jsonl"
            rm -f "$FIFO_PATH" 2>/dev/null || true
            mkfifo "$FIFO_PATH"
            chmod 666 "$FIFO_PATH" || true
    
            # Start Claude (reader) first in background to avoid writer-open blocking
            $CLAUDE_CMD < "$FIFO_PATH" &
            CLAUDE_PID=$!
    
            # For remediation, we send a simple start message since CLAUDE.md contains all context
            USER_MESSAGE="🔧 REMEDIATION MODE ACTIVATED
    
    Please review the CLAUDE.md file for complete context and instructions. You are in remediation mode - focus on fixing the specific issues identified in the feedback while preserving existing functionality."
    
            # Prefer sending via sidecar HTTP endpoint (opens-writes-closes per request)
            if printf '{"text":%s}\n' "$(printf '%s' "$USER_MESSAGE" | jq -Rs .)" | \
                 curl -fsS -X POST http://127.0.0.1:8080/input \
                   -H 'Content-Type: application/json' \
                   --data-binary @- >/dev/null 2>&1; then
              echo "✓ Remediation prompt sent via sidecar /input"
            else
              echo "⚠️ Sidecar /input failed, falling back to direct FIFO write"
              # Fallback: open FIFO writer, send prompt, and close immediately to send EOF
              exec 9>"$FIFO_PATH"
              printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]{{`}}`}}\n' "$(printf '%s' "$USER_MESSAGE" | jq -Rs .)" >&9
              exec 9>&-  # Close immediately to send EOF to Claude
            fi
    
            # Optional debug: dump FIFO holders if requested
            if [ "${DEBUG_FIFO:-false}" = "true" ]; then
              echo "[DEBUG] Dumping FIFO holders for $FIFO_PATH"
              for p in /proc/[0-9]*; do
                pid=${p##*/}
                [ -d "$p/fd" ] || continue
                for fd in "$p"/fd/*; do
                  tgt=$(readlink "$fd" 2>/dev/null || true)
                  case "$tgt" in *agent-input.jsonl*)
                    fdnum=${fd##*/}
                    comm=$(cat "$p/comm" 2>/dev/null || echo "?")
                    echo "  PID=$pid COMM=$comm FD=$fdnum -> $tgt"
                  ;;
                  esac
                done
              done
            fi
    
            # Optional hang diagnostics without enforcing a timeout
            if [ -n "${HANG_DIAG_SECONDS:-}" ] && [ "$HANG_DIAG_SECONDS" -gt 0 ] 2>/dev/null; then
              (
                sleep "$HANG_DIAG_SECONDS"
                if kill -0 "$CLAUDE_PID" 2>/dev/null; then
                  echo "[DEBUG] Hang diag after ${HANG_DIAG_SECONDS}s: dumping FIFO holders and ps"
                  for p in /proc/[0-9]*; do
                    pid=${p##*/}; [ -d "$p/fd" ] || continue
                    for fd in "$p"/fd/*; do tgt=$(readlink "$fd" 2>/dev/null || true); case "$tgt" in *agent-input.jsonl*) fdnum=${fd##*/}; comm=$(cat "$p/comm" 2>/dev/null || echo "?"); echo "  PID=$pid COMM=$comm FD=$fdnum -> $tgt";; esac; done
                  done
                  ps -eo pid,ppid,comm,args | head -200 || true
                fi
              ) & HANG_DIAG_PID=$!
            fi
    
            # Wait for Claude process to complete naturally
            echo "⏳ Waiting for Claude process (PID: $CLAUDE_PID) to complete..."
    
            # Simple wait - Claude should exit naturally when done
            wait "$CLAUDE_PID"
            CLAUDE_EXIT_CODE=$?
    
            if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
              echo "✅ Claude process completed successfully"
            else
              echo "⚠️ Claude process exited with code: $CLAUDE_EXIT_CODE"
            fi
    
            # Stop diagnostics if running
            if [ -n "${HANG_DIAG_PID:-}" ]; then kill "$HANG_DIAG_PID" 2>/dev/null || true; fi
    
            # Ensure FIFO cleanup happens regardless of how Claude exited
            echo "🔧 Performing FIFO cleanup..."
    
            # Close FIFO writer if it was opened (in fallback)
            if [ "$FIFO_OPENED" = "true" ]; then
              echo "🔧 Closing FIFO file descriptor..."
              # Try multiple methods to ensure fd 9 gets closed
              exec 9>&- 2>/dev/null || {
                echo "⚠️ exec 9>&- failed, trying alternative close method"
                eval "exec 9>&-" 2>/dev/null || {
                  echo "⚠️ Alternative close failed, FIFO fd may remain open"
                }
              }
            else
              echo "ℹ️ FIFO was not opened via fallback, checking sidecar"
            fi
    
            # Clean up FIFO file to ensure no processes are blocked
            if [ -p "$FIFO_PATH" ]; then
              echo "🔧 Removing FIFO to ensure clean shutdown"
              rm -f "$FIFO_PATH" 2>/dev/null || echo "⚠️ Could not remove FIFO"
            fi
    
            # Gracefully stop sidecar to allow Job to complete (all containers must exit)
            echo "🔧 Attempting sidecar shutdown..."
            shutdown_attempts=0
            max_shutdown_attempts=3
    
            while [ $shutdown_attempts -lt $max_shutdown_attempts ]; do
              if timeout 5 curl -fsS -X POST http://127.0.0.1:8080/shutdown >/dev/null 2>&1; then
                echo "✓ Sidecar shutdown request successful (attempt $((shutdown_attempts + 1)))"
                break
              else
                shutdown_attempts=$((shutdown_attempts + 1))
                echo "⚠️ Sidecar shutdown request failed (attempt $shutdown_attempts/$max_shutdown_attempts)"
                if [ $shutdown_attempts -lt $max_shutdown_attempts ]; then
                  echo "Retrying in 2 seconds..."
                  sleep 2
                fi
              fi
            done
    
            if [ $shutdown_attempts -eq $max_shutdown_attempts ]; then
              echo "❌ Failed to shutdown sidecar after $max_shutdown_attempts attempts"
              echo "🔧 Force terminating sidecar processes..."
              pkill -f "sidecar" || echo "No sidecar processes found to kill"
            fi
    
            # Wait for sidecar to actually terminate
            echo "⏳ Waiting for sidecar termination..."
            timeout=10
            while [ $timeout -gt 0 ]; do
              if ! pgrep -f "sidecar" > /dev/null 2>&1; then
                echo "✅ Sidecar terminated successfully"
                break
              fi
              sleep 1
              timeout=$((timeout - 1))
            done
    
            if [ $timeout -eq 0 ]; then
              echo "⚠️ Sidecar still running after wait period"
            fi
    fi
    
    echo '════════════════════════════════════════════════════════════════'
    echo '║                 REMEDIATION TASK COMPLETE                    ║'
    echo '════════════════════════════════════════════════════════════════'
    
    # Claude execution completed - no hooks configured
    echo "Claude has completed successfully."
    
    # =============================================================================
    # PR DETECTION AND LABELING
    # =============================================================================
    # After Claude completes, check if a PR was created and apply correlation labels
    if [ -n "${GITHUB_TOKEN:-}" ] && command -v gh >/dev/null 2>&1; then
      echo "🔍 Checking for PRs created by this task..."
    
      # First, try to find PR by task label (Claude should have added task-N label)
      TASK_LABEL="task-${TASK_ID}"
      PR_NUMBER=$(gh pr list -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --label "$TASK_LABEL" --json number --jq '.[0].number' 2>/dev/null || true)
    
      # If not found by label, try by branch name (current branch)
      if [ -z "$PR_NUMBER" ]; then
        CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)
        if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "main" ]; then
          PR_NUMBER=$(gh pr list -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || true)
        fi
      fi
    
      if [ -n "$PR_NUMBER" ]; then
        echo "✅ Found PR #${PR_NUMBER}"
    
        # Get the PR URL
        PR_URL="https://github.com/{{`{{`{{`}}`}}docs_repository_url{{`}}`}}/pull/${PR_NUMBER}"
        echo "📝 PR URL: $PR_URL"
    
        # Update CodeRun status with PR URL via Kubernetes API
        echo "🔄 Updating CodeRun status with PR URL..."
        if command -v kubectl >/dev/null 2>&1; then
          # Create a patch to update the CodeRun status
          PATCH_JSON=$(cat <<EOF
    {
      "status": {
        "pullRequestUrl": "$PR_URL",
        "lastUpdate": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
      }
    }
    EOF
    )
    
          # Apply the patch to update CodeRun status
          if kubectl patch coderun "$CODERUN_NAME" -n "$NAMESPACE" --type=merge --subresource=status -p "$PATCH_JSON" 2>/dev/null; then
            echo "✅ Updated CodeRun status with PR URL"
          else
            echo "⚠️ Failed to update CodeRun status (kubectl patch failed)"
          fi
        else
          echo "⚠️ kubectl not available, cannot update CodeRun status"
        fi
    
        # Apply correlation labels with comprehensive debugging
        echo "🏷️ Adding correlation labels to PR #${PR_NUMBER}..."
    
        # Debug: Check environment variables
        echo "🔍 DEBUG: Environment check for label creation:"
        echo "   TASK_ID: '${TASK_ID}'"
        echo "   WORKFLOW_NAME: '${WORKFLOW_NAME}'"
        echo "   SERVICE_NAME: '${SERVICE_NAME}'"
        echo "   CODERUN_NAME: '${CODERUN_NAME}'"
        echo "   GitHub Token: $([ -n "$GITHUB_TOKEN" ] && echo 'Present' || echo 'Missing')"
    
        # Validate required variables
        if [ -z "$WORKFLOW_NAME" ]; then
          echo "❌ ERROR: WORKFLOW_NAME is not set!"
          echo "🔍 DEBUG: Attempting to extract from CODERUN_NAME..."
          # Try to extract workflow name from CodeRun name pattern
          if [ -n "$CODERUN_NAME" ]; then
            # Pattern: service-t{task}-stage-{hash} created by workflow
            echo "   CODERUN_NAME format: $CODERUN_NAME"
          fi
    
          # Check if we can get it from Kubernetes labels
          if command -v kubectl >/dev/null 2>&1 && [ -n "$CODERUN_NAME" ] && [ -n "$NAMESPACE" ]; then
            echo "🔍 DEBUG: Trying to get workflow name from CodeRun labels..."
            WORKFLOW_FROM_LABELS=$(kubectl get coderun "$CODERUN_NAME" -n "$NAMESPACE" -o jsonpath='{.metadata.labels.workflow-name}' 2>/dev/null || echo "")
            if [ -n "$WORKFLOW_FROM_LABELS" ]; then
              echo "✅ Found workflow name from CodeRun labels: $WORKFLOW_FROM_LABELS"
              WORKFLOW_NAME="$WORKFLOW_FROM_LABELS"
            else
              echo "❌ Could not retrieve workflow name from CodeRun labels"
            fi
          fi
    
          # Final check - if still no workflow name, fail loudly
          if [ -z "$WORKFLOW_NAME" ]; then
            echo "❌ CRITICAL: Cannot determine WORKFLOW_NAME - this will cause correlation issues!"
            echo "🔍 DEBUG: Available environment variables:"
            env | grep -E "WORKFLOW|CODERUN|TASK|SERVICE" | sort
            # DO NOT use 'unknown' - exit with error instead
            echo "❌ Refusing to use 'unknown' label - failing task"
            exit 1
          fi
        fi
    
        TASK_LABEL="task-${TASK_ID}"
        RUN_LABEL="run-${WORKFLOW_NAME}"
        SERVICE_LABEL="service-${SERVICE_NAME}"
    
        echo "📋 Labels to apply:"
        echo "   Task: $TASK_LABEL"
        echo "   Run: $RUN_LABEL"
        echo "   Service: $SERVICE_LABEL"
    
        # Try to add labels with detailed error capture
        echo "🔍 DEBUG: Attempting to add labels to PR..."
        LABEL_ERROR=$(gh pr edit "$PR_NUMBER" -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --add-label "${TASK_LABEL},${RUN_LABEL},${SERVICE_LABEL}" 2>&1)
        LABEL_EXIT_CODE=$?
    
        if [ $LABEL_EXIT_CODE -eq 0 ]; then
          echo "✅ Added correlation labels successfully"
        else
          echo "⚠️ Failed to add labels (exit code: $LABEL_EXIT_CODE)"
          echo "🔍 DEBUG: Error output: $LABEL_ERROR"
    
          # Check if labels exist
          echo "🔍 DEBUG: Checking which labels exist..."
          for label in "$TASK_LABEL" "$RUN_LABEL" "$SERVICE_LABEL"; do
            if gh label list -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --search "$label" | grep -q "^$label"; then
              echo "   ✓ Label '$label' exists"
            else
              echo "   ✗ Label '$label' does not exist"
              # Create the missing label
              echo "   📝 Creating label '$label'..."
              case "$label" in
                task-*) COLOR="f29513"; DESC="Task correlation" ;;
                run-*) COLOR="0366d6"; DESC="Workflow run correlation" ;;
                service-*) COLOR="0e8a16"; DESC="Service correlation" ;;
                *) COLOR="ededed"; DESC="Unknown label type" ;;
              esac
    
              CREATE_ERROR=$(gh label create "$label" -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --color "$COLOR" --description "$DESC" 2>&1)
              CREATE_EXIT=$?
              if [ $CREATE_EXIT -eq 0 ]; then
                echo "   ✅ Created label '$label'"
              else
                echo "   ❌ Failed to create label '$label': $CREATE_ERROR"
              fi
            fi
          done
    
          # Retry adding labels with individual attempts
          echo "🔍 DEBUG: Retrying label addition individually..."
          LABELS_ADDED=0
          for label in "$TASK_LABEL" "$RUN_LABEL" "$SERVICE_LABEL"; do
            RETRY_ERROR=$(gh pr edit "$PR_NUMBER" -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --add-label "$label" 2>&1)
            RETRY_EXIT=$?
            if [ $RETRY_EXIT -eq 0 ]; then
              echo "   ✅ Added label '$label'"
              LABELS_ADDED=$((LABELS_ADDED + 1))
            else
              echo "   ❌ Failed to add label '$label': $RETRY_ERROR"
            fi
          done
    
          if [ $LABELS_ADDED -eq 3 ]; then
            echo "✅ All labels added successfully after retry"
          elif [ $LABELS_ADDED -gt 0 ]; then
            echo "⚠️ Partial success: $LABELS_ADDED/3 labels added"
          else
            echo "❌ CRITICAL: Could not add any labels to PR"
            echo "🔍 DEBUG: Checking PR state..."
            PR_STATE=$(gh pr view "$PR_NUMBER" -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --json state -q .state 2>/dev/null || echo "UNKNOWN")
            echo "   PR State: $PR_STATE"
            if [ "$PR_STATE" = "CLOSED" ] || [ "$PR_STATE" = "MERGED" ]; then
              echo "❌ PR is $PR_STATE - cannot add labels to closed/merged PRs"
            fi
          fi
        fi
      else
        echo "ℹ️ No PR found for this task (Claude may not have created one)"
      fi
    else
      echo "ℹ️ Skipping PR labeling: missing GITHUB_TOKEN or gh CLI"
    fi
    
    # Write sentinel file to signal sidecar to stop (Kubernetes-native file watch)
    touch /workspace/.agent_done 2>/dev/null || true
    
    # Final termination sequence
    echo '════════════════════════════════════════════════════════════════'
    echo '║                 REX CONTAINER TERMINATION                    ║'
    echo '════════════════════════════════════════════════════════════════'
    echo "Container PID: $$"
    echo "Final Process Check:"
    ps aux | head -5
    
    # Write completion marker for workflow tracking
    echo "rex-remediation-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.rex-complete
    
    # Force exit to terminate the pod
    echo "🔚 Force terminating container..."
  code_container-rex.sh.hbs: |
    #!/bin/sh
    
    # Ensure Rust environment is always properly set up
    echo "🔧 Setting up Rust environment..."
    
    # Source Rust environment if available (fixes cargo not found issues)
    if [ -f "$HOME/.cargo/env" ]; then
        . "$HOME/.cargo/env"
        echo "✓ Sourced Rust environment from $HOME/.cargo/env"
    fi
    
    # Also try root cargo env as fallback
    if [ -f "/root/.cargo/env" ]; then
        . "/root/.cargo/env"
        echo "✓ Sourced Rust environment from /root/.cargo/env"
    fi
    
    # Ensure rustup has a default toolchain set
    if command -v rustup >/dev/null 2>&1; then
        rustup default stable 2>/dev/null || true
        echo "✓ Ensured stable Rust toolchain is default"
    else
        echo "⚠️ rustup not found in PATH"
    fi
    
    # Verify Rust is available
    if command -v cargo >/dev/null 2>&1; then
        echo "✓ Cargo is available: $(cargo --version)"
    else
        echo "❌ Cargo not found in PATH"
        echo "Current PATH: $PATH"
        echo "Attempting to find cargo..."
        find /usr -name cargo 2>/dev/null | head -5 || echo "No cargo found in /usr"
        find /home -name cargo 2>/dev/null | head -5 || echo "No cargo found in /home"
    fi
    
    echo '════════════════════════════════════════════════════════════════'
    echo '║           REX/BLAZE DOCUMENTATION WORKFLOW STARTING          ║'
    echo '║                  Implementation Agent Active                  ║'
    echo '║            ⚠️  TASK {{`{{`{{`}}`}}task_id{{`}}`}} ONLY - NO OTHER TASKS ⚠️             ║'
    echo '════════════════════════════════════════════════════════════════'
    echo "🎯 Agent: {{`{{`{{`}}`}}github_app{{`}}`}}"
    echo "📚 Focus: Documentation-first implementation approach"
    echo "📋 Task ID: {{`{{`{{`}}`}}task_id{{`}}`}}"
    echo "⛔ CRITICAL: You must ONLY work on Task {{`{{`{{`}}`}}task_id{{`}}`}} - ignore ALL other tasks"
    
    # Clean up any leftover sentinel file from previous runs
    # This prevents premature sidecar shutdown on sequential task executions
    if [ -f /workspace/.agent_done ]; then
        echo "🧹 Cleaning up sentinel file from previous run"
        rm -f /workspace/.agent_done
    fi
    
    # Disable interactive Git prompts globally
    export GIT_TERMINAL_PROMPT=0
    export GIT_ASKPASS=/bin/true
    export SSH_ASKPASS=/bin/true
    
    # Repository URL
    REPO_URL="{{`{{`{{`}}`}}repository_url{{`}}`}}"
    
    # GitHub App authentication is configured via environment variables
    echo "Using GitHub App authentication"
    
    # Authenticate with GitHub App
    if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
        echo "Authenticating with GitHub App..."
    
        # Create temporary private key file (support escaped newlines)
        TEMP_KEY_FILE="/tmp/github-app-key.pem"
        printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
        chmod 600 "$TEMP_KEY_FILE"
    
        # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
        # JWT header
        JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
        # JWT payload with current time and expiration (10 minutes)
        NOW=$(date +%s)
        EXP=$((NOW + 600))
        JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
        # Sign the JWT
        JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
        JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
        # Get installation ID for the repository (robust parsing of owner/repo)
        INPUT_REPO="{{`{{`{{`}}`}}repository_url{{`}}`}}"
        REPO_OWNER=""
        REPO_NAME=""
    
        if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
            REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
            REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
        elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
            # SSH format git@github.com:owner/repo(.git)
            REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
            REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
        else
            # Fallback: assume slug owner/repo (possibly with .git)
            SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
            REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
            REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
        fi
    
        echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"
    
        echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
        # Get the installation ID (retry and follow redirects). Fallback to org installation.
        INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")
    
        INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')
    
        if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
            echo "⚠️ Repo installation not found, trying org installation..."
            ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
                --connect-timeout 5 --max-time 12 \
                -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/orgs/$REPO_OWNER/installation")
            INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
        fi
    
        if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
            echo "❌ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
            echo "Response (repo): $INSTALLATION_RESPONSE"
            echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
            rm -f "$TEMP_KEY_FILE"
            exit 1
        fi
    
        echo "Installation ID: $INSTALLATION_ID"
    
        # Get installation access token
        TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
        GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
        TOKEN_GENERATED_AT=$(date +%s)  # Track when token was generated for refresh logic
    
        if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
            echo "❌ Failed to get installation access token"
            echo "Response: $TOKEN_RESPONSE"
            rm -f "$TEMP_KEY_FILE"
            exit 1
        fi
    
        # Clean up temporary key file
        rm -f "$TEMP_KEY_FILE"
    
        # Export the token for git to use
        export GITHUB_TOKEN
    
        # Configure git to use the token (use --replace-all to handle multiple existing helpers)
        git config --global --replace-all credential.helper store
        echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    
        # Also authenticate gh CLI with the token
        echo "$GITHUB_TOKEN" | gh auth login --with-token
    
        echo "✓ GitHub App authenticated successfully"
    
        # Token refresh functions for long-running jobs
        refresh_github_token() {
            echo "🔄 Refreshing GitHub App token..."
    
            # Create temporary key file
            TEMP_KEY_FILE="/tmp/github-app-key-$$"
            echo "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
            chmod 600 "$TEMP_KEY_FILE"
    
            # Generate new JWT
            JWT_TOKEN=$(ruby -r openssl -r json -r base64 -e "
            key = OpenSSL::PKey::RSA.new(File.read('$TEMP_KEY_FILE'))
            payload = {
                iat: Time.now.to_i - 60,
                exp: Time.now.to_i + (10 * 60),
                iss: '$GITHUB_APP_ID'
            }
            header = { alg: 'RS256', typ: 'JWT' }
    
            header_enc = Base64.urlsafe_encode64(header.to_json).gsub('=', '')
            payload_enc = Base64.urlsafe_encode64(payload.to_json).gsub('=', '')
            signature = Base64.urlsafe_encode64(key.sign(OpenSSL::Digest::SHA256.new, \"#{header_enc}.#{payload_enc}\")).gsub('=', '')
    
            puts \"#{header_enc}.#{payload_enc}.#{signature}\"
            ")
    
            # Get installation ID (reuse logic from initial auth)
            INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')
    
            if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
                INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
                    -H "Accept: application/vnd.github+json" \
                    "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
            fi
    
            # Get new installation token
            TOKEN_RESPONSE=$(curl -s -X POST \
                -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
            NEW_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
            if [ "$NEW_TOKEN" != "null" ] && [ -n "$NEW_TOKEN" ]; then
                export GITHUB_TOKEN="$NEW_TOKEN"
                export TOKEN_GENERATED_AT=$(date +%s)
    
                # Update git credentials
                echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
                echo "$GITHUB_TOKEN" | gh auth login --with-token 2>/dev/null
    
                echo "✅ Token refreshed successfully"
                rm -f "$TEMP_KEY_FILE"
                return 0
            else
                echo "❌ Failed to refresh token: $TOKEN_RESPONSE"
                rm -f "$TEMP_KEY_FILE"
                return 1
            fi
        }
    
        # Check if token needs refresh (call before git operations)
        refresh_token_if_needed() {
            if [ -z "$TOKEN_GENERATED_AT" ]; then
                echo "⚠️ No token timestamp found, refreshing token..."
                refresh_github_token
                return
            fi
    
            NOW=$(date +%s)
            TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))
    
            # Refresh if token is older than 50 minutes (tokens last 1 hour, refresh at 50 min to be safe)
            if [ $TOKEN_AGE -gt 3000 ]; then
                echo "🔄 Token is $(($TOKEN_AGE / 60)) minutes old, refreshing..."
                refresh_github_token
            fi
        }
    
    else
        echo "❌ GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
        exit 1
    fi
    
    # Git configuration with proper GitHub App attribution
    git config --global --add safe.directory /workspace
    
    # Set GitHub App attribution - use generic format for all agents
    GITHUB_APP="{{`{{`{{`}}`}}github_app{{`}}`}}"
    # Generic attribution that works for any agent
    GIT_AUTHOR_NAME="${GITHUB_APP} Agent (Claude Code)"
    GIT_AUTHOR_EMAIL="${GITHUB_APP}[bot]@users.noreply.github.com"
    
    # Configure git with proper GitHub App attribution
    git config --global user.name "$GIT_AUTHOR_NAME"
    git config --global user.email "$GIT_AUTHOR_EMAIL"
    
    # Set environment variables for Claude Code to use
    export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
    export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
    export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
    export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
    echo "✓ Git configured"
    
    # =============================================================================
    # AUTHENTICATION VERIFICATION
    # =============================================================================
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "🔐 AUTHENTICATION VERIFICATION"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""
    
    # Repository URLs - Handle both full URLs and org/repo format
    # Check if repository_url already contains https://github.com/
    if echo "{{`{{`{{`}}`}}repository_url{{`}}`}}" | grep -q "^https://github.com/"; then
        REPO_HTTP_URL="{{`{{`{{`}}`}}repository_url{{`}}`}}"
        if ! echo "{{`{{`{{`}}`}}repository_url{{`}}`}}" | grep -q "\.git$"; then
            REPO_HTTP_URL="${REPO_HTTP_URL}.git"
        fi
    else
        REPO_HTTP_URL="https://github.com/{{`{{`{{`}}`}}repository_url{{`}}`}}.git"
    fi
    
    # Same for docs repository
    if echo "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" | grep -q "^https://github.com/"; then
        DOCS_HTTP_URL="{{`{{`{{`}}`}}docs_repository_url{{`}}`}}"
        if ! echo "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" | grep -q "\.git$"; then
            DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
        fi
    else
        DOCS_HTTP_URL="https://github.com/{{`{{`{{`}}`}}docs_repository_url{{`}}`}}.git"
    fi
    
    # DEBUG: Show what URLs are being constructed
    echo "🔍 DEBUG: URL Construction & Parameters"
    echo "  Input repository_url: '{{`{{`{{`}}`}}repository_url{{`}}`}}'"
    echo "  Input docs_repository_url: '{{`{{`{{`}}`}}docs_repository_url{{`}}`}}'"
    echo "  Input docs_project_directory: '{{`{{`{{`}}`}}docs_project_directory{{`}}`}}'"
    echo "  Input working_directory: '{{`{{`{{`}}`}}working_directory{{`}}`}}'"
    echo "  Input docs_branch: '{{`{{`{{`}}`}}docs_branch{{`}}`}}'"
    echo "  Input github_app: '{{`{{`{{`}}`}}github_app{{`}}`}}'"
    echo "  Input task_id: '{{`{{`{{`}}`}}task_id{{`}}`}}'"
    echo "  Input service: '{{`{{`{{`}}`}}service{{`}}`}}'"
    echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
    echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
    echo "  Current working directory: $(pwd)"
    echo "  Available environment variables:"
    env | grep -E "(GITHUB|ANTHROPIC)" | sort
    
    # Test HTTPS access to repository
    echo "🔍 DEBUG: Testing HTTPS repository access..."
    echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
    if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
      echo "✓ HTTPS repository access successful"
      echo "  Repository: {{`{{`{{`}}`}}repository_url{{`}}`}} ($REPO_HTTP_URL)"
      echo "  Output: $(cat /tmp/repo_test.out | head -1)"
    else
      echo "❌ HTTPS repository access failed"
      echo "  Repository: {{`{{`{{`}}`}}repository_url{{`}}`}} ($REPO_HTTP_URL)"
      echo "  Error output: $(cat /tmp/repo_test.out)"
      echo "  Git credential helper status:"
      git config --list | grep credential || echo "  No credential helpers configured"
      echo ""
      echo "🚫 ABORTING: Cannot access repository via HTTPS"
      exit 1
    fi
    
    # Test docs repository access
    echo "🔍 DEBUG: Testing docs repository access..."
    echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
    if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
      echo "✓ Docs repository access successful"
      echo "  Repository: {{`{{`{{`}}`}}docs_repository_url{{`}}`}} ($DOCS_HTTP_URL)"
      echo "  Output: $(cat /tmp/docs_test.out | head -1)"
    else
      echo "❌ Docs repository access failed"
      echo "  Repository: {{`{{`{{`}}`}}docs_repository_url{{`}}`}} ($DOCS_HTTP_URL)"
      echo "  Error output: $(cat /tmp/docs_test.out)"
      echo ""
      echo "🚫 ABORTING: Cannot access docs repository via HTTPS"
      exit 1
    fi
    
    # Dual Repository Setup - Platform repo for docs, Target repo for implementation
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "║                 DUAL REPOSITORY SETUP                        ║"
    echo "═══════════════════════════════════════════════════════════════"
    
    # Repository Information
    DOCS_BRANCH="{{`{{`{{`}}`}}docs_branch{{`}}`}}"
    GITHUB_APP="{{`{{`{{`}}`}}github_app{{`}}`}}"
    
    # Helper: derive safe workspace directory name from repo input (URL, SSH, or slug)
    sanitize_repo_dir() {
        input="$1"
        if echo "$input" | grep -qE '^https://github.com/'; then
            owner=$(echo "$input" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
            name=$(echo "$input" | sed -E 's|https://github.com/[^/]+/([^/]+)(\\.git)?|\1|')
            printf '%s-%s' "$owner" "$name"
        elif echo "$input" | grep -qE '^git@github.com:'; then
            owner=$(echo "$input" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
            name=$(echo "$input" | sed -E 's|git@github.com:[^/]+/([^/]+)(\\.git)?|\1|')
            printf '%s-%s' "$owner" "$name"
        else
            # Assume owner/repo (optionally with .git)
            slug=$(echo "$input" | sed -E 's|\\.git$||')
            echo "$slug" | tr '/' '-'
        fi
    }
    
    # Derive workspace directory names (owner-repo)
    DOCS_REPO_DIR=$(sanitize_repo_dir "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}")
    TARGET_REPO_DIR=$(sanitize_repo_dir "{{`{{`{{`}}`}}repository_url{{`}}`}}")
    
    echo "=== REPOSITORY SETUP ==="
    echo "Docs repository: {{`{{`{{`}}`}}docs_repository_url{{`}}`}} ($DOCS_HTTP_URL)"
    echo "Target repository: {{`{{`{{`}}`}}repository_url{{`}}`}} ($REPO_HTTP_URL)"
    echo "Docs branch: $DOCS_BRANCH"
    echo "GitHub App: $GITHUB_APP"
    
    # Always use consistent workflow approach
    # Even if docs and target are the same repo, we clone them separately
    # This avoids complex branch switching and file preservation issues
    echo "=== UNIFIED WORKFLOW APPROACH ==="
    echo "  docs_repository_url: '{{`{{`{{`}}`}}docs_repository_url{{`}}`}}'"
    echo "  repository_url: '{{`{{`{{`}}`}}repository_url{{`}}`}}'"
    echo "  └─ TaskMaster files will be copied from docs repo at: {{`{{`{{`}}`}}docs_project_directory{{`}}`}}"
    
    # Repository Setup - Always use consistent approach
    echo "=== REPOSITORY SETUP ==="
    
    # Step 1: Clone or update docs repository temporarily
    if [ -d "/tmp/docs-repo" ]; then
        echo "🔄 DOCS REPOSITORY: UPDATE - temporary directory exists"
        cd /tmp/docs-repo
        git fetch origin
        git checkout "$DOCS_BRANCH"
        git reset --hard "origin/$DOCS_BRANCH"
        cd /workspace
        echo "✓ Docs repository updated"
    else
        echo "📥 DOCS REPOSITORY: CLONING - extracting task files"
        if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
            echo "❌ Failed to clone docs repository: {{`{{`{{`}}`}}docs_repository_url{{`}}`}} ($DOCS_HTTP_URL)"
            exit 1
        fi
        cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd /workspace
        echo "✓ Docs repository cloned to temporary location"
    fi
    
    # Step 2: Clone or update target repository
    if [ -d "$TARGET_REPO_DIR" ]; then
        echo "🔄 TARGET REPOSITORY: UPDATE - directory already exists"
        echo "📁 Found existing target repository '$TARGET_REPO_DIR', updating..."
        cd "$TARGET_REPO_DIR"
        git fetch origin main
        git reset --hard origin/main
        cd /workspace
        echo "✓ Target repository updated successfully"
    else
        echo "📥 TARGET REPOSITORY: CLONING - first time setup"
        if ! git clone "$REPO_HTTP_URL" "$TARGET_REPO_DIR"; then
            echo "❌ Failed to clone target repository: {{`{{`{{`}}`}}repository_url{{`}}`}} ($REPO_HTTP_URL)"
            exit 1
        fi
        echo "✓ Target repository cloned successfully"
    fi
    
    # Step 3: Copy task files from docs repo to target repo
    echo "📋 TASK FILES: COPYING from docs to target repository"
    mkdir -p "/workspace/$TARGET_REPO_DIR/task"
    
    # Determine docs project directory path
    {{`{{`{{`}}`}}#if docs_project_directory{{`}}`}}
    if [ "{{`{{`{{`}}`}}docs_project_directory{{`}}`}}" = "." ]; then
        DOCS_PATH="/tmp/docs-repo/.taskmaster"
    else
        DOCS_PATH="/tmp/docs-repo/{{`{{`{{`}}`}}docs_project_directory{{`}}`}}/.taskmaster"
    fi
    {{`{{`{{`}}`}}else{{`}}`}}
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
    {{`{{`{{`}}`}}/if{{`}}`}}
    
    # Copy specific task files
    TASK_DIR="$DOCS_PATH/docs/task-{{`{{`{{`}}`}}task_id{{`}}`}}"
    echo "🔍 DEBUG: Looking for task files at: $TASK_DIR"
    echo "🔍 DEBUG: Docs path is: $DOCS_PATH"
    echo "🔍 DEBUG: Contents of docs temp directory:"
    ls -la /tmp/docs-repo/.taskmaster/ || echo "No .taskmaster found"
    echo "🔍 DEBUG: Contents of docs directory:"
    ls -la /tmp/docs-repo/.taskmaster/docs/ || echo "No docs directory found"
    
    if [ -d "$TASK_DIR" ]; then
        echo "🔍 DEBUG: Task directory found, contents:"
        ls -la "$TASK_DIR"
    
        echo "✅ Copying task.md..."
        cp "$TASK_DIR/task.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "✓ task.md copied" || echo "❌ task.md copy failed"
    
        echo "✅ Copying acceptance-criteria.md..."
        cp "$TASK_DIR/acceptance-criteria.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "✓ acceptance-criteria.md copied" || echo "❌ acceptance-criteria.md copy failed"
    
        echo "✅ Copying prompt.md..."
        cp "$TASK_DIR/prompt.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "✓ prompt.md copied" || echo "❌ prompt.md copy failed"
    
        echo "✅ Copying client-config.json..."
        if [ -f "$TASK_DIR/client-config.json" ]; then
            cp "$TASK_DIR/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" && echo "✓ client-config.json copied to Claude working directory" || echo "❌ client-config.json copy failed"
        else
            echo "⚠️ client-config.json not found - MCP client may not be configured"
        fi
    
        echo "✅ Copying toolman-guide.md..."
        if [ -f "$TASK_DIR/toolman-guide.md" ]; then
            cp "$TASK_DIR/toolman-guide.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "✓ toolman-guide.md copied" || echo "❌ toolman-guide.md copy failed"
        else
            echo "⚠️ toolman-guide.md not found - code agent won't have tool usage guidance"
        fi
    
        echo "✓ Task {{`{{`{{`}}`}}task_id{{`}}`}} files copied from $TASK_DIR"
    else
        echo "❌ CRITICAL: Task {{`{{`{{`}}`}}task_id{{`}}`}} directory not found at: $TASK_DIR"
        echo "🔍 DEBUG: Available directories in docs:"
        find /tmp/docs-repo -name "task-*" -type d || echo "No task directories found"
    fi
    
    # Copy architecture.md from docs root
    ARCH_FILE="$DOCS_PATH/docs/architecture.md"
    if [ -f "$ARCH_FILE" ]; then
        cp "$ARCH_FILE" "/workspace/$TARGET_REPO_DIR/task/"
        echo "✓ Architecture documentation copied"
    else
        echo "⚠️ architecture.md not found at: $ARCH_FILE"
    fi
    
    # Copy tasks.json if it exists
    if [ -f "$DOCS_PATH/tasks.json" ]; then
        cp "$DOCS_PATH/tasks.json" "/workspace/$TARGET_REPO_DIR/task/"
        echo "✓ tasks.json copied"
    fi
    
    echo "✓ Task files copied to target repository"
    
    # DEBUG: Verify files were copied successfully
    echo "🔍 DEBUG: Contents of target task directory after copy:"
    ls -la "/workspace/$TARGET_REPO_DIR/task/" || echo "Task directory not found"
    echo "🔍 DEBUG: Checking if prompt.md exists:"
    [ -f "/workspace/$TARGET_REPO_DIR/task/prompt.md" ] && echo "✅ prompt.md exists" || echo "❌ prompt.md missing"
    
    # Step 4: Clean up docs repository
    echo "🧹 CLEANUP: Removing temporary docs repository"
    rm -rf /tmp/docs-repo
    echo "✓ Docs repository cleaned up"
    
    # Set working directory to the target repository root
    REPO_NAME="$TARGET_REPO_DIR"
    echo "✓ Working directory: /workspace/$REPO_NAME"
    
    # Set Claude working directory early (needed for client-config.json copy)
    WORK_DIR="{{`{{`{{`}}`}}working_directory{{`}}`}}"
    if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
      CLAUDE_WORK_DIR="/workspace/$REPO_NAME"
    else
      CLAUDE_WORK_DIR="/workspace/$REPO_NAME/$WORK_DIR"
    fi
    mkdir -p "$CLAUDE_WORK_DIR"
    echo "✓ Set Claude working directory: $CLAUDE_WORK_DIR"
    
    # Setup feature branch for implementation
    echo "=== BRANCH SETUP ==="
    cd "/workspace/$REPO_NAME"
    
    # Sync with latest main to prevent conflicts
    echo "🔄 Syncing with latest main to prevent conflicts..."
    git fetch origin main 2>/dev/null || git fetch origin master 2>/dev/null || echo "⚠️ Could not fetch main/master branch"
    
    # Create or checkout feature branch (with conflict-safe fallback)
    FEATURE_BRANCH="feature/task-{{`{{`{{`}}`}}task_id{{`}}`}}-implementation"
    BRANCH_EXISTS="false"
    
    if git show-ref --verify --quiet refs/heads/$FEATURE_BRANCH; then
        BRANCH_EXISTS="true"
        echo "Feature branch '$FEATURE_BRANCH' exists, checking out..."
        git checkout $FEATURE_BRANCH
    
        echo "📥 Merging latest main into $FEATURE_BRANCH..."
        if git merge origin/main --no-edit; then
            echo "✓ Successfully merged latest main into feature branch"
        else
            echo "⚠️ MERGE CONFLICT: Cannot auto-merge main into $FEATURE_BRANCH"
            echo "🔄 Auto-aborting merge and creating a fresh branch from origin/main"
            # Abort merge if in progress
            git merge --abort 2>/dev/null || true
            # Create a unique fresh branch to avoid reuse conflicts
            NEW_BRANCH="${FEATURE_BRANCH}-$(date -u +%Y%m%d%H%M%S)"
            git checkout -B "$NEW_BRANCH" origin/main
            FEATURE_BRANCH="$NEW_BRANCH"
            echo "✓ Switched to fresh branch: $FEATURE_BRANCH"
        fi
    else
        # Create new feature branch from latest main
        echo "Creating new feature branch '$FEATURE_BRANCH' from latest main..."
        git checkout -b $FEATURE_BRANCH origin/main
        echo "✓ Created feature branch: $FEATURE_BRANCH"
    fi
    
    # 5. Change to Claude Working Directory (already set up earlier)
    cd "$CLAUDE_WORK_DIR"
    echo "✓ Changed to Claude working directory: $CLAUDE_WORK_DIR"
    echo "🔑 CRITICAL: Claude will be launched from this directory"
    
    # Working directory setup completed above
    
    # Configure git user after successful clone
    echo "=== POST-CLONE GIT CONFIGURATION ==="
    # Fix dubious ownership issues
    git config --global --add safe.directory "/workspace/$REPO_NAME"
    echo "✓ Added repository to safe directories"
    
    # Set git config locally in the working repository (persistent on PVC)
    if [ -d "/workspace/$REPO_NAME/.git" ]; then
        cd "/workspace/$REPO_NAME"
        git config --local user.name "$GIT_AUTHOR_NAME"
        git config --local user.email "$GIT_AUTHOR_EMAIL"
        # Set up automatic upstream for new branches
        git config --local push.autoSetupRemote true
        echo "✓ Configured git user in target repository: $GIT_AUTHOR_NAME"
        echo "✓ Enabled automatic upstream setup for new branches"
    fi
    
    cd /workspace
    
    # Copy ConfigMap files to working directory (AFTER repository clone)
    echo "=== CONFIGMAP FILE SETUP ==="
    
    # Claude working directory already set above during repository setup
    
    echo "Setting up files in Claude working directory: $CLAUDE_WORK_DIR"
    cd "$CLAUDE_WORK_DIR"
    
    # Copy all files from ConfigMap to working directory
    if [ -d "/task-files" ]; then
      echo "Copying ConfigMap files to working directory..."
    
      # CLAUDE.md Memory Persistence Logic (controlled by overwriteMemory CRD field)
            OVERWRITE_MEMORY="{{`{{`{{`}}`}}overwrite_memory{{`}}`}}"
    
      # Handle CLAUDE.md based on overwriteMemory setting
            if [ "$OVERWRITE_MEMORY" = "true" ]; then
              # Overwrite mode: Always replace CLAUDE.md with fresh template
        cp "/task-files/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
        cp "/task-files/CLAUDE.md" "/workspace/CLAUDE.md"
              echo "✓ Overwrote CLAUDE.md memory file (fresh start requested)"
              echo "✓ Copied CLAUDE.md to workspace root for easy access"
            else
              # Preserve mode (default): Only copy if doesn't exist
              if [ ! -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
          # Initial creation - copy from ConfigMap
          cp "/task-files/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
          cp "/task-files/CLAUDE.md" "/workspace/CLAUDE.md"
                echo "✓ Created initial CLAUDE.md memory file"
                echo "✓ Copied CLAUDE.md to workspace root for easy access"
              else
                echo "✓ Preserved existing CLAUDE.md memory file (maintaining accumulated context)"
                # Still copy to workspace root for consistency
                cp "$CLAUDE_WORK_DIR/CLAUDE.md" "/workspace/CLAUDE.md"
                echo "✓ Synced CLAUDE.md to workspace root"
              fi
            fi
    
      # Copy all other markdown files (excluding CLAUDE.md)
      for md_file in /task-files/*.md; do
        if [ -f "$md_file" ]; then
          basename_file=$(basename "$md_file")
          # Skip CLAUDE.md since we handled it above
          if [ "$basename_file" != "CLAUDE.md" ]; then
            cp "$md_file" "$CLAUDE_WORK_DIR/"
            echo "✓ Updated $basename_file"
          fi
        fi
      done
    
      # Verify enterprise settings (mounted directly from ConfigMap)
      if [ -f "/etc/claude-code/managed-settings.json" ]; then
        echo "✓ Enterprise settings verified"
        if ! jq empty /etc/claude-code/managed-settings.json 2>/dev/null; then
          echo "❌ Invalid enterprise settings JSON"
          exit 1
        fi
      else
        echo "❌ Enterprise settings not found"
        exit 1
      fi
    
      # Copy guidelines files to working directory
      if [ -f "/task-files/coding-guidelines.md" ]; then
        cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
        echo "✓ Copied coding-guidelines.md to working directory"
      fi
    
      if [ -f "/task-files/github-guidelines.md" ]; then
        cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
        echo "✓ Copied github-guidelines.md to working directory"
      fi
    
      # System prompt will be rendered inline (no file copying needed)
      echo "✓ System prompt template will be rendered inline"
    
      # Hook copying disabled
      echo "! Hook scripts disabled - no hooks will be copied"
    
      # Set up MCP configuration
      echo "Setting up MCP configuration..."
    
      # Copy MCP configuration from ConfigMap to project root (project scope)
      if [ -f "/task-files/mcp.json" ]; then
        cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
        echo "✓ Copied mcp.json to .mcp.json (project scope)"
      else
        echo "⚠️  mcp.json template not found"
      fi
    
      # Enterprise managed settings are mounted directly from ConfigMap
      echo "=== ENTERPRISE MANAGED SETTINGS ==="
      echo "✓ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
      echo "✓ No copying needed - mount automatically reflects latest ConfigMap changes"
    
      echo "✓ ConfigMap files copied to $CLAUDE_WORK_DIR"
    else
      echo "⚠️  Warning: /task-files directory not found (ConfigMap not mounted?)"
    fi
    
    
    # Copy Current Task Documentation to Working Directory
    echo "=== TASK DOCUMENTATION SETUP ==="
    echo "🔍 DEBUG: REPO_NAME is: $REPO_NAME"
    echo "🔍 DEBUG: CLAUDE_WORK_DIR is: $CLAUDE_WORK_DIR"
    echo "🔍 DEBUG: Task ID is: {{`{{`{{`}}`}}task_id{{`}}`}}"
    
    # Task directory should already exist from multi-repo workflow or be created as needed
    mkdir -p "$CLAUDE_WORK_DIR/task"
    echo "✓ Created task directory at: $CLAUDE_WORK_DIR/task"
    
    # Task documentation was copied from docs repository during repository setup
    echo "✓ Task documentation available in task/ directory"
    
    # Move client-config.json if it's in the task directory
    if [ -f "$CLAUDE_WORK_DIR/task/client-config.json" ]; then
        mv "$CLAUDE_WORK_DIR/task/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" && echo "✓ client-config.json moved to Claude working directory" || echo "❌ client-config.json move failed"
    fi
    
    # DEBUG: Verify files were copied successfully
    echo "🔍 DEBUG: Contents of target task directory:"
    ls -la "$CLAUDE_WORK_DIR/task/" || echo "Task directory not found"
    echo "🔍 DEBUG: Checking if prompt.md exists:"
    [ -f "$CLAUDE_WORK_DIR/task/prompt.md" ] && echo "✅ prompt.md exists" || echo "❌ prompt.md missing"
    
    # Verify client-config.json is available in Claude's working directory
    echo "=== TOOLMAN CONFIG SETUP ==="
    CLAUDE_CONFIG="$CLAUDE_WORK_DIR/client-config.json"
    
    if [ -f "$CLAUDE_CONFIG" ]; then
      echo "✓ client-config.json found in Claude working directory"
      # Set MCP_CLIENT_CONFIG environment variable for MCP server/bridge
      export MCP_CLIENT_CONFIG="$CLAUDE_CONFIG"
      echo "✓ MCP_CLIENT_CONFIG set to: $MCP_CLIENT_CONFIG"
    else
      echo "⚠️ client-config.json not found in Claude working directory - MCP client may not work correctly"
    fi
    
    echo '=== WORKSPACE VALIDATION ==='
    
    # Check for required files in Claude's working directory
    MISSING_FILES=""
    REQUIRED_FILES="CLAUDE.md"
    
    echo "Checking for required files..."
    for file in $REQUIRED_FILES; do
      if [ ! -f "$CLAUDE_WORK_DIR/$file" ]; then
        echo "ERROR: Missing required file: $CLAUDE_WORK_DIR/$file"
        MISSING_FILES="$MISSING_FILES $file"
      else
        echo "✓ Found: $CLAUDE_WORK_DIR/$file"
        # Show file size for verification
        size=$(wc -c < "$CLAUDE_WORK_DIR/$file" 2>/dev/null || echo "0")
        echo "  File size: $size bytes"
      fi
    done
    
    # Check git repository (REQUIRED for implementation tasks)
    if [ ! -d "/workspace/$REPO_NAME/.git" ]; then
      echo "✗ CRITICAL ERROR: No target git repository found!"
      MISSING_FILES="$MISSING_FILES git-repository"
    else
      echo "✓ Found: target git repository"
    fi
    
    # If any files are missing, abort
    if [ -n "$MISSING_FILES" ]; then
      echo ""
      echo "═══════════════════════════════════════════════════════════════"
      echo "║                 WORKSPACE VALIDATION FAILED                  ║"
      echo "═══════════════════════════════════════════════════════════════"
      echo ""
      echo "The following required files are missing:"
      for missing in $MISSING_FILES; do
        case "$missing" in
          "CLAUDE.md")
            echo "  ❌ $missing - Main task instructions for Claude"
            ;;
          "git-repository")
            echo "  ❌ $missing - Required for committing implementation changes"
            ;;
          *)
            echo "  ❌ $missing"
            ;;
        esac
      done
      echo ""
      echo "These files should have been created by the ConfigMap setup process."
      echo "Claude will NOT be started to avoid wasting API credits."
      echo ""
      exit 1
    fi
    
    echo "✓ All required files present. Workspace is valid."
    
    echo '=== IMPLEMENTATION TASK DIAGNOSTICS ==='
    echo "Project directory: $CLAUDE_WORK_DIR"
    echo "Project directory contents:"
    ls -la "$CLAUDE_WORK_DIR"
    echo ""
    
    # Show git status
    echo "Git status:"
    git status 2>/dev/null || echo "Git status unavailable"
    echo ""
    
    echo '=== CLAUDE EXECUTION ==='
    
    # Export necessary variables
    export SERVICE_NAME="{{`{{`{{`}}`}}service{{`}}`}}"
    export TASK_ID="{{`{{`{{`}}`}}task_id{{`}}`}}"
    export GITHUB_APP="{{`{{`{{`}}`}}github_app{{`}}`}}"
    
    # Change to project directory before running Claude
    cd "$CLAUDE_WORK_DIR"
    echo "Changed to directory: $(pwd)"
    
    # Verify we're in the correct directory and have required files
    echo "=== WORKING DIRECTORY VERIFICATION ==="
    echo "Current working directory: $(pwd)"
    echo "Expected directory: $CLAUDE_WORK_DIR"
    if [ "$(pwd)" != "$CLAUDE_WORK_DIR" ]; then
      echo "❌ ERROR: Failed to change to correct working directory!"
      echo "Attempting to change directory again..."
      cd "$CLAUDE_WORK_DIR" || exit 1
      echo "✓ Successfully changed to: $(pwd)"
    fi
    
    # Verify git repository is accessible from Claude working directory
    echo "=== GIT REPOSITORY VERIFICATION ==="
    if [ ! -d ".git" ]; then
      echo "❌ ERROR: No .git directory found in Claude working directory: $(pwd)"
      echo "📂 Checking parent directory structure:"
      echo "  Current: $(pwd)"
      echo "  Contents: $(ls -la . | head -5)"
      if [ -d "/workspace/$REPO_NAME/.git" ]; then
        echo "  Found .git at: /workspace/$REPO_NAME/"
        echo "🔧 This indicates a working directory path mismatch"
        echo "🔧 CLAUDE_WORK_DIR: $CLAUDE_WORK_DIR"
        echo "🔧 Expected git repo: /workspace/$REPO_NAME"
      fi
      exit 1
    else
      echo "✅ Git repository verified at: $(pwd)/.git"
      echo "✅ Repository status: $(git status --porcelain | wc -l) modified files"
      echo "✅ Current branch: $(git branch --show-current 2>/dev/null || echo 'detached')"
    fi
    
    # Verify setup
    echo "✓ Code implementation environment ready"
    
    # Build Claude command
    CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"
    
    # Look for agent-specific system prompt file from agents ConfigMap
    # The system prompt should be in the agents ConfigMap if configured
    if [ -f "/config/agents/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md" ]; then
        echo "✓ Found system prompt file for {{`{{`{{`}}`}}github_app{{`}}`}}, adding to Claude command"
        CLAUDE_CMD="$CLAUDE_CMD --system-prompt /config/agents/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md"
        if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
            echo "[DEBUG] System prompt path: /config/agents/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md"
            echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "/config/agents/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md" | sed 's/^/[DEBUG] /'
            echo "[DEBUG] ----"
        fi
    elif [ -f "/task-files/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md" ]; then
        # Fallback to task-files if included inline
        echo "✓ Found system prompt in task ConfigMap for {{`{{`{{`}}`}}github_app{{`}}`}}"
        CLAUDE_CMD="$CLAUDE_CMD --system-prompt /task-files/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md"
        if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
            echo "[DEBUG] System prompt path: /task-files/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md"
            echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "/task-files/{{`{{`{{`}}`}}github_app{{`}}`}}_system-prompt.md" | sed 's/^/[DEBUG] /'
            echo "[DEBUG] ----"
        fi
    else
        echo "ℹ️ No system prompt file found for agent {{`{{`{{`}}`}}github_app{{`}}`}}, using defaults"
    fi
    
    # Model is set via settings.json template, not CLI flag
    
    # Add continue flag if this is a retry attempt or user requested continuation
    {{`{{`{{`}}`}}#if continue_session{{`}}`}}
    CLAUDE_CMD="$CLAUDE_CMD --continue"
    echo 'Adding --continue flag (attempt {{`{{`{{`}}`}}attempts{{`}}`}}{{`{{`{{`}}`}}#if user_requested{{`}}`}} - user requested{{`{{`{{`}}`}}/if{{`}}`}})'
    {{`{{`{{`}}`}}/if{{`}}`}}
    
    echo "════════════════════════════════════════════════════════════════"
    echo "║                    STARTING CLAUDE EXECUTION                  ║"
    echo "════════════════════════════════════════════════════════════════"
    echo "Command: $CLAUDE_CMD"
    echo "Note: Claude will automatically read CLAUDE.md from the working directory"
    
    # Inline system prompt (static content)
    SYSTEM_PROMPT='## 🚨 CRITICAL SYSTEM REQUIREMENTS 🚨
    
    **⛔ OVERCONFIDENCE MITIGATION - MANDATORY VERIFICATION ⛔**
    
    You have a DANGEROUS tendency to declare task completion before actually verifying everything works. This is ABSOLUTELY UNACCEPTABLE.
    
    **MANDATORY VERIFICATION REQUIREMENTS:**
    - ✅ **MUST** actually run and test your code - never assume it works
    - ✅ **MUST** verify ALL acceptance criteria through actual testing
    - ✅ **MUST** confirm your changes don'\''t break existing functionality
    - ✅ **MUST** test end-to-end workflows and edge cases
    - ✅ **MUST** run all linters and build checks successfully
    - ✅ **CANNOT** claim completion based on code appearance alone
    
    **YOU ARE PROHIBITED FROM CLAIMING SUCCESS UNTIL:**
    1. You have executed and verified every piece of functionality
    2. You have tested integration with existing systems
    3. You have confirmed all acceptance criteria pass through testing
    4. All automated tests pass (linting, builds, unit tests)
    5. You have verified the solution works end-to-end in practice
    
    **IF YOU DECLARE SUCCESS WITHOUT VERIFICATION, YOU HAVE FAILED.**
    
    ## 🔧 ORCHESTRATOR EXECUTION CONTEXT
    
    - **Service**: {{`{{`{{`}}`}}service{{`}}`}}
    - **Task ID**: {{`{{`{{`}}`}}task_id{{`}}`}}
    - **Repository**: {{`{{`{{`}}`}}repository_url{{`}}`}}
    - **Docs Repository**: {{`{{`{{`}}`}}docs_repository_url{{`}}`}}
    - **Working Directory**: {{`{{`{{`}}`}}working_directory{{`}}`}}
    - **GitHub App**: {{`{{`{{`}}`}}github_app{{`}}`}}
    
    {{`{{`{{`}}`}}#if continue_session{{`}}`}}
    ## 🔄 CONTINUE SESSION - PR COMMENT RESOLUTION PRIORITY
    
    **⚠️ MANDATORY FIRST STEP: Before proceeding with any other work, you MUST:**
    
    1. **Check for unresolved PR comments**: Use `gh pr view --json reviews` or check the PR directly
    2. **Resolve ALL pending comments first**: Address reviewer feedback, fix issues, respond to questions
    3. **Push comment resolutions**: Commit and push any fixes for reviewer concerns
    4. **Only then proceed**: After ALL PR comments are resolved, continue with the main task
    
    **This ensures reviewer feedback takes priority and maintains collaborative workflow quality.**
    
    {{`{{`{{`}}`}}/if{{`}}`}}
    ## ⚠️ EXECUTION REQUIREMENTS
    
    - **Follow patterns**: Use @coding-guidelines.md and @github-guidelines.md
    - **Pre-PR quality gates (MANDATORY)**: Do NOT open a PR unless all of these pass locally:
      - `cargo fmt --all -- --check`
      - `cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic`
      - `cargo test --workspace --all-features` and high coverage (aim ≥95%, target ~100% on critical paths)
    - **GitHub workflow**: Read @github-guidelines.md for commit standards
    - **Verify continuously**: Run tests and checks after each significant change
    - **Commit incrementally**: Don'\''t save all changes for the end
    - **Test thoroughly**: Validate against acceptance criteria before completion
    
    ## 🚨 NON-NEGOTIABLE PULL REQUEST REQUIREMENT 🚨
    
    **⛔ CRITICAL: YOU MUST CREATE A PULL REQUEST - NO EXCEPTIONS ⛔**
    
    **MANDATORY FINAL STEP:**
    - **MUST** create a pull request using `gh pr create` command
    - **MUST** include proper labels (task-{{`{{`{{`}}`}}task_id{{`}}`}}, run-{{`{{`{{`}}`}}workflow.name{{`}}`}}, service-{{`{{`{{`}}`}}service{{`}}`}})
    - **MUST** verify PR creation succeeded before claiming task completion
    - **THE TASK IS INCOMPLETE AND FAILED IF NO PR IS CREATED**
    
    **YOU CANNOT COMPLETE THIS TASK WITHOUT CREATING A PULL REQUEST.**
    **IF YOU DO NOT CREATE A PR, YOU HAVE FAILED THE TASK COMPLETELY.**
    
    **Remember**: Focus on thorough implementation and verification.'
    
    echo "Starting Claude execution (stream-json via FIFO)..."
    echo "=========================="
    
    # Safe mode toggle for debugging (prevents token consumption)
    SAFE_MODE="false"  # Set to "false" for full task execution
    
    if [ "$SAFE_MODE" = "true" ]; then
        echo "🛡️ SAFE MODE ENABLED - Running simple test instead of full task"
        FIFO_PATH="/workspace/agent-input.jsonl"
        rm -f "$FIFO_PATH" 2>/dev/null || true
        mkfifo "$FIFO_PATH"
        chmod 666 "$FIFO_PATH" || true
        # Keep a persistent writer open and start Claude in background to avoid EOF race
        exec 9>"$FIFO_PATH"
        $CLAUDE_CMD < "$FIFO_PATH" &
        CLAUDE_PID=$!
        printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":"What time is it? Please answer this simple question and exit immediately."}]{{`}}`}}\n' >&9
        # Close writer so reader can exit cleanly
        exec 9>&-
        wait $CLAUDE_PID
    else
        # Debug: Show what's actually in the task directory before checking for prompt.md
        echo "🔍 DEBUG: About to check for prompt.md at: $CLAUDE_WORK_DIR/task/prompt.md"
        echo "🔍 DEBUG: Contents of task directory:"
        ls -la "$CLAUDE_WORK_DIR/task/" || echo "Task directory not found or empty"
        echo "🔍 DEBUG: Current working directory contents:"
        ls -la "$CLAUDE_WORK_DIR/" || echo "Working directory not accessible"
    
        # Check if prompt.md exists and use it as main prompt
        if [ -f "$CLAUDE_WORK_DIR/task/prompt.md" ]; then
            echo "✓ Using task-specific prompt from docs service: task/prompt.md"
    
            echo "startingTask:{{`{{`{{`}}`}}task_id{{`}}`}}"
            echo ""
    
            # DEBUG: Print MCP_CLIENT_CONFIG for troubleshooting client config issues
            echo "🔍 DEBUG: MCP_CLIENT_CONFIG is set to: '$MCP_CLIENT_CONFIG'"
            if [ -f "$MCP_CLIENT_CONFIG" ]; then
                echo "🔍 DEBUG: MCP_CLIENT_CONFIG file exists and is readable"
                echo "🔍 DEBUG: First few lines of client config:"
                head -10 "$MCP_CLIENT_CONFIG" 2>/dev/null || echo "Could not read client config file"
            else
                echo "🔍 DEBUG: MCP_CLIENT_CONFIG file does NOT exist or is not readable"
            fi
            echo ""
    
            # Prepare prompt prefix with CRITICAL task isolation instruction
            PROMPT_PREFIX="⛔ **CRITICAL TASK ISOLATION REQUIREMENT** ⛔
    
    You are assigned to work on **TASK {{`{{`{{`}}`}}task_id{{`}}`}} ONLY**.
    
    **STRICT RULES:**
    1. You MUST ONLY implement Task {{`{{`{{`}}`}}task_id{{`}}`}} - ignore ALL other tasks
    2. DO NOT skip ahead to other tasks, even if you see evidence of previous work
    3. DO NOT implement task-2, task-3, task-4, etc. - ONLY Task {{`{{`{{`}}`}}task_id{{`}}`}}
    4. If you see existing code from other tasks, IGNORE IT
    5. If your memory (CLAUDE.md) mentions other tasks, IGNORE those parts
    6. Focus SOLELY on the requirements in task/prompt.md for Task {{`{{`{{`}}`}}task_id{{`}}`}}
    
    **TASK VERIFICATION:** Before starting, confirm you are working on Task {{`{{`{{`}}`}}task_id{{`}}`}} by stating: \"Starting implementation of Task {{`{{`{{`}}`}}task_id{{`}}`}} only.\"
    
    ---
    
    "
    
            # Add toolman guidance if available
            if [ -f "$CLAUDE_WORK_DIR/task/toolman-guide.md" ]; then
                PROMPT_PREFIX="${PROMPT_PREFIX}🔧 **Tool Usage Reference**
    
    Before starting implementation, you MUST read and follow the task-specific tool guidance in the file \`task/toolman-guide.md\`. This file contains:
    - Selected tools for this specific task
    - When and how to use each tool
    - Tool arguments, parameters, and configuration options
    - Implementation workflow and best practices
    - Tool relationships and sequencing
    
    **The toolman-guide.md is your authoritative reference for tool usage in this task.**
    
    ---
    
    "
                echo "✓ Including task isolation instructions and toolman guidance"
            else
                echo "✓ Including task isolation instructions (no toolman guide found)"
            fi
    
            # Seed initial user turn via a FIFO (system prompts are set via CLI flags, not streamed)
            FIFO_PATH="/workspace/agent-input.jsonl"
            rm -f "$FIFO_PATH" 2>/dev/null || true
            mkfifo "$FIFO_PATH"
            chmod 666 "$FIFO_PATH" || true
    
            # Start Claude (reader) first in background to avoid writer-open blocking
            $CLAUDE_CMD < "$FIFO_PATH" &
            CLAUDE_PID=$!
    
            # Start background token refresh for long-running jobs
            (
                while kill -0 $CLAUDE_PID 2>/dev/null; do
                    sleep 2700  # Check every 45 minutes
    
                    if [ -n "$TOKEN_GENERATED_AT" ] && [ -n "$GITHUB_APP_PRIVATE_KEY" ]; then
                        NOW=$(date +%s)
                        TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))
    
                        if [ $TOKEN_AGE -gt 2700 ]; then
                            echo "[Background] Token is $(($TOKEN_AGE / 60)) minutes old, refreshing..."
                            refresh_github_token
                        fi
                    fi
                done
            ) &
            TOKEN_REFRESH_PID=$!
            echo "✓ Started background token refresh (PID: $TOKEN_REFRESH_PID)"
    
            # Compose initial user turn
            USER_COMBINED=$(printf "%s" "${PROMPT_PREFIX}$(cat "$CLAUDE_WORK_DIR/task/prompt.md")" | jq -Rs .)
    
            # Prefer sending via sidecar HTTP endpoint (opens-writes-closes per request)
            FIFO_OPENED=false
            if printf '{"text":%s}\n' "$USER_COMBINED" | \
                 curl -fsS -X POST http://127.0.0.1:8080/input \
                   -H 'Content-Type: application/json' \
                   --data-binary @- >/dev/null 2>&1; then
              echo "✓ Initial prompt sent via sidecar /input"
            else
              echo "⚠️ Sidecar /input failed, falling back to direct FIFO write"
              # Fallback: open FIFO writer, send prompt, and close immediately to send EOF
              exec 9>"$FIFO_PATH"
              printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]{{`}}`}}\n' "$USER_COMBINED" >&9
              exec 9>&-  # Close immediately to send EOF to Claude
              FIFO_OPENED=false  # Mark as already closed
            fi
    
            # Optional debug: dump FIFO holders if requested
            if [ "${DEBUG_FIFO:-false}" = "true" ]; then
              echo "[DEBUG] Dumping FIFO holders for $FIFO_PATH"
              for p in /proc/[0-9]*; do
                pid=${p##*/}
                [ -d "$p/fd" ] || continue
                for fd in "$p"/fd/*; do
                  tgt=$(readlink "$fd" 2>/dev/null || true)
                  case "$tgt" in *agent-input.jsonl*)
                    fdnum=${fd##*/}
                    comm=$(cat "$p/comm" 2>/dev/null || echo "?")
                    echo "  PID=$pid COMM=$comm FD=$fdnum -> $tgt"
                  ;;
                  esac
                done
              done
            fi
    
            # Optional hang diagnostics without enforcing a timeout
            if [ -n "${HANG_DIAG_SECONDS:-}" ] && [ "$HANG_DIAG_SECONDS" -gt 0 ] 2>/dev/null; then
              (
                sleep "$HANG_DIAG_SECONDS"
                if kill -0 "$CLAUDE_PID" 2>/dev/null; then
                  echo "[DEBUG] Hang diag after ${HANG_DIAG_SECONDS}s: dumping FIFO holders and ps"
                  for p in /proc/[0-9]*; do
                    pid=${p##*/}; [ -d "$p/fd" ] || continue
                    for fd in "$p"/fd/*; do tgt=$(readlink "$fd" 2>/dev/null || true); case "$tgt" in *agent-input.jsonl*) fdnum=${fd##*/}; comm=$(cat "$p/comm" 2>/dev/null || echo "?"); echo "  PID=$pid COMM=$comm FD=$fdnum -> $tgt";; esac; done
                  done
                  ps -eo pid,ppid,comm,args | head -200 || true
                fi
              ) & HANG_DIAG_PID=$!
            fi
    
            # Wait for Claude process to complete naturally
            echo "⏳ Waiting for Claude process (PID: $CLAUDE_PID) to complete..."
    
            # Simple wait - Claude should exit naturally when done
            wait "$CLAUDE_PID"
            CLAUDE_EXIT_CODE=$?
    
            # Stop token refresh background process
            if [ -n "$TOKEN_REFRESH_PID" ]; then
                kill $TOKEN_REFRESH_PID 2>/dev/null || true
                echo "✓ Stopped token refresh process"
            fi
    
            if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
              echo "✅ Claude process completed successfully"
            else
              echo "⚠️ Claude process exited with code: $CLAUDE_EXIT_CODE"
            fi
    
            # Stop diagnostics if running
            if [ -n "${HANG_DIAG_PID:-}" ]; then kill "$HANG_DIAG_PID" 2>/dev/null || true; fi
    
            # Ensure FIFO cleanup happens regardless of how Claude exited
            echo "🔧 Performing FIFO cleanup..."
    
            # Close FIFO writer if it was opened (in fallback)
            if [ "$FIFO_OPENED" = "true" ]; then
              echo "🔧 Closing FIFO file descriptor..."
              # Try multiple methods to ensure fd 9 gets closed
              exec 9>&- 2>/dev/null || {
                echo "⚠️ exec 9>&- failed, trying alternative close method"
                eval "exec 9>&-" 2>/dev/null || {
                  echo "⚠️ Alternative close failed, FIFO fd may remain open"
                }
              }
            else
              echo "ℹ️ FIFO was not opened via fallback, checking sidecar"
            fi
    
            # Clean up FIFO file to ensure no processes are blocked
            if [ -p "$FIFO_PATH" ]; then
              echo "🔧 Removing FIFO to ensure clean shutdown"
              rm -f "$FIFO_PATH" 2>/dev/null || echo "⚠️ Could not remove FIFO"
            fi
    
            # Gracefully stop sidecar to allow Job to complete (all containers must exit)
            echo "🔧 Attempting sidecar shutdown..."
            shutdown_attempts=0
            max_shutdown_attempts=3
    
            while [ $shutdown_attempts -lt $max_shutdown_attempts ]; do
              if timeout 5 curl -fsS -X POST http://127.0.0.1:8080/shutdown >/dev/null 2>&1; then
                echo "✓ Sidecar shutdown request successful (attempt $((shutdown_attempts + 1)))"
                break
              else
                shutdown_attempts=$((shutdown_attempts + 1))
                echo "⚠️ Sidecar shutdown request failed (attempt $shutdown_attempts/$max_shutdown_attempts)"
                if [ $shutdown_attempts -lt $max_shutdown_attempts ]; then
                  echo "Retrying in 2 seconds..."
                  sleep 2
                fi
              fi
            done
    
            if [ $shutdown_attempts -eq $max_shutdown_attempts ]; then
              echo "❌ Failed to shutdown sidecar after $max_shutdown_attempts attempts"
              echo "🔧 Force terminating sidecar processes..."
              pkill -f "sidecar" || echo "No sidecar processes found to kill"
            fi
    
            # Wait for sidecar to actually terminate
            echo "⏳ Waiting for sidecar termination..."
            timeout=10
            while [ $timeout -gt 0 ]; do
              if ! pgrep -f "sidecar" > /dev/null 2>&1; then
                echo "✅ Sidecar terminated successfully"
                break
              fi
              sleep 1
              timeout=$((timeout - 1))
            done
    
            if [ $timeout -eq 0 ]; then
              echo "⚠️ Sidecar still running after wait period"
            fi
        else
            echo "❌ ERROR: No prompt.md found from docs service"
            echo "The docs service should always provide task/prompt.md"
            echo "Check docs repository and task configuration"
            exit 1
        fi
    fi
    
    echo '════════════════════════════════════════════════════════════════'
    echo '║                 IMPLEMENTATION TASK COMPLETE                 ║'
    echo '════════════════════════════════════════════════════════════════'
    
    # Claude execution completed - no hooks configured
    echo "Claude has completed successfully."
    
    # =============================================================================
    # PR DETECTION AND LABELING
    # =============================================================================
    # After Claude completes, check if a PR was created and apply correlation labels
    if [ -n "${GITHUB_TOKEN:-}" ] && command -v gh >/dev/null 2>&1; then
      echo "🔍 Checking for PRs created by this task..."
    
      # First, try to find PR by task label (Claude should have added task-N label)
      TASK_LABEL="task-${TASK_ID}"
      PR_NUMBER=$(gh pr list -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --label "$TASK_LABEL" --json number --jq '.[0].number' 2>/dev/null || true)
    
      # If not found by label, try by branch name (current branch)
      if [ -z "$PR_NUMBER" ]; then
        CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)
        if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "main" ]; then
          PR_NUMBER=$(gh pr list -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || true)
        fi
      fi
    
      if [ -n "$PR_NUMBER" ]; then
        echo "✅ Found PR #${PR_NUMBER}"
    
        # Get the PR URL
        PR_URL="https://github.com/{{`{{`{{`}}`}}docs_repository_url{{`}}`}}/pull/${PR_NUMBER}"
        echo "📝 PR URL: $PR_URL"
    
        # Update CodeRun status with PR URL via Kubernetes API
        echo "🔄 Updating CodeRun status with PR URL..."
        if command -v kubectl >/dev/null 2>&1; then
          # Create a patch to update the CodeRun status
          PATCH_JSON=$(cat <<EOF
    {
      "status": {
        "pullRequestUrl": "$PR_URL",
        "lastUpdate": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
      }
    }
    EOF
    )
    
          # Apply the patch to update CodeRun status
          if kubectl patch coderun "$CODERUN_NAME" -n "$NAMESPACE" --type=merge --subresource=status -p "$PATCH_JSON" 2>/dev/null; then
            echo "✅ Updated CodeRun status with PR URL"
          else
            echo "⚠️ Failed to update CodeRun status (kubectl patch failed)"
          fi
        else
          echo "⚠️ kubectl not available, cannot update CodeRun status"
        fi
    
        # Apply correlation labels with comprehensive debugging
        echo "🏷️ Adding correlation labels to PR #${PR_NUMBER}..."
    
        # Debug: Check environment variables
        echo "🔍 DEBUG: Environment check for label creation:"
        echo "   TASK_ID: '${TASK_ID}'"
        echo "   WORKFLOW_NAME: '${WORKFLOW_NAME}'"
        echo "   SERVICE_NAME: '${SERVICE_NAME}'"
        echo "   CODERUN_NAME: '${CODERUN_NAME}'"
        echo "   GitHub Token: $([ -n "$GITHUB_TOKEN" ] && echo 'Present' || echo 'Missing')"
    
        # Validate required variables
        if [ -z "$WORKFLOW_NAME" ]; then
          echo "❌ ERROR: WORKFLOW_NAME is not set!"
          echo "🔍 DEBUG: Attempting to extract from CODERUN_NAME..."
          # Try to extract workflow name from CodeRun name pattern
          if [ -n "$CODERUN_NAME" ]; then
            # Pattern: service-t{task}-stage-{hash} created by workflow
            echo "   CODERUN_NAME format: $CODERUN_NAME"
          fi
    
          # Check if we can get it from Kubernetes labels
          if command -v kubectl >/dev/null 2>&1 && [ -n "$CODERUN_NAME" ] && [ -n "$NAMESPACE" ]; then
            echo "🔍 DEBUG: Trying to get workflow name from CodeRun labels..."
            WORKFLOW_FROM_LABELS=$(kubectl get coderun "$CODERUN_NAME" -n "$NAMESPACE" -o jsonpath='{.metadata.labels.workflow-name}' 2>/dev/null || echo "")
            if [ -n "$WORKFLOW_FROM_LABELS" ]; then
              echo "✅ Found workflow name from CodeRun labels: $WORKFLOW_FROM_LABELS"
              WORKFLOW_NAME="$WORKFLOW_FROM_LABELS"
            else
              echo "❌ Could not retrieve workflow name from CodeRun labels"
            fi
          fi
    
          # Final check - if still no workflow name, fail loudly
          if [ -z "$WORKFLOW_NAME" ]; then
            echo "❌ CRITICAL: Cannot determine WORKFLOW_NAME - this will cause correlation issues!"
            echo "🔍 DEBUG: Available environment variables:"
            env | grep -E "WORKFLOW|CODERUN|TASK|SERVICE" | sort
            # DO NOT use 'unknown' - exit with error instead
            echo "❌ Refusing to use 'unknown' label - failing task"
            exit 1
          fi
        fi
    
        TASK_LABEL="task-${TASK_ID}"
        RUN_LABEL="run-${WORKFLOW_NAME}"
        SERVICE_LABEL="service-${SERVICE_NAME}"
    
        echo "📋 Labels to apply:"
        echo "   Task: $TASK_LABEL"
        echo "   Run: $RUN_LABEL"
        echo "   Service: $SERVICE_LABEL"
    
        # Try to add labels with detailed error capture
        echo "🔍 DEBUG: Attempting to add labels to PR..."
        LABEL_ERROR=$(gh pr edit "$PR_NUMBER" -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --add-label "${TASK_LABEL},${RUN_LABEL},${SERVICE_LABEL}" 2>&1)
        LABEL_EXIT_CODE=$?
    
        if [ $LABEL_EXIT_CODE -eq 0 ]; then
          echo "✅ Added correlation labels successfully"
        else
          echo "⚠️ Failed to add labels (exit code: $LABEL_EXIT_CODE)"
          echo "🔍 DEBUG: Error output: $LABEL_ERROR"
    
          # Check if labels exist
          echo "🔍 DEBUG: Checking which labels exist..."
          for label in "$TASK_LABEL" "$RUN_LABEL" "$SERVICE_LABEL"; do
            if gh label list -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --search "$label" | grep -q "^$label"; then
              echo "   ✓ Label '$label' exists"
            else
              echo "   ✗ Label '$label' does not exist"
              # Create the missing label
              echo "   📝 Creating label '$label'..."
              case "$label" in
                task-*) COLOR="f29513"; DESC="Task correlation" ;;
                run-*) COLOR="0366d6"; DESC="Workflow run correlation" ;;
                service-*) COLOR="0e8a16"; DESC="Service correlation" ;;
                *) COLOR="ededed"; DESC="Unknown label type" ;;
              esac
    
              CREATE_ERROR=$(gh label create "$label" -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --color "$COLOR" --description "$DESC" 2>&1)
              CREATE_EXIT=$?
              if [ $CREATE_EXIT -eq 0 ]; then
                echo "   ✅ Created label '$label'"
              else
                echo "   ❌ Failed to create label '$label': $CREATE_ERROR"
              fi
            fi
          done
    
          # Retry adding labels with individual attempts
          echo "🔍 DEBUG: Retrying label addition individually..."
          LABELS_ADDED=0
          for label in "$TASK_LABEL" "$RUN_LABEL" "$SERVICE_LABEL"; do
            RETRY_ERROR=$(gh pr edit "$PR_NUMBER" -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --add-label "$label" 2>&1)
            RETRY_EXIT=$?
            if [ $RETRY_EXIT -eq 0 ]; then
              echo "   ✅ Added label '$label'"
              LABELS_ADDED=$((LABELS_ADDED + 1))
            else
              echo "   ❌ Failed to add label '$label': $RETRY_ERROR"
            fi
          done
    
          if [ $LABELS_ADDED -eq 3 ]; then
            echo "✅ All labels added successfully after retry"
          elif [ $LABELS_ADDED -gt 0 ]; then
            echo "⚠️ Partial success: $LABELS_ADDED/3 labels added"
          else
            echo "❌ CRITICAL: Could not add any labels to PR"
            echo "🔍 DEBUG: Checking PR state..."
            PR_STATE=$(gh pr view "$PR_NUMBER" -R "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" --json state -q .state 2>/dev/null || echo "UNKNOWN")
            echo "   PR State: $PR_STATE"
            if [ "$PR_STATE" = "CLOSED" ] || [ "$PR_STATE" = "MERGED" ]; then
              echo "❌ PR is $PR_STATE - cannot add labels to closed/merged PRs"
            fi
          fi
        fi
      else
        echo "ℹ️ No PR found for this task (Claude may not have created one)"
      fi
    else
      echo "ℹ️ Skipping PR labeling: missing GITHUB_TOKEN or gh CLI"
    fi
    
    # Write sentinel file to signal sidecar to stop (Kubernetes-native file watch)
    touch /workspace/.agent_done 2>/dev/null || true
    
    # Final termination sequence
    echo '════════════════════════════════════════════════════════════════'
    echo '║                 REX CONTAINER TERMINATION                    ║'
    echo '════════════════════════════════════════════════════════════════'
    echo "Container PID: $$"
    echo "Final Process Check:"
    ps aux | head -5
    
    # Write completion marker for workflow tracking
    echo "rex-implementation-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.rex-complete
    
    # Force exit to terminate the pod
    echo "🔚 Force terminating container..."
  code_container-tess.sh.hbs: |
    #!/bin/sh
    
    # CRITICAL: Clean up sentinel file IMMEDIATELY to prevent sidecar from shutting down
    # This MUST happen before anything else, as the sidecar starts before our script
    if [ -f /workspace/.agent_done ]; then
        echo "🧹 URGENT: Removing leftover sentinel file from previous run"
        rm -f /workspace/.agent_done
    fi
    
    # Also clean up Tess completion marker if present
    if [ -f /workspace/.tess-complete ]; then
        echo "🧹 Removing Tess completion marker from previous run"
        rm -f /workspace/.tess-complete
    fi
    
    # Ensure Rust environment is always properly set up
    echo "🔧 Setting up Rust environment..."
    
    # Source Rust environment if available (fixes cargo not found issues)
    # Try multiple possible locations for Rust environment
    RUST_ENV_SOURCES=(
        "$HOME/.cargo/env"
        "/root/.cargo/env"
        "/usr/local/cargo/env"
        "/home/ubuntu/.cargo/env"
        "/home/user/.cargo/env"
    )
    
    for env_file in "${RUST_ENV_SOURCES[@]}"; do
        if [ -f "$env_file" ]; then
            echo "✓ Sourcing Rust environment from $env_file"
            . "$env_file"
            # Export PATH explicitly after sourcing
            export PATH="$HOME/.cargo/bin:/usr/local/cargo/bin:$PATH"
            break
        fi
    done
    
    # Ensure rustup has a default toolchain set
    if command -v rustup >/dev/null 2>&1; then
        echo "✓ Rustup found, ensuring stable toolchain is default..."
        rustup default stable 2>/dev/null || true
        # Re-source environment after setting default
        if [ -f "$HOME/.cargo/env" ]; then
            . "$HOME/.cargo/env"
        elif [ -f "/root/.cargo/env" ]; then
            . "/root/.cargo/env"
        fi
        export PATH="$HOME/.cargo/bin:/usr/local/cargo/bin:$PATH"
        echo "✓ Ensured stable Rust toolchain is default"
    else
        echo "⚠️ rustup not found in PATH"
    fi
    
    # Verify Rust is available with multiple fallback attempts
    if command -v cargo >/dev/null 2>&1; then
        echo "✓ Cargo is available: $(cargo --version)"
    elif [ -f "/usr/local/cargo/bin/cargo" ]; then
        echo "✓ Found cargo at /usr/local/cargo/bin/cargo"
        export PATH="/usr/local/cargo/bin:$PATH"
        echo "✓ Cargo is available: $(cargo --version)"
    elif [ -f "$HOME/.cargo/bin/cargo" ]; then
        echo "✓ Found cargo at $HOME/.cargo/bin/cargo"
        export PATH="$HOME/.cargo/bin:$PATH"
        echo "✓ Cargo is available: $(cargo --version)"
    else
        echo "❌ Cargo not found in PATH"
        echo "Current PATH: $PATH"
        echo "Attempting to find cargo..."
        find /usr -name cargo 2>/dev/null | head -5 || echo "No cargo found in /usr"
        find /home -name cargo 2>/dev/null | head -5 || echo "No cargo found in /home"
        find /root -name cargo 2>/dev/null | head -5 || echo "No cargo found in /root"
        # Try to install Rust as last resort
        echo "🔧 Attempting to install Rust via rustup..."
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y || true
        . "$HOME/.cargo/env" || true
        export PATH="$HOME/.cargo/bin:$PATH"
        if command -v cargo >/dev/null 2>&1; then
            echo "✓ Cargo installed and available: $(cargo --version)"
        else
            echo "❌ Failed to install Rust, continuing without cargo..."
        fi
    fi
    
    echo '════════════════════════════════════════════════════════════════'
    echo '║              TESS TESTING WORKFLOW STARTING                  ║'
    echo '║         Quality Assurance & Deployment Testing Agent         ║'
    echo '════════════════════════════════════════════════════════════════'
    echo "🎯 Agent: {{`{{`{{`}}`}}github_app{{`}}`}}"
    echo "🧪 Focus: Comprehensive testing, deployment validation, test coverage"
    echo "📋 Task ID: {{`{{`{{`}}`}}task_id{{`}}`}}"
    echo "✅ Mission: 120% satisfaction through exhaustive testing"
    echo "🔍 Debug Session: $(date '+%Y-%m-%d %H:%M:%S') - PID: $$"
    echo "📊 Log Level: DEBUG (showing JSON construction details)"
    
    # Disable interactive Git prompts globally
    export GIT_TERMINAL_PROMPT=0
    export GIT_ASKPASS=/bin/true
    export SSH_ASKPASS=/bin/true
    
    # Repository URL
    REPO_URL="{{`{{`{{`}}`}}repository_url{{`}}`}}"
    
    # GitHub App authentication is configured via environment variables
    echo "Using GitHub App authentication for testing workflow"
    
    # Function to ensure sidecar shutdown
    shutdown_sidecar() {
      echo "🔧 Signaling sidecar to shutdown..."
      touch /workspace/.agent_done 2>/dev/null || true
    
      echo "🔧 Attempting sidecar shutdown..."
      local shutdown_attempts=0
      local max_shutdown_attempts=3
    
      while [ $shutdown_attempts -lt $max_shutdown_attempts ]; do
        if timeout 5 curl -fsS -X POST http://127.0.0.1:8080/shutdown >/dev/null 2>&1; then
          echo "✓ Sidecar shutdown request successful (attempt $((shutdown_attempts + 1)))"
          break
        else
          shutdown_attempts=$((shutdown_attempts + 1))
          echo "⚠️ Sidecar shutdown request failed (attempt $shutdown_attempts/$max_shutdown_attempts)"
          if [ $shutdown_attempts -lt $max_shutdown_attempts ]; then
            echo "Retrying in 2 seconds..."
            sleep 2
          fi
        fi
      done
    
      if [ $shutdown_attempts -eq $max_shutdown_attempts ]; then
        echo "❌ Failed to shutdown sidecar after $max_shutdown_attempts attempts"
        echo "⚠️ Cannot force terminate sidecar from this container (PID namespace isolation)"
        echo "📝 Sidecar may still be running - Kubernetes will handle cleanup on pod termination"
      fi
    }
    
    # Authenticate with GitHub App
    if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
        echo "Authenticating with GitHub App..."
    
        # Create temporary private key file (support escaped newlines)
        TEMP_KEY_FILE="/tmp/github-app-key.pem"
        printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
        chmod 600 "$TEMP_KEY_FILE"
    
        # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
        # JWT header
        JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
        # JWT payload with current time and expiration (10 minutes)
        NOW=$(date +%s)
        EXP=$((NOW + 600))
        JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
        # Sign the JWT
        JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
        JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
        # Get installation ID for the repository (robust parsing of owner/repo)
        INPUT_REPO="{{`{{`{{`}}`}}repository_url{{`}}`}}"
        REPO_OWNER=""
        REPO_NAME=""
    
        if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
            REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
            REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
        elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
            # SSH format git@github.com:owner/repo(.git)
            REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
            REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
        else
            # Fallback: assume slug owner/repo (possibly with .git)
            SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
            REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
            REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
        fi
    
        echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"
    
        echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
        # Get the installation ID (retry and follow redirects). Fallback to org installation.
        INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")
    
        INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')
    
        if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
            echo "⚠️ Repo installation not found, trying org installation..."
            ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
                --connect-timeout 5 --max-time 12 \
                -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/orgs/$REPO_OWNER/installation")
            INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
        fi
    
        if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
            echo "❌ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
            echo "Response (repo): $INSTALLATION_RESPONSE"
            echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
            rm -f "$TEMP_KEY_FILE"
            exit 1
        fi
    
        echo "Installation ID: $INSTALLATION_ID"
    
        # Get installation access token
        TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
        GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
        TOKEN_GENERATED_AT=$(date +%s)  # Track when token was generated for refresh logic
    
        if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
            echo "❌ Failed to get installation access token"
            echo "Response: $TOKEN_RESPONSE"
            rm -f "$TEMP_KEY_FILE"
            exit 1
        fi
    
        echo "✅ Successfully authenticated with GitHub App"
    
        # Clean up temporary key file
        rm -f "$TEMP_KEY_FILE"
    
        # Export the token for git to use
        export GITHUB_TOKEN
    
        # Configure git to use the token (use --replace-all to handle multiple existing helpers)
        git config --global --replace-all credential.helper store
        echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    
        # Also authenticate gh CLI with the token
        echo "$GITHUB_TOKEN" | gh auth login --with-token
    
        # Token refresh functions for long-running jobs
        refresh_github_token() {
            echo "🔄 Refreshing GitHub App token..."
    
            # Create temporary key file
            TEMP_KEY_FILE="/tmp/github-app-key-$$"
            echo "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
            chmod 600 "$TEMP_KEY_FILE"
    
            # Generate new JWT
            JWT_TOKEN=$(ruby -r openssl -r json -r base64 -e "
            key = OpenSSL::PKey::RSA.new(File.read('$TEMP_KEY_FILE'))
            payload = {
                iat: Time.now.to_i - 60,
                exp: Time.now.to_i + (10 * 60),
                iss: '$GITHUB_APP_ID'
            }
            header = { alg: 'RS256', typ: 'JWT' }
    
            header_enc = Base64.urlsafe_encode64(header.to_json).gsub('=', '')
            payload_enc = Base64.urlsafe_encode64(payload.to_json).gsub('=', '')
            signature = Base64.urlsafe_encode64(key.sign(OpenSSL::Digest::SHA256.new, \"#{header_enc}.#{payload_enc}\")).gsub('=', '')
    
            puts \"#{header_enc}.#{payload_enc}.#{signature}\"
            ")
    
            # Get installation ID (reuse logic from initial auth)
            INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation" | jq -r '.id')
    
            if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
                INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
                    -H "Accept: application/vnd.github+json" \
                    "https://api.github.com/orgs/$REPO_OWNER/installation" | jq -r '.id')
            fi
    
            # Get new installation token
            TOKEN_RESPONSE=$(curl -s -X POST \
                -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
            NEW_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
            if [ "$NEW_TOKEN" != "null" ] && [ -n "$NEW_TOKEN" ]; then
                export GITHUB_TOKEN="$NEW_TOKEN"
                export TOKEN_GENERATED_AT=$(date +%s)
    
                # Update git credentials
                echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
                echo "$GITHUB_TOKEN" | gh auth login --with-token 2>/dev/null
    
                echo "✅ Token refreshed successfully"
                rm -f "$TEMP_KEY_FILE"
                return 0
            else
                echo "❌ Failed to refresh token: $TOKEN_RESPONSE"
                rm -f "$TEMP_KEY_FILE"
                return 1
            fi
        }
    
        # Check if token needs refresh (call before git operations)
        refresh_token_if_needed() {
            if [ -z "$TOKEN_GENERATED_AT" ]; then
                echo "⚠️ No token timestamp found, refreshing token..."
                refresh_github_token
                return
            fi
    
            NOW=$(date +%s)
            TOKEN_AGE=$((NOW - TOKEN_GENERATED_AT))
    
            # Refresh if token is older than 50 minutes (tokens last 1 hour, refresh at 50 min to be safe)
            if [ $TOKEN_AGE -gt 3000 ]; then
                echo "🔄 Token is $(($TOKEN_AGE / 60)) minutes old, refreshing..."
                refresh_github_token
            fi
        }
    
    else
        echo "❌ GitHub App credentials not found"
        exit 1
    fi
    
    # Set working directory for the agent
    # Set Working Directory (Critical for Claude Execution) - Match Rex pattern
    WORK_DIR="{{`{{`{{`}}`}}working_directory{{`}}`}}"
    if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
      CLAUDE_WORK_DIR="/workspace/$REPO_NAME"
    else
      CLAUDE_WORK_DIR="/workspace/$REPO_NAME/$WORK_DIR"
    fi
    mkdir -p "$CLAUDE_WORK_DIR"
    cd "$CLAUDE_WORK_DIR"
    
    # Prepare environment for testing
    echo "════════════════════════════════════════════════════════════════"
    echo "🧪 PREPARING TESTING ENVIRONMENT"
    echo "════════════════════════════════════════════════════════════════"
    
    # Git configuration with proper GitHub App attribution
    git config --global --add safe.directory /workspace
    
    # Set GitHub App attribution - use generic format for all agents
    GITHUB_APP="{{`{{`{{`}}`}}github_app{{`}}`}}"
    # Generic attribution that works for any agent
    GIT_AUTHOR_NAME="${GITHUB_APP} Agent (Claude Code)"
    GIT_AUTHOR_EMAIL="${GITHUB_APP}[bot]@users.noreply.github.com"
    
    # Configure git with proper GitHub App attribution
    git config --global user.name "$GIT_AUTHOR_NAME"
    git config --global user.email "$GIT_AUTHOR_EMAIL"
    
    # Set environment variables for Claude Code to use
    export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
    export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
    export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
    export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
    echo "✓ Git configured"
    
    # =============================================================================
    # AUTHENTICATION VERIFICATION
    # =============================================================================
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "🔐 AUTHENTICATION VERIFICATION"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""
    
    # Repository URLs - Handle both full URLs and org/repo format
    # Check if repository_url already contains https://github.com/
    if echo "{{`{{`{{`}}`}}repository_url{{`}}`}}" | grep -q "^https://github.com/"; then
        REPO_HTTP_URL="{{`{{`{{`}}`}}repository_url{{`}}`}}"
        if ! echo "{{`{{`{{`}}`}}repository_url{{`}}`}}" | grep -q "\.git$"; then
            REPO_HTTP_URL="${REPO_HTTP_URL}.git"
        fi
    else
        REPO_HTTP_URL="https://github.com/{{`{{`{{`}}`}}repository_url{{`}}`}}.git"
    fi
    
    # Same for docs repository
    if echo "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" | grep -q "^https://github.com/"; then
        DOCS_HTTP_URL="{{`{{`{{`}}`}}docs_repository_url{{`}}`}}"
        if ! echo "{{`{{`{{`}}`}}docs_repository_url{{`}}`}}" | grep -q "\.git$"; then
            DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
        fi
    else
        DOCS_HTTP_URL="https://github.com/{{`{{`{{`}}`}}docs_repository_url{{`}}`}}.git"
    fi
    
    # DEBUG: Show what URLs are being constructed
    echo "🔍 DEBUG: URL Construction & Parameters"
    echo "  Input repository_url: '{{`{{`{{`}}`}}repository_url{{`}}`}}'"
    echo "  Input docs_repository_url: '{{`{{`{{`}}`}}docs_repository_url{{`}}`}}'"
    echo "  Input docs_project_directory: '{{`{{`{{`}}`}}docs_project_directory{{`}}`}}'"
    echo "  Input working_directory: '{{`{{`{{`}}`}}working_directory{{`}}`}}'"
    echo "  Input docs_branch: '{{`{{`{{`}}`}}docs_branch{{`}}`}}'"
    echo "  Input github_app: '{{`{{`{{`}}`}}github_app{{`}}`}}'"
    echo "  Input task_id: '{{`{{`{{`}}`}}task_id{{`}}`}}'"
    echo "  Input service: '{{`{{`{{`}}`}}service{{`}}`}}'"
    echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
    echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
    echo "  Current working directory: $(pwd)"
    echo "  Available environment variables:"
    env | grep -E "(GITHUB|ANTHROPIC)" | sort
    
    # Test HTTPS access to repository
    echo "🔍 DEBUG: Testing HTTPS repository access..."
    echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
    if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
      echo "✓ HTTPS repository access successful"
      echo "  Repository: {{`{{`{{`}}`}}repository_url{{`}}`}} ($REPO_HTTP_URL)"
      echo "  Output: $(cat /tmp/repo_test.out | head -1)"
    else
      echo "❌ HTTPS repository access failed"
      echo "  Repository: {{`{{`{{`}}`}}repository_url{{`}}`}} ($REPO_HTTP_URL)"
      echo "  Error output: $(cat /tmp/repo_test.out)"
      echo "  Git credential helper status:"
      git config --list | grep credential || echo "  No credential helpers configured"
      echo ""
      echo "🚫 ABORTING: Cannot access repository via HTTPS"
      exit 1
    fi
    
    # Test docs repository access
    echo "🔍 DEBUG: Testing docs repository access..."
    echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
    if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
      echo "✓ Docs repository access successful"
      echo "  Repository: {{`{{`{{`}}`}}docs_repository_url{{`}}`}} ($DOCS_HTTP_URL)"
      echo "  Output: $(cat /tmp/docs_test.out | head -1)"
    else
      echo "❌ Docs repository access failed"
      echo "  Repository: {{`{{`{{`}}`}}docs_repository_url{{`}}`}} ($DOCS_HTTP_URL)"
      echo "  Error output: $(cat /tmp/docs_test.out)"
      echo ""
      echo "🚫 ABORTING: Cannot access docs repository via HTTPS"
      exit 1
    fi
    
    # Clone or update repository (directly to Claude working directory)
    if [ -d "$CLAUDE_WORK_DIR/.git" ]; then
        echo "📁 Found existing repository at working directory, updating..."
        cd "$CLAUDE_WORK_DIR"
        git fetch origin --prune
    else
        # Ensure parent directories exist
        mkdir -p "$(dirname "$CLAUDE_WORK_DIR")"
    
        # If directory exists but isn't a git repo, remove it first
        if [ -d "$CLAUDE_WORK_DIR" ] && [ ! -d "$CLAUDE_WORK_DIR/.git" ]; then
            echo "🧹 Removing non-git directory to prepare for clone..."
            rm -rf "$CLAUDE_WORK_DIR"
        fi
    
        echo "📥 Cloning repository to working directory..."
        # Make sure parent directory exists and we're in a valid location
        PARENT_DIR="$(dirname "$CLAUDE_WORK_DIR")"
        mkdir -p "$PARENT_DIR"
        cd "$PARENT_DIR"
    
        # Use the REPO_HTTP_URL constructed in authentication verification section
        if ! git clone "$REPO_HTTP_URL" "$(basename "$CLAUDE_WORK_DIR")"; then
            echo "❌ Failed to clone repository"
            echo "Debug: CLAUDE_WORK_DIR=$CLAUDE_WORK_DIR"
            echo "Debug: Parent directory exists: $(ls -la "$PARENT_DIR" 2>/dev/null || echo 'No')"
            exit 1
        fi
        cd "$(basename "$CLAUDE_WORK_DIR")"
    fi
    
    # Utility function for safe Git operations
    safe_git_pull() {
        local remote="$1"
        local branch="$2"
    
        echo "📥 Attempting to pull from $remote/$branch..."
    
        # Try rebase first (cleaner history)
        if git pull --rebase "$remote" "$branch" 2>/dev/null; then
            echo "✓ Successfully pulled with rebase"
            return 0
        fi
    
        # Try merge if rebase fails
        if git pull --no-rebase "$remote" "$branch" 2>/dev/null; then
            echo "✓ Successfully pulled with merge"
            return 0
        fi
    
        # If both fail, show current status and continue
        echo "⚠️ Could not pull due to divergent branches or conflicts"
        echo "📍 Current commit: $(git rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
        echo "📍 Local changes: $(git status --porcelain | wc -l) files modified"
        echo "📍 Continuing with current branch state"
        return 1
    }
    
    # Checkout PR branch for testing review
    if [ -n "$PR_NUMBER" ] && [ -n "$PR_URL" ]; then
        echo "🔄 Checking out PR #$PR_NUMBER for QA testing..."
        cd "$CLAUDE_WORK_DIR"
        git fetch origin --prune
        PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName' 2>/dev/null || echo "")
        if [ -n "$PR_BRANCH" ]; then
            # Try to checkout/create the branch
            if git checkout "$PR_BRANCH" 2>/dev/null; then
                echo "✓ Checked out existing branch: $PR_BRANCH"
            else
                echo "📝 Creating new local branch from remote: $PR_BRANCH"
                if git checkout -b "$PR_BRANCH" "origin/$PR_BRANCH" 2>/dev/null; then
                    echo "✓ Created new branch: $PR_BRANCH"
                else
                    echo "⚠️ Could not create branch $PR_BRANCH, staying on current branch"
                    # Skip to the next part without the continue
                fi
            fi
    
            # Only attempt pull if we successfully checked out/created the branch
            if [ "$(git rev-parse --abbrev-ref HEAD 2>/dev/null)" = "$PR_BRANCH" ]; then
                # Handle divergent branches gracefully using utility function
                if ! safe_git_pull origin "$PR_BRANCH"; then
                    echo "📍 Continuing with current branch state for testing"
                fi
            fi
            echo "✓ Checked out PR branch: $PR_BRANCH"
        else
            echo "⚠️ Could not determine PR branch name, staying on default branch"
        fi
    
        # Add PR context to CLAUDE.md for reference
        echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
        echo "# PR Context for Testing" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
        echo "- **PR Number**: $PR_NUMBER" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
        echo "- **PR URL**: $PR_URL" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
        echo "- **Branch**: $PR_BRANCH" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
        echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    else
        echo "ℹ️ No PR context provided - working on default branch"
    fi
    
    echo "════════════════════════════════════════════════════════════════"
    echo "🔧 TESTING INFRASTRUCTURE SETUP"
    echo "════════════════════════════════════════════════════════════════"
    
    # Setup Kubernetes admin access if available
    if [ -f "/etc/kube/config" ]; then
        export KUBECONFIG=/etc/kube/config
        echo "✅ Kubernetes admin access configured"
        kubectl version --client 2>/dev/null || echo "⚠️ kubectl not available"
    fi
    
    # Setup database admin credentials if available
    if [ -n "$POSTGRES_ADMIN_PASSWORD" ]; then
        export PGPASSWORD="$POSTGRES_ADMIN_PASSWORD"
        echo "✅ PostgreSQL admin credentials configured"
    fi
    
    if [ -n "$REDIS_ADMIN_PASSWORD" ]; then
        export REDIS_PASSWORD="$REDIS_ADMIN_PASSWORD"
        echo "✅ Redis admin credentials configured"
    fi
    
    # Setup Argo CD admin access if available
    if [ -n "$ARGOCD_ADMIN_TOKEN" ]; then
        export ARGOCD_AUTH_TOKEN="$ARGOCD_ADMIN_TOKEN"
        echo "✅ Argo CD admin access configured"
    fi
    
    echo "════════════════════════════════════════════════════════════════"
    echo "📋 TESTING WORKFLOW REQUIREMENTS"
    echo "════════════════════════════════════════════════════════════════"
    echo ""
    echo "PHASE 0: CI/CD Setup (IMMEDIATE PRIORITY)"
    echo "- Set up GitHub Actions CI pipeline if not exists"
    echo "- Add test running and coverage reporting to CI"
    echo "- Configure branch protection rules with test gates"
    echo "- Ensure tests must pass before merge"
    echo "- Do this AS SOON as there's enough code to test"
    echo ""
    echo "PHASE 1: Acceptance Criteria Validation"
    echo "- Review implementation against acceptance criteria (NOT architecture)"
    echo "- Verify ALL acceptance criteria are fully met"
    echo "- Focus on task/acceptance-criteria.md requirements"
    echo "- Add PR comments for any missing acceptance criteria"
    echo ""
    echo "PHASE 2: Test Writing (PRIMARY RESPONSIBILITY)"
    echo "- Write comprehensive unit tests for all code"
    echo "- Write integration tests for all features"
    echo "- AIM FOR 100% TEST COVERAGE - this is critical!"
    echo "- Ensure all tests pass before approval"
    echo "- Push test files to the PR branch"
    echo "- ONLY write test files (*_test.*, *.test.*, etc.)"
    echo "- NEVER modify implementation/business logic code"
    echo ""
    echo "PHASE 3: Manual Testing & Validation"
    echo "- Run the test suite and verify coverage"
    echo "- Test application functionality manually"
    echo "- Verify no regressions introduced"
    echo "- Document findings in PR comments"
    echo ""
    echo "CRITICAL: Set up CI gates early & achieve 100% coverage!"
    echo "════════════════════════════════════════════════════════════════"
    
    # Copy task files if docs repository is specified
    {{`{{`{{`}}`}}#if docs_repository_url{{`}}`}}
    echo "📋 Copying task files from documentation repository..."
    DOCS_REPO_URL="{{`{{`{{`}}`}}docs_repository_url{{`}}`}}"
    DOCS_BRANCH="{{`{{`{{`}}`}}#if docs_branch{{`}}`}}{{`{{`{{`}}`}}docs_branch{{`}}`}}{{`{{`{{`}}`}}else{{`}}`}}main{{`{{`{{`}}`}}/if{{`}}`}}"
    DOCS_HTTP_URL=$(echo "$DOCS_REPO_URL" | sed "s|https://github.com/|https://x-access-token:${GITHUB_TOKEN}@github.com/|")
    
    if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo 2>/dev/null; then
        echo "❌ Failed to clone docs repository from $DOCS_REPO_URL"
        echo "📍 This may be due to authentication or network issues"
        echo "📍 Continuing without task files from docs repository"
    else
        cd /tmp/docs-repo || {
            echo "⚠️ Could not change to docs repository directory"
            cd "$CLAUDE_WORK_DIR"
        }
    
        # Try to checkout the docs branch with error handling
        if git checkout "$DOCS_BRANCH" 2>/dev/null; then
            echo "✓ Checked out docs branch: $DOCS_BRANCH"
            cd "$CLAUDE_WORK_DIR"
        else
            echo "⚠️ Could not checkout docs branch $DOCS_BRANCH"
            echo "📍 Available branches: $(git branch -r 2>/dev/null | head -5 || echo 'unknown')"
            cd "$CLAUDE_WORK_DIR"
        fi
    fi
    
    # Copy task files
    mkdir -p "$CLAUDE_WORK_DIR/task"
    {{`{{`{{`}}`}}#if docs_project_directory{{`}}`}}
    if [ "{{`{{`{{`}}`}}docs_project_directory{{`}}`}}" = "." ]; then
        DOCS_PATH="/tmp/docs-repo/.taskmaster"
    else
        DOCS_PATH="/tmp/docs-repo/{{`{{`{{`}}`}}docs_project_directory{{`}}`}}/.taskmaster"
    fi
    {{`{{`{{`}}`}}else{{`}}`}}
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
    {{`{{`{{`}}`}}/if{{`}}`}}
    
    TASK_DIR="$DOCS_PATH/docs/task-{{`{{`{{`}}`}}task_id{{`}}`}}"
    if [ -d "$TASK_DIR" ]; then
        cp "$TASK_DIR/task.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
        cp "$TASK_DIR/acceptance-criteria.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
        cp "$TASK_DIR/prompt.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
        cp "$TASK_DIR/toolman-guide.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
        echo "✓ Task {{`{{`{{`}}`}}task_id{{`}}`}} files copied"
    fi
    
    # Copy architecture.md
    if [ -f "$DOCS_PATH/docs/architecture.md" ]; then
        cp "$DOCS_PATH/docs/architecture.md" "$CLAUDE_WORK_DIR/task/"
    fi
    
    # Clean up docs repo
    rm -rf /tmp/docs-repo
    {{`{{`{{`}}`}}/if{{`}}`}}
    
    # Repository is now cloned directly to Claude working directory - no copy needed
    echo "✓ Repository cloned directly to working directory"
    
    # Check if we should continue previous session
    {{`{{`{{`}}`}}#if continue_session{{`}}`}}
    echo "📂 Continuing from previous session..."
    # Preserve existing CLAUDE.md if it exists
    if [ -f "/workspace/CLAUDE.md" ]; then
        echo "✓ Found existing CLAUDE.md, preserving session memory"
    fi
    {{`{{`{{`}}`}}else{{`}}`}}
    {{`{{`{{`}}`}}#if overwrite_memory{{`}}`}}
    echo "🔄 Overwriting session memory as requested..."
    rm -f /workspace/CLAUDE.md
    {{`{{`{{`}}`}}/if{{`}}`}}
    {{`{{`{{`}}`}}/if{{`}}`}}
    
    # Generate configuration files from templates
    echo "🔧 Generating Tess-specific configuration files..."
    
    # Enterprise managed settings are mounted directly from ConfigMap
    echo "=== ENTERPRISE MANAGED SETTINGS ==="
    echo "✓ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
    echo "✓ No copying needed - mount automatically reflects latest ConfigMap changes"
    
    # Copy MCP client configuration from task files
    if [ -f "/task-files/client-config.json" ]; then
