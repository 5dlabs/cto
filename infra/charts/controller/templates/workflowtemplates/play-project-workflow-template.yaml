{{- if .Values.argo.enabled }}
---
# Full Project Play Workflow Template
# Executes all tasks in a project sequentially from task-1 to task-N
# Implements task discovery, current-task markers, and archiving

apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: play-project-workflow-template
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/name: play-project-workflow-template
    app.kubernetes.io/part-of: platform
    agents.platform/orchestration: full-project
    workflow-type: project-orchestration
spec:
  # Service account with proper permissions
  serviceAccountName: argo-workflow

  # Ensure labels are applied to instantiated Workflows created from this template
  workflowMetadata:
    labels:
      workflow-type: project-orchestration

  # Main entry point
  entrypoint: orchestrate-project

  # Global arguments
  arguments:
    parameters:
      # Agent selection (using same pattern as play-workflow-template)
      - name: implementation-agent
        value: "5DLabs-Rex"
        description: "Default agent for backend/general implementation tasks"
      - name: implementation-cli
        value: "factory"
      - name: implementation-model
        value: "claude-sonnet-4-5-20250929"
      - name: implementation-tools
        value: '{"remote":[],"localServers":{}}'
      - name: implementation-model-rotation
        value: '[]'
      - name: implementation-max-retries
        value: "10"
      - name: frontend-agent
        value: "5DLabs-Blaze"
        description: "Specialized agent for frontend tasks (React, UI components)"
      - name: frontend-cli
        value: "codex"
      - name: frontend-model
        value: "gpt-5-codex"
      - name: frontend-tools
        value: '{"remote":[],"localServers":{}}'
      - name: frontend-model-rotation
        value: '[]'
      - name: frontend-max-retries
        value: "10"
      - name: quality-agent
        value: "5DLabs-Cleo"
      - name: quality-cli
        value: "claude"
      - name: quality-model
        value: "claude-sonnet-4-5-20250929"
      - name: quality-tools
        value: '{"remote":[],"localServers":{}}'
      - name: quality-model-rotation
        value: '[]'
      - name: quality-max-retries
        value: "5"
      - name: security-agent
        value: "5DLabs-Cipher"
      - name: security-cli
        value: "codex"
      - name: security-model
        value: "gpt-5"
      - name: security-tools
        value: '{"remote":[],"localServers":{}}'
      - name: security-model-rotation
        value: '[]'
      - name: security-max-retries
        value: "5"
      - name: testing-agent
        value: "5DLabs-Tess"
      - name: testing-cli
        value: "claude"
      - name: testing-model
        value: "claude-sonnet-4-5-20250929"
      - name: testing-tools
        value: '{"remote":[],"localServers":{}}'
      - name: testing-model-rotation
        value: '[]'
      - name: testing-max-retries
        value: "5"
      - name: opencode-max-retries
        value: "3"

      # Repository configuration
      - name: repository
        value: "5dlabs/cto-play-test"
      - name: service
        value: "play-test"
      - name: docs-repository
        value: "https://github.com/5dlabs/cto-play-test"
      - name: docs-project-directory
        value: "docs"
      - name: docs-branch
        value: "main"

      # Execution control
      - name: start-from-task
        value: "1"
        description: "Task ID to start/resume from"
      - name: max-tasks
        value: "100"
        description: "Maximum number of tasks to execute"
      - name: parallel-execution
        value: "true"
        description: "Enable parallel execution of independent tasks"
      - name: integration-pr-enabled
        value: "true"
        description: "Create an integration PR per level merging all task branches"
      - name: integration-base-branch
        value: "main"
        description: "Base branch for integration merges"
      - name: conflict-detection
        value: "true"
        description: "Detect overlapping changed files across PRs within a level"

      # Model configuration
      - name: model
        value: "claude-3-5-sonnet-20241022"

  templates:
    # Main orchestration template
    - name: orchestrate-project
      steps:
        # Step 1: Discover all tasks
        - - name: discover-tasks
            template: task-discovery
            arguments:
              parameters:
              - name: docs-directory
                value: "{{`{{workflow.parameters.docs-project-directory}}`}}"
              - name: start-from
                value: "{{`{{workflow.parameters.start-from-task}}`}}"
              - name: max-tasks
                value: "{{`{{workflow.parameters.max-tasks}}`}}"

        # Step 2: Build dependency graph (if parallel execution enabled)
        - - name: build-dependency-graph
            template: dependency-graph-builder
            arguments:
              parameters:
              - name: docs-directory
                value: "{{`{{workflow.parameters.docs-project-directory}}`}}"
            when: "{{`{{workflow.parameters.parallel-execution}}`}}"

        # Step 3: Process tasks (parallel or sequential based on parameter)
        - - name: process-tasks-parallel
            template: parallel-task-processor
            arguments:
              parameters:
              - name: execution-levels
                value: "{{`{{steps.build-dependency-graph.outputs.parameters.execution-levels}}`}}"
              - name: task-count
                value: "{{`{{steps.discover-tasks.outputs.parameters.task-count}}`}}"
            when: "{{`{{workflow.parameters.parallel-execution}}`}}"
          - name: process-tasks-sequential
            template: sequential-task-processor
            arguments:
              parameters:
              - name: task-list
                value: "{{`{{steps.discover-tasks.outputs.parameters.task-list}}`}}"
              - name: task-count
                value: "{{`{{steps.discover-tasks.outputs.parameters.task-count}}`}}"
            when: "!{{`{{workflow.parameters.parallel-execution}}`}}"

    # Task discovery template
    - name: task-discovery
      inputs:
        parameters:
        - name: docs-directory
        - name: start-from
        - name: max-tasks
      outputs:
        parameters:
        - name: task-list
          valueFrom:
            path: /tmp/task-list.txt
        - name: task-count
          valueFrom:
            path: /tmp/task-count.txt
      script:
        image: alpine/k8s:1.31.0
        env:
        - name: GITHUB_APP_ID
          valueFrom:
            secretKeyRef:
              name: github-app-5dlabs-morgan
              key: app-id
        - name: GITHUB_APP_PRIVATE_KEY
          valueFrom:
            secretKeyRef:
              name: github-app-5dlabs-morgan
              key: private-key
        command: [sh]
        source: |
          #!/bin/sh
          set -e

          echo "ğŸ” Discovering tasks in workspace..."

          # Clone repository to get task structure
          apk add --no-cache git curl openssl jq

          # Normalize docs-repository: accept either org/repo or full URL
          DOCS_REPO_INPUT="{{`{{workflow.parameters.docs-repository}}`}}"
          case "$DOCS_REPO_INPUT" in
            http://*|https://*)
              DOCS_REPO_URL="$DOCS_REPO_INPUT"
              ;;
            *)
              DOCS_REPO_URL="https://github.com/$DOCS_REPO_INPUT"
              ;;
          esac

          AUTH_URL="$DOCS_REPO_URL"
          # If Morgan App credentials are present, generate an installation token
          if [ -n "${GITHUB_APP_ID:-}" ] && [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
            echo "ğŸ” Using Morgan GitHub App to authenticate clone"
            # Write the private key to a temp file (support escaped newlines)
            TEMP_KEY="/tmp/github-app-key.pem"
            printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY"
            chmod 600 "$TEMP_KEY"

            # Build JWT manually
            NOW=$(date +%s)
            EXP=$((NOW + 600))
            JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 2>/dev/null || base64)
            JWT_HEADER=$(echo -n "$JWT_HEADER" | tr '+/' '-_' | tr -d '=')
            JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 2>/dev/null || base64)
            JWT_PAYLOAD=$(echo -n "$JWT_PAYLOAD" | tr '+/' '-_' | tr -d '=')
            JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 -w 0 2>/dev/null || base64)
            JWT_SIGNATURE=$(echo -n "$JWT_SIGNATURE" | tr '+/' '-_' | tr -d '=')
            JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

            # Derive owner/repo from input if possible for repo-scoped installation lookup
            OWNER=""
            REPO=""
            case "$DOCS_REPO_INPUT" in
              http://*|https://*)
                OWNER=$(echo "$DOCS_REPO_INPUT" | sed -E 's#https?://github.com/([^/]+)/.*#\1#')
                REPO=$(echo "$DOCS_REPO_INPUT" | sed -E 's#https?://github.com/[^/]+/([^/]+)(\.git)?$#\1#')
                ;;
              *)
                OWNER=$(echo "$DOCS_REPO_INPUT" | cut -d'/' -f1)
                REPO=$(echo "$DOCS_REPO_INPUT" | cut -d'/' -f2)
                ;;
            esac

            echo "ğŸ” Resolving installation for $OWNER/$REPO"
            INSTALLATION_ID=$(curl -s -L \
              -H "Authorization: Bearer $JWT_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/$OWNER/$REPO/installation" | jq -r '.id')

            if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" = "null" ]; then
              echo "â„¹ï¸ Repo installation not found, trying org installation"
              INSTALLATION_ID=$(curl -s -L \
                -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/orgs/$OWNER/installation" | jq -r '.id')
            fi

            if [ -n "$INSTALLATION_ID" ] && [ "$INSTALLATION_ID" != "null" ]; then
              TOKEN=$(curl -s -X POST \
                -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')
              if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
                AUTH_URL=$(echo "$DOCS_REPO_URL" | sed "s#^https://#https://x-access-token:$TOKEN@#")
              else
                echo "âš ï¸ Failed to obtain installation token; proceeding anonymously"
              fi
            else
              echo "âš ï¸ No installation found for $OWNER; proceeding anonymously"
            fi

            rm -f "$TEMP_KEY"
          fi

          echo "ğŸ”— Cloning: $DOCS_REPO_URL"
          git clone --depth 1 --branch "{{`{{workflow.parameters.docs-branch}}`}}" \
            "$AUTH_URL" /workspace

          cd /workspace/"{{`{{inputs.parameters.docs-directory}}`}}"

          # Resilient task directory discovery - check both possible locations
          TASK_DIR=""
          if [ -d ".taskmaster/docs" ] && [ -n "$(ls -A .taskmaster/docs/task-* 2>/dev/null)" ]; then
            TASK_DIR=".taskmaster/docs"
            echo "âœ“ Found task files in docs/ directory"
          elif [ -d ".taskmaster/tasks" ] && [ -n "$(ls -A .taskmaster/tasks/task-* 2>/dev/null)" ]; then
            TASK_DIR=".taskmaster/tasks"
            echo "âœ“ Found task files in tasks/ directory"
          fi

          if [ -z "$TASK_DIR" ]; then
            echo "âŒ No TaskMaster task directories found. Checked:"
            echo "   - .taskmaster/docs/task-*"
            echo "   - .taskmaster/tasks/task-*"
            # Create empty output files so Argo can read them
            echo "" > /tmp/task-list.txt
            echo "0" > /tmp/task-count.txt
            exit 1
          fi

          # Discover task directories
          echo "ğŸ“‹ Scanning for task-* directories in $TASK_DIR..."
          tasks=""
          count=0

          for dir in $(ls -1d $TASK_DIR/task-* 2>/dev/null | sort -V); do
            task_num=$(basename "$dir" | sed 's/task-//')

            # Check if task number is >= start-from
            if [ "$task_num" -ge "{{`{{inputs.parameters.start-from}}`}}" ]; then
              if [ -z "$tasks" ]; then
                tasks="$task_num"
              else
                tasks="$tasks,$task_num"
              fi
              count=$((count + 1))

              # Check max tasks limit
              if [ "$count" -ge "{{`{{inputs.parameters.max-tasks}}`}}" ]; then
                echo "âš ï¸ Reached max tasks limit: {{`{{inputs.parameters.max-tasks}}`}}"
                break
              fi
            fi
          done

          if [ -z "$tasks" ]; then
            echo "âŒ No tasks found starting from task-{{`{{inputs.parameters.start-from}}`}}"
            # Create empty output files so Argo can read them
            echo "" > /tmp/task-list.txt
            echo "0" > /tmp/task-count.txt
            exit 1
          fi

          echo "âœ… Found $count tasks: $tasks"
          echo "$tasks" > /tmp/task-list.txt
          echo "$count" > /tmp/task-count.txt

    # Dependency graph builder - parses tasks.json and builds execution levels
    - name: dependency-graph-builder
      inputs:
        parameters:
        - name: docs-directory
      outputs:
        parameters:
        - name: execution-levels
          valueFrom:
            path: /tmp/execution-levels.json
        - name: parallelism-stats
          valueFrom:
            path: /tmp/parallelism-stats.json
      script:
        image: alpine/k8s:1.31.0
        env:
        - name: GITHUB_APP_ID
          valueFrom:
            secretKeyRef:
              name: github-app-5dlabs-morgan
              key: app-id
        - name: GITHUB_APP_PRIVATE_KEY
          valueFrom:
            secretKeyRef:
              name: github-app-5dlabs-morgan
              key: private-key
        command: [sh]
        source: |
          #!/bin/sh
          set -e

          echo "ğŸ“Š Building dependency graph from TaskMaster data..."

          # Install Python and required packages
          apk add --no-cache python3 git curl openssl jq

          # Normalize docs-repository: accept either org/repo or full URL
          DOCS_REPO_INPUT="{{`{{workflow.parameters.docs-repository}}`}}"
          case "$DOCS_REPO_INPUT" in
            http://*|https://*)
              DOCS_REPO_URL="$DOCS_REPO_INPUT"
              ;;
            *)
              DOCS_REPO_URL="https://github.com/$DOCS_REPO_INPUT"
              ;;
          esac

          AUTH_URL="$DOCS_REPO_URL"
          # If Morgan App credentials are present, generate an installation token
          if [ -n "${GITHUB_APP_ID:-}" ] && [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
            echo "ğŸ” Using Morgan GitHub App to authenticate clone"
            # Write the private key to a temp file (support escaped newlines)
            TEMP_KEY="/tmp/github-app-key.pem"
            printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY"
            chmod 600 "$TEMP_KEY"

            # Build JWT manually
            NOW=$(date +%s)
            EXP=$((NOW + 600))
            JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 2>/dev/null || base64)
            JWT_HEADER=$(echo -n "$JWT_HEADER" | tr '+/' '-_' | tr -d '=')
            JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 2>/dev/null || base64)
            JWT_PAYLOAD=$(echo -n "$JWT_PAYLOAD" | tr '+/' '-_' | tr -d '=')
            JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 -w 0 2>/dev/null || base64)
            JWT_SIGNATURE=$(echo -n "$JWT_SIGNATURE" | tr '+/' '-_' | tr -d '=')
            JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

            # Derive owner/repo from input if possible for repo-scoped installation lookup
            OWNER=""
            REPO=""
            case "$DOCS_REPO_INPUT" in
              http://*|https://*)
                OWNER=$(echo "$DOCS_REPO_INPUT" | sed -E 's#https?://github.com/([^/]+)/.*#\1#')
                REPO=$(echo "$DOCS_REPO_INPUT" | sed -E 's#https?://github.com/[^/]+/([^/]+)(\.git)?$#\1#')
                ;;
              *)
                OWNER=$(echo "$DOCS_REPO_INPUT" | cut -d'/' -f1)
                REPO=$(echo "$DOCS_REPO_INPUT" | cut -d'/' -f2)
                ;;
            esac

            echo "ğŸ” Resolving installation for $OWNER/$REPO"
            INSTALLATION_ID=$(curl -s -L \
              -H "Authorization: Bearer $JWT_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/$OWNER/$REPO/installation" | jq -r '.id')

            if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" = "null" ]; then
              echo "â„¹ï¸ Repo installation not found, trying org installation"
              INSTALLATION_ID=$(curl -s -L \
                -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/orgs/$OWNER/installation" | jq -r '.id')
            fi

            if [ -n "$INSTALLATION_ID" ] && [ "$INSTALLATION_ID" != "null" ]; then
              TOKEN=$(curl -s -X POST \
                -H "Authorization: Bearer $JWT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')
              if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
                AUTH_URL=$(echo "$DOCS_REPO_URL" | sed "s#^https://#https://x-access-token:$TOKEN@#")
              else
                echo "âš ï¸ Failed to obtain installation token; proceeding anonymously"
              fi
            else
              echo "âš ï¸ No installation found for $OWNER; proceeding anonymously"
            fi

            rm -f "$TEMP_KEY"
          fi

          echo "ğŸ”— Cloning: $DOCS_REPO_URL"
          git clone --depth 1 --branch "{{`{{workflow.parameters.docs-branch}}`}}" \
            "$AUTH_URL" /workspace

          cd /workspace/"{{`{{inputs.parameters.docs-directory}}`}}"

          # Check for .taskmaster/tasks/tasks.json
          TASKS_JSON=".taskmaster/tasks/tasks.json"
          if [ ! -f "$TASKS_JSON" ]; then
            echo "âŒ TaskMaster tasks.json not found: $TASKS_JSON"
            exit 1
          fi

          # Download dependency graph builder script
          echo "ğŸ“¥ Fetching dependency graph builder..."
          curl -sSL https://raw.githubusercontent.com/5dlabs/cto/main/scripts/build-dependency-graph.py \
            -o /tmp/build-dependency-graph.py
          chmod +x /tmp/build-dependency-graph.py

          # Run dependency graph builder
          echo "ğŸ”§ Building dependency graph..."
          python3 /tmp/build-dependency-graph.py "$TASKS_JSON" /tmp/graph-output.json

          # Extract execution levels and stats
          jq -c '.levels' /tmp/graph-output.json > /tmp/execution-levels.json
          jq -c '.stats' /tmp/graph-output.json > /tmp/parallelism-stats.json

          echo "âœ… Dependency graph built successfully"
          echo "ğŸ“Š Parallelism stats:"
          jq '.' /tmp/parallelism-stats.json

    # Parallel task processor - processes tasks by execution level
    - name: parallel-task-processor
      inputs:
        parameters:
        - name: execution-levels
        - name: task-count
      script:
        image: alpine/k8s:1.31.0
        env:
        - name: GITHUB_APP_ID
          valueFrom:
            secretKeyRef:
              name: github-app-5dlabs-morgan
              key: app-id
        - name: GITHUB_APP_PRIVATE_KEY
          valueFrom:
            secretKeyRef:
              name: github-app-5dlabs-morgan
              key: private-key
        command: [sh]
        source: |
          #!/bin/sh
          set -e

          echo "ğŸš€ Processing tasks in parallel by dependency levels..."

          apk add --no-cache jq

          # Parse execution levels
          LEVELS='{{`{{inputs.parameters.execution-levels}}`}}'
          echo "ğŸ“Š Execution levels: $LEVELS"

          # Count total levels
          NUM_LEVELS=$(echo "$LEVELS" | jq '. | length')
          echo "ğŸ“Š Total execution levels: $NUM_LEVELS"

          # Process each level
          level_index=0
          while [ $level_index -lt $NUM_LEVELS ]; do
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "ğŸ“Š LEVEL $level_index"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

            # Get tasks for this level
            level_tasks=$(echo "$LEVELS" | jq -r ".[$level_index] | @json")
            task_array=$(echo "$level_tasks" | jq -r '.[]')
            
            if [ -z "$task_array" ]; then
              echo "âš ï¸ No tasks in level $level_index, skipping..."
              level_index=$((level_index + 1))
              continue
            fi

            # Launch all tasks in this level in parallel
            echo "ğŸš€ Launching parallel tasks for level $level_index:"
            workflow_names=""
            for task_id in $task_array; do
              echo "  â†’ Task $task_id"
              
              # Agent routing is handled by child workflow's determine-task-agent step
              # Parent simply passes through all agent parameters for child to use
              
              cat > /tmp/workflow-task-${task_id}.yaml <<EOF
          apiVersion: argoproj.io/v1alpha1
          kind: Workflow
          metadata:
            generateName: play-task-${task_id}-
            namespace: {{ .Release.Namespace }}
            labels:
              task-id: "$task_id"
              execution-level: "$level_index"
              repository: "$(echo "{{`{{workflow.parameters.repository}}`}}" | tr '/' '-')"
              current-stage: "pending"
              parent-workflow: "{{`{{workflow.name}}`}}"
              project-play: "true"
              parallel-execution: "true"
          spec:
            workflowTemplateRef:
              name: play-workflow-template
            arguments:
              parameters:
                - name: task-id
                  value: "$task_id"
                - name: repository
                  value: "{{`{{workflow.parameters.repository}}`}}"
                - name: service
                  value: "{{`{{workflow.parameters.service}}`}}"
                - name: docs-repository
                  value: "{{`{{workflow.parameters.docs-repository}}`}}"
                - name: docs-project-directory
                  value: "{{`{{workflow.parameters.docs-project-directory}}`}}"
                - name: docs-branch
                  value: "{{`{{workflow.parameters.docs-branch}}`}}"
                - name: implementation-agent
                  value: "{{`{{workflow.parameters.implementation-agent}}`}}"
                - name: implementation-cli
                  value: "{{`{{workflow.parameters.implementation-cli}}`}}"
                - name: implementation-model
                  value: "{{`{{workflow.parameters.implementation-model}}`}}"
                - name: implementation-tools
                  value: '{{`{{workflow.parameters.implementation-tools}}`}}'
                - name: implementation-model-rotation
                  value: '{{`{{workflow.parameters.implementation-model-rotation}}`}}'
                - name: frontend-agent
                  value: "{{`{{workflow.parameters.frontend-agent}}`}}"
                - name: frontend-cli
                  value: "{{`{{workflow.parameters.frontend-cli}}`}}"
                - name: frontend-model
                  value: "{{`{{workflow.parameters.frontend-model}}`}}"
                - name: frontend-tools
                  value: '{{`{{workflow.parameters.frontend-tools}}`}}'
                - name: frontend-model-rotation
                  value: '{{`{{workflow.parameters.frontend-model-rotation}}`}}'
                - name: frontend-max-retries
                  value: "{{`{{workflow.parameters.frontend-max-retries}}`}}"
                - name: quality-agent
                  value: "{{`{{workflow.parameters.quality-agent}}`}}"
                - name: quality-cli
                  value: "{{`{{workflow.parameters.quality-cli}}`}}"
                - name: quality-model
                  value: "{{`{{workflow.parameters.quality-model}}`}}"
                - name: quality-tools
                  value: '{{`{{workflow.parameters.quality-tools}}`}}'
                - name: quality-model-rotation
                  value: '{{`{{workflow.parameters.quality-model-rotation}}`}}'
                - name: security-agent
                  value: "{{`{{workflow.parameters.security-agent}}`}}"
                - name: security-cli
                  value: "{{`{{workflow.parameters.security-cli}}`}}"
                - name: security-model
                  value: "{{`{{workflow.parameters.security-model}}`}}"
                - name: security-tools
                  value: '{{`{{workflow.parameters.security-tools}}`}}'
                - name: security-model-rotation
                  value: '{{`{{workflow.parameters.security-model-rotation}}`}}'
                - name: testing-agent
                  value: "{{`{{workflow.parameters.testing-agent}}`}}"
                - name: testing-cli
                  value: "{{`{{workflow.parameters.testing-cli}}`}}"
                - name: testing-model
                  value: "{{`{{workflow.parameters.testing-model}}`}}"
                - name: testing-tools
                  value: '{{`{{workflow.parameters.testing-tools}}`}}'
                - name: testing-model-rotation
                  value: '{{`{{workflow.parameters.testing-model-rotation}}`}}'
                - name: implementation-max-retries
                  value: "{{`{{workflow.parameters.implementation-max-retries}}`}}"
                - name: quality-max-retries
                  value: "{{`{{workflow.parameters.quality-max-retries}}`}}"
                - name: security-max-retries
                  value: "{{`{{workflow.parameters.security-max-retries}}`}}"
                - name: testing-max-retries
                  value: "{{`{{workflow.parameters.testing-max-retries}}`}}"
                - name: opencode-max-retries
                  value: "{{`{{workflow.parameters.opencode-max-retries}}`}}"
                - name: auto-merge
                  value: "{{`{{workflow.parameters.auto-merge}}`}}"
                - name: model
                  value: "{{`{{workflow.parameters.model}}`}}"
          EOF

              workflow_name=$(kubectl create -f /tmp/workflow-task-${task_id}.yaml -o jsonpath='{.metadata.name}')
              
              if [ -z "$workflow_name" ]; then
                echo "âŒ Failed to create workflow for task-$task_id"
                exit 1
              fi
              
              echo "    âœ… Created workflow: $workflow_name"
              
              if [ -z "$workflow_names" ]; then
                workflow_names="$workflow_name"
              else
                workflow_names="$workflow_names $workflow_name"
              fi
            done

            # Wait for all tasks in this level to complete
            echo ""
            echo "â³ Waiting for all tasks in level $level_index to complete..."
            max_wait=7200  # 2 hours max wait per level
            elapsed=0
            interval=30

            while [ $elapsed -lt $max_wait ]; do
              all_done=true
              any_failed=false
              
              for workflow_name in $workflow_names; do
                status=$(kubectl get workflow "$workflow_name" \
                  -n {{ .Release.Namespace }} \
                  -o jsonpath='{.status.phase}' 2>/dev/null || echo "NotFound")

                case "$status" in
                  "Succeeded")
                    # Task completed successfully
                    ;;
                  "Failed"|"Error")
                    echo "âŒ Workflow $workflow_name failed"
                    any_failed=true
                    all_done=false
                    ;;
                  "Running"|"Pending")
                    all_done=false
                    ;;
                  *)
                    all_done=false
                    ;;
                esac
              done

              if [ "$any_failed" = "true" ]; then
                echo "âŒ One or more tasks in level $level_index failed"
                exit 1
              fi

              if [ "$all_done" = "true" ]; then
                echo "âœ… All tasks in level $level_index completed successfully"

              # Optional: Create integration PR that merges all task branches in this level
              if [ "{{`{{workflow.parameters.integration-pr-enabled}}`}}" = "true" ]; then
                echo "ğŸ§© Coordinating integration PR for level $level_index"

                apk add --no-cache git curl openssl

                # Normalize repository: accept either org/repo or full URL
                REPO_INPUT="{{`{{workflow.parameters.repository}}`}}"
                case "$REPO_INPUT" in
                  http://*|https://*)
                    REPO_URL="$REPO_INPUT"
                    ;;
                  *)
                    REPO_URL="https://github.com/$REPO_INPUT"
                    ;;
                esac

                # Build Morgan GitHub App JWT to get installation token
                if [ -n "${GITHUB_APP_ID:-}" ] && [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
                  echo "ğŸ” Using Morgan GitHub App to authenticate repo clone and push"
                  TEMP_KEY="/tmp/github-app-key.pem"
                  printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY"
                  chmod 600 "$TEMP_KEY"

                  NOW=$(date +%s)
                  EXP=$((NOW + 600))
                  JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 2>/dev/null || base64)
                  JWT_HEADER=$(echo -n "$JWT_HEADER" | tr '+/' '-_' | tr -d '=')
                  JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 2>/dev/null || base64)
                  JWT_PAYLOAD=$(echo -n "$JWT_PAYLOAD" | tr '+/' '-_' | tr -d '=')
                  JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 -w 0 2>/dev/null || base64)
                  JWT_SIGNATURE=$(echo -n "$JWT_SIGNATURE" | tr '+/' '-_' | tr -d '=')
                  JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

                  # Derive owner/repo
                  OWNER=""
                  REPO=""
                  case "$REPO_INPUT" in
                    http://*|https://*)
                      OWNER=$(echo "$REPO_INPUT" | sed -E 's#https?://github.com/([^/]+)/.*#\1#')
                      REPO=$(echo "$REPO_INPUT" | sed -E 's#https?://github.com/[^/]+/([^/]+)(\.git)?$#\1#')
                      ;;
                    *)
                      OWNER=$(echo "$REPO_INPUT" | cut -d'/' -f1)
                      REPO=$(echo "$REPO_INPUT" | cut -d'/' -f2)
                      ;;
                  esac

                  echo "ğŸ” Resolving installation for $OWNER/$REPO"
                  INSTALLATION_ID=$(curl -s -L \
                    -H "Authorization: Bearer $JWT_TOKEN" \
                    -H "Accept: application/vnd.github+json" \
                    "https://api.github.com/repos/$OWNER/$REPO/installation" | jq -r '.id')

                  if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" = "null" ]; then
                    echo "â„¹ï¸ Repo installation not found, trying org installation"
                    INSTALLATION_ID=$(curl -s -L \
                      -H "Authorization: Bearer $JWT_TOKEN" \
                      -H "Accept: application/vnd.github+json" \
                      "https://api.github.com/orgs/$OWNER/installation" | jq -r '.id')
                  fi

                  TOKEN=""
                  if [ -n "$INSTALLATION_ID" ] && [ "$INSTALLATION_ID" != "null" ]; then
                    TOKEN=$(curl -s -X POST \
                      -H "Authorization: Bearer $JWT_TOKEN" \
                      -H "Accept: application/vnd.github+json" \
                      "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')
                  fi

                  if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
                    echo "âŒ Failed to obtain installation token; cannot create integration PR"
                  else
                    AUTH_URL=$(echo "$REPO_URL" | sed "s#^https://#https://x-access-token:$TOKEN@#")

                    # Clone repo and prepare integration branch
                    WORKDIR="/tmp/integration-$level_index"
                    rm -rf "$WORKDIR" && mkdir -p "$WORKDIR"
                    git clone --depth 1 --branch "{{`{{workflow.parameters.integration-base-branch}}`}}" "$AUTH_URL" "$WORKDIR"
                    cd "$WORKDIR"

                    BASE_BRANCH="{{`{{workflow.parameters.integration-base-branch}}`}}"
                    INTEGRATION_BRANCH="integration/level-$level_index-{{`{{workflow.name}}`}}"

                    # Create or reset integration branch
                    git checkout -B "$INTEGRATION_BRANCH" "origin/$BASE_BRANCH"

                    # Optional conflict detection via PR changed files
                    if [ "{{`{{workflow.parameters.conflict-detection}}`}}" = "true" ]; then
                      echo "ğŸ§ª Performing pre-merge conflict detection"
                      ALL_FILES="/tmp/changed-files.txt"
                      : > "$ALL_FILES"
                      CONFLICT_WARNING=false
                      for task_id in $task_array; do
                        # Find PR number for branch feature/task-$task_id-implementation
                        HEAD_BRANCH="feature/task-${task_id}-implementation"
                        PR_DATA=$(curl -s -L \
                          -H "Authorization: Bearer $JWT_TOKEN" \
                          -H "Accept: application/vnd.github+json" \
                          "https://api.github.com/repos/$OWNER/$REPO/pulls?state=open&head=$OWNER:$HEAD_BRANCH")
                        PR_NUM=$(echo "$PR_DATA" | jq -r '.[0].number // empty')
                        if [ -n "$PR_NUM" ]; then
                          curl -s -L \
                            -H "Authorization: Bearer $JWT_TOKEN" \
                            -H "Accept: application/vnd.github+json" \
                            "https://api.github.com/repos/$OWNER/$REPO/pulls/$PR_NUM/files" | jq -r '.[].filename' >> "$ALL_FILES"
                        fi
                      done
                      if [ -s "$ALL_FILES" ]; then
                        SORTED=$(sort "$ALL_FILES")
                        DUPES=$(echo "$SORTED" | uniq -d)
                        if [ -n "$DUPES" ]; then
                          echo "âš ï¸ Potential overlap detected across PRs in level $level_index:"
                          echo "$DUPES"
                          CONFLICT_WARNING=true
                        fi
                      fi
                    fi

                    # Merge each task branch into integration branch
                    MERGE_FAILED=false
                    for task_id in $task_array; do
                      BR="feature/task-${task_id}-implementation"
                      echo "ğŸ”€ Merging $BR into $INTEGRATION_BRANCH"
                      git fetch origin "$BR:$BR" || true
                      if git show-ref --verify --quiet "refs/heads/$BR" || git ls-remote --exit-code --heads origin "$BR" >/dev/null 2>&1; then
                        # Ensure local ref exists
                        git fetch origin "$BR:$BR" || true
                        if ! git merge --no-ff -m "Merge $BR into $INTEGRATION_BRANCH" "$BR"; then
                          echo "âŒ Merge conflict when merging $BR"
                          MERGE_FAILED=true
                          break
                        fi
                      else
                        echo "â„¹ï¸ Branch $BR not found; skipping"
                      fi
                    done

                    if [ "$MERGE_FAILED" = "true" ]; then
                      echo "âŒ Integration merge failed due to conflicts"
                      exit 1
                    fi

                    # Push integration branch and create PR
                    git push -f origin "$INTEGRATION_BRANCH"

                    PR_TITLE="Integration PR: Level $level_index for {{`{{workflow.name}}`}}"
                    PR_BODY="This PR merges task branches for level $level_index: $(echo $task_array | tr '\n' ' ')"
                    CREATE_BODY=$(printf '{"title":"%s","head":"%s","base":"%s","body":"%s"}' "$PR_TITLE" "$INTEGRATION_BRANCH" "$BASE_BRANCH" "$PR_BODY")
                    EXISTING=$(curl -s -L \
                      -H "Authorization: Bearer $JWT_TOKEN" \
                      -H "Accept: application/vnd.github+json" \
                      "https://api.github.com/repos/$OWNER/$REPO/pulls?state=open&head=$OWNER:$INTEGRATION_BRANCH")
                    EXISTING_NUM=$(echo "$EXISTING" | jq -r '.[0].number // empty')
                    if [ -n "$EXISTING_NUM" ]; then
                      echo "âœ… Integration PR already exists: #$EXISTING_NUM"
                    else
                      RESP=$(curl -s -X POST \
                        -H "Authorization: Bearer $JWT_TOKEN" \
                        -H "Accept: application/vnd.github+json" \
                        -d "$CREATE_BODY" \
                        "https://api.github.com/repos/$OWNER/$REPO/pulls")
                      URL=$(echo "$RESP" | jq -r '.html_url // empty')
                      NUM=$(echo "$RESP" | jq -r '.number // empty')
                      if [ -n "$NUM" ]; then
                        echo "âœ… Created integration PR #$NUM: $URL"
                      else
                        echo "âš ï¸ Failed to create integration PR"
                      fi
                    fi

                    # Cleanup
                    rm -f "$TEMP_KEY"
                  fi
                else
                  echo "âš ï¸ Morgan GitHub App credentials not available; skipping integration PR"
                fi
              fi
                break
              fi

              if [ $((elapsed % 300)) -eq 0 ]; then
                echo "ğŸ”„ Level $level_index still running... ($elapsed seconds elapsed)"
              fi

              sleep $interval
              elapsed=$((elapsed + interval))
            done

            if [ $elapsed -ge $max_wait ]; then
              echo ""
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "â±ï¸ TIMEOUT: Level $level_index exceeded maximum wait time ($max_wait seconds)"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo ""
              
              # Detailed diagnostics for each workflow
              echo "ğŸ“Š DIAGNOSTICS: Checking status of all workflows in level $level_index..."
              echo ""
              
              stuck_count=0
              failed_count=0
              succeeded_count=0
              unknown_count=0
              
              for workflow_name in $workflow_names; do
                status=$(kubectl get workflow "$workflow_name" \
                  -n {{ .Release.Namespace }} \
                  -o jsonpath='{.status.phase}' 2>/dev/null || echo "NotFound")
                
                message=$(kubectl get workflow "$workflow_name" \
                  -n {{ .Release.Namespace }} \
                  -o jsonpath='{.status.message}' 2>/dev/null || echo "")
                
                case "$status" in
                  "Succeeded")
                    echo "  âœ… $workflow_name: Succeeded"
                    succeeded_count=$((succeeded_count + 1))
                    ;;
                  "Failed"|"Error")
                    echo "  âŒ $workflow_name: $status"
                    if [ -n "$message" ]; then
                      echo "     Message: $message"
                    fi
                    failed_count=$((failed_count + 1))
                    # Get node status for more details
                    failed_nodes=$(kubectl get workflow "$workflow_name" \
                      -n {{ .Release.Namespace }} \
                      -o jsonpath='{.status.nodes[*].phase}' 2>/dev/null | tr ' ' '\n' | grep -E "Failed|Error" | wc -l || echo "0")
                    if [ "$failed_nodes" -gt 0 ]; then
                      echo "     Failed nodes: $failed_nodes"
                    fi
                    ;;
                  "Running"|"Pending")
                    echo "  â³ $workflow_name: $status (stuck or still processing)"
                    stuck_count=$((stuck_count + 1))
                    
                    # Get active pods for this workflow
                    active_pods=$(kubectl get pods \
                      -n {{ .Release.Namespace }} \
                      -l workflows.argoproj.io/workflow="$workflow_name" \
                      --field-selector=status.phase=Running \
                      -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
                    
                    if [ -n "$active_pods" ]; then
                      echo "     Active pods: $(echo "$active_pods" | wc -w | tr -d ' ')"
                      for pod in $active_pods; do
                        pod_age=$(kubectl get pod "$pod" \
                          -n {{ .Release.Namespace }} \
                          -o jsonpath='{.status.startTime}' 2>/dev/null || echo "")
                        if [ -n "$pod_age" ]; then
                          echo "       - $pod (running since: $pod_age)"
                        else
                          echo "       - $pod"
                        fi
                      done
                    else
                      echo "     No active pods found"
                    fi
                    ;;
                  "NotFound")
                    echo "  âš ï¸  $workflow_name: Not found (may have been deleted)"
                    unknown_count=$((unknown_count + 1))
                    ;;
                  *)
                    echo "  â“ $workflow_name: Unknown status '$status'"
                    unknown_count=$((unknown_count + 1))
                    ;;
                esac
                echo ""
              done
              
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "ğŸ“ˆ SUMMARY:"
              echo "  âœ… Succeeded: $succeeded_count"
              echo "  âŒ Failed: $failed_count"
              echo "  â³ Still running/stuck: $stuck_count"
              echo "  â“ Unknown: $unknown_count"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo ""
              
              # Provide actionable remediation steps
              if [ "$failed_count" -gt 0 ]; then
                echo "ğŸ”§ REMEDIATION:"
                echo "  1. Check failed workflow logs: kubectl logs -n {{ .Release.Namespace }} -l workflows.argoproj.io/workflow=<workflow-name>"
                echo "  2. Review workflow status: kubectl get workflow <workflow-name> -n {{ .Release.Namespace }} -o yaml"
                echo "  3. Check CodeRun status if applicable: kubectl get coderun -n {{ .Release.Namespace }}"
                echo ""
              fi
              
              if [ "$stuck_count" -gt 0 ]; then
                echo "ğŸ”§ REMEDIATION FOR STUCK WORKFLOWS:"
                echo "  1. Check pod logs: kubectl logs -n {{ .Release.Namespace }} <pod-name>"
                echo "  2. Check workflow suspend status: kubectl get workflow <workflow-name> -n {{ .Release.Namespace }} -o jsonpath='{.status.nodes[*].phase}'"
                echo "  3. Workflows may be waiting on external events (PR creation, webhooks, etc.)"
                echo "  4. Consider increasing max_wait timeout if tasks legitimately take longer than 2 hours"
                echo ""
              fi
              
              # Exit with error, but provide context
              if [ "$failed_count" -gt 0 ] && [ "$stuck_count" -eq 0 ]; then
                echo "âŒ Level $level_index failed: $failed_count task(s) failed"
                exit 1
              elif [ "$stuck_count" -gt 0 ]; then
                echo "â±ï¸ Level $level_index timeout: $stuck_count task(s) did not complete within $max_wait seconds"
                echo "   This may indicate:"
                echo "   - Workflows waiting on external events (GitHub PRs, webhooks)"
                echo "   - Long-running implementation tasks that exceed timeout"
                echo "   - Workflow suspension/resume issues"
                exit 1
              else
                echo "âŒ Level $level_index timeout: Unknown issue preventing completion"
                exit 1
              fi
            fi

            # Progress report
            completed_levels=$((level_index + 1))
            percent=$((completed_levels * 100 / NUM_LEVELS))
            echo ""
            echo "ğŸ“Š PROGRESS: $completed_levels/$NUM_LEVELS levels complete ($percent%)"
            printf "["
            for i in $(seq 1 20); do
              if [ $((i * 5)) -le $percent ]; then
                printf "â–ˆ"
              else
                printf "â–‘"
              fi
            done
            printf "] $percent%%\n"
            echo ""

            level_index=$((level_index + 1))
          done

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ‰ ALL LEVELS COMPLETED SUCCESSFULLY!"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          # Create telemetry summary
          WORKFLOW_END=$(date +%s)
          WORKFLOW_START=$(kubectl get workflow "{{`{{workflow.name}}`}}" -n {{ .Release.Namespace }} -o jsonpath='{.status.startedAt}' | xargs -I {} date -d {} +%s 2>/dev/null || echo "$WORKFLOW_END")
          TOTAL_DURATION=$((WORKFLOW_END - WORKFLOW_START))
          
          # Estimate sequential time (sum of all task durations)
          SEQUENTIAL_ESTIMATE=$(({{`{{inputs.parameters.task-count}}`}} * 1800))  # Assume 30min per task average
          
          # Calculate actual speedup
          ACTUAL_SPEEDUP="1.0"
          if [ $TOTAL_DURATION -gt 0 ]; then
            ACTUAL_SPEEDUP=$(echo "scale=2; $SEQUENTIAL_ESTIMATE / $TOTAL_DURATION" | bc -l 2>/dev/null || echo "1.0")
          fi

          cat > /tmp/telemetry.json <<EOF
          {
            "workflow_name": "{{`{{workflow.name}}`}}",
            "execution_mode": "parallel",
            "total_tasks": {{`{{inputs.parameters.task-count}}`}},
            "execution_levels": $NUM_LEVELS,
            "total_duration_seconds": $TOTAL_DURATION,
            "estimated_sequential_seconds": $SEQUENTIAL_ESTIMATE,
            "actual_speedup": "$ACTUAL_SPEEDUP",
            "completed_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          }
          EOF

          echo "ğŸ“Š PERFORMANCE TELEMETRY"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ¯ Total tasks: {{`{{inputs.parameters.task-count}}`}}"
          echo "ğŸ“Š Execution levels: $NUM_LEVELS"
          echo "â±ï¸ Total duration: ${TOTAL_DURATION}s"
          echo "ğŸš€ Estimated speedup: ${ACTUAL_SPEEDUP}x"
          echo ""

          # Store telemetry as ConfigMap for later analysis
          kubectl create configmap "telemetry-{{`{{workflow.name}}`}}" \
            --from-file=telemetry.json=/tmp/telemetry.json \
            -n {{ .Release.Namespace }} \
            --dry-run=client -o yaml | kubectl apply -n {{ .Release.Namespace }} -f -

    # Sequential task processor - processes tasks one by one
    - name: sequential-task-processor
      inputs:
        parameters:
        - name: task-list
        - name: task-count
      script:
        image: alpine/k8s:1.31.0
        env:
        - name: GITHUB_APP_ID
          valueFrom:
            secretKeyRef:
              name: github-app-5dlabs-morgan
              key: app-id
        - name: GITHUB_APP_PRIVATE_KEY
          valueFrom:
            secretKeyRef:
              name: github-app-5dlabs-morgan
              key: private-key
        command: [sh]
        source: |
          #!/bin/sh
          set -e

          echo "ğŸ“‹ Processing {{`{{inputs.parameters.task-count}}`}} tasks sequentially..."

          # Convert comma-separated list to space-separated for iteration
          task_list="{{`{{inputs.parameters.task-list}}`}}"
          task_list="${task_list//,/ }"

          # Process each task sequentially
          task_index=1
          for task_id in $task_list; do
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "ğŸ¯ Starting Task $task_id ($task_index/{{`{{inputs.parameters.task-count}}`}})"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

            # Create current-task marker
            cat > /tmp/current-task.json <<EOF
          {
            "task_id": "$task_id",
            "started_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "workflow_id": "{{`{{workflow.name}}`}}",
            "task_index": $task_index,
            "total_tasks": {{`{{inputs.parameters.task-count}}`}}
          }
          EOF
            kubectl create configmap current-task-{{`{{workflow.name}}`}} \
              --from-file=current-task.json=/tmp/current-task.json \
              -n {{ .Release.Namespace }} \
              --dry-run=client -o yaml | kubectl apply -n {{ .Release.Namespace }} -f -

            # Submit workflow for this task
            echo "ğŸš€ Submitting workflow for task-$task_id..."

            # Agent routing is handled by child workflow's determine-task-agent step
            # Parent simply passes through all agent parameters for child to use

            cat > /tmp/workflow.yaml <<EOF
          apiVersion: argoproj.io/v1alpha1
          kind: Workflow
          metadata:
            generateName: play-task-${task_id}-
            namespace: {{ .Release.Namespace }}
            labels:
              task-id: "$task_id"
              repository: "$(echo "{{`{{workflow.parameters.repository}}`}}" | tr '/' '-')"
              current-stage: "pending"
              parent-workflow: "{{`{{workflow.name}}`}}"
              project-play: "true"
          spec:
            workflowTemplateRef:
              name: play-workflow-template
            arguments:
              parameters:
                - name: task-id
                  value: "$task_id"
                - name: repository
                  value: "{{`{{workflow.parameters.repository}}`}}"
                - name: service
                  value: "{{`{{workflow.parameters.service}}`}}"
                - name: docs-repository
                  value: "{{`{{workflow.parameters.docs-repository}}`}}"
                - name: docs-project-directory
                  value: "{{`{{workflow.parameters.docs-project-directory}}`}}"
                - name: docs-branch
                  value: "{{`{{workflow.parameters.docs-branch}}`}}"
                - name: implementation-agent
                  value: "{{`{{workflow.parameters.implementation-agent}}`}}"
                - name: implementation-cli
                  value: "{{`{{workflow.parameters.implementation-cli}}`}}"
                - name: implementation-model
                  value: "{{`{{workflow.parameters.implementation-model}}`}}"
                - name: implementation-tools
                  value: '{{`{{workflow.parameters.implementation-tools}}`}}'
                - name: implementation-model-rotation
                  value: '{{`{{workflow.parameters.implementation-model-rotation}}`}}'
                - name: frontend-agent
                  value: "{{`{{workflow.parameters.frontend-agent}}`}}"
                - name: frontend-cli
                  value: "{{`{{workflow.parameters.frontend-cli}}`}}"
                - name: frontend-model
                  value: "{{`{{workflow.parameters.frontend-model}}`}}"
                - name: frontend-tools
                  value: '{{`{{workflow.parameters.frontend-tools}}`}}'
                - name: frontend-model-rotation
                  value: '{{`{{workflow.parameters.frontend-model-rotation}}`}}'
                - name: frontend-max-retries
                  value: "{{`{{workflow.parameters.frontend-max-retries}}`}}"
                - name: quality-agent
                  value: "{{`{{workflow.parameters.quality-agent}}`}}"
                - name: quality-cli
                  value: "{{`{{workflow.parameters.quality-cli}}`}}"
                - name: quality-model
                  value: "{{`{{workflow.parameters.quality-model}}`}}"
                - name: quality-tools
                  value: '{{`{{workflow.parameters.quality-tools}}`}}'
                - name: quality-model-rotation
                  value: '{{`{{workflow.parameters.quality-model-rotation}}`}}'
                - name: security-agent
                  value: "{{`{{workflow.parameters.security-agent}}`}}"
                - name: security-cli
                  value: "{{`{{workflow.parameters.security-cli}}`}}"
                - name: security-model
                  value: "{{`{{workflow.parameters.security-model}}`}}"
                - name: security-tools
                  value: '{{`{{workflow.parameters.security-tools}}`}}'
                - name: security-model-rotation
                  value: '{{`{{workflow.parameters.security-model-rotation}}`}}'
                - name: testing-agent
                  value: "{{`{{workflow.parameters.testing-agent}}`}}"
                - name: testing-cli
                  value: "{{`{{workflow.parameters.testing-cli}}`}}"
                - name: testing-model
                  value: "{{`{{workflow.parameters.testing-model}}`}}"
                - name: testing-tools
                  value: '{{`{{workflow.parameters.testing-tools}}`}}'
                - name: testing-model-rotation
                  value: '{{`{{workflow.parameters.testing-model-rotation}}`}}'
                - name: implementation-max-retries
                  value: "{{`{{workflow.parameters.implementation-max-retries}}`}}"
                - name: quality-max-retries
                  value: "{{`{{workflow.parameters.quality-max-retries}}`}}"
                - name: security-max-retries
                  value: "{{`{{workflow.parameters.security-max-retries}}`}}"
                - name: testing-max-retries
                  value: "{{`{{workflow.parameters.testing-max-retries}}`}}"
                - name: opencode-max-retries
                  value: "{{`{{workflow.parameters.opencode-max-retries}}`}}"
                - name: auto-merge
                  value: "{{`{{workflow.parameters.auto-merge}}`}}"
                - name: model
                  value: "{{`{{workflow.parameters.model}}`}}"
          EOF

            workflow_name=$(kubectl create -f /tmp/workflow.yaml -o jsonpath='{.metadata.name}')

            if [ -z "$workflow_name" ]; then
              echo "âŒ Failed to create workflow for task-$task_id"
              exit 1
            fi

            echo "âœ… Created workflow: $workflow_name"

            # Wait for workflow completion
            echo "â³ Waiting for task-$task_id to complete..."
            max_wait=7200  # 2 hours max wait per task
            elapsed=0
            interval=30

            while [ $elapsed -lt $max_wait ]; do
              status=$(kubectl get workflow "$workflow_name" \
                -n {{ .Release.Namespace }} \
                -o jsonpath='{.status.phase}' 2>/dev/null || echo "NotFound")

              case "$status" in
                "Succeeded")
                  echo "âœ… Task $task_id completed successfully"
                  break
                  ;;
                "Failed"|"Error")
                  echo "âŒ Task $task_id failed"
                  kubectl get workflow "$workflow_name" -n {{ .Release.Namespace }} -o yaml | tail -20
                  exit 1
                  ;;
                "Running"|"Pending")
                  if [ $((elapsed % 300)) -eq 0 ]; then
                    echo "ğŸ”„ Task $task_id still running... ($elapsed seconds elapsed)"
                  fi
                  ;;
                *)
                  echo "ğŸ“Š Task $task_id status: $status"
                  ;;
              esac

              sleep $interval
              elapsed=$((elapsed + interval))
            done

            if [ $elapsed -ge $max_wait ]; then
              echo ""
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "â±ï¸ TIMEOUT: Task $task_id exceeded maximum wait time ($max_wait seconds)"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo ""
              
              # Get detailed workflow status
              status=$(kubectl get workflow "$workflow_name" \
                -n {{ .Release.Namespace }} \
                -o jsonpath='{.status.phase}' 2>/dev/null || echo "NotFound")
              
              message=$(kubectl get workflow "$workflow_name" \
                -n {{ .Release.Namespace }} \
                -o jsonpath='{.status.message}' 2>/dev/null || echo "")
              
              echo "ğŸ“Š Workflow Status: $status"
              if [ -n "$message" ]; then
                echo "ğŸ“ Message: $message"
              fi
              
              # Get active pods
              active_pods=$(kubectl get pods \
                -n {{ .Release.Namespace }} \
                -l workflows.argoproj.io/workflow="$workflow_name" \
                --field-selector=status.phase=Running \
                -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
              
              if [ -n "$active_pods" ]; then
                echo "ğŸ” Active pods:"
                for pod in $active_pods; do
                  echo "   - $pod"
                done
              fi
              
              echo ""
              echo "ğŸ”§ REMEDIATION:"
              echo "  1. Check workflow logs: kubectl logs -n {{ .Release.Namespace }} -l workflows.argoproj.io/workflow=$workflow_name"
              echo "  2. Review workflow: kubectl get workflow $workflow_name -n {{ .Release.Namespace }} -o yaml"
              echo "  3. Check if workflow is suspended waiting for external events"
              echo ""
              
              exit 1
            fi

            # Archive task (placeholder for now)
            echo "ğŸ“¦ Archiving task-$task_id..."
            kubectl create configmap task-archive-${task_id}-{{`{{workflow.name}}`}} \
              --from-literal=task_id="$task_id" \
              --from-literal=completed_at="$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
              -n {{ .Release.Namespace }} \
              --dry-run=client -o yaml | kubectl apply -n {{ .Release.Namespace }} -f -

            # Progress report
            percent=$((task_index * 100 / {{`{{inputs.parameters.task-count}}`}}))
            echo ""
            echo "ğŸ“Š PROGRESS: $task_index/{{`{{inputs.parameters.task-count}}`}} tasks complete ($percent%)"
            printf "["
            for i in $(seq 1 20); do
              if [ $((i * 5)) -le $percent ]; then
                printf "â–ˆ"
              else
                printf "â–‘"
              fi
            done
            printf "] $percent%%\n"
            echo ""

            task_index=$((task_index + 1))
          done

          # Clean up current-task marker
          kubectl delete configmap current-task-{{`{{workflow.name}}`}} \
            -n {{ .Release.Namespace }} --ignore-not-found=true

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ‰ ALL TASKS COMPLETED SUCCESSFULLY!"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

{{- end }}

