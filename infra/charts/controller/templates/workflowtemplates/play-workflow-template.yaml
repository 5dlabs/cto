{{- if .Values.argo.enabled }}
---
# Multi-Agent Play Workflow Template
# Orchestrates Rex/Blaze → Cleo → Tess through event-driven coordination
# Supports parameterized agent selection and suspend/resume patterns

apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: play-workflow-template
  namespace: {{.Release.Namespace}}
  labels:
    app.kubernetes.io/name: play-workflow-template
    app.kubernetes.io/part-of: platform
    agents.platform/orchestration: multi-agent
    workflow-type: play-orchestration
spec:
  # Service account with proper permissions for CRD operations
  serviceAccountName: argo-workflow

  # Ensure labels are applied to instantiated Workflows created from this template
  workflowMetadata:
    labels:
      workflow-type: play-orchestration
    annotations:
      # Store initial parameters for forwarding to subsequent tasks
      platform.agents/initial-params: |
        {
          "model": "{{`{{workflow.parameters.model}}`}}",
          "implementation-agent": "{{`{{workflow.parameters.implementation-agent}}`}}",
          "quality-agent": "{{`{{workflow.parameters.quality-agent}}`}}",
          "testing-agent": "{{`{{workflow.parameters.testing-agent}}`}}",
          "repository": "{{`{{workflow.parameters.repository}}`}}",
          "service": "{{`{{workflow.parameters.service}}`}}",
          "docs-repository": "{{`{{workflow.parameters.docs-repository}}`}}",
          "docs-project-directory": "{{`{{workflow.parameters.docs-project-directory}}`}}"
        }

  # Main entry point
  entrypoint: main

  # Global arguments for workflow configuration
  arguments:
    parameters:
      # Agent selection parameters (no hardcoded names)
      - name: implementation-agent
        description: "Agent to use for implementation work (e.g., 5DLabs-Rex, 5DLabs-Blaze)"
        value: ""  # Must be provided by MCP client
      - name: quality-agent
        description: "Agent to use for quality assurance (e.g., 5DLabs-Cleo)"
        value: ""  # Must be provided by MCP client
      - name: testing-agent
        description: "Agent to use for testing and validation (e.g., 5DLabs-Tess)"
        value: ""  # Must be provided by MCP client

      # Task and repository configuration
      - name: task-id
        description: "Unique task identifier for correlation (required)"
        value: ""  # Must be provided by MCP client
      - name: repository
        description: "GitHub repository for the work"
        value: ""  # Must be provided by MCP client
      - name: service
        description: "Service identifier for persistent workspace"
        value: ""  # Must be provided by MCP client
      - name: docs-repository
        description: "GitHub repository containing documentation"
        value: ""  # Must be provided by MCP client
      - name: docs-project-directory
        description: "Directory within docs repository containing project documentation"
        value: ""  # Must be provided by MCP client

      # Model configuration
      - name: model
        description: "Claude model to use for all agents"
        value: ""  # Must be provided by MCP client

      # PR context (populated by suspend/resume)
      - name: pr-url
        description: "Pull request URL (populated after PR creation)"
        value: ""
      - name: pr-number
        description: "Pull request number (populated after PR creation)"
        value: ""

      # QA feedback (populated by suspend/resume)
      - name: qa-status
        description: "QA approval status (populated after QA)"
        value: ""
      - name: qa-comments
        description: "QA feedback comments (populated after QA)"
        value: ""
      - name: merge-sha
        description: "Merge commit SHA (populated after PR merge)"
        value: ""

      # Task requirements (secrets and environment variables)
      - name: task-requirements
        description: "Base64-encoded requirements.yaml content for all agents"
        value: ""

  # Workflow instance naming pattern
  onExit: cleanup-handler

  # Volume claim templates for shared workspace
  volumeClaimTemplates:
    - metadata:
        name: workspace
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 10Gi

  templates:
    # Main DAG with sequential task execution and suspend points
    - name: main
      dag:
        tasks:
          # Stage 0: Initialize workflow stage tracking
          - name: initialize-stage
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "pending"
                - name: verify-update
                  value: "true"

          # Stage 1: Implementation cycle (Rex runs; if no PR, retry cycle)
          - name: implementation-cycle
            dependencies: [initialize-stage]
            template: implementation-cycle
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{workflow.parameters.implementation-agent}}`}}"
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: stage
                  value: "implementation"

          # Update stage after implementation cycle completes (PR created)
          - name: update-to-waiting-pr-created
            dependencies: [implementation-cycle]
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "waiting-pr-created"
                - name: verify-update
                  value: "true"

          # Stage 2: Quality work
          - name: quality-work
            dependencies: [implementation-cycle, update-to-waiting-pr-created]
            template: agent-coderun
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{workflow.parameters.quality-agent}}`}}"
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: stage
                  value: "quality"
                - name: pr-url
                  value: "{{`{{tasks.implementation-cycle.outputs.parameters.pr-url}}`}}"
                - name: pr-number
                  value: "{{`{{tasks.implementation-cycle.outputs.parameters.pr-number}}`}}"

          # Update stage after quality work completes
          - name: update-to-waiting-qa
            dependencies: [quality-work]
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "waiting-ready-for-qa"
                - name: verify-update
                  value: "true"

          # Suspend point 2: Wait for ready-for-qa label
          - name: wait-ready-for-qa
            dependencies: [update-to-waiting-qa]
            template: suspend-for-event
            arguments:
              parameters:
                - name: event-type
                  value: "ready-for-qa"
                - name: stage-name
                  value: "waiting-ready-for-qa"

          # Stage 3: Testing work
          - name: testing-work
            dependencies: [wait-ready-for-qa]
            template: agent-coderun
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{workflow.parameters.testing-agent}}`}}"
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: stage
                  value: "testing"
                - name: pr-url
                  value: "{{`{{tasks.implementation-cycle.outputs.parameters.pr-url}}`}}"
                - name: pr-number
                  value: "{{`{{tasks.implementation-cycle.outputs.parameters.pr-number}}`}}"
                - name: qa-ready
                  value: "true"

          # Update stage after testing work completes
          - name: update-to-waiting-merge
            dependencies: [testing-work]
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "waiting-pr-merged"
                - name: verify-update
                  value: "true"

          # SKIP PR APPROVAL - GO STRAIGHT TO MERGE
          # Suspend point 3: Wait for PR merged to main
          - name: wait-merge-to-main
            dependencies: [update-to-waiting-merge]
            template: suspend-for-event
            arguments:
              parameters:
                - name: event-type
                  value: "pr-merged"
                - name: stage-name
                  value: "waiting-pr-merged"

          - name: complete-task
            dependencies: [wait-merge-to-main]
            template: task-completion
            arguments:
              parameters:
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: approval-status
                  value: "{{`{{workflow.parameters.qa-status}}`}}"
                - name: merge-sha
                  value: "{{`{{workflow.parameters.merge-sha}}`}}"

    # Template for creating CodeRun CRDs for agent execution and waiting for completion
    # Implementation cycle: run Rex, then check/poll for PR; if not found, repeat by failing upstream
    - name: implementation-cycle
      inputs:
        parameters:
          - name: github-app
          - name: task-id
          - name: stage
      outputs:
        parameters:
          - name: pr-url
            valueFrom:
              parameter: "{{`{{steps.wait-for-pr.outputs.parameters.pr-url}}`}}"
          - name: pr-number
            valueFrom:
              parameter: "{{`{{steps.wait-for-pr.outputs.parameters.pr-number}}`}}"
      steps:
        - - name: implementation-work
            template: agent-coderun
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{inputs.parameters.github-app}}`}}"
                - name: task-id
                  value: "{{`{{inputs.parameters.task-id}}`}}"
                - name: stage
                  value: "{{`{{inputs.parameters.stage}}`}}"
        - - name: wait-for-pr
            template: check-or-wait-for-pr
            arguments:
              parameters:
                - name: repository
                  value: "{{`{{workflow.parameters.repository}}`}}"
                - name: task-id
                  value: "{{`{{inputs.parameters.task-id}}`}}"
                - name: stage
                  value: "{{`{{inputs.parameters.stage}}`}}"

    # Template to check/poll GitHub for PR existence for task label
    - name: check-or-wait-for-pr
      inputs:
        parameters:
          - name: repository
          - name: task-id
          - name: stage
      outputs:
        parameters:
          - name: pr-url
            valueFrom:
              path: /tmp/pr-url.txt
            default: ""
          - name: pr-number
            valueFrom:
              path: /tmp/pr-number.txt
            default: ""
      script:
        image: alpine:3.20
        env:
          - name: GITHUB_APP_ID
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: app-id
          - name: GITHUB_APP_PRIVATE_KEY
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: private-key
        command: [sh]
        source: |
          #!/bin/sh
          set -e
          REPO="{{`{{inputs.parameters.repository}}`}}"
          TASK_ID="{{`{{inputs.parameters.task-id}}`}}"
          LABEL="task-${TASK_ID}"
          RUN_LABEL="run-{{`{{workflow.name}}`}}"
          SERVICE_LABEL="service-{{`{{workflow.parameters.service}}`}}"

          # For single-repo setups, we need to find PRs from previous workflow runs
          # Check if we're in a subsequent stage (quality/testing) by checking input parameters
          STAGE="{{`{{inputs.parameters.stage}}`}}"

          if [ "$STAGE" = "quality" ] || [ "$STAGE" = "testing" ]; then
            echo "🔎 Stage $STAGE: Looking for existing PR with label ${LABEL} in ${REPO}"
          else
            echo "🔎 Looking for PR with labels ${LABEL} and ${RUN_LABEL} in ${REPO}"
          fi

          # Ensure tools
          apk add --no-cache curl jq openssl >/dev/null 2>&1 || true

          AUTH_HEADER=""
          OWNER=$(echo "$REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

          if [ -n "${GITHUB_APP_ID:-}" ] && [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
            echo "🔐 Using Morgan GitHub App for authenticated API calls"
            TEMP_KEY="/tmp/github-app-key.pem"
            # Support escaped newlines in secret
            printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY"
            chmod 600 "$TEMP_KEY"

            NOW=$(date +%s)
            EXP=$((NOW + 600))
            HDR=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 2>/dev/null || printf '{"alg":"RS256","typ":"JWT"}' | base64)
            HDR=$(echo -n "$HDR" | tr '+/' '-_' | tr -d '=')
            PAY=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 2>/dev/null || printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64)
            PAY=$(echo -n "$PAY" | tr '+/' '-_' | tr -d '=')
            SIG=$(printf '%s.%s' "$HDR" "$PAY" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 -w 0 2>/dev/null || openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64)
            SIG=$(echo -n "$SIG" | tr '+/' '-_' | tr -d '=')
            JWT="$HDR.$PAY.$SIG"

            # Resolve installation ID (repo first, fallback org)
            INSTALLATION_ID=$(curl -s -L \
              -H "Authorization: Bearer $JWT" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/$OWNER/$REPO_NAME/installation" | jq -r '.id')

            if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" = "null" ]; then
              INSTALLATION_ID=$(curl -s -L \
                -H "Authorization: Bearer $JWT" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/orgs/$OWNER/installation" | jq -r '.id')
            fi

            if [ -n "$INSTALLATION_ID" ] && [ "$INSTALLATION_ID" != "null" ]; then
              TOKEN=$(curl -s -X POST \
                -H "Authorization: Bearer $JWT" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')
              if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
                AUTH_HEADER="Authorization: Bearer $TOKEN"
              fi
            fi

            rm -f "$TEMP_KEY"
          else
            echo "ℹ️ Morgan credentials not available; using unauthenticated GitHub API"
          fi

          # Poll up to 60s (12 x 5s)
          attempts=12
          while [ $attempts -gt 0 ]; do
            # GitHub API - list open PRs
            if [ -n "$AUTH_HEADER" ]; then
              resp=$(curl -sL -H "Accept: application/vnd.github+json" -H "$AUTH_HEADER" "https://api.github.com/repos/${REPO}/pulls?state=open") || resp="[]"
            else
              resp=$(curl -sL -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${REPO}/pulls?state=open") || resp="[]"
            fi

            # Different search logic based on stage
            if [ "$STAGE" = "quality" ] || [ "$STAGE" = "testing" ]; then
              # For quality/testing stages, just look for the task label (PR already exists)
              pr_url=$(echo "$resp" | jq -r '.[] | select((.labels // []) | any(.name=="'"$LABEL"'")) | .html_url' | head -n1)
              pr_number=$(echo "$resp" | jq -r '.[] | select((.labels // []) | any(.name=="'"$LABEL"'")) | .number' | head -n1)
            else
              # For implementation stage, look for both task and run labels first
              pr_url=$(echo "$resp" | jq -r '.[] | select((.labels // []) | (any(.name=="'"$LABEL"'") and any(.name=="'"$RUN_LABEL"'"))) | .html_url' | head -n1)
              pr_number=$(echo "$resp" | jq -r '.[] | select((.labels // []) | (any(.name=="'"$LABEL"'") and any(.name=="'"$RUN_LABEL"'"))) | .number' | head -n1)
              # Fall back to just task label if not found
              if [ -z "$pr_number" ] || [ "$pr_number" = "null" ]; then
                pr_url=$(echo "$resp" | jq -r '.[] | select((.labels // []) | any(.name=="'"$LABEL"'")) | .html_url' | head -n1)
                pr_number=$(echo "$resp" | jq -r '.[] | select((.labels // []) | any(.name=="'"$LABEL"'")) | .number' | head -n1)
              fi
            fi

            if [ -n "$pr_number" ] && [ "$pr_number" != "null" ]; then
              echo "$pr_url" > /tmp/pr-url.txt
              echo "$pr_number" > /tmp/pr-number.txt
              echo "✅ Found PR #$pr_number"
              if [ -n "$TOKEN" ]; then
                add_labels_payload=$(printf '{"labels":["%s","%s","%s"]}' "$LABEL" "$RUN_LABEL" "$SERVICE_LABEL")
                curl -s -X POST \
                  -H "Authorization: Bearer $TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  -H "Content-Type: application/json" \
                  -d "$add_labels_payload" \
                  "https://api.github.com/repos/${REPO}/issues/${pr_number}/labels" >/dev/null 2>&1 || true
                echo "🏷️ Ensured PR #$pr_number has labels: $LABEL, $RUN_LABEL, $SERVICE_LABEL"
              fi
              exit 0
            fi

            attempts=$((attempts-1))
            echo "⏳ PR not found yet, retrying... ($attempts left)"
            sleep 5
          done

          if [ "$STAGE" = "quality" ] || [ "$STAGE" = "testing" ]; then
            echo "❌ No PR found for ${LABEL}. This indicates the implementation stage hasn't created a PR yet."
            # For quality/testing, this is an error condition
            > /tmp/pr-url.txt
            > /tmp/pr-number.txt
            exit 1
          else
            echo "❌ No PR found for ${LABEL} after waiting."
            # Leave outputs empty; upstream can decide to re-run implementation
            > /tmp/pr-url.txt
            > /tmp/pr-number.txt
            exit 0
          fi
    - name: agent-coderun
      inputs:
        parameters:
          - name: github-app
          - name: task-id
          - name: stage
          - name: pr-url
            default: ""
          - name: pr-number
            default: ""
          - name: qa-ready
            default: "false"
      outputs:
        parameters:
          - name: coderun-name
            valueFrom:
              parameter: "{{`{{steps.resolve-coderun-name.outputs.parameters.coderun-name}}`}}"
      steps:
        - - name: create-coderun-resource
            template: create-coderun-resource
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{inputs.parameters.github-app}}`}}"
                - name: task-id
                  value: "{{`{{inputs.parameters.task-id}}`}}"
                - name: stage
                  value: "{{`{{inputs.parameters.stage}}`}}"
                - name: pr-url
                  value: "{{`{{inputs.parameters.pr-url}}`}}"
                - name: pr-number
                  value: "{{`{{inputs.parameters.pr-number}}`}}"
                - name: qa-ready
                  value: "{{`{{inputs.parameters.qa-ready}}`}}"
        - - name: resolve-coderun-name
            template: resolve-coderun-name
            arguments:
              parameters:
                - name: stage
                  value: "{{`{{inputs.parameters.stage}}`}}"
                - name: task-id
                  value: "{{`{{inputs.parameters.task-id}}`}}"
                - name: candidate-name
                  value: "{{`{{steps.create-coderun-resource.outputs.parameters.name}}`}}"
        - - name: wait-for-completion
            template: wait-coderun-completion
            arguments:
              parameters:
                - name: coderun-name
                  value: "{{`{{steps.resolve-coderun-name.outputs.parameters.coderun-name}}`}}"

    # Template for creating CodeRun resources
    - name: create-coderun-resource
      inputs:
        parameters:
          - name: github-app
          - name: task-id
          - name: stage
          - name: pr-url
            default: ""
          - name: pr-number
            default: ""
          - name: qa-ready
            default: "false"
      outputs:
        parameters:
          - name: name
            valueFrom:
              jsonPath: '{.metadata.name}'
      resource:
        action: create
        setOwnerReference: true
        successCondition: status.phase == Succeeded
        failureCondition: status.phase == Failed
        manifest: |
          apiVersion: agents.platform/v1
          kind: CodeRun
          metadata:
            generateName: "{{`{{workflow.parameters.service}}`}}-t{{`{{inputs.parameters.task-id}}`}}-{{`{{inputs.parameters.stage}}`}}-"
            namespace: {{.Release.Namespace}}
            labels:
              task-id: "{{`{{inputs.parameters.task-id}}`}}"
              service: "{{`{{workflow.parameters.service}}`}}"
              github-app: "{{`{{inputs.parameters.github-app}}`}}"
              workflow-name: "{{`{{workflow.name}}`}}"
              workflow-run: "{{`{{workflow.name}}`}}"
              workflow-stage: "{{`{{inputs.parameters.stage}}`}}"
              workflow-type: "play-orchestration"
          spec:
            taskId: {{`{{inputs.parameters.task-id}}`}}
            service: "{{`{{workflow.parameters.service}}`}}"
            repositoryUrl: "{{`{{workflow.parameters.repository}}`}}"
            docsRepositoryUrl: "https://github.com/{{`{{workflow.parameters.docs-repository}}`}}"
            docsProjectDirectory: "{{`{{workflow.parameters.docs-project-directory}}`}}"
            workingDirectory: "."
            githubApp: "{{`{{inputs.parameters.github-app}}`}}"
            model: "{{`{{workflow.parameters.model}}`}}"
            continueSession: true
            overwriteMemory: false
            docsBranch: "main"
            contextVersion: 1
            # Pass task requirements if available
            taskRequirements: "{{`{{workflow.parameters.task-requirements}}`}}"
            # Pass PR context as environment if available
            env:
              PR_URL: "{{`{{inputs.parameters.pr-url}}`}}"
              PR_NUMBER: "{{`{{inputs.parameters.pr-number}}`}}"
              QA_READY: "{{`{{inputs.parameters.qa-ready}}`}}"
              WORKFLOW_STAGE: "{{`{{inputs.parameters.stage}}`}}"
              WORKFLOW_NAME: "{{`{{workflow.name}}`}}"
              SERVICE_NAME: "{{`{{workflow.parameters.service}}`}}"
              RUN_NAME: "{{`{{workflow.name}}`}}"

    # Helper to reliably resolve the created CodeRun name before waiting for completion
    - name: resolve-coderun-name
      inputs:
        parameters:
          - name: stage
          - name: task-id
          - name: candidate-name
            default: ""
      outputs:
        parameters:
          - name: coderun-name
            valueFrom:
              path: /tmp/coderun-name.txt
      script:
        image: alpine/k8s:1.31.0
        command: [sh]
        source: |
          #!/bin/sh
          set -e
          CANDIDATE="{{`{{inputs.parameters.candidate-name}}`}}"
          if [ -n "$CANDIDATE" ] && [ "$CANDIDATE" != "null" ]; then
            echo "$CANDIDATE" > /tmp/coderun-name.txt
            exit 0
          fi
          # Fallback: resolve by labels (assumes a single CodeRun for this workflow/task/stage)
          ATTEMPTS=12
          while [ $ATTEMPTS -gt 0 ]; do
            NAME=$(kubectl get coderun.agents.platform -n {{ .Release.Namespace }} \
              -l workflow-name={{`{{workflow.name}}`}},workflow-stage={{`{{inputs.parameters.stage}}`}},task-id={{`{{inputs.parameters.task-id}}`}} \
              -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
            if [ -n "$NAME" ]; then
              echo "$NAME" > /tmp/coderun-name.txt
              exit 0
            fi
            sleep 5
            ATTEMPTS=$((ATTEMPTS-1))
          done
          echo "No CodeRun found for labels after waiting" >&2
          exit 1
      retryStrategy:
        limit: 50
        retryPolicy: "OnError"
        backoff:
          duration: "30s"
          factor: 2
          # No maxDuration - allow unlimited time for CodeRun creation

    # Template for waiting for CodeRun completion
    - name: wait-coderun-completion
      inputs:
        parameters:
          - name: coderun-name
      resource:
        action: get
        manifest: |
          apiVersion: agents.platform/v1
          kind: CodeRun
          metadata:
            name: "{{`{{inputs.parameters.coderun-name}}`}}"
            namespace: {{.Release.Namespace}}
        successCondition: status.phase == Succeeded
        failureCondition: status.phase == Failed
      retryStrategy:
        limit: 200
        retryPolicy: "OnError"
        backoff:
          duration: "60s"
          factor: 2
          # No maxDuration - allow unlimited time for CodeRun completion

    # Template for atomic workflow stage updates with optimistic locking
    - name: update-workflow-stage
      inputs:
        parameters:
          - name: new-stage
            description: "The new stage to transition to"
          - name: verify-update
            description: "Whether to verify the update succeeded"
            default: "true"
      outputs:
        parameters:
          - name: update-status
            valueFrom:
              path: /tmp/update-status.txt
            default: "unknown"
          - name: resource-version
            valueFrom:
              path: /tmp/resource-version.txt
            default: ""
      script:
        image: alpine/k8s:1.31.0
        command: [bash]
        source: |
          #!/bin/bash
          set -e

          echo "========================================="
          echo "Updating Workflow Stage"
          echo "========================================="
          echo "Workflow: {{`{{workflow.name}}`}}"
          echo "Current Task: {{`{{workflow.parameters.task-id}}`}}"
          echo "New Stage: {{`{{inputs.parameters.new-stage}}`}}"
          echo ""

          # Function to validate stage transition
          validate_stage_transition() {
            local current_stage=$1
            local new_stage=$2

            # Special case: Allow setting initial stage to "pending" when no stage label exists
            if [[ -z "$current_stage" ]] && [[ "$new_stage" == "pending" ]]; then
              echo "✅ Allowing initial stage setting: (none) → $new_stage"
              return 0
            fi

            # Define valid transitions
            case $current_stage in
              "pending")
                [[ $new_stage == "waiting-pr-created" ]] && return 0
                ;;
              "waiting-pr-created")
                [[ $new_stage == "waiting-ready-for-qa" ]] && return 0
                ;;
              "waiting-ready-for-qa")
                [[ $new_stage == "waiting-pr-merged" ]] && return 0
                ;;
              "waiting-pr-merged")
                [[ $new_stage == "completed" ]] && return 0
                ;;
            esac

            echo "❌ Invalid stage transition: $current_stage → $new_stage"
            return 1
          }

          # Get current state and resource version for optimistic locking
          echo "Fetching current workflow state..."
          WORKFLOW_JSON=$(kubectl get workflow "{{`{{workflow.name}}`}}" \
            -n {{ .Release.Namespace }} \
            -o json)

          # Check if current-stage label actually exists (not just defaulted)
          CURRENT_STAGE_RAW=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.labels["current-stage"]')
          if [ "$CURRENT_STAGE_RAW" = "null" ]; then
            CURRENT_STAGE=""
            echo "Current stage: (no label exists)"
          else
            CURRENT_STAGE="$CURRENT_STAGE_RAW"
            echo "Current stage: $CURRENT_STAGE"
          fi

          RESOURCE_VERSION=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.resourceVersion')
          echo "Resource version: $RESOURCE_VERSION"

          # Validate stage transition
          if ! validate_stage_transition "$CURRENT_STAGE" "{{`{{inputs.parameters.new-stage}}`}}"; then
            echo "❌ Stage transition validation failed"
            echo "failed" > /tmp/update-status.txt
            exit 1
          fi

          # Prepare the JSON patch with optimistic locking
          REPOSITORY_LABEL=$(echo '{{`{{workflow.parameters.repository}}`}}' | tr '/' '-')
          PATCH_JSON='{
            "metadata": {
              "resourceVersion": "'$RESOURCE_VERSION'",
              "labels": {
                "current-stage": "{{`{{inputs.parameters.new-stage}}`}}",
                "task-id": "{{`{{workflow.parameters.task-id}}`}}",
                "repository": "'$REPOSITORY_LABEL'",
                "previous-stage": "'$CURRENT_STAGE'"
              }
            }
          }'

          echo ""
          echo "Prepared patch payload:"
          echo "$PATCH_JSON" | jq .

          # Apply the patch with exponential backoff retry
          MAX_RETRIES=5
          RETRY_COUNT=0
          UPDATE_SUCCESS=false
          BACKOFF_TIME=1

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo ""
            echo "Attempt $((RETRY_COUNT+1)) of $MAX_RETRIES..."

            if kubectl patch workflow "{{`{{workflow.name}}`}}" \
              --type='merge' \
              --patch="$PATCH_JSON" \
              -n {{ .Release.Namespace }}; then

              UPDATE_SUCCESS=true
              echo "✅ Stage update successful"
              break
            else
              echo "⚠️ Stage update failed with status: $?"
              echo "Retrying in $BACKOFF_TIME seconds..."
              sleep $BACKOFF_TIME

              # Update resource version before retry
              RESOURCE_VERSION=$(kubectl get workflow "{{`{{workflow.name}}`}}" \
                -n {{ .Release.Namespace }} \
                -o jsonpath='{.metadata.resourceVersion}')

              # Update patch with new resource version
              PATCH_JSON=$(echo "$PATCH_JSON" | jq --arg rv "$RESOURCE_VERSION" \
                '.metadata.resourceVersion = $rv')

              RETRY_COUNT=$((RETRY_COUNT+1))
              BACKOFF_TIME=$((BACKOFF_TIME*2))
            fi
          done

          # Save resource version for other templates
          echo "$RESOURCE_VERSION" > /tmp/resource-version.txt

          # Always verify the update
          echo ""
          echo "Verifying stage update..."

          VERIFY_MAX_RETRIES=3
          VERIFY_COUNT=0
          VERIFY_SUCCESS=false

          while [ $VERIFY_COUNT -lt $VERIFY_MAX_RETRIES ]; do
            WORKFLOW_JSON=$(kubectl get workflow "{{`{{workflow.name}}`}}" \
              -n {{ .Release.Namespace }} \
              -o json)

            CURRENT_STAGE=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.labels["current-stage"]')
            PREVIOUS_STAGE=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.labels["previous-stage"]')
            NEW_RESOURCE_VERSION=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.resourceVersion')

            echo "Current Stage: $CURRENT_STAGE"
            echo "Previous Stage: $PREVIOUS_STAGE"
            echo "Resource Version: $NEW_RESOURCE_VERSION"

            if [ "$CURRENT_STAGE" = "{{`{{inputs.parameters.new-stage}}`}}" ]; then
              VERIFY_SUCCESS=true
              echo "✅ Verification successful: Stage transition complete"
              echo "success" > /tmp/update-status.txt
              break
            else
              echo "⚠️ Verification attempt $((VERIFY_COUNT+1)) failed, retrying..."
              VERIFY_COUNT=$((VERIFY_COUNT+1))
              sleep 2
            fi
          done

          if [ "$VERIFY_SUCCESS" != true ]; then
            echo "❌ Stage update verification failed after $VERIFY_MAX_RETRIES attempts"
            echo "failed" > /tmp/update-status.txt
            exit 1
          fi

          # Output monitoring metrics
          cat <<EOF > /tmp/stage-transition-metrics.json
          {
            "workflow": "{{`{{workflow.name}}`}}",
            "task_id": "{{`{{workflow.parameters.task-id}}`}}",
            "transition": {
              "from": "$PREVIOUS_STAGE",
              "to": "$CURRENT_STAGE",
              "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
              "duration_seconds": "$SECONDS",
              "retry_count": "$RETRY_COUNT",
              "verify_count": "$VERIFY_COUNT",
              "resource_version": "$NEW_RESOURCE_VERSION"
            }
          }
          EOF

          echo ""
          echo "Stage transition completed successfully"
          echo "Duration: $SECONDS seconds"
          echo "Retries required: $RETRY_COUNT"
          echo "Verification attempts: $VERIFY_COUNT"
      retryStrategy:
        limit: 20
        retryPolicy: "OnFailure"
        backoff:
          duration: "60s"
          factor: 2
          # No maxDuration - allow unlimited time for workflow stage updates

    # Template for suspend points waiting for external events via webhooks
    - name: suspend-for-event
      inputs:
        parameters:
          - name: event-type
          - name: stage-name
      metadata:
        labels:
          current-stage: "{{`{{inputs.parameters.stage-name}}`}}"
          task-id: "{{`{{workflow.parameters.task-id}}`}}"
          workflow-type: "play-orchestration"
      suspend: {}  # Indefinite suspend until external resume via webhooks

    # Template for task completion and cleanup
    - name: task-completion
      inputs:
        parameters:
          - name: task-id
          - name: approval-status
          - name: merge-sha
      script:
        image: alpine/k8s:1.31.0
        command: [sh]
        source: |
          #!/bin/sh
          set -e

          echo "========================================="
          echo "Completing Task {{`{{inputs.parameters.task-id}}`}}"
          echo "========================================="
          echo "Approval Status: {{`{{inputs.parameters.approval-status}}`}}"
          echo "Merge SHA: {{`{{inputs.parameters.merge-sha}}`}}"
          echo ""

          # Create completion marker
          echo "Task {{`{{inputs.parameters.task-id}}`}} completed at $(date)" > /tmp/task-complete.txt
          echo "Workflow: {{`{{workflow.name}}`}}" >> /tmp/task-complete.txt
          echo "Duration: {{`{{workflow.duration}}`}}" >> /tmp/task-complete.txt
          echo "PR Approved: {{`{{inputs.parameters.approval-status}}`}}" >> /tmp/task-complete.txt

          # Generate workflow summary
          cat <<EOF > /tmp/workflow-summary.md
          # Task {{`{{inputs.parameters.task-id}}`}} Completion Summary

          ## Workflow Details
          - **Workflow Name**: {{`{{workflow.name}}`}}
          - **Task ID**: {{`{{inputs.parameters.task-id}}`}}
          - **Repository**: {{`{{workflow.parameters.repository}}`}}
          - **Duration**: {{`{{workflow.duration}}`}}

          ## Agent Execution
          - **Implementation Agent**: {{`{{workflow.parameters.implementation-agent}}`}}
          - **Quality Agent**: {{`{{workflow.parameters.quality-agent}}`}}
          - **Testing Agent**: {{`{{workflow.parameters.testing-agent}}`}}

          ## Results
          - **PR Number**: {{`{{workflow.parameters.pr-number}}`}}
          - **Approval Status**: {{`{{inputs.parameters.approval-status}}`}}
          - **Merge SHA**: {{`{{inputs.parameters.merge-sha}}`}}

          ## Stages Completed
          1. ✅ Implementation Work
          2. ✅ Quality Assurance
          3. ✅ Testing & Validation
          4. ✅ PR Approval

          Task successfully completed and merged to main branch.
          EOF

          echo ""
          echo "Workflow summary generated successfully"
          echo "Task {{`{{inputs.parameters.task-id}}`}} workflow completed!"
          echo ""
          echo "Note: Next task will be started automatically by webhook system"
        volumeMounts:
          - name: workspace
            mountPath: /work

    # Cleanup handler for workflow completion/failure
    - name: cleanup-handler
      script:
        image: alpine:3.20
        command: [sh]
        source: |
          #!/bin/sh
          echo "========================================="
          echo "Workflow Cleanup Handler"
          echo "========================================="
          echo "Workflow Name: {{`{{workflow.name}}`}}"
          echo "Status: {{`{{workflow.status}}`}}"
          echo "Task ID: {{`{{workflow.parameters.task-id}}`}}"

          # Log final workflow state
          if [ "{{`{{workflow.status}}`}}" = "Succeeded" ]; then
            echo "✅ Workflow completed successfully"
          else
            echo "❌ Workflow failed or was terminated"
          fi

          echo "Cleanup completed"

  # TTL strategy for workflow cleanup
  ttlStrategy:
    secondsAfterCompletion: 86400    # Keep completed workflows for 24 hours
    secondsAfterFailure: 259200      # Keep failed workflows for 3 days
    secondsAfterSuccess: 86400       # Keep successful workflows for 24 hours

  # Pod garbage collection
  podGC:
    strategy: OnPodCompletion
    deleteDelayDuration: 60s
{{- end }}
