{{- if .Values.argo.enabled }}
---
# Multi-Agent Play Workflow Template
# Orchestrates Rex ‚Üí Cleo ‚Üí Tess through event-driven coordination
# Rex implements ‚Üí Cleo ensures quality ‚Üí Tess validates E2E in Kubernetes
# Supports parameterized agent selection and suspend/resume patterns

apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: play-workflow-template
  namespace: {{.Release.Namespace}}
  labels:
    app.kubernetes.io/name: play-workflow-template
    app.kubernetes.io/part-of: platform
    agents.platform/orchestration: multi-agent
    workflow-type: play-orchestration
spec:
  # Service account with proper permissions for CRD operations
  serviceAccountName: argo-workflow

  # Workflow timeout (14 days for long-running multi-agent workflows)
  activeDeadlineSeconds: 1209600

  # Ensure labels are applied to instantiated Workflows created from this template
  workflowMetadata:
    labels:
      workflow-type: play-orchestration
    annotations:
      # Store initial parameters for forwarding to subsequent tasks
      platform.agents/initial-params: |
        {
          "implementation-agent": "{{`{{workflow.parameters.implementation-agent}}`}}",
          "implementation-cli": "{{`{{workflow.parameters.implementation-cli}}`}}",
          "implementation-model": "{{`{{workflow.parameters.implementation-model}}`}}",
          "frontend-agent": "{{`{{workflow.parameters.frontend-agent}}`}}",
          "frontend-cli": "{{`{{workflow.parameters.frontend-cli}}`}}",
          "frontend-model": "{{`{{workflow.parameters.frontend-model}}`}}",
          "quality-agent": "{{`{{workflow.parameters.quality-agent}}`}}",
          "quality-cli": "{{`{{workflow.parameters.quality-cli}}`}}",
          "quality-model": "{{`{{workflow.parameters.quality-model}}`}}",
          "security-agent": "{{`{{workflow.parameters.security-agent}}`}}",
          "security-cli": "{{`{{workflow.parameters.security-cli}}`}}",
          "security-model": "{{`{{workflow.parameters.security-model}}`}}",
          "testing-agent": "{{`{{workflow.parameters.testing-agent}}`}}",
          "testing-cli": "{{`{{workflow.parameters.testing-cli}}`}}",
          "testing-model": "{{`{{workflow.parameters.testing-model}}`}}",
          "repository": "{{`{{workflow.parameters.repository}}`}}",
          "service": "{{`{{workflow.parameters.service}}`}}",
          "docs-repository": "{{`{{workflow.parameters.docs-repository}}`}}",
          "docs-project-directory": "{{`{{workflow.parameters.docs-project-directory}}`}}",
          "implementation-max-retries": "{{`{{workflow.parameters.implementation-max-retries}}`}}",
          "frontend-max-retries": "{{`{{workflow.parameters.frontend-max-retries}}`}}",
          "quality-max-retries": "{{`{{workflow.parameters.quality-max-retries}}`}}",
          "security-max-retries": "{{`{{workflow.parameters.security-max-retries}}`}}",
          "testing-max-retries": "{{`{{workflow.parameters.testing-max-retries}}`}}",
          "auto-merge": "{{`{{workflow.parameters.auto-merge}}`}}",
          "final-task": "{{`{{workflow.parameters.final-task}}`}}"
        }

  # Main entry point
  entrypoint: main

  # Global arguments for workflow configuration
  arguments:
    parameters:
      # Agent selection parameters (no hardcoded names)
      - name: implementation-agent
        description: "Agent to use for implementation work (e.g., 5DLabs-Rex)"
        value: ""  # Must be provided by MCP client
      - name: frontend-agent
        description: "Agent to use for frontend work (e.g., 5DLabs-Blaze)"
        value: ""  # Must be provided by MCP client
      - name: quality-agent
        description: "Agent to use for quality assurance (e.g., 5DLabs-Cleo)"
        value: ""  # Must be provided by MCP client
      - name: security-agent
        description: "Agent to use for security scanning (e.g., 5DLabs-Cipher)"
        value: ""  # Must be provided by MCP client
      - name: testing-agent
        description: "Agent to use for testing and validation (e.g., 5DLabs-Tess)"
        value: ""  # Must be provided by MCP client

      # Task and repository configuration
      - name: task-id
        description: "Unique task identifier for correlation (required)"
        value: ""  # Must be provided by MCP client
      - name: repository
        description: "GitHub repository for the work"
        value: ""  # Must be provided by MCP client
      - name: service
        description: "Service identifier for persistent workspace"
        value: ""  # Must be provided by MCP client
      - name: docs-repository
        description: "GitHub repository containing documentation"
        value: ""  # Must be provided by MCP client
      - name: docs-project-directory
        description: "Directory within docs repository containing project documentation"
        value: ""  # Must be provided by MCP client

      # CLI configuration per agent (multi-CLI aware)
      - name: implementation-cli
        description: "CLI to use for implementation agent (e.g., codex, claude)"
        value: ""  # Must be provided by MCP client
      - name: implementation-model
        description: "Model to use for implementation agent (e.g., gpt-5-codex, claude-sonnet-4-20250514)"
        value: ""  # Must be provided by MCP client
      - name: quality-cli
        description: "CLI to use for quality agent (e.g., claude, codex)"
        value: ""  # Must be provided by MCP client
      - name: quality-model
        description: "Model to use for quality agent"
        value: ""  # Must be provided by MCP client
      - name: security-cli
        description: "CLI to use for security agent (e.g., claude, codex)"
        value: ""  # Must be provided by MCP client
      - name: security-model
        description: "Model to use for security agent"
        value: ""  # Must be provided by MCP client
      - name: testing-cli
        description: "CLI to use for testing agent"
        value: ""  # Must be provided by MCP client
      - name: testing-model
        description: "Model to use for testing agent"
        value: ""  # Must be provided by MCP client
      - name: frontend-cli
        description: "CLI to use for frontend agent (e.g., codex, claude)"
        value: ""  # Must be provided by MCP client
      - name: frontend-model
        description: "Model to use for frontend agent"
        value: ""  # Must be provided by MCP client

      # Agent tool configurations (JSON strings from client-side config)
      - name: implementation-tools
        description: "JSON string of tools config for implementation agent"
        value: "{}"  # Defaults to empty, populated by MCP client
      - name: quality-tools
        description: "JSON string of tools config for quality agent"
        value: "{}"  # Defaults to empty, populated by MCP client
      - name: security-tools
        description: "JSON string of tools config for security agent"
        value: "{}"  # Defaults to empty, populated by MCP client
      - name: testing-tools
        description: "JSON string of tools config for testing agent"
        value: "{}"  # Defaults to empty, populated by MCP client
      - name: frontend-tools
        description: "JSON string of tools config for frontend agent"
        value: "{}"  # Defaults to empty, populated by MCP client

      # Model rotation configurations (JSON arrays of model names)
      - name: implementation-model-rotation
        description: "JSON array of model names for implementation agent retry rotation"
        value: "[]"  # Defaults to empty array, populated by MCP client from cto-config.json
      - name: quality-model-rotation
        description: "JSON array of model names for quality agent retry rotation"
        value: "[]"  # Defaults to empty array, populated by MCP client from cto-config.json
      - name: security-model-rotation
        description: "JSON array of model names for security agent retry rotation"
        value: "[]"  # Defaults to empty array, populated by MCP client from cto-config.json
      - name: testing-model-rotation
        description: "JSON array of model names for testing agent retry rotation"
        value: "[]"  # Defaults to empty array, populated by MCP client from cto-config.json
      - name: frontend-model-rotation
        description: "JSON array of model names for frontend agent retry rotation"
        value: "[]"  # Defaults to empty array, populated by MCP client from cto-config.json

      # PR context (populated by suspend/resume)
      - name: pr-url
        description: "Pull request URL (populated after PR creation)"
        value: ""
      - name: pr-number
        description: "Pull request number (populated after PR creation)"
        value: ""

      # QA feedback (populated by suspend/resume)
      - name: qa-status
        description: "QA approval status (populated after QA)"
        value: ""
      - name: qa-comments
        description: "QA feedback comments (populated after QA)"
        value: ""
      - name: merge-sha
        description: "Merge commit SHA (populated after PR merge)"
        value: ""

      # Task requirements (secrets and environment variables)
      - name: task-requirements
        description: "Base64-encoded requirements.yaml content for all agents"
        value: ""
      - name: opencode-max-retries
        description: "Maximum retry attempts for OpenCode agent executions (0 = unlimited)"
        value: "10"
      - name: opencode-verbose
        description: "Enable verbose output for OpenCode agents (1 = markdown format, 0 = json)"
        value: "0"
      - name: implementation-max-retries
        description: "Maximum retry attempts for implementation agent executions (0 = unlimited)"
        value: "10"
      - name: quality-max-retries
        description: "Maximum retry attempts for quality agent executions (0 = unlimited)"
        value: "10"
      - name: security-max-retries
        description: "Maximum retry attempts for security agent executions (0 = unlimited)"
        value: "10"
      - name: testing-max-retries
        description: "Maximum retry attempts for testing agent executions (0 = unlimited)"
        value: "10"
      - name: frontend-max-retries
        description: "Maximum retry attempts for frontend agent executions (0 = unlimited)"
        value: "10"
      - name: auto-merge
        description: "Whether Tess should automatically merge PRs after approval (true/false)"
        value: "false"
      - name: final-task
        description: "Whether this is the final task requiring deployment verification (true/false)"
        value: "false"

  # Workflow instance naming pattern
  onExit: cleanup-handler

  templates:
    # Main DAG with sequential task execution and suspend points
    - name: main
      dag:
        tasks:
          # Stage 0: Initialize workflow stage tracking
          - name: initialize-stage
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "pending"
                - name: verify-update
                  value: "true"

          # Stage 1: Update to implementation stage before Rex starts
          - name: update-to-implementation
            dependencies: [initialize-stage]
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "implementation-in-progress"
                - name: verify-update
                  value: "false"

          # Remediation loop: Rex ‚Üí Cleo ‚Üí Tess until approved
          - name: remediation-iteration
            dependencies: [update-to-implementation]
            template: remediation-iteration
            arguments:
              parameters:
                - name: max-retries
                  value: "{{`{{workflow.parameters.implementation-max-retries}}`}}"

          # Update stage after successful remediation (approved status)
          - name: update-to-waiting-merge
            dependencies: [remediation-iteration]
            when: "{{`{{tasks.remediation-iteration.outputs.parameters.remediation-status}}`}} == approved"
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "waiting-pr-merged"
                - name: verify-update
                  value: "true"

          # SKIP PR APPROVAL - GO STRAIGHT TO MERGE
          # Suspend point 3: Wait for PR merged to main
          - name: wait-merge-to-main
            dependencies: [update-to-waiting-merge]
            when: "{{`{{tasks.remediation-iteration.outputs.parameters.remediation-status}}`}} == approved"
            template: suspend-for-event
            arguments:
              parameters:
                - name: event-type
                  value: "pr-merged"
                - name: stage-name
                  value: "waiting-pr-merged"

          - name: complete-task
            dependencies: [wait-merge-to-main]
            when: "{{`{{tasks.remediation-iteration.outputs.parameters.remediation-status}}`}} == approved"
            template: task-completion
            arguments:
              parameters:
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: approval-status
                  value: "{{`{{tasks.remediation-iteration.outputs.parameters.remediation-status}}`}}"
                - name: merge-sha
                  value: "{{`{{workflow.parameters.merge-sha}}`}}"

          - name: complete-task-failed
            dependencies: [remediation-iteration]
            when: "{{`{{tasks.remediation-iteration.outputs.parameters.remediation-status}}`}} == failed"
            template: task-completion
            arguments:
              parameters:
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: approval-status
                  value: "failed"
                - name: merge-sha
                  value: ""

    # Template for creating CodeRun CRDs for agent execution and waiting for completion
    # Implementation cycle: run Rex, then check/poll for PR; if not found, repeat by failing upstream
    - name: implementation-cycle
      inputs:
        parameters:
          - name: github-app
          - name: task-id
          - name: stage
          - name: cli-type
          - name: model
          - name: model-rotation
            default: "[]"
          - name: max-retries
          - name: task-language
            default: "rust"
          - name: task-framework
            default: ""
      outputs:
        parameters:
          - name: pr-url
            valueFrom:
              parameter: "{{`{{steps.wait-for-pr.outputs.parameters.pr-url}}`}}"
          - name: pr-number
            valueFrom:
              parameter: "{{`{{steps.wait-for-pr.outputs.parameters.pr-number}}`}}"
      steps:
        - - name: implementation-work
            template: agent-coderun
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{inputs.parameters.github-app}}`}}"
                - name: task-id
                  value: "{{`{{inputs.parameters.task-id}}`}}"
                - name: stage
                  value: "{{`{{inputs.parameters.stage}}`}}"
                - name: cli-type
                  value: "{{`{{inputs.parameters.cli-type}}`}}"
                - name: model
                  value: "{{`{{inputs.parameters.model}}`}}"
                - name: model-rotation
                  value: "{{`{{inputs.parameters.model-rotation}}`}}"
                - name: tools-config
                  value: "{{`{{workflow.parameters.implementation-tools}}`}}"
                - name: max-retries
                  value: "{{`{{inputs.parameters.max-retries}}`}}"
                - name: task-language
                  value: "{{`{{inputs.parameters.task-language}}`}}"
                - name: task-framework
                  value: "{{`{{inputs.parameters.task-framework}}`}}"
        - - name: wait-for-pr
            template: check-or-wait-for-pr
            arguments:
              parameters:
                - name: repository
                  value: "{{`{{workflow.parameters.repository}}`}}"
                - name: task-id
                  value: "{{`{{inputs.parameters.task-id}}`}}"
                - name: stage
                  value: "{{`{{inputs.parameters.stage}}`}}"

    # Run a full remediation iteration (Rex ‚Üí Cleo ‚Üí Tess) with automatic retries
    - name: remediation-iteration
      inputs:
        parameters:
          - name: max-retries
            value: "10"
      outputs:
        parameters:
          - name: pr-url
            valueFrom:
              parameter: "{{`{{steps.implementation.outputs.parameters.pr-url}}`}}"
          - name: pr-number
            valueFrom:
              parameter: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"
          - name: remediation-status
            valueFrom:
              parameter: "{{`{{steps.evaluate-remediation.outputs.parameters.remediation-status}}`}}"
      retryStrategy:
        retryPolicy: Always
        limit: "{{`{{inputs.parameters.max-retries}}`}}"
        backoff:
          duration: "60s"
          factor: 2
      steps:
        - - name: determine-agent
            template: determine-task-agent
            arguments:
              parameters:
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: docs-repository
                  value: "{{`{{workflow.parameters.docs-repository}}`}}"
                - name: docs-project-directory
                  value: "{{`{{workflow.parameters.docs-project-directory}}`}}"
        - - name: implementation
            template: implementation-cycle
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{steps.determine-agent.outputs.parameters.github-app}}`}}"
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: stage
                  value: "implementation"
                - name: cli-type
                  value: "{{`{{steps.determine-agent.outputs.parameters.cli-type}}`}}"
                - name: model
                  value: "{{`{{steps.determine-agent.outputs.parameters.model}}`}}"
                - name: model-rotation
                  value: "{{`{{steps.determine-agent.outputs.parameters.model-rotation}}`}}"
                - name: max-retries
                  value: "{{`{{steps.determine-agent.outputs.parameters.max-retries}}`}}"
                - name: task-language
                  value: "{{`{{steps.determine-agent.outputs.parameters.task-language}}`}}"
                - name: task-framework
                  value: "{{`{{steps.determine-agent.outputs.parameters.task-framework}}`}}"
        # Note: No longer suspending for PR created event - implementation-cycle already
        # verified PR exists via check-or-wait-for-pr polling. Webhook-based resume was
        # creating race conditions where PR webhook fired before suspend point was reached.
        - - name: update-to-quality-in-progress
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "quality-in-progress"
                - name: verify-update
                  value: "true"
        - - name: check-quality-completion
            template: check-pr-merge-status
            arguments:
              parameters:
                - name: repository
                  value: "{{`{{workflow.parameters.repository}}`}}"
                - name: pr-number
                  value: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"
                - name: stage-name
                  value: "quality"
        - - name: quality-work
            template: agent-coderun
            continueOn:
              failed: true  # Allow workflow to proceed to Cipher even if Cleo finds issues
            when: "'{{`{{steps.check-quality-completion.outputs.parameters.skip-stage}}`}}' != 'true'"
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{workflow.parameters.quality-agent}}`}}"
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: stage
                  value: "quality"
                - name: cli-type
                  value: "{{`{{workflow.parameters.quality-cli}}`}}"
                - name: model
                  value: "{{`{{workflow.parameters.quality-model}}`}}"
                - name: model-rotation
                  value: "{{`{{workflow.parameters.quality-model-rotation}}`}}"
                - name: tools-config
                  value: "{{`{{workflow.parameters.quality-tools}}`}}"
                - name: pr-url
                  value: "{{`{{steps.implementation.outputs.parameters.pr-url}}`}}"
                - name: pr-number
                  value: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"
                - name: max-retries
                  value: "{{`{{workflow.parameters.quality-max-retries}}`}}"
        # Proceed to Cipher security scanning after Cleo quality checks
        # Skip security stage if agent/cli/model are not configured
        - - name: update-to-security-in-progress
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "security-in-progress"
                - name: verify-update
                  value: "true"
            when: "'{{`{{workflow.parameters.security-agent}}`}}' != '' && '{{`{{workflow.parameters.security-cli}}`}}' != '' && '{{`{{workflow.parameters.security-model}}`}}' != ''"
        - - name: check-security-completion
            template: check-pr-merge-status
            arguments:
              parameters:
                - name: repository
                  value: "{{`{{workflow.parameters.repository}}`}}"
                - name: pr-number
                  value: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"
                - name: stage-name
                  value: "security"
            when: "'{{`{{workflow.parameters.security-agent}}`}}' != '' && '{{`{{workflow.parameters.security-cli}}`}}' != '' && '{{`{{workflow.parameters.security-model}}`}}' != ''"
        - - name: security-work
            template: agent-coderun
            continueOn:
              failed: true  # Allow workflow to proceed to Tess even if Cipher finds security issues
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{workflow.parameters.security-agent}}`}}"
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: stage
                  value: "security"
                - name: cli-type
                  value: "{{`{{workflow.parameters.security-cli}}`}}"
                - name: model
                  value: "{{`{{workflow.parameters.security-model}}`}}"
                - name: model-rotation
                  value: "{{`{{workflow.parameters.security-model-rotation}}`}}"
                - name: tools-config
                  value: "{{`{{workflow.parameters.security-tools}}`}}"
                - name: pr-url
                  value: "{{`{{steps.implementation.outputs.parameters.pr-url}}`}}"
                - name: pr-number
                  value: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"
                - name: max-retries
                  value: "{{`{{workflow.parameters.security-max-retries}}`}}"
            when: "'{{`{{workflow.parameters.security-agent}}`}}' != '' && '{{`{{workflow.parameters.security-cli}}`}}' != '' && '{{`{{workflow.parameters.security-model}}`}}' != '' && '{{`{{steps.check-security-completion.outputs.parameters.skip-stage}}`}}' != 'true'"
        - - name: skip-security-stage
            template: skip-stage-notice
            arguments:
              parameters:
                - name: stage-name
                  value: "security"
                - name: reason
                  value: "security-agent, security-cli, or security-model not configured"
            when: "'{{`{{workflow.parameters.security-agent}}`}}' == '' || '{{`{{workflow.parameters.security-cli}}`}}' == '' || '{{`{{workflow.parameters.security-model}}`}}' == ''"
        # Proceed directly to Tess testing after Cipher completes
        # No suspension needed - Tess runs automatically after security review
        # continueOn.failed allows workflow to complete even if Tess finds issues
        - - name: check-testing-completion
            template: check-pr-merge-status
            arguments:
              parameters:
                - name: repository
                  value: "{{`{{workflow.parameters.repository}}`}}"
                - name: pr-number
                  value: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"
                - name: stage-name
                  value: "testing"
        - - name: update-to-testing
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "testing-in-progress"
                - name: verify-update
                  value: "true"
            when: "'{{`{{steps.check-testing-completion.outputs.parameters.skip-stage}}`}}' != 'true'"
        - - name: testing-work
            template: agent-coderun
            continueOn:
              failed: true
            when: "'{{`{{steps.check-testing-completion.outputs.parameters.skip-stage}}`}}' != 'true'"
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{workflow.parameters.testing-agent}}`}}"
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: stage
                  value: "testing"
                - name: cli-type
                  value: "{{`{{workflow.parameters.testing-cli}}`}}"
                - name: model
                  value: "{{`{{workflow.parameters.testing-model}}`}}"
                - name: model-rotation
                  value: "{{`{{workflow.parameters.testing-model-rotation}}`}}"
                - name: tools-config
                  value: "{{`{{workflow.parameters.testing-tools}}`}}"
                - name: pr-url
                  value: "{{`{{steps.implementation.outputs.parameters.pr-url}}`}}"
                - name: pr-number
                  value: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"
                - name: max-retries
                  value: "{{`{{workflow.parameters.testing-max-retries}}`}}"
                - name: qa-ready
                  value: "true"
                - name: auto-merge
                  value: "{{`{{workflow.parameters.auto-merge}}`}}"
                - name: final-task
                  value: "{{`{{workflow.parameters.final-task}}`}}"
        # After Tess completes testing, update to waiting for PR merge
        - - name: update-to-waiting-merge
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "waiting-pr-merged"
                - name: verify-update
                  value: "true"
        - - name: evaluate-remediation
            template: assess-remediation-outcome
            arguments:
              parameters:
                - name: repository
                  value: "{{`{{workflow.parameters.repository}}`}}"
                - name: pr-number
                  value: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"

    # Template to check/poll GitHub for PR existence for task label
    - name: check-or-wait-for-pr
      inputs:
        parameters:
          - name: repository
          - name: task-id
          - name: stage
      outputs:
        parameters:
          - name: pr-url
            valueFrom:
              path: /tmp/pr-url.txt
            default: ""
          - name: pr-number
            valueFrom:
              path: /tmp/pr-number.txt
            default: ""
      script:
        image: alpine:3.20
        env:
          - name: GITHUB_APP_ID
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: app-id
          - name: GITHUB_APP_PRIVATE_KEY
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: private-key
        command: [sh]
        source: |
          #!/bin/sh
          set -e
          REPO="{{`{{inputs.parameters.repository}}`}}"
          TASK_ID="{{`{{inputs.parameters.task-id}}`}}"
          TASK_LABEL="task-${TASK_ID}"
          RUN_LABEL="run-{{`{{workflow.name}}`}}"
          SERVICE_LABEL="service-{{`{{workflow.parameters.service}}`}}"
          EXPECTED_BRANCH="feature/task-${TASK_ID}-implementation"

          # For single-repo setups, we need to find PRs from the current workflow run
          # Always use both task label AND run label to avoid finding old PRs from previous runs
          STAGE="{{`{{inputs.parameters.stage}}`}}"

          echo "üîé Stage $STAGE: Looking for PR with labels ${TASK_LABEL} and ${RUN_LABEL} in ${REPO}"

          # Ensure tools
          apk add --no-cache curl jq openssl >/dev/null 2>&1 || true

          AUTH_HEADER=""
          OWNER=$(echo "$REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

          if [ -n "${GITHUB_APP_ID:-}" ] && [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
            echo "üîê Using Morgan GitHub App for authenticated API calls"
            TEMP_KEY="/tmp/github-app-key.pem"
            # Support escaped newlines in secret
            printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY"
            chmod 600 "$TEMP_KEY"

            NOW=$(date +%s)
            EXP=$((NOW + 600))
            HDR=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 2>/dev/null || printf '{"alg":"RS256","typ":"JWT"}' | base64)
            HDR=$(echo -n "$HDR" | tr '+/' '-_' | tr -d '=')
            PAY=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 2>/dev/null || printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64)
            PAY=$(echo -n "$PAY" | tr '+/' '-_' | tr -d '=')
            SIG=$(printf '%s.%s' "$HDR" "$PAY" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 -w 0 2>/dev/null || openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64)
            SIG=$(echo -n "$SIG" | tr '+/' '-_' | tr -d '=')
            JWT="$HDR.$PAY.$SIG"

            # Resolve installation ID (repo first, fallback org)
            INSTALLATION_ID=$(curl -s -L \
              -H "Authorization: Bearer $JWT" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/$OWNER/$REPO_NAME/installation" | jq -r '.id')

            if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" = "null" ]; then
              INSTALLATION_ID=$(curl -s -L \
                -H "Authorization: Bearer $JWT" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/orgs/$OWNER/installation" | jq -r '.id')
            fi

            if [ -n "$INSTALLATION_ID" ] && [ "$INSTALLATION_ID" != "null" ]; then
              TOKEN=$(curl -s -X POST \
                -H "Authorization: Bearer $JWT" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')
              if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
                AUTH_HEADER="Authorization: Bearer $TOKEN"
              fi
            fi

            rm -f "$TEMP_KEY"
          else
            echo "‚ÑπÔ∏è Morgan credentials not available; using unauthenticated GitHub API"
          fi

          # Poll for PR creation with reasonable timeout
          # Implementation agents (Factory/Rex) can take 30-90s to create PR after code completion
          # Quality/Security/Testing should be faster as PR already exists
          if [ "$STAGE" = "implementation" ]; then
            attempts=18  # 90s total (18 √ó 5s) for implementation PR creation
          else
            attempts=8   # 40s total (8 √ó 5s) for existing PR detection
          fi
          while [ $attempts -gt 0 ]; do
            # First, try to find PR by labels (fast path for already-labeled PRs)
            q_labels=$(printf "%s" "$TASK_LABEL,$RUN_LABEL" | sed 's/,/%2C/g')
            url="https://api.github.com/repos/${REPO}/issues?state=open&labels=${q_labels}"
            if [ -n "$AUTH_HEADER" ]; then
              resp=$(curl -sL -H "Accept: application/vnd.github+json" -H "$AUTH_HEADER" "$url") || resp="[]"
            else
              resp=$(curl -sL -H "Accept: application/vnd.github+json" "$url") || resp="[]"
            fi

            pr_url=$(echo "$resp" | jq -r '.[] | select(.pull_request != null) | .html_url' | head -n1)
            pr_number=$(echo "$resp" | jq -r '.[] | select(.pull_request != null) | .number' | head -n1)

            # If not found by exact labels, try searching by branch name (open PRs first)
            if [ -z "$pr_number" ] || [ "$pr_number" = "null" ]; then
              echo "üîç No PR found by labels, searching by branch name..."
              url="https://api.github.com/repos/${REPO}/pulls?state=open&head=${OWNER}:${EXPECTED_BRANCH}"
              if [ -n "$AUTH_HEADER" ]; then
                resp=$(curl -sL -H "Accept: application/vnd.github+json" -H "$AUTH_HEADER" "$url") || resp="[]"
              else
                resp=$(curl -sL -H "Accept: application/vnd.github+json" "$url") || resp="[]"
              fi
              
              pr_url=$(echo "$resp" | jq -r '.[0].html_url // empty' | head -n1)
              pr_number=$(echo "$resp" | jq -r '.[0].number // empty' | head -n1)
              
              if [ -n "$pr_number" ] && [ "$pr_number" != "null" ]; then
                echo "‚úÖ Found PR #$pr_number by branch name: $EXPECTED_BRANCH"
              else
                # If no open PR found, check for closed PRs (may indicate previous run)
                echo "üîç No open PR found, checking for closed PRs on same branch..."
                url="https://api.github.com/repos/${REPO}/pulls?state=closed&head=${OWNER}:${EXPECTED_BRANCH}&sort=updated&direction=desc&per_page=1"
                if [ -n "$AUTH_HEADER" ]; then
                  resp=$(curl -sL -H "Accept: application/vnd.github+json" -H "$AUTH_HEADER" "$url") || resp="[]"
                else
                  resp=$(curl -sL -H "Accept: application/vnd.github+json" "$url") || resp="[]"
                fi
                
                closed_pr_number=$(echo "$resp" | jq -r '.[0].number // empty' | head -n1)
                if [ -n "$closed_pr_number" ] && [ "$closed_pr_number" != "null" ]; then
                  echo "‚ö†Ô∏è Found CLOSED PR #$closed_pr_number for branch $EXPECTED_BRANCH"
                  echo "   This indicates a PR was created but closed (merged or manually closed)"
                  echo "   Implementation agent should create a new PR, but none found"
                  echo "   This may indicate PR creation failed or implementation didn't complete"
                fi
              fi
            fi

            # If still not found, try searching by task label only (lenient fallback)
            # CRITICAL: Must verify branch matches to avoid using PRs from previous runs
            if [ -z "$pr_number" ] || [ "$pr_number" = "null" ]; then
              echo "üîç No PR found by branch, trying task label only (lenient search)..."
              q_task_label=$(printf "%s" "$TASK_LABEL" | sed 's/,/%2C/g')
              url="https://api.github.com/repos/${REPO}/issues?state=open&labels=${q_task_label}"
              if [ -n "$AUTH_HEADER" ]; then
                resp=$(curl -sL -H "Accept: application/vnd.github+json" -H "$AUTH_HEADER" "$url") || resp="[]"
              else
                resp=$(curl -sL -H "Accept: application/vnd.github+json" "$url") || resp="[]"
              fi
              
              # Check all PRs with task label and verify branch matches
              found_valid_pr=false
              for pr_item in $(echo "$resp" | jq -c '.[] | select(.pull_request != null)'); do
                candidate_pr_number=$(echo "$pr_item" | jq -r '.number')
                if [ -n "$candidate_pr_number" ] && [ "$candidate_pr_number" != "null" ]; then
                  # Fetch PR details to check branch name
                  pr_detail_url="https://api.github.com/repos/${REPO}/pulls/${candidate_pr_number}"
                  if [ -n "$AUTH_HEADER" ]; then
                    pr_detail=$(curl -sL -H "Accept: application/vnd.github+json" -H "$AUTH_HEADER" "$pr_detail_url") || pr_detail="{}"
                  else
                    pr_detail=$(curl -sL -H "Accept: application/vnd.github+json" "$pr_detail_url") || pr_detail="{}"
                  fi
                  
                  pr_branch=$(echo "$pr_detail" | jq -r '.head.ref // ""')
<<<<<<< HEAD
                  # Normalize both branches for comparison (handle with/without feature/ prefix)
                  expected_normalized=$(echo "$EXPECTED_BRANCH" | sed 's|^feature/||')
                  pr_branch_normalized=$(echo "$pr_branch" | sed 's|^feature/||')
                  if [ "$pr_branch_normalized" = "$expected_normalized" ] || [ "$pr_branch" = "$EXPECTED_BRANCH" ]; then
=======
                  if [ "$pr_branch" = "$(echo "$EXPECTED_BRANCH" | sed 's|^feature/||')" ] || [ "$pr_branch" = "$EXPECTED_BRANCH" ]; then
>>>>>>> a08321e55773528bab08ba84347416004ede72e4
                    pr_url=$(echo "$pr_item" | jq -r '.html_url')
                    pr_number="$candidate_pr_number"
                    found_valid_pr=true
                    echo "‚úÖ Found PR #$pr_number by task label with matching branch: $pr_branch"
                    echo "‚ö†Ô∏è Note: Run label ($RUN_LABEL) may not match, but branch matches - proceeding"
                    break
                  fi
                fi
              done
              
              if [ "$found_valid_pr" = "false" ]; then
                echo "‚ö†Ô∏è Found PR(s) with task label but none match expected branch ($EXPECTED_BRANCH)"
                echo "   Skipping to avoid using PRs from previous workflow runs"
                pr_number=""
                pr_url=""
              fi
            fi

            if [ -n "$pr_number" ] && [ "$pr_number" != "null" ]; then
              echo "$pr_url" > /tmp/pr-url.txt
              echo "$pr_number" > /tmp/pr-number.txt
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo "‚úÖ PR FOUND: #$pr_number"
              echo "  URL: $pr_url"
              echo "  Stage: ${STAGE}"
              echo "  Repository: ${REPO}"
              if [ -n "$TOKEN" ]; then
                echo "  Adding correlation labels..."
                add_labels_payload=$(printf '{"labels":["%s","%s","%s"]}' "$TASK_LABEL" "$RUN_LABEL" "$SERVICE_LABEL")
                if curl -s -X POST \
                  -H "Authorization: Bearer $TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  -H "Content-Type: application/json" \
                  -d "$add_labels_payload" \
                  "https://api.github.com/repos/${REPO}/issues/${pr_number}/labels" >/dev/null 2>&1; then
                  echo "  ‚úÖ Labels added: $TASK_LABEL, $RUN_LABEL, $SERVICE_LABEL"
                else
                  echo "  ‚ö†Ô∏è Failed to add labels (PR still usable)"
                fi
              else
                echo "  ‚ö†Ô∏è No auth token - skipping label update"
              fi
              echo "  Proceeding to next workflow stage..."
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              exit 0
            fi

            attempts=$((attempts-1))
            echo "‚è≥ PR not found yet, retrying... ($attempts left)"
            sleep 5
          done

          # PR not found after polling - provide detailed error info
          echo "‚ùå ERROR: No PR found after waiting for ${STAGE} stage"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üìã Search Details:"
          echo "  Task ID: ${TASK_ID}"
          echo "  Repository: ${REPO}"
          echo "  Stage: ${STAGE}"
          echo "  Expected Branch: ${EXPECTED_BRANCH}"
          echo "  Expected Labels: ${TASK_LABEL}, ${RUN_LABEL}, ${SERVICE_LABEL}"
          echo ""
          echo "üîç Possible Causes:"
          if [ "$STAGE" = "implementation" ]; then
            echo "  1. Implementation agent hasn't created PR yet (waited 90s)"
            echo "  2. Implementation failed before PR creation"
            echo "  3. PR created with different branch name or labels"
            echo "  4. All PRs for this branch are CLOSED (previous runs)"
            echo "  5. Network/API issues preventing PR creation"
            echo ""
            echo "üí° Recommendation:"
            echo "  Check implementation CodeRun logs for errors"
            echo "  Verify GitHub App has PR creation permissions"
            echo "  If closed PRs exist, implementation agent should create a new PR"
            echo "  Check if implementation agent completed successfully"
          else
            echo "  1. Implementation agent didn't create a PR"
            echo "  2. PR was created but lacks required labels"
            echo "  3. PR branch name doesn't match expected pattern"
            echo ""
            echo "üí° Recommendation:"
            echo "  Verify implementation stage completed successfully"
            echo "  Check if PR exists with correct labels: ${TASK_LABEL}, ${RUN_LABEL}"
          fi
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          > /tmp/pr-url.txt
          > /tmp/pr-number.txt
          exit 1
    # Evaluate PR labels to determine remediation outcome
    - name: assess-remediation-outcome
      inputs:
        parameters:
          - name: repository
          - name: pr-number
      outputs:
        parameters:
          - name: remediation-status
            valueFrom:
              path: /tmp/remediation-status.txt
            default: "needs-fixes"
      script:
        image: alpine:3.20
        env:
          - name: GITHUB_APP_ID
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: app-id
          - name: GITHUB_APP_PRIVATE_KEY
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: private-key
        command: [sh]
        source: |
          #!/bin/sh
          set -e

          REPO="{{`{{inputs.parameters.repository}}`}}"
          PR_NUMBER="{{`{{inputs.parameters.pr-number}}`}}"

          if [ -z "$PR_NUMBER" ]; then
            echo "‚ö†Ô∏è No PR number available; assuming remediation still required"
            echo "needs-fixes" > /tmp/remediation-status.txt
            exit 1
          fi

          apk add --no-cache curl jq openssl >/dev/null 2>&1 || true

          OWNER=$(echo "$REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

          AUTH_HEADER=""
          if [ -n "${GITHUB_APP_ID:-}" ] && [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
            TEMP_KEY="/tmp/github-app-key.pem"
            printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY"
            chmod 600 "$TEMP_KEY"

            NOW=$(date +%s)
            EXP=$((NOW + 600))
            HDR=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 2>/dev/null || printf '{"alg":"RS256","typ":"JWT"}' | base64)
            HDR=$(echo -n "$HDR" | tr '+/' '-_' | tr -d '=')
            PAY=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 2>/dev/null || printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64)
            PAY=$(echo -n "$PAY" | tr '+/' '-_' | tr -d '=')
            SIG=$(printf '%s.%s' "$HDR" "$PAY" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 -w 0 2>/dev/null || openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64)
            SIG=$(echo -n "$SIG" | tr '+/' '-_' | tr -d '=')
            JWT="$HDR.$PAY.$SIG"

            INSTALLATION_ID=$(curl -s -L               -H "Authorization: Bearer $JWT"               -H "Accept: application/vnd.github+json"               "https://api.github.com/repos/$OWNER/$REPO_NAME/installation" | jq -r '.id')

            if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" = "null" ]; then
              INSTALLATION_ID=$(curl -s -L                 -H "Authorization: Bearer $JWT"                 -H "Accept: application/vnd.github+json"                 "https://api.github.com/orgs/$OWNER/installation" | jq -r '.id')
            fi

            if [ -n "$INSTALLATION_ID" ] && [ "$INSTALLATION_ID" != "null" ]; then
              TOKEN=$(curl -s -X POST                 -H "Authorization: Bearer $JWT"                 -H "Accept: application/vnd.github+json"                 "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')
              if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
                AUTH_HEADER="Authorization: Bearer $TOKEN"
              fi
            fi

            rm -f "$TEMP_KEY"
          fi

          MAX_ATTEMPTS=30
          SLEEP_SECONDS=10

          attempt=1
          while [ $attempt -le $MAX_ATTEMPTS ]; do
            echo "üîç Checking PR #$PR_NUMBER labels (attempt $attempt/$MAX_ATTEMPTS)"

            if [ -n "$AUTH_HEADER" ]; then
              ISSUE=$(curl -s -L                 -H "Accept: application/vnd.github+json"                 -H "$AUTH_HEADER"                 "https://api.github.com/repos/$REPO/issues/$PR_NUMBER")
            else
              ISSUE=$(curl -s -L                 -H "Accept: application/vnd.github+json"                 "https://api.github.com/repos/$REPO/issues/$PR_NUMBER")
            fi

            LABELS=$(echo "$ISSUE" | jq -r '.labels[].name')

            if echo "$LABELS" | grep -q '^approved$'; then
              echo "approved" > /tmp/remediation-status.txt
              echo "‚úÖ PR approved by Tess"
              exit 0
            fi

            if echo "$LABELS" | grep -q '^failed-remediation$'; then
              echo "failed" > /tmp/remediation-status.txt
              echo "‚õî Remediation marked as failed"
              exit 0
            fi

            if echo "$LABELS" | grep -q '^needs-fixes$'; then
              echo "needs-fixes" > /tmp/remediation-status.txt
              echo "üîÅ Needs-fixes label detected; triggering another remediation pass"
              exit 1
            fi

            # Note: Stage transitions are now driven by GitHub PR reviews (Cleo/Tess approvals)
            # Labels are only used for correlation (task-*, service-*, run-*) and remediation (needs-fixes)
            if [ -z "$LABELS" ]; then
              echo "‚ÑπÔ∏è PR currently has no workflow labels; waiting"
            else
              echo "‚ÑπÔ∏è Current labels: $LABELS"
            fi

            attempt=$((attempt + 1))
            if [ $attempt -le $MAX_ATTEMPTS ]; then
              sleep $SLEEP_SECONDS
            fi
          done

          echo "needs-fixes" > /tmp/remediation-status.txt
          echo "‚ö†Ô∏è Timed out waiting for remediation decision; retrying iteration"
          exit 1
    - name: agent-coderun
      inputs:
        parameters:
          - name: github-app
          - name: task-id
          - name: stage
          - name: cli-type
            default: ""
          - name: model
            default: ""
          - name: model-rotation
            default: "[]"
          - name: tools-config
            default: "{}"
          - name: pr-url
            default: ""
          - name: pr-number
            default: ""
          - name: qa-ready
            default: "false"
          - name: max-retries
            default: ""
          - name: auto-merge
            default: "false"
          - name: final-task
            default: "false"
          - name: task-language
            default: "rust"
          - name: task-framework
            default: ""
      outputs:
        parameters:
          - name: coderun-name
            valueFrom:
              parameter: "{{`{{steps.resolve-coderun-name.outputs.parameters.coderun-name}}`}}"
      steps:
        - - name: create-coderun-resource
            template: create-coderun-resource
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{inputs.parameters.github-app}}`}}"
                - name: task-id
                  value: "{{`{{inputs.parameters.task-id}}`}}"
                - name: stage
                  value: "{{`{{inputs.parameters.stage}}`}}"
                - name: cli-type
                  value: "{{`{{inputs.parameters.cli-type}}`}}"
                - name: model
                  value: "{{`{{inputs.parameters.model}}`}}"
                - name: model-rotation
                  value: "{{`{{inputs.parameters.model-rotation}}`}}"
                - name: tools-config
                  value: "{{`{{inputs.parameters.tools-config}}`}}"
                - name: pr-url
                  value: "{{`{{inputs.parameters.pr-url}}`}}"
                - name: pr-number
                  value: "{{`{{inputs.parameters.pr-number}}`}}"
                - name: qa-ready
                  value: "{{`{{inputs.parameters.qa-ready}}`}}"
                - name: max-retries
                  value: "{{`{{inputs.parameters.max-retries}}`}}"
                - name: auto-merge
                  value: "{{`{{inputs.parameters.auto-merge}}`}}"
                - name: final-task
                  value: "{{`{{inputs.parameters.final-task}}`}}"
                - name: task-language
                  value: "{{`{{inputs.parameters.task-language}}`}}"
                - name: task-framework
                  value: "{{`{{inputs.parameters.task-framework}}`}}"
        - - name: resolve-coderun-name
            template: resolve-coderun-name
            arguments:
              parameters:
                - name: stage
                  value: "{{`{{inputs.parameters.stage}}`}}"
                - name: task-id
                  value: "{{`{{inputs.parameters.task-id}}`}}"
                - name: candidate-name
                  value: "{{`{{steps.create-coderun-resource.outputs.parameters.name}}`}}"
        - - name: wait-for-completion
            template: wait-coderun-completion
            arguments:
              parameters:
                - name: coderun-name
                  value: "{{`{{steps.resolve-coderun-name.outputs.parameters.coderun-name}}`}}"

    # Template for creating CodeRun resources
    - name: create-coderun-resource
      inputs:
        parameters:
          - name: github-app
          - name: task-id
          - name: stage
          - name: cli-type
            default: ""
          - name: model
            default: ""
          - name: model-rotation
            default: "[]"
          - name: tools-config
            default: "{}"
          - name: pr-url
            default: ""
          - name: pr-number
            default: ""
          - name: qa-ready
            default: "false"
          - name: max-retries
            default: ""
          - name: auto-merge
            default: "false"
          - name: final-task
            default: "false"
          - name: task-language
            default: "rust"
          - name: task-framework
            default: ""
      outputs:
        parameters:
          - name: name
            valueFrom:
              jsonPath: '{.metadata.name}'
      resource:
        action: create
        setOwnerReference: true
        successCondition: status.phase == Succeeded
        failureCondition: status.phase == Failed
        manifest: |
          apiVersion: agents.platform/v1
          kind: CodeRun
          metadata:
            generateName: "{{`{{workflow.parameters.service}}`}}-t{{`{{inputs.parameters.task-id}}`}}-{{`{{inputs.parameters.stage}}`}}-"
            namespace: {{.Release.Namespace}}
            labels:
              task-id: "{{`{{inputs.parameters.task-id}}`}}"
              service: "{{`{{workflow.parameters.service}}`}}"
              github-app: "{{`{{inputs.parameters.github-app}}`}}"
              workflow-name: "{{`{{workflow.name}}`}}"
              workflow-run: "{{`{{workflow.name}}`}}"
              stage: "{{`{{inputs.parameters.stage}}`}}"
              workflow-stage: "{{`{{inputs.parameters.stage}}`}}"
              workflow-type: "play-orchestration"
            annotations:
              agents.platform/tools-config: |
                {{`{{inputs.parameters.tools-config}}`}}
          spec:
            taskId: {{`{{inputs.parameters.task-id}}`}}
            service: "{{`{{workflow.parameters.service}}`}}"
            repositoryUrl: "{{`{{workflow.parameters.repository}}`}}"
            docsRepositoryUrl: "https://github.com/{{`{{workflow.parameters.docs-repository}}`}}"
            docsProjectDirectory: "{{`{{workflow.parameters.docs-project-directory}}`}}"
            workingDirectory: "."
            githubApp: "{{`{{inputs.parameters.github-app}}`}}"
            model: "{{`{{inputs.parameters.model}}`}}"
            continueSession: true
            overwriteMemory: false
            docsBranch: "main"
            contextVersion: 1
            cliConfig:
              cliType: "{{`{{inputs.parameters.cli-type}}`}}"
              model: "{{`{{inputs.parameters.model}}`}}"
              modelRotation: {{`{{inputs.parameters.model-rotation}}`}}
            # Pass task requirements if available
            taskRequirements: "{{`{{workflow.parameters.task-requirements}}`}}"
            # Pass PR context as environment if available
            env:
              PR_URL: "{{`{{inputs.parameters.pr-url}}`}}"
              PR_NUMBER: "{{`{{inputs.parameters.pr-number}}`}}"
              QA_READY: "{{`{{inputs.parameters.qa-ready}}`}}"
              WORKFLOW_STAGE: "{{`{{inputs.parameters.stage}}`}}"
              WORKFLOW_NAME: "{{`{{workflow.name}}`}}"
              SERVICE_NAME: "{{`{{workflow.parameters.service}}`}}"
              RUN_NAME: "{{`{{workflow.name}}`}}"
              TASK_ID: "{{`{{inputs.parameters.task-id}}`}}"
              TASK_LANGUAGE: "{{`{{inputs.parameters.task-language}}`}}"
              TASK_FRAMEWORK: "{{`{{inputs.parameters.task-framework}}`}}"
              EXECUTION_MAX_RETRIES: "{{`{{inputs.parameters.max-retries}}`}}"
              FACTORY_MAX_RETRIES: "{{`{{inputs.parameters.max-retries}}`}}"
              CODEX_MAX_RETRIES: "{{`{{inputs.parameters.max-retries}}`}}"
              CURSOR_MAX_RETRIES: "{{`{{inputs.parameters.max-retries}}`}}"
              CLAUDE_MAX_RETRIES: "{{`{{inputs.parameters.max-retries}}`}}"
              OPENCODE_MAX_RETRIES: "{{`{{inputs.parameters.max-retries}}`}}"
              OPENCODE_VERBOSE: "{{`{{workflow.parameters.opencode-verbose}}`}}"
              AUTO_MERGE: "{{`{{inputs.parameters.auto-merge}}`}}"
              FINAL_TASK: "{{`{{inputs.parameters.final-task}}`}}"

    # Helper to reliably resolve the created CodeRun name before waiting for completion
    - name: resolve-coderun-name
      inputs:
        parameters:
          - name: stage
          - name: task-id
          - name: candidate-name
            default: ""
      outputs:
        parameters:
          - name: coderun-name
            valueFrom:
              path: /tmp/coderun-name.txt
      script:
        image: alpine/k8s:1.31.0
        command: [sh]
        source: |
          #!/bin/sh
          set -e
          CANDIDATE="{{`{{inputs.parameters.candidate-name}}`}}"
          if [ -n "$CANDIDATE" ] && [ "$CANDIDATE" != "null" ]; then
            echo "$CANDIDATE" > /tmp/coderun-name.txt
            exit 0
          fi
          # Fallback: resolve by labels (assumes a single CodeRun for this workflow/task/stage)
          ATTEMPTS=12
          while [ $ATTEMPTS -gt 0 ]; do
            NAME=$(kubectl get coderun.agents.platform -n {{ .Release.Namespace }} \
              -l workflow-name={{`{{workflow.name}}`}},workflow-stage={{`{{inputs.parameters.stage}}`}},task-id={{`{{inputs.parameters.task-id}}`}} \
              -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
            if [ -n "$NAME" ]; then
              echo "$NAME" > /tmp/coderun-name.txt
              exit 0
            fi
            sleep 5
            ATTEMPTS=$((ATTEMPTS-1))
          done
          echo "No CodeRun found for labels after waiting" >&2
          exit 1
      retryStrategy:
        limit: 50
        retryPolicy: "OnError"
        backoff:
          duration: "30s"
          factor: 2
          # No maxDuration - allow unlimited time for CodeRun creation

    # Template for waiting for CodeRun completion
    - name: wait-coderun-completion
      inputs:
        parameters:
          - name: coderun-name
      resource:
        action: get
        manifest: |
          apiVersion: agents.platform/v1
          kind: CodeRun
          metadata:
            name: "{{`{{inputs.parameters.coderun-name}}`}}"
            namespace: {{.Release.Namespace}}
        successCondition: status.phase == Succeeded
        failureCondition: status.phase == Failed
      retryStrategy:
        limit: 200
        retryPolicy: "OnError"
        backoff:
          duration: "60s"
          factor: 2
          # No maxDuration - allow unlimited time for CodeRun completion

    # Template for atomic workflow stage updates with optimistic locking
    - name: update-workflow-stage
      inputs:
        parameters:
          - name: new-stage
            description: "The new stage to transition to"
          - name: verify-update
            description: "Whether to verify the update succeeded"
            default: "true"
      outputs:
        parameters:
          - name: update-status
            valueFrom:
              path: /tmp/update-status.txt
            default: "unknown"
          - name: resource-version
            valueFrom:
              path: /tmp/resource-version.txt
            default: ""
      script:
        image: alpine/k8s:1.31.0
        command: [bash]
        source: |
          #!/bin/bash
          set -e

          echo "========================================="
          echo "Updating Workflow Stage"
          echo "========================================="
          echo "Workflow: {{`{{workflow.name}}`}}"
          echo "Current Task: {{`{{workflow.parameters.task-id}}`}}"
          echo "New Stage: {{`{{inputs.parameters.new-stage}}`}}"
          echo ""

          # Function to validate stage transition
          validate_stage_transition() {
            local current_stage=$1
            local new_stage=$2

            # Special case: Allow setting initial stage to "pending" when no stage label exists
            if [[ -z "$current_stage" ]] && [[ "$new_stage" == "pending" ]]; then
              echo "‚úÖ Allowing initial stage setting: (none) ‚Üí $new_stage"
              return 0
            fi

            # Define valid transitions (Rex ‚Üí Cleo ‚Üí Cipher ‚Üí Tess flow)
            case $current_stage in
              "pending")
                # Implementation path: pending ‚Üí implementation-in-progress (Rex starts)
                [[ $new_stage == "implementation-in-progress" ]] && return 0
                # Primary path: pending ‚Üí quality-in-progress
                [[ $new_stage == "quality-in-progress" ]] && return 0
                # Legacy paths for backward compatibility
                [[ $new_stage == "waiting-quality-complete" ]] && return 0
                [[ $new_stage == "waiting-pr-created" ]] && return 0
                ;;
              "implementation-in-progress")
                # After implementation: ‚Üí quality or waiting states
                [[ $new_stage == "quality-in-progress" ]] && return 0
                [[ $new_stage == "waiting-quality-complete" ]] && return 0
                [[ $new_stage == "waiting-pr-created" ]] && return 0
                ;;
              "waiting-pr-created")
                [[ $new_stage == "quality-in-progress" ]] && return 0
                [[ $new_stage == "waiting-quality-complete" ]] && return 0
                ;;
              "quality-in-progress")
                # New path: quality ‚Üí security
                [[ $new_stage == "security-in-progress" ]] && return 0
                # Legacy paths for backward compatibility
                [[ $new_stage == "waiting-quality-complete" ]] && return 0
                ;;
              "security-in-progress")
                # Security ‚Üí testing (support both new and legacy stage names)
                [[ $new_stage == "testing-in-progress" ]] && return 0
                [[ $new_stage == "waiting-ready-for-qa" ]] && return 0
                ;;
              "testing-in-progress")
                # Testing ‚Üí completion (Tess done)
                [[ $new_stage == "waiting-pr-merged" ]] && return 0
                [[ $new_stage == "completed" ]] && return 0
                ;;
              "waiting-quality-complete")
                [[ $new_stage == "waiting-ready-for-qa" ]] && return 0
                ;;
              "waiting-ready-for-qa")
                [[ $new_stage == "waiting-pr-merged" ]] && return 0
                [[ $new_stage == "testing-in-progress" ]] && return 0
                ;;
              "waiting-pr-merged")
                # Allow re-entering remediation stages during retry loops
                [[ $new_stage == "quality-in-progress" ]] && return 0
                [[ $new_stage == "security-in-progress" ]] && return 0
                [[ $new_stage == "testing-in-progress" ]] && return 0
                # Normal forward progression to completion
                [[ $new_stage == "completed" ]] && return 0
                ;;
            esac

            echo "‚ùå Invalid stage transition: $current_stage ‚Üí $new_stage"
            return 1
          }

          # Get current state and resource version for optimistic locking
          echo "Fetching current workflow state..."
          WORKFLOW_JSON=$(kubectl get workflow "{{`{{workflow.name}}`}}" \
            -n {{ .Release.Namespace }} \
            -o json)

          # Check if current-stage label actually exists (not just defaulted)
          CURRENT_STAGE_RAW=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.labels["current-stage"]')
          if [ "$CURRENT_STAGE_RAW" = "null" ]; then
            CURRENT_STAGE=""
            echo "Current stage: (no label exists)"
          else
            CURRENT_STAGE="$CURRENT_STAGE_RAW"
            echo "Current stage: $CURRENT_STAGE"
          fi

          RESOURCE_VERSION=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.resourceVersion')
          echo "Resource version: $RESOURCE_VERSION"

          TARGET_STAGE="{{`{{inputs.parameters.new-stage}}`}}"

          # Persist the current resource version for downstream steps even if we early-exit
          echo "$RESOURCE_VERSION" > /tmp/resource-version.txt

          if [ "$CURRENT_STAGE" = "$TARGET_STAGE" ]; then
            echo "üîÅ Stage is already set to $TARGET_STAGE; no update required"
            echo "success" > /tmp/update-status.txt
            exit 0
          fi

          # Validate stage transition
          if ! validate_stage_transition "$CURRENT_STAGE" "$TARGET_STAGE"; then
            echo "‚ùå Stage transition validation failed"
            echo "failed" > /tmp/update-status.txt
            exit 1
          fi

          # Prepare the JSON patch with optimistic locking
          REPOSITORY_LABEL=$(echo '{{`{{workflow.parameters.repository}}`}}' | tr '/' '-')
          PATCH_JSON='{
            "metadata": {
              "resourceVersion": "'$RESOURCE_VERSION'",
              "labels": {
                "current-stage": "{{`{{inputs.parameters.new-stage}}`}}",
                "task-id": "{{`{{workflow.parameters.task-id}}`}}",
                "repository": "'$REPOSITORY_LABEL'",
                "previous-stage": "'$CURRENT_STAGE'"
              }
            }
          }'

          echo ""
          echo "Prepared patch payload:"
          echo "$PATCH_JSON" | jq .

          # Apply the patch with exponential backoff retry
          MAX_RETRIES=5
          RETRY_COUNT=0
          UPDATE_SUCCESS=false
          BACKOFF_TIME=1

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo ""
            echo "Attempt $((RETRY_COUNT+1)) of $MAX_RETRIES..."

            if kubectl patch workflow "{{`{{workflow.name}}`}}" \
              --type='merge' \
              --patch="$PATCH_JSON" \
              -n {{ .Release.Namespace }}; then

              UPDATE_SUCCESS=true
              echo "‚úÖ Stage update successful"
              break
            else
              echo "‚ö†Ô∏è Stage update failed with status: $?"
              echo "Retrying in $BACKOFF_TIME seconds..."
              sleep $BACKOFF_TIME

              # Update resource version before retry
              RESOURCE_VERSION=$(kubectl get workflow "{{`{{workflow.name}}`}}" \
                -n {{ .Release.Namespace }} \
                -o jsonpath='{.metadata.resourceVersion}')

              # Update patch with new resource version
              PATCH_JSON=$(echo "$PATCH_JSON" | jq --arg rv "$RESOURCE_VERSION" \
                '.metadata.resourceVersion = $rv')

              RETRY_COUNT=$((RETRY_COUNT+1))
              BACKOFF_TIME=$((BACKOFF_TIME*2))
            fi
          done

          # Save resource version for other templates
          echo "$RESOURCE_VERSION" > /tmp/resource-version.txt

          # Always verify the update
          echo ""
          echo "Verifying stage update..."

          VERIFY_MAX_RETRIES=3
          VERIFY_COUNT=0
          VERIFY_SUCCESS=false

          while [ $VERIFY_COUNT -lt $VERIFY_MAX_RETRIES ]; do
            WORKFLOW_JSON=$(kubectl get workflow "{{`{{workflow.name}}`}}" \
              -n {{ .Release.Namespace }} \
              -o json)

            CURRENT_STAGE=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.labels["current-stage"]')
            PREVIOUS_STAGE=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.labels["previous-stage"]')
            NEW_RESOURCE_VERSION=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.resourceVersion')

            echo "Current Stage: $CURRENT_STAGE"
            echo "Previous Stage: $PREVIOUS_STAGE"
            echo "Resource Version: $NEW_RESOURCE_VERSION"

            if [ "$CURRENT_STAGE" = "{{`{{inputs.parameters.new-stage}}`}}" ]; then
              VERIFY_SUCCESS=true
              echo "‚úÖ Verification successful: Stage transition complete"
              echo "success" > /tmp/update-status.txt
              break
            else
              echo "‚ö†Ô∏è Verification attempt $((VERIFY_COUNT+1)) failed, retrying..."
              VERIFY_COUNT=$((VERIFY_COUNT+1))
              sleep 2
            fi
          done

          if [ "$VERIFY_SUCCESS" != true ]; then
            echo "‚ùå Stage update verification failed after $VERIFY_MAX_RETRIES attempts"
            echo "failed" > /tmp/update-status.txt
            exit 1
          fi

          # Output monitoring metrics
          cat <<EOF > /tmp/stage-transition-metrics.json
          {
            "workflow": "{{`{{workflow.name}}`}}",
            "task_id": "{{`{{workflow.parameters.task-id}}`}}",
            "transition": {
              "from": "$PREVIOUS_STAGE",
              "to": "$CURRENT_STAGE",
              "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
              "duration_seconds": "$SECONDS",
              "retry_count": "$RETRY_COUNT",
              "verify_count": "$VERIFY_COUNT",
              "resource_version": "$NEW_RESOURCE_VERSION"
            }
          }
          EOF

          echo ""
          echo "Stage transition completed successfully"
          echo "Duration: $SECONDS seconds"
          echo "Retries required: $RETRY_COUNT"
          echo "Verification attempts: $VERIFY_COUNT"
      retryStrategy:
        limit: 20
        retryPolicy: "OnFailure"
        backoff:
          duration: "60s"
          factor: 2
          # No maxDuration - allow unlimited time for workflow stage updates

    # Template for suspend points waiting for external events via webhooks
    - name: suspend-for-event
      inputs:
        parameters:
          - name: event-type
          - name: stage-name
      metadata:
        labels:
          current-stage: "{{`{{inputs.parameters.stage-name}}`}}"
          task-id: "{{`{{workflow.parameters.task-id}}`}}"
          workflow-type: "play-orchestration"
      suspend: {}  # Indefinite suspend until external resume via webhooks

    # Template for skipping optional stages when configuration is missing
    - name: skip-stage-notice
      inputs:
        parameters:
          - name: stage-name
          - name: reason
      script:
        image: alpine:3.20
        command: [sh]
        source: |
          echo "‚è≠Ô∏è  Skipping {{`{{inputs.parameters.stage-name}}`}} stage"
          echo "Reason: {{`{{inputs.parameters.reason}}`}}"
          echo "‚ö†Ô∏è  This is optional - workflow will proceed to next stage"
          echo "‚úÖ Stage skipped successfully"

    # Template for task completion and cleanup
    - name: task-completion
      inputs:
        parameters:
          - name: task-id
          - name: approval-status
          - name: merge-sha
      script:
        image: alpine/k8s:1.31.0
        command: [sh]
        source: |
          #!/bin/sh
          set -e

          echo "========================================="
          echo "Completing Task {{`{{inputs.parameters.task-id}}`}}"
          echo "========================================="
          echo "Approval Status: {{`{{inputs.parameters.approval-status}}`}}"
          echo "Merge SHA: {{`{{inputs.parameters.merge-sha}}`}}"
          echo ""

          # Create completion marker
          echo "Task {{`{{inputs.parameters.task-id}}`}} completed at $(date)" > /tmp/task-complete.txt
          echo "Workflow: {{`{{workflow.name}}`}}" >> /tmp/task-complete.txt
          echo "Duration: {{`{{workflow.duration}}`}}" >> /tmp/task-complete.txt
          echo "PR Approved: {{`{{inputs.parameters.approval-status}}`}}" >> /tmp/task-complete.txt

          # Generate workflow summary
          cat <<EOF > /tmp/workflow-summary.md
          # Task {{`{{inputs.parameters.task-id}}`}} Completion Summary

          ## Workflow Details
          - **Workflow Name**: {{`{{workflow.name}}`}}
          - **Task ID**: {{`{{inputs.parameters.task-id}}`}}
          - **Repository**: {{`{{workflow.parameters.repository}}`}}
          - **Duration**: {{`{{workflow.duration}}`}}

          ## Agent Execution
          - **Implementation Agent**: {{`{{workflow.parameters.implementation-agent}}`}}
          - **Quality Agent**: {{`{{workflow.parameters.quality-agent}}`}}
          - **Testing Agent**: {{`{{workflow.parameters.testing-agent}}`}}

          ## Results
          - **PR Number**: {{`{{workflow.parameters.pr-number}}`}}
          - **Approval Status**: {{`{{inputs.parameters.approval-status}}`}}
          - **Merge SHA**: {{`{{inputs.parameters.merge-sha}}`}}

          ## Stages Completed
          1. ‚úÖ Implementation Work
          2. ‚úÖ Quality Assurance
          3. ‚úÖ Testing & Validation
          4. ‚úÖ PR Approval

          Task successfully completed and merged to main branch.
          EOF

          echo ""
          echo "Workflow summary generated successfully"
          echo "Task {{`{{inputs.parameters.task-id}}`}} workflow completed!"
          echo ""
          echo "Note: Next task will be started automatically by webhook system"

    # Template to determine which agent should handle a task based on its type
    - name: determine-task-agent
      inputs:
        parameters:
          - name: task-id
          - name: docs-repository
          - name: docs-project-directory
      outputs:
        parameters:
          - name: github-app
            valueFrom:
              path: /tmp/github-app.txt
          - name: cli-type
            valueFrom:
              path: /tmp/cli-type.txt
          - name: model
            valueFrom:
              path: /tmp/model.txt
          - name: model-rotation
            valueFrom:
              path: /tmp/model-rotation.txt
          - name: max-retries
            valueFrom:
              path: /tmp/max-retries.txt
          - name: task-language
            valueFrom:
              path: /tmp/task-language.txt
          - name: task-framework
            valueFrom:
              path: /tmp/task-framework.txt
      script:
        image: alpine:3.20
        env:
          - name: GITHUB_APP_ID
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: app-id
          - name: GITHUB_APP_PRIVATE_KEY
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: private-key
        command: [sh]
        source: |
          #!/bin/sh
          set -e
          
          TASK_ID="{{`{{inputs.parameters.task-id}}`}}"
          DOCS_REPO="{{`{{inputs.parameters.docs-repository}}`}}"
          DOCS_PROJECT_DIR="{{`{{inputs.parameters.docs-project-directory}}`}}"
          
          echo "üîç Determining agent for task ${TASK_ID}"
          echo "   Docs repository: ${DOCS_REPO}"
          echo "   Project directory: ${DOCS_PROJECT_DIR}"
          
          # Install tools
          apk add --no-cache curl jq openssl git >/dev/null 2>&1 || true
          
          # Authenticate with GitHub App
          TEMP_KEY="/tmp/github-app-key.pem"
          printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY"
          chmod 600 "$TEMP_KEY"
          
          NOW=$(date +%s)
          EXP=$((NOW + 600))
          HDR=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 2>/dev/null || printf '{"alg":"RS256","typ":"JWT"}' | base64)
          HDR=$(echo -n "$HDR" | tr '+/' '-_' | tr -d '=')
          PAY=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 2>/dev/null || printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64)
          PAY=$(echo -n "$PAY" | tr '+/' '-_' | tr -d '=')
          SIG=$(printf '%s.%s' "$HDR" "$PAY" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 -w 0 2>/dev/null || openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64)
          SIG=$(echo -n "$SIG" | tr '+/' '-_' | tr -d '=')
          JWT="$HDR.$PAY.$SIG"
          
          OWNER=$(echo "$DOCS_REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$DOCS_REPO" | cut -d'/' -f2)
          
          # Get installation token
          INSTALLATION_ID=$(curl -s -L \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$OWNER/$REPO_NAME/installation" | jq -r '.id')
          
          if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" = "null" ]; then
            INSTALLATION_ID=$(curl -s -L \
              -H "Authorization: Bearer $JWT" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/orgs/$OWNER/installation" | jq -r '.id')
          fi
          
          TOKEN=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')
          
          rm -f "$TEMP_KEY"
          
          # Clone docs repository to read task file
          CLONE_DIR="/tmp/docs-repo"
          rm -rf "$CLONE_DIR"
          
          echo "üì• Cloning docs repository..."
          git clone --depth 1 "https://x-access-token:${TOKEN}@github.com/${DOCS_REPO}.git" "$CLONE_DIR" 2>&1 || {
            echo "‚ùå Failed to clone repository"
            # Fallback to implementation agent
            echo "{{`{{workflow.parameters.implementation-agent}}`}}" > /tmp/github-app.txt
            echo "{{`{{workflow.parameters.implementation-cli}}`}}" > /tmp/cli-type.txt
            echo "{{`{{workflow.parameters.implementation-model}}`}}" > /tmp/model.txt
            echo "{{`{{workflow.parameters.implementation-model-rotation}}`}}" > /tmp/model-rotation.txt
            echo "{{`{{workflow.parameters.implementation-max-retries}}`}}" > /tmp/max-retries.txt
            echo "rust" > /tmp/task-language.txt
            echo "" > /tmp/task-framework.txt
            exit 0
          }
          
          # Load task metadata from tasks.json when available
          TASKS_JSON="${CLONE_DIR}/${DOCS_PROJECT_DIR}/.taskmaster/tasks/tasks.json"
          TASK_ENTRY=""
          if [ -f "$TASKS_JSON" ]; then
            TASK_ENTRY=$(jq -c --arg tid "$TASK_ID" '
              (
                .master.tasks[]? | select((.id|tostring) == $tid)
              ),
              (
                .tasks[]? | select((.id|tostring) == $tid)
              )
            ' "$TASKS_JSON" 2>/dev/null | head -n 1)
          fi
          
          AGENT_TYPE=""
          LANGUAGE=""
          FRAMEWORK=""
          TASK_TITLE=""
          TASK_DESC=""
          TASK_DETAILS=""
          
          FOUND_TASK_METADATA=false
          if [ -n "$TASK_ENTRY" ]; then
            FOUND_TASK_METADATA=true
            AGENT_TYPE=$(echo "$TASK_ENTRY" | jq -r '.agentHint // .agentType // empty')
            TASK_TITLE=$(echo "$TASK_ENTRY" | jq -r '.title // empty')
            TASK_DESC=$(echo "$TASK_ENTRY" | jq -r '.description // empty')
            TASK_DETAILS=$(echo "$TASK_ENTRY" | jq -r '.details // empty')
            LANGUAGE=$(echo "$TASK_ENTRY" | jq -r '.language // .taskLanguage // empty')
            FRAMEWORK=$(echo "$TASK_ENTRY" | jq -r '.framework // .taskFramework // empty')
          fi
          
          # Attempt to locate task file for supplemental metadata
          TASK_FILE=""
          TASK_BASE_DIR="${CLONE_DIR}/${DOCS_PROJECT_DIR}/.taskmaster/tasks"
          if [ -d "$TASK_BASE_DIR" ]; then
            PADDED_ID=""
            case "$TASK_ID" in
              *[!0-9]*|"")
                PADDED_ID=""
                ;;
              *)
                PADDED_ID=$(printf "%03d" "$TASK_ID")
                ;;
            esac
            
            for candidate in \
              "$TASK_BASE_DIR/task-${TASK_ID}.md" \
              "$TASK_BASE_DIR/task-${TASK_ID}.txt" \
              "$TASK_BASE_DIR/task_${TASK_ID}.md" \
              "$TASK_BASE_DIR/task_${TASK_ID}.txt"; do
              if [ -z "$TASK_FILE" ] && [ -f "$candidate" ]; then
                TASK_FILE="$candidate"
              fi
            done
            
            if [ -z "$TASK_FILE" ] && [ -n "$PADDED_ID" ]; then
              for candidate in \
                "$TASK_BASE_DIR/task-${PADDED_ID}.md" \
                "$TASK_BASE_DIR/task-${PADDED_ID}.txt" \
                "$TASK_BASE_DIR/task_${PADDED_ID}.md" \
                "$TASK_BASE_DIR/task_${PADDED_ID}.txt"; do
                if [ -z "$TASK_FILE" ] && [ -f "$candidate" ]; then
                  TASK_FILE="$candidate"
                fi
              done
            fi
          fi
          
          if [ -n "$TASK_FILE" ]; then
            echo "üìÑ Reading task file: ${TASK_FILE}"
          if [ -z "$AGENT_TYPE" ]; then
              AGENT_TYPE=$(grep -i "^\*\*Agent Type\*\*:" "$TASK_FILE" | sed 's/.*: *//; s/ *$//' || echo "")
              if [ -z "$AGENT_TYPE" ]; then
            AGENT_TYPE=$(grep -i "^Agent Type:" "$TASK_FILE" | sed 's/.*: *//; s/ *$//' || echo "")
          fi
            fi
            if [ -z "$LANGUAGE" ]; then
          LANGUAGE=$(grep -i "^\*\*Language\*\*:" "$TASK_FILE" | sed 's/.*: *//; s/ *$//' || echo "")
          if [ -z "$LANGUAGE" ]; then
            LANGUAGE=$(grep -i "^Language:" "$TASK_FILE" | sed 's/.*: *//; s/ *$//' || echo "")
          fi
            fi
            if [ -z "$FRAMEWORK" ]; then
          FRAMEWORK=$(grep -i "^\*\*Framework\*\*:" "$TASK_FILE" | sed 's/.*: *//; s/ *$//' || echo "")
          if [ -z "$FRAMEWORK" ]; then
            FRAMEWORK=$(grep -i "^Framework:" "$TASK_FILE" | sed 's/.*: *//; s/ *$//' || echo "")
              fi
            fi
          else
            echo "‚ÑπÔ∏è Task file not found in expected locations"
          fi
          
          # Convert extracted values to lowercase for comparison
          AGENT_TYPE=$(echo "$AGENT_TYPE" | tr '[:upper:]' '[:lower:]')
          LANGUAGE=$(echo "$LANGUAGE" | tr '[:upper:]' '[:lower:]')
          FRAMEWORK=$(echo "$FRAMEWORK" | tr '[:upper:]' '[:lower:]')
          
          # Content-based auto-detection ONLY if we have no structured task metadata
          if [ "$FOUND_TASK_METADATA" = "false" ] && [ -z "$AGENT_TYPE" ]; then
            echo "‚ÑπÔ∏è No task metadata found, attempting content-based detection"
            TASK_CONTENT="$TASK_TITLE $TASK_DESC $TASK_DETAILS"
            if [ -n "$TASK_FILE" ]; then
              TASK_CONTENT="$TASK_CONTENT $(cat "$TASK_FILE" 2>/dev/null)"
            fi
            
            # Enhanced frontend detection - check for Material-UI to catch misrouted tasks
            if echo "$TASK_CONTENT" | grep -qiE "(frontend|react|component|ui|interface|styling|css|html|jsx|tsx|vue|angular|svelte|material-ui|mui|@mui)"; then
              echo "üîç Auto-detected frontend task (keywords matched)"
              echo "‚ö†Ô∏è WARNING: If Material-UI/MUI keywords detected, this MUST route to Blaze (frontend agent)"
              AGENT_TYPE="frontend"
            fi
            
            # Also try to detect framework when no metadata
            if [ -z "$FRAMEWORK" ]; then
              if echo "$TASK_CONTENT" | grep -qi "next"; then
                FRAMEWORK="nextjs"
              elif echo "$TASK_CONTENT" | grep -qi "react"; then
                FRAMEWORK="react"
              fi
            fi
          fi
          
          # CRITICAL: Additional validation - check task content for Material-UI to catch misrouted frontend tasks
          if [ -z "$AGENT_TYPE" ] || [ "$AGENT_TYPE" != "frontend" ]; then
            VALIDATION_CONTENT="$TASK_TITLE $TASK_DESC $TASK_DETAILS"
            if [ -n "$TASK_FILE" ]; then
              VALIDATION_CONTENT="$VALIDATION_CONTENT $(cat "$TASK_FILE" 2>/dev/null)"
            fi
            
            # If we find React/frontend keywords but agent type isn't frontend, force frontend routing
            if echo "$VALIDATION_CONTENT" | grep -qiE "(react.*component|react.*frontend|material-ui|mui|@mui/material|next\.js.*component)"; then
              echo "üö® CRITICAL: Detected frontend/React task but agent type is '${AGENT_TYPE}'"
              echo "üîÑ FORCING frontend agent routing (Blaze required for React/frontend tasks)"
              AGENT_TYPE="frontend"
            fi
          fi
          
          # Default language if not specified
          if [ -z "$LANGUAGE" ]; then
            if [ "$AGENT_TYPE" = "frontend" ] || [ "$AGENT_TYPE" = "ui" ]; then
              LANGUAGE="typescript"
            else
              LANGUAGE="rust"
            fi
          fi
          
          echo "   Detected agent type: '${AGENT_TYPE}'"
          echo "   Detected language: '${LANGUAGE}'"
          echo "   Detected framework: '${FRAMEWORK}'"
          
          # Determine which agent to use based on agent type
          case "$AGENT_TYPE" in
            "frontend"|"ui"|"react"|"nextjs")
              echo "‚úÖ Routing to FRONTEND agent (Blaze)"
              FRONTEND_AGENT="{{`{{workflow.parameters.frontend-agent}}`}}"
              
              # Validate frontend-agent is not empty
              if [ -z "$FRONTEND_AGENT" ] || [ "$FRONTEND_AGENT" = "" ]; then
                echo "‚ùå ERROR: frontend-agent parameter is empty but task requires frontend agent!"
                echo "‚ö†Ô∏è Falling back to implementation-agent, but this task should use Blaze"
                echo "{{`{{workflow.parameters.implementation-agent}}`}}" > /tmp/github-app.txt
                echo "{{`{{workflow.parameters.implementation-cli}}`}}" > /tmp/cli-type.txt
                echo "{{`{{workflow.parameters.implementation-model}}`}}" > /tmp/model.txt
                echo "{{`{{workflow.parameters.implementation-model-rotation}}`}}" > /tmp/model-rotation.txt
                echo "{{`{{workflow.parameters.implementation-max-retries}}`}}" > /tmp/max-retries.txt
              else
                echo "$FRONTEND_AGENT" > /tmp/github-app.txt
                echo "{{`{{workflow.parameters.frontend-cli}}`}}" > /tmp/cli-type.txt
                echo "{{`{{workflow.parameters.frontend-model}}`}}" > /tmp/model.txt
                echo "{{`{{workflow.parameters.frontend-model-rotation}}`}}" > /tmp/model-rotation.txt
                echo "{{`{{workflow.parameters.frontend-max-retries}}`}}" > /tmp/max-retries.txt
              fi
              ;;
            *)
              echo "‚úÖ Routing to IMPLEMENTATION agent (Rex)"
              IMPL_AGENT="{{`{{workflow.parameters.implementation-agent}}`}}"
              
              # Validate implementation-agent is not empty
              if [ -z "$IMPL_AGENT" ] || [ "$IMPL_AGENT" = "" ]; then
                echo "‚ùå ERROR: implementation-agent parameter is empty!"
                echo "‚ö†Ô∏è Cannot proceed without agent configuration"
                exit 1
              fi
              
              echo "$IMPL_AGENT" > /tmp/github-app.txt
              echo "{{`{{workflow.parameters.implementation-cli}}`}}" > /tmp/cli-type.txt
              echo "{{`{{workflow.parameters.implementation-model}}`}}" > /tmp/model.txt
              echo "{{`{{workflow.parameters.implementation-model-rotation}}`}}" > /tmp/model-rotation.txt
              echo "{{`{{workflow.parameters.implementation-max-retries}}`}}" > /tmp/max-retries.txt
              ;;
          esac
          
          # Final validation - ensure we have a valid agent
          FINAL_AGENT=$(cat /tmp/github-app.txt 2>/dev/null || echo "")
          if [ -z "$FINAL_AGENT" ] || [ "$FINAL_AGENT" = "" ]; then
            echo "‚ùå FATAL ERROR: No agent determined for task ${TASK_ID}"
            echo "   Agent type detected: ${AGENT_TYPE}"
            echo "   Language: ${LANGUAGE}"
            echo "   Framework: ${FRAMEWORK}"
            exit 1
          fi
          
          # Validate agent is not testing-agent (Tess should never do implementation)
          if echo "$FINAL_AGENT" | grep -qiE "(tess|testing)"; then
            echo "üö® CRITICAL ERROR: Testing agent (Tess) cannot perform implementation work!"
            echo "   Task ${TASK_ID} appears to be frontend/implementation but routed to testing agent"
            echo "   This will cause incorrect component library usage (Material-UI instead of shadcn/ui)"
            echo "   Aborting to prevent incorrect implementation"
            exit 1
          fi
          
          # Write language and framework to output files
          echo "$LANGUAGE" > /tmp/task-language.txt
          echo "$FRAMEWORK" > /tmp/task-framework.txt
          
          echo "   GitHub App: $(cat /tmp/github-app.txt)"
          echo "   CLI Type: $(cat /tmp/cli-type.txt)"
          echo "   Model: $(cat /tmp/model.txt)"
          echo "   Language: ${LANGUAGE}"
          echo "   Framework: ${FRAMEWORK}"
          echo ""
          echo "üéØ Agent determination complete"

    # Check if PR is already merged (for completion state checking)
    - name: check-pr-merge-status
      inputs:
        parameters:
          - name: repository
          - name: pr-number
          - name: stage-name
            default: ""
      outputs:
        parameters:
          - name: is-merged
            valueFrom:
              path: /tmp/is-merged.txt
            default: "false"
          - name: skip-stage
            valueFrom:
              path: /tmp/skip-stage.txt
            default: "false"
      script:
        image: alpine:3.20
        env:
          - name: GITHUB_APP_ID
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: app-id
          - name: GITHUB_APP_PRIVATE_KEY
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: private-key
        command: [sh]
        source: |
          #!/bin/sh
          set -e

          REPO="{{`{{inputs.parameters.repository}}`}}"
          PR_NUMBER="{{`{{inputs.parameters.pr-number}}`}}"
          STAGE_NAME="{{`{{inputs.parameters.stage-name}}`}}"

          echo "========================================="
          echo "Checking PR Merge Status & Agent Completion"
          echo "========================================="
          echo "Repository: $REPO"
          echo "PR Number: $PR_NUMBER"
          echo "Stage: $STAGE_NAME"
          echo ""

          # Default to not merged and don't skip
          echo "false" > /tmp/is-merged.txt
          echo "false" > /tmp/skip-stage.txt

          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "" ]; then
            echo "‚ÑπÔ∏è No PR number provided, cannot check merge status"
            exit 0
          fi

          apk add --no-cache curl jq openssl >/dev/null 2>&1 || true

          OWNER=$(echo "$REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

          # GitHub App authentication (same pattern as other templates)
          AUTH_HEADER=""
          if [ -n "${GITHUB_APP_ID:-}" ] && [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
            TEMP_KEY="/tmp/github-app-key.pem"
            printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY"
            chmod 600 "$TEMP_KEY"

            NOW=$(date +%s)
            EXP=$((NOW + 600))
            HDR=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 2>/dev/null || printf '{"alg":"RS256","typ":"JWT"}' | base64)
            HDR=$(echo -n "$HDR" | tr '+/' '-_' | tr -d '=')
            PAY=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 2>/dev/null || printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64)
            PAY=$(echo -n "$PAY" | tr '+/' '-_' | tr -d '=')
            SIG=$(printf '%s.%s' "$HDR" "$PAY" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 -w 0 2>/dev/null || openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64)
            SIG=$(echo -n "$SIG" | tr '+/' '-_' | tr -d '=')
            JWT="$HDR.$PAY.$SIG"

            INSTALLATION_ID=$(curl -s -L \
              -H "Authorization: Bearer $JWT" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/$OWNER/$REPO_NAME/installation" | jq -r '.id')

            if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" = "null" ]; then
              INSTALLATION_ID=$(curl -s -L \
                -H "Authorization: Bearer $JWT" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/orgs/$OWNER/installation" | jq -r '.id')
            fi

            if [ -n "$INSTALLATION_ID" ] && [ "$INSTALLATION_ID" != "null" ]; then
              TOKEN=$(curl -s -X POST \
                -H "Authorization: Bearer $JWT" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')
              if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
                AUTH_HEADER="Authorization: Bearer $TOKEN"
              fi
            fi

            rm -f "$TEMP_KEY"
          fi

          if [ -z "$AUTH_HEADER" ]; then
            echo "‚ö†Ô∏è No GitHub authentication available, cannot check PR status"
            exit 0
          fi

          # Check PR status
          echo "üîç Checking PR #$PR_NUMBER status..."
          PR_DATA=$(curl -s -L \
            -H "Accept: application/vnd.github+json" \
            -H "$AUTH_HEADER" \
            "https://api.github.com/repos/$REPO/pulls/$PR_NUMBER")

          STATE=$(echo "$PR_DATA" | jq -r '.state // "unknown"')
          MERGED=$(echo "$PR_DATA" | jq -r '.merged // false')
          MERGED_AT=$(echo "$PR_DATA" | jq -r '.merged_at // "null"')

          echo "   State: $STATE"
          echo "   Merged: $MERGED"
          echo "   Merged At: $MERGED_AT"

          if [ "$MERGED" = "true" ] || [ "$STATE" = "closed" ]; then
            echo "‚úÖ PR is already merged/closed - task is complete!"
            echo "true" > /tmp/is-merged.txt
            echo "true" > /tmp/skip-stage.txt
            
            echo ""
            echo "üéØ Skipping $STAGE_NAME stage - work already complete"
            exit 0
          fi

          # Determine which agent bot to check for based on stage
          AGENT_BOT=""
          case "$STAGE_NAME" in
            "quality")
              AGENT_BOT="5dlabs-cleo[bot]"
              ;;
            "security")
              AGENT_BOT="5dlabs-cipher[bot]"
              ;;
            "testing")
              AGENT_BOT="5dlabs-tess[bot]"
              ;;
          esac

          # Check if the stage-specific agent has already approved this PR
          # Only skip if the MOST RECENT review is an approval
          # This allows remediation loops: Request Changes ‚Üí Fix ‚Üí Re-review ‚Üí Approve
          if [ -n "$AGENT_BOT" ]; then
            echo ""
            echo "üîç Checking $AGENT_BOT review status for PR #$PR_NUMBER..."
            
            REVIEWS_DATA=$(curl -s -L \
              -H "Accept: application/vnd.github+json" \
              -H "$AUTH_HEADER" \
              "https://api.github.com/repos/$REPO/pulls/$PR_NUMBER/reviews")

            # Get the most recent review from this agent (GitHub API returns reviews oldest first)
            LATEST_REVIEW_STATE=$(echo "$REVIEWS_DATA" | jq -r --arg bot "$AGENT_BOT" '[.[] | select(.user.login == $bot)] | last | .state // "NONE"')

            if [ "$LATEST_REVIEW_STATE" = "APPROVED" ]; then
              echo "‚úÖ $AGENT_BOT has already APPROVED this PR"
              echo "   Skipping $STAGE_NAME stage to prevent duplicate execution"
              echo "true" > /tmp/skip-stage.txt
              exit 0
            elif [ "$LATEST_REVIEW_STATE" = "CHANGES_REQUESTED" ]; then
              echo "üîÑ $AGENT_BOT previously requested changes - allowing re-review after fixes"
            elif [ "$LATEST_REVIEW_STATE" = "COMMENTED" ]; then
              echo "üí¨ $AGENT_BOT previously commented - allowing full review"
            else
              echo "‚ÑπÔ∏è $AGENT_BOT has not yet reviewed this PR"
            fi
          fi

          echo "‚úì PR is open and not merged - stage should proceed"

    # Log information about GitHub checks (diagnostic only)

    # Cleanup handler for workflow completion/failure
    - name: cleanup-handler
      script:
        image: alpine:3.20
        command: [sh]
        source: |
          #!/bin/sh
          echo "========================================="
          echo "Workflow Cleanup Handler"
          echo "========================================="
          echo "Workflow Name: {{`{{workflow.name}}`}}"
          echo "Status: {{`{{workflow.status}}`}}"
          echo "Task ID: {{`{{workflow.parameters.task-id}}`}}"

          # Log final workflow state
          if [ "{{`{{workflow.status}}`}}" = "Succeeded" ]; then
            echo "‚úÖ Workflow completed successfully"
          else
            echo "‚ùå Workflow failed or was terminated"
          fi

          echo "Cleanup completed"

  # TTL strategy for workflow cleanup
  ttlStrategy:
    secondsAfterCompletion: 86400    # Keep completed workflows for 24 hours
    secondsAfterFailure: 259200      # Keep failed workflows for 3 days
    secondsAfterSuccess: 86400       # Keep successful workflows for 24 hours

  # Pod garbage collection
  podGC:
    strategy: OnPodCompletion
    deleteDelayDuration: 60s
{{- end }}
