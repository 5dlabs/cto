{{- if .Values.argo.enabled }}
---
# Multi-Agent Play Workflow Template
# Orchestrates Rex → Cleo → Tess through event-driven coordination
# Rex implements → Cleo ensures quality → Tess validates E2E in Kubernetes
# Supports parameterized agent selection and suspend/resume patterns

apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: play-workflow-template
  namespace: {{.Release.Namespace}}
  labels:
    app.kubernetes.io/name: play-workflow-template
    app.kubernetes.io/part-of: platform
    agents.platform/orchestration: multi-agent
    workflow-type: play-orchestration
spec:
  # Service account with proper permissions for CRD operations
  serviceAccountName: argo-workflow

  # Workflow timeout (14 days for long-running multi-agent workflows)
  activeDeadlineSeconds: 1209600

  # Ensure labels are applied to instantiated Workflows created from this template
  workflowMetadata:
    labels:
      workflow-type: play-orchestration
    annotations:
      # Store initial parameters for forwarding to subsequent tasks
      platform.agents/initial-params: |
        {
          "implementation-agent": "{{`{{workflow.parameters.implementation-agent}}`}}",
          "implementation-cli": "{{`{{workflow.parameters.implementation-cli}}`}}",
          "implementation-model": "{{`{{workflow.parameters.implementation-model}}`}}",
          "frontend-agent": "{{`{{workflow.parameters.frontend-agent}}`}}",
          "frontend-cli": "{{`{{workflow.parameters.frontend-cli}}`}}",
          "frontend-model": "{{`{{workflow.parameters.frontend-model}}`}}",
          "quality-agent": "{{`{{workflow.parameters.quality-agent}}`}}",
          "quality-cli": "{{`{{workflow.parameters.quality-cli}}`}}",
          "quality-model": "{{`{{workflow.parameters.quality-model}}`}}",
          "security-agent": "{{`{{workflow.parameters.security-agent}}`}}",
          "security-cli": "{{`{{workflow.parameters.security-cli}}`}}",
          "security-model": "{{`{{workflow.parameters.security-model}}`}}",
          "testing-agent": "{{`{{workflow.parameters.testing-agent}}`}}",
          "testing-cli": "{{`{{workflow.parameters.testing-cli}}`}}",
          "testing-model": "{{`{{workflow.parameters.testing-model}}`}}",
          "repository": "{{`{{workflow.parameters.repository}}`}}",
          "service": "{{`{{workflow.parameters.service}}`}}",
          "docs-repository": "{{`{{workflow.parameters.docs-repository}}`}}",
          "docs-project-directory": "{{`{{workflow.parameters.docs-project-directory}}`}}",
          "implementation-max-retries": "{{`{{workflow.parameters.implementation-max-retries}}`}}",
          "frontend-max-retries": "{{`{{workflow.parameters.frontend-max-retries}}`}}",
          "quality-max-retries": "{{`{{workflow.parameters.quality-max-retries}}`}}",
          "security-max-retries": "{{`{{workflow.parameters.security-max-retries}}`}}",
          "testing-max-retries": "{{`{{workflow.parameters.testing-max-retries}}`}}",
          "auto-merge": "{{`{{workflow.parameters.auto-merge}}`}}",
          "final-task": "{{`{{workflow.parameters.final-task}}`}}"
        }

  # Main entry point
  entrypoint: main

  # Global arguments for workflow configuration
  arguments:
    parameters:
      # Agent selection parameters (no hardcoded names)
      - name: implementation-agent
        description: "Agent to use for implementation work (e.g., 5DLabs-Rex)"
        value: ""  # Must be provided by MCP client
      - name: frontend-agent
        description: "Agent to use for frontend work (e.g., 5DLabs-Blaze)"
        value: ""  # Must be provided by MCP client
      - name: quality-agent
        description: "Agent to use for quality assurance (e.g., 5DLabs-Cleo)"
        value: ""  # Must be provided by MCP client
      - name: security-agent
        description: "Agent to use for security scanning (e.g., 5DLabs-Cipher)"
        value: ""  # Must be provided by MCP client
      - name: testing-agent
        description: "Agent to use for testing and validation (e.g., 5DLabs-Tess)"
        value: ""  # Must be provided by MCP client

      # Task and repository configuration
      - name: task-id
        description: "Unique task identifier for correlation (required)"
        value: ""  # Must be provided by MCP client
      - name: repository
        description: "GitHub repository for the work"
        value: ""  # Must be provided by MCP client
      - name: service
        description: "Service identifier for persistent workspace"
        value: ""  # Must be provided by MCP client
      - name: docs-repository
        description: "GitHub repository containing documentation"
        value: ""  # Must be provided by MCP client
      - name: docs-project-directory
        description: "Directory within docs repository containing project documentation"
        value: ""  # Must be provided by MCP client

      # CLI configuration per agent (multi-CLI aware)
      - name: implementation-cli
        description: "CLI to use for implementation agent (e.g., codex, claude)"
        value: ""  # Must be provided by MCP client
      - name: implementation-model
        description: "Model to use for implementation agent (e.g., gpt-5-codex, claude-sonnet-4-20250514)"
        value: ""  # Must be provided by MCP client
      - name: quality-cli
        description: "CLI to use for quality agent (e.g., claude, codex)"
        value: ""  # Must be provided by MCP client
      - name: quality-model
        description: "Model to use for quality agent"
        value: ""  # Must be provided by MCP client
      - name: security-cli
        description: "CLI to use for security agent (e.g., claude, codex)"
        value: ""  # Must be provided by MCP client
      - name: security-model
        description: "Model to use for security agent"
        value: ""  # Must be provided by MCP client
      - name: testing-cli
        description: "CLI to use for testing agent"
        value: ""  # Must be provided by MCP client
      - name: testing-model
        description: "Model to use for testing agent"
        value: ""  # Must be provided by MCP client
      - name: frontend-cli
        description: "CLI to use for frontend agent (e.g., codex, claude)"
        value: ""  # Must be provided by MCP client
      - name: frontend-model
        description: "Model to use for frontend agent"
        value: ""  # Must be provided by MCP client

      # Agent tool configurations (JSON strings from client-side config)
      - name: implementation-tools
        description: "JSON string of tools config for implementation agent"
        value: "{}"  # Defaults to empty, populated by MCP client
      - name: quality-tools
        description: "JSON string of tools config for quality agent"
        value: "{}"  # Defaults to empty, populated by MCP client
      - name: security-tools
        description: "JSON string of tools config for security agent"
        value: "{}"  # Defaults to empty, populated by MCP client
      - name: testing-tools
        description: "JSON string of tools config for testing agent"
        value: "{}"  # Defaults to empty, populated by MCP client
      - name: frontend-tools
        description: "JSON string of tools config for frontend agent"
        value: "{}"  # Defaults to empty, populated by MCP client

      # Model rotation configurations (JSON arrays of model names)
      - name: implementation-model-rotation
        description: "JSON array of model names for implementation agent retry rotation"
        value: "[]"  # Defaults to empty array, populated by MCP client from cto-config.json
      - name: quality-model-rotation
        description: "JSON array of model names for quality agent retry rotation"
        value: "[]"  # Defaults to empty array, populated by MCP client from cto-config.json
      - name: security-model-rotation
        description: "JSON array of model names for security agent retry rotation"
        value: "[]"  # Defaults to empty array, populated by MCP client from cto-config.json
      - name: testing-model-rotation
        description: "JSON array of model names for testing agent retry rotation"
        value: "[]"  # Defaults to empty array, populated by MCP client from cto-config.json
      - name: frontend-model-rotation
        description: "JSON array of model names for frontend agent retry rotation"
        value: "[]"  # Defaults to empty array, populated by MCP client from cto-config.json

      # PR context (populated by suspend/resume)
      - name: pr-url
        description: "Pull request URL (populated after PR creation)"
        value: ""
      - name: pr-number
        description: "Pull request number (populated after PR creation)"
        value: ""

      # QA feedback (populated by suspend/resume)
      - name: qa-status
        description: "QA approval status (populated after QA)"
        value: ""
      - name: qa-comments
        description: "QA feedback comments (populated after QA)"
        value: ""
      - name: merge-sha
        description: "Merge commit SHA (populated after PR merge)"
        value: ""

      # Task requirements (secrets and environment variables)
      - name: task-requirements
        description: "Base64-encoded requirements.yaml content for all agents"
        value: ""
      - name: opencode-max-retries
        description: "Maximum retry attempts for OpenCode agent executions (0 = unlimited)"
        value: "10"
      - name: opencode-verbose
        description: "Enable verbose output for OpenCode agents (1 = markdown format, 0 = json)"
        value: "0"
      - name: implementation-max-retries
        description: "Maximum retry attempts for implementation agent executions (0 = unlimited)"
        value: "10"
      - name: quality-max-retries
        description: "Maximum retry attempts for quality agent executions (0 = unlimited)"
        value: "10"
      - name: security-max-retries
        description: "Maximum retry attempts for security agent executions (0 = unlimited)"
        value: "10"
      - name: testing-max-retries
        description: "Maximum retry attempts for testing agent executions (0 = unlimited)"
        value: "10"
      - name: frontend-max-retries
        description: "Maximum retry attempts for frontend agent executions (0 = unlimited)"
        value: "10"
      - name: auto-merge
        description: "Whether Tess should automatically merge PRs after approval (true/false)"
        value: "false"
      - name: final-task
        description: "Whether this is the final task requiring deployment verification (true/false)"
        value: "false"

  # Workflow instance naming pattern
  onExit: cleanup-handler

  templates:
    # Main DAG with sequential task execution and suspend points
    - name: main
      dag:
        tasks:
          # Stage 0: Initialize workflow stage tracking
          - name: initialize-stage
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "pending"
                - name: verify-update
                  value: "true"

          # Remediation loop: Rex → Cleo → Tess until approved
          - name: remediation-iteration
            dependencies: [initialize-stage]
            template: remediation-iteration

          # Update stage after successful remediation (approved status)
          - name: update-to-waiting-merge
            dependencies: [remediation-iteration]
            when: "{{`{{tasks.remediation-iteration.outputs.parameters.remediation-status}}`}} == approved"
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "waiting-pr-merged"
                - name: verify-update
                  value: "true"

          # SKIP PR APPROVAL - GO STRAIGHT TO MERGE
          # Suspend point 3: Wait for PR merged to main
          - name: wait-merge-to-main
            dependencies: [update-to-waiting-merge]
            when: "{{`{{tasks.remediation-iteration.outputs.parameters.remediation-status}}`}} == approved"
            template: suspend-for-event
            arguments:
              parameters:
                - name: event-type
                  value: "pr-merged"
                - name: stage-name
                  value: "waiting-pr-merged"

          - name: complete-task
            dependencies: [wait-merge-to-main]
            when: "{{`{{tasks.remediation-iteration.outputs.parameters.remediation-status}}`}} == approved"
            template: task-completion
            arguments:
              parameters:
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: approval-status
                  value: "{{`{{tasks.remediation-iteration.outputs.parameters.remediation-status}}`}}"
                - name: merge-sha
                  value: "{{`{{workflow.parameters.merge-sha}}`}}"

          - name: complete-task-failed
            dependencies: [remediation-iteration]
            when: "{{`{{tasks.remediation-iteration.outputs.parameters.remediation-status}}`}} == failed"
            template: task-completion
            arguments:
              parameters:
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: approval-status
                  value: "failed"
                - name: merge-sha
                  value: ""

    # Template for creating CodeRun CRDs for agent execution and waiting for completion
    # Implementation cycle: run Rex, then check/poll for PR; if not found, repeat by failing upstream
    - name: implementation-cycle
      inputs:
        parameters:
          - name: github-app
          - name: task-id
          - name: stage
          - name: cli-type
          - name: model
          - name: model-rotation
            default: "[]"
          - name: max-retries
          - name: task-language
            default: "rust"
          - name: task-framework
            default: ""
      outputs:
        parameters:
          - name: pr-url
            valueFrom:
              parameter: "{{`{{steps.wait-for-pr.outputs.parameters.pr-url}}`}}"
          - name: pr-number
            valueFrom:
              parameter: "{{`{{steps.wait-for-pr.outputs.parameters.pr-number}}`}}"
      steps:
        - - name: implementation-work
            template: agent-coderun
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{inputs.parameters.github-app}}`}}"
                - name: task-id
                  value: "{{`{{inputs.parameters.task-id}}`}}"
                - name: stage
                  value: "{{`{{inputs.parameters.stage}}`}}"
                - name: cli-type
                  value: "{{`{{inputs.parameters.cli-type}}`}}"
                - name: model
                  value: "{{`{{inputs.parameters.model}}`}}"
                - name: model-rotation
                  value: "{{`{{inputs.parameters.model-rotation}}`}}"
                - name: tools-config
                  value: "{{`{{workflow.parameters.implementation-tools}}`}}"
                - name: max-retries
                  value: "{{`{{inputs.parameters.max-retries}}`}}"
                - name: task-language
                  value: "{{`{{inputs.parameters.task-language}}`}}"
                - name: task-framework
                  value: "{{`{{inputs.parameters.task-framework}}`}}"
        - - name: wait-for-pr
            template: check-or-wait-for-pr
            arguments:
              parameters:
                - name: repository
                  value: "{{`{{workflow.parameters.repository}}`}}"
                - name: task-id
                  value: "{{`{{inputs.parameters.task-id}}`}}"
                - name: stage
                  value: "{{`{{inputs.parameters.stage}}`}}"

    # Run a full remediation iteration (Rex → Cleo → Tess) with automatic retries
    - name: remediation-iteration
      outputs:
        parameters:
          - name: pr-url
            valueFrom:
              parameter: "{{`{{steps.implementation.outputs.parameters.pr-url}}`}}"
          - name: pr-number
            valueFrom:
              parameter: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"
          - name: remediation-status
            valueFrom:
              parameter: "{{`{{steps.evaluate-remediation.outputs.parameters.remediation-status}}`}}"
      retryStrategy:
        retryPolicy: Always
        limit: 0
        backoff:
          duration: "60s"
          factor: 2
      steps:
        - - name: determine-agent
            template: determine-task-agent
            arguments:
              parameters:
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: docs-repository
                  value: "{{`{{workflow.parameters.docs-repository}}`}}"
                - name: docs-project-directory
                  value: "{{`{{workflow.parameters.docs-project-directory}}`}}"
        - - name: implementation
            template: implementation-cycle
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{steps.determine-agent.outputs.parameters.github-app}}`}}"
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: stage
                  value: "implementation"
                - name: cli-type
                  value: "{{`{{steps.determine-agent.outputs.parameters.cli-type}}`}}"
                - name: model
                  value: "{{`{{steps.determine-agent.outputs.parameters.model}}`}}"
                - name: model-rotation
                  value: "{{`{{steps.determine-agent.outputs.parameters.model-rotation}}`}}"
                - name: max-retries
                  value: "{{`{{steps.determine-agent.outputs.parameters.max-retries}}`}}"
                - name: task-language
                  value: "{{`{{steps.determine-agent.outputs.parameters.task-language}}`}}"
                - name: task-framework
                  value: "{{`{{steps.determine-agent.outputs.parameters.task-framework}}`}}"
        # Note: No longer suspending for PR created event - implementation-cycle already
        # verified PR exists via check-or-wait-for-pr polling. Webhook-based resume was
        # creating race conditions where PR webhook fired before suspend point was reached.
        - - name: update-to-quality-in-progress
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "quality-in-progress"
                - name: verify-update
                  value: "true"
        - - name: quality-work
            template: agent-coderun
            continueOn:
              failed: true  # Allow workflow to proceed to Cipher even if Cleo finds issues
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{workflow.parameters.quality-agent}}`}}"
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: stage
                  value: "quality"
                - name: cli-type
                  value: "{{`{{workflow.parameters.quality-cli}}`}}"
                - name: model
                  value: "{{`{{workflow.parameters.quality-model}}`}}"
                - name: model-rotation
                  value: "{{`{{workflow.parameters.quality-model-rotation}}`}}"
                - name: tools-config
                  value: "{{`{{workflow.parameters.quality-tools}}`}}"
                - name: pr-url
                  value: "{{`{{steps.implementation.outputs.parameters.pr-url}}`}}"
                - name: pr-number
                  value: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"
                - name: max-retries
                  value: "{{`{{workflow.parameters.quality-max-retries}}`}}"
        # Proceed to Cipher security scanning after Cleo quality checks
        - - name: update-to-security-in-progress
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "security-in-progress"
                - name: verify-update
                  value: "true"
        - - name: security-work
            template: agent-coderun
            continueOn:
              failed: true  # Allow workflow to proceed to Tess even if Cipher finds security issues
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{workflow.parameters.security-agent}}`}}"
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: stage
                  value: "security"
                - name: cli-type
                  value: "{{`{{workflow.parameters.security-cli}}`}}"
                - name: model
                  value: "{{`{{workflow.parameters.security-model}}`}}"
                - name: model-rotation
                  value: "{{`{{workflow.parameters.security-model-rotation}}`}}"
                - name: tools-config
                  value: "{{`{{workflow.parameters.security-tools}}`}}"
                - name: pr-url
                  value: "{{`{{steps.implementation.outputs.parameters.pr-url}}`}}"
                - name: pr-number
                  value: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"
                - name: max-retries
                  value: "{{`{{workflow.parameters.security-max-retries}}`}}"
        # No suspend needed after Cipher - proceed directly to Tess
        # Cipher hands off to Tess, which is final approver
        # continueOn.failed allows Tess to run even if Cipher raises security concerns
        - - name: testing-work
            template: agent-coderun
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{workflow.parameters.testing-agent}}`}}"
                - name: task-id
                  value: "{{`{{workflow.parameters.task-id}}`}}"
                - name: stage
                  value: "testing"
                - name: cli-type
                  value: "{{`{{workflow.parameters.testing-cli}}`}}"
                - name: model
                  value: "{{`{{workflow.parameters.testing-model}}`}}"
                - name: model-rotation
                  value: "{{`{{workflow.parameters.testing-model-rotation}}`}}"
                - name: tools-config
                  value: "{{`{{workflow.parameters.testing-tools}}`}}"
                - name: pr-url
                  value: "{{`{{steps.implementation.outputs.parameters.pr-url}}`}}"
                - name: pr-number
                  value: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"
                - name: max-retries
                  value: "{{`{{workflow.parameters.testing-max-retries}}`}}"
                - name: auto-merge
                  value: "{{`{{workflow.parameters.auto-merge}}`}}"
                - name: final-task
                  value: "{{`{{workflow.parameters.final-task}}`}}"
        - - name: update-to-waiting-qa
            template: update-workflow-stage
            arguments:
              parameters:
                - name: new-stage
                  value: "waiting-ready-for-qa"
                - name: verify-update
                  value: "true"
        # Tess approval happens via GitHub PR review - sensor resumes at waiting-ready-for-qa
        - - name: wait-for-tess-approval
            template: suspend-for-event
            arguments:
              parameters:
                - name: event-type
                  value: "tess-approval"
                - name: stage-name
                  value: "waiting-ready-for-qa"
        - - name: evaluate-remediation
            template: assess-remediation-outcome
            arguments:
              parameters:
                - name: repository
                  value: "{{`{{workflow.parameters.repository}}`}}"
                - name: pr-number
                  value: "{{`{{steps.implementation.outputs.parameters.pr-number}}`}}"

    # Template to check/poll GitHub for PR existence for task label
    - name: check-or-wait-for-pr
      inputs:
        parameters:
          - name: repository
          - name: task-id
          - name: stage
      outputs:
        parameters:
          - name: pr-url
            valueFrom:
              path: /tmp/pr-url.txt
            default: ""
          - name: pr-number
            valueFrom:
              path: /tmp/pr-number.txt
            default: ""
      script:
        image: alpine:3.20
        env:
          - name: GITHUB_APP_ID
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: app-id
          - name: GITHUB_APP_PRIVATE_KEY
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: private-key
        command: [sh]
        source: |
          #!/bin/sh
          set -e
          REPO="{{`{{inputs.parameters.repository}}`}}"
          TASK_ID="{{`{{inputs.parameters.task-id}}`}}"
          LABEL="task-${TASK_ID}"
          RUN_LABEL="run-{{`{{workflow.name}}`}}"
          SERVICE_LABEL="service-{{`{{workflow.parameters.service}}`}}"

          # For single-repo setups, we need to find PRs from the current workflow run
          # Always use both task label AND run label to avoid finding old PRs from previous runs
          STAGE="{{`{{inputs.parameters.stage}}`}}"

          echo "🔎 Stage $STAGE: Looking for PR with labels ${LABEL} and ${RUN_LABEL} in ${REPO}"

          # Ensure tools
          apk add --no-cache curl jq openssl >/dev/null 2>&1 || true

          AUTH_HEADER=""
          OWNER=$(echo "$REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

          if [ -n "${GITHUB_APP_ID:-}" ] && [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
            echo "🔐 Using Morgan GitHub App for authenticated API calls"
            TEMP_KEY="/tmp/github-app-key.pem"
            # Support escaped newlines in secret
            printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY"
            chmod 600 "$TEMP_KEY"

            NOW=$(date +%s)
            EXP=$((NOW + 600))
            HDR=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 2>/dev/null || printf '{"alg":"RS256","typ":"JWT"}' | base64)
            HDR=$(echo -n "$HDR" | tr '+/' '-_' | tr -d '=')
            PAY=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 2>/dev/null || printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64)
            PAY=$(echo -n "$PAY" | tr '+/' '-_' | tr -d '=')
            SIG=$(printf '%s.%s' "$HDR" "$PAY" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 -w 0 2>/dev/null || openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64)
            SIG=$(echo -n "$SIG" | tr '+/' '-_' | tr -d '=')
            JWT="$HDR.$PAY.$SIG"

            # Resolve installation ID (repo first, fallback org)
            INSTALLATION_ID=$(curl -s -L \
              -H "Authorization: Bearer $JWT" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/$OWNER/$REPO_NAME/installation" | jq -r '.id')

            if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" = "null" ]; then
              INSTALLATION_ID=$(curl -s -L \
                -H "Authorization: Bearer $JWT" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/orgs/$OWNER/installation" | jq -r '.id')
            fi

            if [ -n "$INSTALLATION_ID" ] && [ "$INSTALLATION_ID" != "null" ]; then
              TOKEN=$(curl -s -X POST \
                -H "Authorization: Bearer $JWT" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')
              if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
                AUTH_HEADER="Authorization: Bearer $TOKEN"
              fi
            fi

            rm -f "$TEMP_KEY"
          else
            echo "ℹ️ Morgan credentials not available; using unauthenticated GitHub API"
          fi

          # Poll with reduced attempts for faster failure detection
          # Agents should create PRs quickly; 20s total wait (4 x 5s) is sufficient
          # Previous: 12 attempts = 60s total (too long for typical PR creation)
          attempts=4
          while [ $attempts -gt 0 ]; do
            # First, try to find PR by labels (fast path for already-labeled PRs)
            q_labels=$(printf "%s" "$LABEL,$RUN_LABEL" | sed 's/,/%2C/g')
            url="https://api.github.com/repos/${REPO}/issues?state=open&labels=${q_labels}"
            if [ -n "$AUTH_HEADER" ]; then
              resp=$(curl -sL -H "Accept: application/vnd.github+json" -H "$AUTH_HEADER" "$url") || resp="[]"
            else
              resp=$(curl -sL -H "Accept: application/vnd.github+json" "$url") || resp="[]"
            fi

            pr_url=$(echo "$resp" | jq -r '.[] | select(.pull_request != null) | .html_url' | head -n1)
            pr_number=$(echo "$resp" | jq -r '.[] | select(.pull_request != null) | .number' | head -n1)

            # If not found by labels, try searching by branch name
            if [ -z "$pr_number" ] || [ "$pr_number" = "null" ]; then
              echo "🔍 No PR found by labels, searching by branch name..."
              BRANCH_NAME="feature/task-${TASK_ID}-implementation"
              url="https://api.github.com/repos/${REPO}/pulls?state=open&head=${OWNER}:${BRANCH_NAME}"
              if [ -n "$AUTH_HEADER" ]; then
                resp=$(curl -sL -H "Accept: application/vnd.github+json" -H "$AUTH_HEADER" "$url") || resp="[]"
              else
                resp=$(curl -sL -H "Accept: application/vnd.github+json" "$url") || resp="[]"
              fi
              
              pr_url=$(echo "$resp" | jq -r '.[0].html_url // empty' | head -n1)
              pr_number=$(echo "$resp" | jq -r '.[0].number // empty' | head -n1)
              
              if [ -n "$pr_number" ] && [ "$pr_number" != "null" ]; then
                echo "✅ Found PR #$pr_number by branch name: $BRANCH_NAME"
              fi
            fi

            if [ -n "$pr_number" ] && [ "$pr_number" != "null" ]; then
              echo "$pr_url" > /tmp/pr-url.txt
              echo "$pr_number" > /tmp/pr-number.txt
              echo "✅ Found PR #$pr_number"
              if [ -n "$TOKEN" ]; then
                add_labels_payload=$(printf '{"labels":["%s","%s","%s"]}' "$LABEL" "$RUN_LABEL" "$SERVICE_LABEL")
                curl -s -X POST \
                  -H "Authorization: Bearer $TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  -H "Content-Type: application/json" \
                  -d "$add_labels_payload" \
                  "https://api.github.com/repos/${REPO}/issues/${pr_number}/labels" >/dev/null 2>&1 || true
                echo "🏷️ Ensured PR #$pr_number has labels: $LABEL, $RUN_LABEL, $SERVICE_LABEL"
              fi
              exit 0
            fi

            attempts=$((attempts-1))
            echo "⏳ PR not found yet, retrying... ($attempts left)"
            sleep 5
          done

          if [ "$STAGE" = "quality" ] || [ "$STAGE" = "security" ] || [ "$STAGE" = "testing" ]; then
            echo "❌ No PR found with labels ${LABEL} and ${RUN_LABEL}. This indicates the implementation stage hasn't created a PR yet."
            # For quality/security/testing, this is an error condition
            > /tmp/pr-url.txt
            > /tmp/pr-number.txt
            exit 1
          else
            echo "❌ No PR found with labels ${LABEL} and ${RUN_LABEL} after waiting."
            # Leave outputs empty; upstream can decide to re-run implementation
            > /tmp/pr-url.txt
            > /tmp/pr-number.txt
            exit 0
          fi
    # Evaluate PR labels to determine remediation outcome
    - name: assess-remediation-outcome
      inputs:
        parameters:
          - name: repository
          - name: pr-number
      outputs:
        parameters:
          - name: remediation-status
            valueFrom:
              path: /tmp/remediation-status.txt
            default: "needs-fixes"
      script:
        image: alpine:3.20
        env:
          - name: GITHUB_APP_ID
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: app-id
          - name: GITHUB_APP_PRIVATE_KEY
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: private-key
        command: [sh]
        source: |
          #!/bin/sh
          set -e

          REPO="{{`{{inputs.parameters.repository}}`}}"
          PR_NUMBER="{{`{{inputs.parameters.pr-number}}`}}"

          if [ -z "$PR_NUMBER" ]; then
            echo "⚠️ No PR number available; assuming remediation still required"
            echo "needs-fixes" > /tmp/remediation-status.txt
            exit 1
          fi

          apk add --no-cache curl jq openssl >/dev/null 2>&1 || true

          OWNER=$(echo "$REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

          AUTH_HEADER=""
          if [ -n "${GITHUB_APP_ID:-}" ] && [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
            TEMP_KEY="/tmp/github-app-key.pem"
            printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY"
            chmod 600 "$TEMP_KEY"

            NOW=$(date +%s)
            EXP=$((NOW + 600))
            HDR=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 2>/dev/null || printf '{"alg":"RS256","typ":"JWT"}' | base64)
            HDR=$(echo -n "$HDR" | tr '+/' '-_' | tr -d '=')
            PAY=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 2>/dev/null || printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64)
            PAY=$(echo -n "$PAY" | tr '+/' '-_' | tr -d '=')
            SIG=$(printf '%s.%s' "$HDR" "$PAY" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 -w 0 2>/dev/null || openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64)
            SIG=$(echo -n "$SIG" | tr '+/' '-_' | tr -d '=')
            JWT="$HDR.$PAY.$SIG"

            INSTALLATION_ID=$(curl -s -L               -H "Authorization: Bearer $JWT"               -H "Accept: application/vnd.github+json"               "https://api.github.com/repos/$OWNER/$REPO_NAME/installation" | jq -r '.id')

            if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" = "null" ]; then
              INSTALLATION_ID=$(curl -s -L                 -H "Authorization: Bearer $JWT"                 -H "Accept: application/vnd.github+json"                 "https://api.github.com/orgs/$OWNER/installation" | jq -r '.id')
            fi

            if [ -n "$INSTALLATION_ID" ] && [ "$INSTALLATION_ID" != "null" ]; then
              TOKEN=$(curl -s -X POST                 -H "Authorization: Bearer $JWT"                 -H "Accept: application/vnd.github+json"                 "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')
              if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
                AUTH_HEADER="Authorization: Bearer $TOKEN"
              fi
            fi

            rm -f "$TEMP_KEY"
          fi

          MAX_ATTEMPTS=30
          SLEEP_SECONDS=10

          attempt=1
          while [ $attempt -le $MAX_ATTEMPTS ]; do
            echo "🔍 Checking PR #$PR_NUMBER labels (attempt $attempt/$MAX_ATTEMPTS)"

            if [ -n "$AUTH_HEADER" ]; then
              ISSUE=$(curl -s -L                 -H "Accept: application/vnd.github+json"                 -H "$AUTH_HEADER"                 "https://api.github.com/repos/$REPO/issues/$PR_NUMBER")
            else
              ISSUE=$(curl -s -L                 -H "Accept: application/vnd.github+json"                 "https://api.github.com/repos/$REPO/issues/$PR_NUMBER")
            fi

            LABELS=$(echo "$ISSUE" | jq -r '.labels[].name')

            if echo "$LABELS" | grep -q '^approved$'; then
              echo "approved" > /tmp/remediation-status.txt
              echo "✅ PR approved by Tess"
              exit 0
            fi

            if echo "$LABELS" | grep -q '^failed-remediation$'; then
              echo "failed" > /tmp/remediation-status.txt
              echo "⛔ Remediation marked as failed"
              exit 0
            fi

            if echo "$LABELS" | grep -q '^needs-fixes$'; then
              echo "needs-fixes" > /tmp/remediation-status.txt
              echo "🔁 Needs-fixes label detected; triggering another remediation pass"
              exit 1
            fi

            # Note: Stage transitions are now driven by GitHub PR reviews (Cleo/Tess approvals)
            # Labels are only used for correlation (task-*, service-*, run-*) and remediation (needs-fixes)
            if [ -z "$LABELS" ]; then
              echo "ℹ️ PR currently has no workflow labels; waiting"
            else
              echo "ℹ️ Current labels: $LABELS"
            fi

            attempt=$((attempt + 1))
            if [ $attempt -le $MAX_ATTEMPTS ]; then
              sleep $SLEEP_SECONDS
            fi
          done

          echo "needs-fixes" > /tmp/remediation-status.txt
          echo "⚠️ Timed out waiting for remediation decision; retrying iteration"
          exit 1
    - name: agent-coderun
      inputs:
        parameters:
          - name: github-app
          - name: task-id
          - name: stage
          - name: cli-type
            default: ""
          - name: model
            default: ""
          - name: model-rotation
            default: "[]"
          - name: tools-config
            default: "{}"
          - name: pr-url
            default: ""
          - name: pr-number
            default: ""
          - name: qa-ready
            default: "false"
          - name: max-retries
            default: ""
          - name: auto-merge
            default: "false"
          - name: final-task
            default: "false"
          - name: task-language
            default: "rust"
          - name: task-framework
            default: ""
      outputs:
        parameters:
          - name: coderun-name
            valueFrom:
              parameter: "{{`{{steps.resolve-coderun-name.outputs.parameters.coderun-name}}`}}"
      steps:
        - - name: create-coderun-resource
            template: create-coderun-resource
            arguments:
              parameters:
                - name: github-app
                  value: "{{`{{inputs.parameters.github-app}}`}}"
                - name: task-id
                  value: "{{`{{inputs.parameters.task-id}}`}}"
                - name: stage
                  value: "{{`{{inputs.parameters.stage}}`}}"
                - name: cli-type
                  value: "{{`{{inputs.parameters.cli-type}}`}}"
                - name: model
                  value: "{{`{{inputs.parameters.model}}`}}"
                - name: model-rotation
                  value: "{{`{{inputs.parameters.model-rotation}}`}}"
                - name: tools-config
                  value: "{{`{{inputs.parameters.tools-config}}`}}"
                - name: pr-url
                  value: "{{`{{inputs.parameters.pr-url}}`}}"
                - name: pr-number
                  value: "{{`{{inputs.parameters.pr-number}}`}}"
                - name: qa-ready
                  value: "{{`{{inputs.parameters.qa-ready}}`}}"
                - name: max-retries
                  value: "{{`{{inputs.parameters.max-retries}}`}}"
                - name: auto-merge
                  value: "{{`{{inputs.parameters.auto-merge}}`}}"
                - name: final-task
                  value: "{{`{{inputs.parameters.final-task}}`}}"
                - name: task-language
                  value: "{{`{{inputs.parameters.task-language}}`}}"
                - name: task-framework
                  value: "{{`{{inputs.parameters.task-framework}}`}}"
        - - name: resolve-coderun-name
            template: resolve-coderun-name
            arguments:
              parameters:
                - name: stage
                  value: "{{`{{inputs.parameters.stage}}`}}"
                - name: task-id
                  value: "{{`{{inputs.parameters.task-id}}`}}"
                - name: candidate-name
                  value: "{{`{{steps.create-coderun-resource.outputs.parameters.name}}`}}"
        - - name: wait-for-completion
            template: wait-coderun-completion
            arguments:
              parameters:
                - name: coderun-name
                  value: "{{`{{steps.resolve-coderun-name.outputs.parameters.coderun-name}}`}}"

    # Template for creating CodeRun resources
    - name: create-coderun-resource
      inputs:
        parameters:
          - name: github-app
          - name: task-id
          - name: stage
          - name: cli-type
            default: ""
          - name: model
            default: ""
          - name: model-rotation
            default: "[]"
          - name: tools-config
            default: "{}"
          - name: pr-url
            default: ""
          - name: pr-number
            default: ""
          - name: qa-ready
            default: "false"
          - name: max-retries
            default: ""
          - name: auto-merge
            default: "false"
          - name: final-task
            default: "false"
          - name: task-language
            default: "rust"
          - name: task-framework
            default: ""
      outputs:
        parameters:
          - name: name
            valueFrom:
              jsonPath: '{.metadata.name}'
      resource:
        action: create
        setOwnerReference: true
        successCondition: status.phase == Succeeded
        failureCondition: status.phase == Failed
        manifest: |
          apiVersion: agents.platform/v1
          kind: CodeRun
          metadata:
            generateName: "{{`{{workflow.parameters.service}}`}}-t{{`{{inputs.parameters.task-id}}`}}-{{`{{inputs.parameters.stage}}`}}-"
            namespace: {{.Release.Namespace}}
            labels:
              task-id: "{{`{{inputs.parameters.task-id}}`}}"
              service: "{{`{{workflow.parameters.service}}`}}"
              github-app: "{{`{{inputs.parameters.github-app}}`}}"
              workflow-name: "{{`{{workflow.name}}`}}"
              workflow-run: "{{`{{workflow.name}}`}}"
              workflow-stage: "{{`{{inputs.parameters.stage}}`}}"
              workflow-type: "play-orchestration"
            annotations:
              agents.platform/tools-config: |
                {{`{{inputs.parameters.tools-config}}`}}
          spec:
            taskId: {{`{{inputs.parameters.task-id}}`}}
            service: "{{`{{workflow.parameters.service}}`}}"
            repositoryUrl: "{{`{{workflow.parameters.repository}}`}}"
            docsRepositoryUrl: "https://github.com/{{`{{workflow.parameters.docs-repository}}`}}"
            docsProjectDirectory: "{{`{{workflow.parameters.docs-project-directory}}`}}"
            workingDirectory: "."
            githubApp: "{{`{{inputs.parameters.github-app}}`}}"
            model: "{{`{{inputs.parameters.model}}`}}"
            continueSession: true
            overwriteMemory: false
            docsBranch: "main"
            contextVersion: 1
            cliConfig:
              cliType: "{{`{{inputs.parameters.cli-type}}`}}"
              model: "{{`{{inputs.parameters.model}}`}}"
              modelRotation: {{`{{inputs.parameters.model-rotation}}`}}
            # Pass task requirements if available
            taskRequirements: "{{`{{workflow.parameters.task-requirements}}`}}"
            # Pass PR context as environment if available
            env:
              PR_URL: "{{`{{inputs.parameters.pr-url}}`}}"
              PR_NUMBER: "{{`{{inputs.parameters.pr-number}}`}}"
              QA_READY: "{{`{{inputs.parameters.qa-ready}}`}}"
              WORKFLOW_STAGE: "{{`{{inputs.parameters.stage}}`}}"
              WORKFLOW_NAME: "{{`{{workflow.name}}`}}"
              SERVICE_NAME: "{{`{{workflow.parameters.service}}`}}"
              RUN_NAME: "{{`{{workflow.name}}`}}"
              TASK_ID: "{{`{{inputs.parameters.task-id}}`}}"
              TASK_LANGUAGE: "{{`{{inputs.parameters.task-language}}`}}"
              TASK_FRAMEWORK: "{{`{{inputs.parameters.task-framework}}`}}"
              EXECUTION_MAX_RETRIES: "{{`{{inputs.parameters.max-retries}}`}}"
              FACTORY_MAX_RETRIES: "{{`{{inputs.parameters.max-retries}}`}}"
              CODEX_MAX_RETRIES: "{{`{{inputs.parameters.max-retries}}`}}"
              CURSOR_MAX_RETRIES: "{{`{{inputs.parameters.max-retries}}`}}"
              CLAUDE_MAX_RETRIES: "{{`{{inputs.parameters.max-retries}}`}}"
              OPENCODE_MAX_RETRIES: "{{`{{inputs.parameters.max-retries}}`}}"
              OPENCODE_VERBOSE: "{{`{{workflow.parameters.opencode-verbose}}`}}"
              AUTO_MERGE: "{{`{{inputs.parameters.auto-merge}}`}}"
              FINAL_TASK: "{{`{{inputs.parameters.final-task}}`}}"

    # Helper to reliably resolve the created CodeRun name before waiting for completion
    - name: resolve-coderun-name
      inputs:
        parameters:
          - name: stage
          - name: task-id
          - name: candidate-name
            default: ""
      outputs:
        parameters:
          - name: coderun-name
            valueFrom:
              path: /tmp/coderun-name.txt
      script:
        image: alpine/k8s:1.31.0
        command: [sh]
        source: |
          #!/bin/sh
          set -e
          CANDIDATE="{{`{{inputs.parameters.candidate-name}}`}}"
          if [ -n "$CANDIDATE" ] && [ "$CANDIDATE" != "null" ]; then
            echo "$CANDIDATE" > /tmp/coderun-name.txt
            exit 0
          fi
          # Fallback: resolve by labels (assumes a single CodeRun for this workflow/task/stage)
          ATTEMPTS=12
          while [ $ATTEMPTS -gt 0 ]; do
            NAME=$(kubectl get coderun.agents.platform -n {{ .Release.Namespace }} \
              -l workflow-name={{`{{workflow.name}}`}},workflow-stage={{`{{inputs.parameters.stage}}`}},task-id={{`{{inputs.parameters.task-id}}`}} \
              -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
            if [ -n "$NAME" ]; then
              echo "$NAME" > /tmp/coderun-name.txt
              exit 0
            fi
            sleep 5
            ATTEMPTS=$((ATTEMPTS-1))
          done
          echo "No CodeRun found for labels after waiting" >&2
          exit 1
      retryStrategy:
        limit: 50
        retryPolicy: "OnError"
        backoff:
          duration: "30s"
          factor: 2
          # No maxDuration - allow unlimited time for CodeRun creation

    # Template for waiting for CodeRun completion
    - name: wait-coderun-completion
      inputs:
        parameters:
          - name: coderun-name
      resource:
        action: get
        manifest: |
          apiVersion: agents.platform/v1
          kind: CodeRun
          metadata:
            name: "{{`{{inputs.parameters.coderun-name}}`}}"
            namespace: {{.Release.Namespace}}
        successCondition: status.phase == Succeeded
        failureCondition: status.phase == Failed
      retryStrategy:
        limit: 200
        retryPolicy: "OnError"
        backoff:
          duration: "60s"
          factor: 2
          # No maxDuration - allow unlimited time for CodeRun completion

    # Template for atomic workflow stage updates with optimistic locking
    - name: update-workflow-stage
      inputs:
        parameters:
          - name: new-stage
            description: "The new stage to transition to"
          - name: verify-update
            description: "Whether to verify the update succeeded"
            default: "true"
      outputs:
        parameters:
          - name: update-status
            valueFrom:
              path: /tmp/update-status.txt
            default: "unknown"
          - name: resource-version
            valueFrom:
              path: /tmp/resource-version.txt
            default: ""
      script:
        image: alpine/k8s:1.31.0
        command: [bash]
        source: |
          #!/bin/bash
          set -e

          echo "========================================="
          echo "Updating Workflow Stage"
          echo "========================================="
          echo "Workflow: {{`{{workflow.name}}`}}"
          echo "Current Task: {{`{{workflow.parameters.task-id}}`}}"
          echo "New Stage: {{`{{inputs.parameters.new-stage}}`}}"
          echo ""

          # Function to validate stage transition
          validate_stage_transition() {
            local current_stage=$1
            local new_stage=$2

            # Special case: Allow setting initial stage to "pending" when no stage label exists
            if [[ -z "$current_stage" ]] && [[ "$new_stage" == "pending" ]]; then
              echo "✅ Allowing initial stage setting: (none) → $new_stage"
              return 0
            fi

            # Define valid transitions (Rex → Cleo → Cipher → Tess flow)
            case $current_stage in
              "pending")
                # Primary path: pending → quality-in-progress
                [[ $new_stage == "quality-in-progress" ]] && return 0
                # Legacy paths for backward compatibility
                [[ $new_stage == "waiting-quality-complete" ]] && return 0
                [[ $new_stage == "waiting-pr-created" ]] && return 0
                ;;
              "waiting-pr-created")
                [[ $new_stage == "quality-in-progress" ]] && return 0
                [[ $new_stage == "waiting-quality-complete" ]] && return 0
                ;;
              "quality-in-progress")
                # New path: quality → security
                [[ $new_stage == "security-in-progress" ]] && return 0
                # Legacy paths for backward compatibility
                [[ $new_stage == "waiting-quality-complete" ]] && return 0
                ;;
              "security-in-progress")
                # Security → testing
                [[ $new_stage == "waiting-ready-for-qa" ]] && return 0
                ;;
              "waiting-quality-complete")
                [[ $new_stage == "waiting-ready-for-qa" ]] && return 0
                ;;
              "waiting-ready-for-qa")
                [[ $new_stage == "waiting-pr-merged" ]] && return 0
                ;;
              "waiting-pr-merged")
                [[ $new_stage == "completed" ]] && return 0
                ;;
            esac

            echo "❌ Invalid stage transition: $current_stage → $new_stage"
            return 1
          }

          # Get current state and resource version for optimistic locking
          echo "Fetching current workflow state..."
          WORKFLOW_JSON=$(kubectl get workflow "{{`{{workflow.name}}`}}" \
            -n {{ .Release.Namespace }} \
            -o json)

          # Check if current-stage label actually exists (not just defaulted)
          CURRENT_STAGE_RAW=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.labels["current-stage"]')
          if [ "$CURRENT_STAGE_RAW" = "null" ]; then
            CURRENT_STAGE=""
            echo "Current stage: (no label exists)"
          else
            CURRENT_STAGE="$CURRENT_STAGE_RAW"
            echo "Current stage: $CURRENT_STAGE"
          fi

          RESOURCE_VERSION=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.resourceVersion')
          echo "Resource version: $RESOURCE_VERSION"

          TARGET_STAGE="{{`{{inputs.parameters.new-stage}}`}}"

          # Persist the current resource version for downstream steps even if we early-exit
          echo "$RESOURCE_VERSION" > /tmp/resource-version.txt

          if [ "$CURRENT_STAGE" = "$TARGET_STAGE" ]; then
            echo "🔁 Stage is already set to $TARGET_STAGE; no update required"
            echo "success" > /tmp/update-status.txt
            exit 0
          fi

          # Validate stage transition
          if ! validate_stage_transition "$CURRENT_STAGE" "$TARGET_STAGE"; then
            echo "❌ Stage transition validation failed"
            echo "failed" > /tmp/update-status.txt
            exit 1
          fi

          # Prepare the JSON patch with optimistic locking
          REPOSITORY_LABEL=$(echo '{{`{{workflow.parameters.repository}}`}}' | tr '/' '-')
          PATCH_JSON='{
            "metadata": {
              "resourceVersion": "'$RESOURCE_VERSION'",
              "labels": {
                "current-stage": "{{`{{inputs.parameters.new-stage}}`}}",
                "task-id": "{{`{{workflow.parameters.task-id}}`}}",
                "repository": "'$REPOSITORY_LABEL'",
                "previous-stage": "'$CURRENT_STAGE'"
              }
            }
          }'

          echo ""
          echo "Prepared patch payload:"
          echo "$PATCH_JSON" | jq .

          # Apply the patch with exponential backoff retry
          MAX_RETRIES=5
          RETRY_COUNT=0
          UPDATE_SUCCESS=false
          BACKOFF_TIME=1

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo ""
            echo "Attempt $((RETRY_COUNT+1)) of $MAX_RETRIES..."

            if kubectl patch workflow "{{`{{workflow.name}}`}}" \
              --type='merge' \
              --patch="$PATCH_JSON" \
              -n {{ .Release.Namespace }}; then

              UPDATE_SUCCESS=true
              echo "✅ Stage update successful"
              break
            else
              echo "⚠️ Stage update failed with status: $?"
              echo "Retrying in $BACKOFF_TIME seconds..."
              sleep $BACKOFF_TIME

              # Update resource version before retry
              RESOURCE_VERSION=$(kubectl get workflow "{{`{{workflow.name}}`}}" \
                -n {{ .Release.Namespace }} \
                -o jsonpath='{.metadata.resourceVersion}')

              # Update patch with new resource version
              PATCH_JSON=$(echo "$PATCH_JSON" | jq --arg rv "$RESOURCE_VERSION" \
                '.metadata.resourceVersion = $rv')

              RETRY_COUNT=$((RETRY_COUNT+1))
              BACKOFF_TIME=$((BACKOFF_TIME*2))
            fi
          done

          # Save resource version for other templates
          echo "$RESOURCE_VERSION" > /tmp/resource-version.txt

          # Always verify the update
          echo ""
          echo "Verifying stage update..."

          VERIFY_MAX_RETRIES=3
          VERIFY_COUNT=0
          VERIFY_SUCCESS=false

          while [ $VERIFY_COUNT -lt $VERIFY_MAX_RETRIES ]; do
            WORKFLOW_JSON=$(kubectl get workflow "{{`{{workflow.name}}`}}" \
              -n {{ .Release.Namespace }} \
              -o json)

            CURRENT_STAGE=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.labels["current-stage"]')
            PREVIOUS_STAGE=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.labels["previous-stage"]')
            NEW_RESOURCE_VERSION=$(echo "$WORKFLOW_JSON" | jq -r '.metadata.resourceVersion')

            echo "Current Stage: $CURRENT_STAGE"
            echo "Previous Stage: $PREVIOUS_STAGE"
            echo "Resource Version: $NEW_RESOURCE_VERSION"

            if [ "$CURRENT_STAGE" = "{{`{{inputs.parameters.new-stage}}`}}" ]; then
              VERIFY_SUCCESS=true
              echo "✅ Verification successful: Stage transition complete"
              echo "success" > /tmp/update-status.txt
              break
            else
              echo "⚠️ Verification attempt $((VERIFY_COUNT+1)) failed, retrying..."
              VERIFY_COUNT=$((VERIFY_COUNT+1))
              sleep 2
            fi
          done

          if [ "$VERIFY_SUCCESS" != true ]; then
            echo "❌ Stage update verification failed after $VERIFY_MAX_RETRIES attempts"
            echo "failed" > /tmp/update-status.txt
            exit 1
          fi

          # Output monitoring metrics
          cat <<EOF > /tmp/stage-transition-metrics.json
          {
            "workflow": "{{`{{workflow.name}}`}}",
            "task_id": "{{`{{workflow.parameters.task-id}}`}}",
            "transition": {
              "from": "$PREVIOUS_STAGE",
              "to": "$CURRENT_STAGE",
              "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
              "duration_seconds": "$SECONDS",
              "retry_count": "$RETRY_COUNT",
              "verify_count": "$VERIFY_COUNT",
              "resource_version": "$NEW_RESOURCE_VERSION"
            }
          }
          EOF

          echo ""
          echo "Stage transition completed successfully"
          echo "Duration: $SECONDS seconds"
          echo "Retries required: $RETRY_COUNT"
          echo "Verification attempts: $VERIFY_COUNT"
      retryStrategy:
        limit: 20
        retryPolicy: "OnFailure"
        backoff:
          duration: "60s"
          factor: 2
          # No maxDuration - allow unlimited time for workflow stage updates

    # Template for suspend points waiting for external events via webhooks
    - name: suspend-for-event
      inputs:
        parameters:
          - name: event-type
          - name: stage-name
      metadata:
        labels:
          current-stage: "{{`{{inputs.parameters.stage-name}}`}}"
          task-id: "{{`{{workflow.parameters.task-id}}`}}"
          workflow-type: "play-orchestration"
      suspend: {}  # Indefinite suspend until external resume via webhooks

    # Template for task completion and cleanup
    - name: task-completion
      inputs:
        parameters:
          - name: task-id
          - name: approval-status
          - name: merge-sha
      script:
        image: alpine/k8s:1.31.0
        command: [sh]
        source: |
          #!/bin/sh
          set -e

          echo "========================================="
          echo "Completing Task {{`{{inputs.parameters.task-id}}`}}"
          echo "========================================="
          echo "Approval Status: {{`{{inputs.parameters.approval-status}}`}}"
          echo "Merge SHA: {{`{{inputs.parameters.merge-sha}}`}}"
          echo ""

          # Create completion marker
          echo "Task {{`{{inputs.parameters.task-id}}`}} completed at $(date)" > /tmp/task-complete.txt
          echo "Workflow: {{`{{workflow.name}}`}}" >> /tmp/task-complete.txt
          echo "Duration: {{`{{workflow.duration}}`}}" >> /tmp/task-complete.txt
          echo "PR Approved: {{`{{inputs.parameters.approval-status}}`}}" >> /tmp/task-complete.txt

          # Generate workflow summary
          cat <<EOF > /tmp/workflow-summary.md
          # Task {{`{{inputs.parameters.task-id}}`}} Completion Summary

          ## Workflow Details
          - **Workflow Name**: {{`{{workflow.name}}`}}
          - **Task ID**: {{`{{inputs.parameters.task-id}}`}}
          - **Repository**: {{`{{workflow.parameters.repository}}`}}
          - **Duration**: {{`{{workflow.duration}}`}}

          ## Agent Execution
          - **Implementation Agent**: {{`{{workflow.parameters.implementation-agent}}`}}
          - **Quality Agent**: {{`{{workflow.parameters.quality-agent}}`}}
          - **Testing Agent**: {{`{{workflow.parameters.testing-agent}}`}}

          ## Results
          - **PR Number**: {{`{{workflow.parameters.pr-number}}`}}
          - **Approval Status**: {{`{{inputs.parameters.approval-status}}`}}
          - **Merge SHA**: {{`{{inputs.parameters.merge-sha}}`}}

          ## Stages Completed
          1. ✅ Implementation Work
          2. ✅ Quality Assurance
          3. ✅ Testing & Validation
          4. ✅ PR Approval

          Task successfully completed and merged to main branch.
          EOF

          echo ""
          echo "Workflow summary generated successfully"
          echo "Task {{`{{inputs.parameters.task-id}}`}} workflow completed!"
          echo ""
          echo "Note: Next task will be started automatically by webhook system"

    # Template to determine which agent should handle a task based on its type
    - name: determine-task-agent
      inputs:
        parameters:
          - name: task-id
          - name: docs-repository
          - name: docs-project-directory
      outputs:
        parameters:
          - name: github-app
            valueFrom:
              path: /tmp/github-app.txt
          - name: cli-type
            valueFrom:
              path: /tmp/cli-type.txt
          - name: model
            valueFrom:
              path: /tmp/model.txt
          - name: model-rotation
            valueFrom:
              path: /tmp/model-rotation.txt
          - name: max-retries
            valueFrom:
              path: /tmp/max-retries.txt
          - name: task-language
            valueFrom:
              path: /tmp/task-language.txt
          - name: task-framework
            valueFrom:
              path: /tmp/task-framework.txt
      script:
        image: alpine:3.20
        env:
          - name: GITHUB_APP_ID
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: app-id
          - name: GITHUB_APP_PRIVATE_KEY
            valueFrom:
              secretKeyRef:
                name: github-app-5dlabs-morgan
                key: private-key
        command: [sh]
        source: |
          #!/bin/sh
          set -e
          
          TASK_ID="{{`{{inputs.parameters.task-id}}`}}"
          DOCS_REPO="{{`{{inputs.parameters.docs-repository}}`}}"
          DOCS_PROJECT_DIR="{{`{{inputs.parameters.docs-project-directory}}`}}"
          
          echo "🔍 Determining agent for task ${TASK_ID}"
          echo "   Docs repository: ${DOCS_REPO}"
          echo "   Project directory: ${DOCS_PROJECT_DIR}"
          
          # Install tools
          apk add --no-cache curl jq openssl git >/dev/null 2>&1 || true
          
          # Authenticate with GitHub App
          TEMP_KEY="/tmp/github-app-key.pem"
          printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY"
          chmod 600 "$TEMP_KEY"
          
          NOW=$(date +%s)
          EXP=$((NOW + 600))
          HDR=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 2>/dev/null || printf '{"alg":"RS256","typ":"JWT"}' | base64)
          HDR=$(echo -n "$HDR" | tr '+/' '-_' | tr -d '=')
          PAY=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 2>/dev/null || printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64)
          PAY=$(echo -n "$PAY" | tr '+/' '-_' | tr -d '=')
          SIG=$(printf '%s.%s' "$HDR" "$PAY" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 -w 0 2>/dev/null || openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64)
          SIG=$(echo -n "$SIG" | tr '+/' '-_' | tr -d '=')
          JWT="$HDR.$PAY.$SIG"
          
          OWNER=$(echo "$DOCS_REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$DOCS_REPO" | cut -d'/' -f2)
          
          # Get installation token
          INSTALLATION_ID=$(curl -s -L \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$OWNER/$REPO_NAME/installation" | jq -r '.id')
          
          if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" = "null" ]; then
            INSTALLATION_ID=$(curl -s -L \
              -H "Authorization: Bearer $JWT" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/orgs/$OWNER/installation" | jq -r '.id')
          fi
          
          TOKEN=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')
          
          rm -f "$TEMP_KEY"
          
          # Clone docs repository to read task file
          CLONE_DIR="/tmp/docs-repo"
          rm -rf "$CLONE_DIR"
          
          echo "📥 Cloning docs repository..."
          git clone --depth 1 "https://x-access-token:${TOKEN}@github.com/${DOCS_REPO}.git" "$CLONE_DIR" 2>&1 || {
            echo "❌ Failed to clone repository"
            # Fallback to implementation agent
            echo "{{`{{workflow.parameters.implementation-agent}}`}}" > /tmp/github-app.txt
            echo "{{`{{workflow.parameters.implementation-cli}}`}}" > /tmp/cli-type.txt
            echo "{{`{{workflow.parameters.implementation-model}}`}}" > /tmp/model.txt
            echo "{{`{{workflow.parameters.implementation-model-rotation}}`}}" > /tmp/model-rotation.txt
            echo "{{`{{workflow.parameters.implementation-max-retries}}`}}" > /tmp/max-retries.txt
            echo "rust" > /tmp/task-language.txt
            echo "" > /tmp/task-framework.txt
            exit 0
          }
          
          # Find and read task file
          TASK_FILE="${CLONE_DIR}/${DOCS_PROJECT_DIR}/.taskmaster/tasks/task-${TASK_ID}.md"
          
          if [ ! -f "$TASK_FILE" ]; then
            echo "⚠️ Task file not found: ${TASK_FILE}"
            echo "   Using default implementation agent"
            echo "{{`{{workflow.parameters.implementation-agent}}`}}" > /tmp/github-app.txt
            echo "{{`{{workflow.parameters.implementation-cli}}`}}" > /tmp/cli-type.txt
            echo "{{`{{workflow.parameters.implementation-model}}`}}" > /tmp/model.txt
            echo "{{`{{workflow.parameters.implementation-model-rotation}}`}}" > /tmp/model-rotation.txt
            echo "{{`{{workflow.parameters.implementation-max-retries}}`}}" > /tmp/max-retries.txt
            echo "rust" > /tmp/task-language.txt
            echo "" > /tmp/task-framework.txt
            exit 0
          fi
          
          echo "📄 Reading task file: ${TASK_FILE}"
          
          # Extract agentType from task file (look for "**Agent Type**: frontend" pattern)
          AGENT_TYPE=$(grep -i "^\*\*Agent Type\*\*:" "$TASK_FILE" | sed 's/.*: *//; s/ *$//' || echo "")
          
          if [ -z "$AGENT_TYPE" ]; then
            # Try alternative format: "Agent Type: frontend"
            AGENT_TYPE=$(grep -i "^Agent Type:" "$TASK_FILE" | sed 's/.*: *//; s/ *$//' || echo "")
          fi
          
          # Convert to lowercase for comparison
          AGENT_TYPE=$(echo "$AGENT_TYPE" | tr '[:upper:]' '[:lower:]')
          
          # Extract language from task file (look for "**Language**: typescript" pattern)
          LANGUAGE=$(grep -i "^\*\*Language\*\*:" "$TASK_FILE" | sed 's/.*: *//; s/ *$//' || echo "")
          
          if [ -z "$LANGUAGE" ]; then
            # Try alternative format: "Language: typescript"
            LANGUAGE=$(grep -i "^Language:" "$TASK_FILE" | sed 's/.*: *//; s/ *$//' || echo "")
          fi
          
          # Convert to lowercase for comparison
          LANGUAGE=$(echo "$LANGUAGE" | tr '[:upper:]' '[:lower:]')
          
          # Extract framework from task file (look for "**Framework**: react, nextjs" pattern)
          FRAMEWORK=$(grep -i "^\*\*Framework\*\*:" "$TASK_FILE" | sed 's/.*: *//; s/ *$//' || echo "")
          
          if [ -z "$FRAMEWORK" ]; then
            # Try alternative format: "Framework: react"
            FRAMEWORK=$(grep -i "^Framework:" "$TASK_FILE" | sed 's/.*: *//; s/ *$//' || echo "")
          fi
          
          # Convert to lowercase for comparison
          FRAMEWORK=$(echo "$FRAMEWORK" | tr '[:upper:]' '[:lower:]')
          
          # Default language/framework if not specified
          if [ -z "$LANGUAGE" ]; then
            if [ "$AGENT_TYPE" = "frontend" ] || [ "$AGENT_TYPE" = "ui" ]; then
              LANGUAGE="typescript"
            else
              LANGUAGE="rust"
            fi
          fi
          
          echo "   Detected agent type: '${AGENT_TYPE}'"
          echo "   Detected language: '${LANGUAGE}'"
          echo "   Detected framework: '${FRAMEWORK}'"
          
          # Determine which agent to use based on agent type
          case "$AGENT_TYPE" in
            "frontend"|"ui"|"react"|"nextjs")
              echo "✅ Routing to FRONTEND agent (Blaze)"
              echo "{{`{{workflow.parameters.frontend-agent}}`}}" > /tmp/github-app.txt
              echo "{{`{{workflow.parameters.frontend-cli}}`}}" > /tmp/cli-type.txt
              echo "{{`{{workflow.parameters.frontend-model}}`}}" > /tmp/model.txt
              echo "{{`{{workflow.parameters.frontend-model-rotation}}`}}" > /tmp/model-rotation.txt
              echo "{{`{{workflow.parameters.frontend-max-retries}}`}}" > /tmp/max-retries.txt
              ;;
            *)
              echo "✅ Routing to IMPLEMENTATION agent (Rex)"
              echo "{{`{{workflow.parameters.implementation-agent}}`}}" > /tmp/github-app.txt
              echo "{{`{{workflow.parameters.implementation-cli}}`}}" > /tmp/cli-type.txt
              echo "{{`{{workflow.parameters.implementation-model}}`}}" > /tmp/model.txt
              echo "{{`{{workflow.parameters.implementation-model-rotation}}`}}" > /tmp/model-rotation.txt
              echo "{{`{{workflow.parameters.implementation-max-retries}}`}}" > /tmp/max-retries.txt
              ;;
          esac
          
          # Write language and framework to output files
          echo "$LANGUAGE" > /tmp/task-language.txt
          echo "$FRAMEWORK" > /tmp/task-framework.txt
          
          echo "   GitHub App: $(cat /tmp/github-app.txt)"
          echo "   CLI Type: $(cat /tmp/cli-type.txt)"
          echo "   Model: $(cat /tmp/model.txt)"
          echo "   Language: ${LANGUAGE}"
          echo "   Framework: ${FRAMEWORK}"
          echo ""
          echo "🎯 Agent determination complete"

    # Cleanup handler for workflow completion/failure
    - name: cleanup-handler
      script:
        image: alpine:3.20
        command: [sh]
        source: |
          #!/bin/sh
          echo "========================================="
          echo "Workflow Cleanup Handler"
          echo "========================================="
          echo "Workflow Name: {{`{{workflow.name}}`}}"
          echo "Status: {{`{{workflow.status}}`}}"
          echo "Task ID: {{`{{workflow.parameters.task-id}}`}}"

          # Log final workflow state
          if [ "{{`{{workflow.status}}`}}" = "Succeeded" ]; then
            echo "✅ Workflow completed successfully"
          else
            echo "❌ Workflow failed or was terminated"
          fi

          echo "Cleanup completed"

  # TTL strategy for workflow cleanup
  ttlStrategy:
    secondsAfterCompletion: 86400    # Keep completed workflows for 24 hours
    secondsAfterFailure: 259200      # Keep failed workflows for 3 days
    secondsAfterSuccess: 86400       # Keep successful workflows for 24 hours

  # Pod garbage collection
  podGC:
    strategy: OnPodCompletion
    deleteDelayDuration: 60s
{{- end }}
