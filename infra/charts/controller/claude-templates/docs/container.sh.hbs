#!/bin/sh

echo 'Starting documentation generation...'

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication (SSH not required)"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    # Function to generate fresh GitHub App token
generate_github_token() {
    echo "Generating fresh GitHub App token..."
    
    # Create temporary private key file from environment variable
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    echo "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"
    
    echo "Using private key from environment variable"
    
    # Generate JWT token for GitHub App (same approach as code script)
    # JWT header
    JWT_HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(echo -n "{\"iat\":$NOW,\"exp\":$EXP,\"iss\":\"$GITHUB_APP_ID\"}" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # Sign the JWT
    JWT_SIGNATURE=$(echo -n "$JWT_HEADER.$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
    if [ -z "$JWT_TOKEN" ]; then
        echo "❌ Failed to generate JWT token"
        exit 1
    fi
    
    # Get installation ID for the repository
    REPO_OWNER=$(echo "{{repository_url}}" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
    REPO_NAME=$(echo "{{repository_url}}" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    
    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
    # Get the installation access token
    INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")
    
    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')
    
    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "❌ Failed to get installation ID for repository"
        echo "Response: $INSTALLATION_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "Installation ID: $INSTALLATION_ID"
    
    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "❌ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"
    
    # Export the token for git to use
    export GITHUB_TOKEN
    
    # Configure git to use the token
    git config --global credential.helper store
    git config --global --add credential.helper '!f() { echo "username=x-access-token"; echo "password=$GITHUB_TOKEN"; }; f'
    
    # gh CLI will automatically use GITHUB_TOKEN environment variable
    echo "🔐 GitHub CLI will use GITHUB_TOKEN environment variable for authentication"
    
    echo "✓ GitHub App authenticated successfully"
}

    # Call the function to authenticate
    generate_github_token
    
    # Early authentication test - verify we can access the repository before starting heavy work
    echo "🔍 Testing GitHub authentication early..."
    if gh api user > /dev/null 2>&1; then
        echo "✅ GitHub API access confirmed"
    else
        echo "❌ GitHub API access failed - stopping early to avoid wasted compute"
        exit 1
    fi
    
    # Test repository access specifically  
    REPO_OWNER=$(echo "$REPO_URL" | sed 's|https://github.com/||' | sed 's|/.*||')
    REPO_NAME=$(echo "$REPO_URL" | sed 's|.*/||')
    if gh api "repos/$REPO_OWNER/$REPO_NAME" > /dev/null 2>&1; then
        echo "✅ Repository access confirmed for $REPO_OWNER/$REPO_NAME"
    else
        echo "❌ Repository access failed for $REPO_OWNER/$REPO_NAME - stopping early"
        exit 1
    fi
    
else
    echo "❌ GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
    exit 1
fi


# Git configuration with proper GitHub App attribution
git config --global --add safe.directory /workspace

# Set GitHub App attribution based on the app name
GITHUB_APP="{{github_app}}"
case "$GITHUB_APP" in
    "morgan-5dlabs")
        GIT_AUTHOR_NAME="Morgan Agent (Claude Code)"
        GIT_AUTHOR_EMAIL="224488090+morgan-5dlabs[bot]@users.noreply.github.com"
        ;;
    "5DLabs-Blaze")
        GIT_AUTHOR_NAME="Blaze Agent (Claude Code)"
        GIT_AUTHOR_EMAIL="224516107+5DLabs-Blaze[bot]@users.noreply.github.com"
        ;;
    "5DLabs-Rex")
        GIT_AUTHOR_NAME="Rex Agent (Claude Code)"
        GIT_AUTHOR_EMAIL="224516160+5DLabs-Rex[bot]@users.noreply.github.com"
        ;;
    *)
        # Fallback for unknown apps
        GIT_AUTHOR_NAME="AI Agent (Claude Code)"
        GIT_AUTHOR_EMAIL="$GITHUB_APP@users.noreply.github.com"
        ;;
esac

# Configure git with proper GitHub App attribution
git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

# Set environment variables for Claude Code to use
export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"

echo "✓ Git configured"

# Repository setup
REPO_BRANCH="{{source_branch}}"
echo "Repository: $REPO_URL"
echo "Branch: $REPO_BRANCH"

if [ -d "/workspace/.git" ]; then
  echo "Repository exists, updating..."
  cd /workspace
  git remote set-url origin "$REPO_URL"
  git fetch origin
  git checkout "$REPO_BRANCH"
  git pull origin "$REPO_BRANCH"
else
  echo "Setting up repository..."
  # Clone to temp directory first, then move contents
  TEMP_CLONE_DIR="/tmp/repo-clone"
  rm -rf "$TEMP_CLONE_DIR"

  if ! git clone --depth 1 --branch "$REPO_BRANCH" "$REPO_URL" "$TEMP_CLONE_DIR"; then
    echo "❌ Failed to clone repository"
    exit 1
  fi

  # Move repository contents to workspace
  mv "$TEMP_CLONE_DIR"/* /workspace/ 2>/dev/null || true
  mv "$TEMP_CLONE_DIR"/.[^.]* /workspace/ 2>/dev/null || true
  rm -rf "$TEMP_CLONE_DIR"
  cd /workspace
fi

echo "✓ Repository ready"

# Working directory setup
WORKING_DIR="{{working_directory}}"
if [ -n "$WORKING_DIR" ] && [ "$WORKING_DIR" != "." ]; then
  CLAUDE_WORK_DIR="/workspace/$WORKING_DIR"
  cd "$CLAUDE_WORK_DIR" || exit 1
  echo "✓ Working directory: $CLAUDE_WORK_DIR"
else
  CLAUDE_WORK_DIR="/workspace"
  echo "✓ Working directory: $CLAUDE_WORK_DIR"
fi

# Copy ConfigMap files
echo "Setting up ConfigMap files..."
if [ -d "/task-files" ]; then
  # Copy markdown files
  for md_file in /task-files/*.md; do
    if [ -f "$md_file" ]; then
      basename_file=$(basename "$md_file")
      if [ "$basename_file" = "claude.md" ]; then
        cp -f "$md_file" "$CLAUDE_WORK_DIR/CLAUDE.md"
      else
        cp -f "$md_file" "$CLAUDE_WORK_DIR/"
      fi
      echo "✓ Copied $basename_file"
    fi
  done

  # Verify enterprise settings
  if [ -f "/etc/claude-code/managed-settings.json" ]; then
    echo "✓ Enterprise settings verified"
    if ! jq empty /etc/claude-code/managed-settings.json 2>/dev/null; then
      echo "❌ Invalid enterprise settings JSON"
      exit 1
    fi
  else
    echo "❌ Enterprise settings not found"
    exit 1
  fi

  # Copy hook scripts
  for hook_file in /task-files/hooks-*.sh; do
    if [ -f "$hook_file" ]; then
      hook_name=$(basename "$hook_file" | sed 's/^hooks-//')
      cp "$hook_file" "$CLAUDE_WORK_DIR/$hook_name"
      chmod +x "$CLAUDE_WORK_DIR/$hook_name"
      echo "✓ Copied hook: $hook_name"
    fi
  done

else
  echo "❌ ConfigMap not mounted at /task-files"
  exit 1
fi

# Validate workspace
echo "Validating workspace..."
REQUIRED_FILES="CLAUDE.md"
for file in $REQUIRED_FILES; do
  if [ ! -f "$CLAUDE_WORK_DIR/$file" ]; then
    echo "❌ Missing required file: $file"
    exit 1
  fi
done

# Check for .taskmaster directory
if [ ! -d "$CLAUDE_WORK_DIR/.taskmaster" ]; then
  echo "❌ .taskmaster directory not found"
  exit 1
fi

# Individual task files are used instead of tasks.json
if [ ! -d "$CLAUDE_WORK_DIR/.taskmaster/docs" ]; then
  echo "❌ .taskmaster/docs directory not found"
  exit 1
fi

# Generate individual task files from tasks.json if it exists
echo "Setting up individual task files..."
if [ -f "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" ]; then
  echo "📋 Found tasks.json, generating individual task files..."
  
  # Use jq to extract tasks and create individual files (handle null values safely)
  jq -r '.tasks[]? | select(.id != null) | "\(.id // "")|\(.title // "No Title")|\(.description // "")|\(.details // "")|\(.testStrategy // "")"' \
    "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" | while IFS='|' read -r task_id title description details test_strategy; do
    
    if [ -n "$task_id" ] && [ "$task_id" != "null" ]; then
      task_dir="$CLAUDE_WORK_DIR/.taskmaster/docs/task-$task_id"
      mkdir -p "$task_dir"
      
      # Create task.txt with formatted content
      cat > "$task_dir/task.txt" << EOF
# Task $task_id: $title

## Description
$description

## Implementation Details
$details

## Test Strategy
$test_strategy
EOF
      
      echo "✓ Generated docs/task-$task_id/task.txt"
    fi
  done
else
  echo "⚠️ No tasks.json found - task files will not be generated"
fi

echo "✓ Workspace validated"

# Environment setup
export SERVICE_NAME="{{service_name}}"
export SOURCE_BRANCH="{{source_branch}}"
export WORKING_DIR="{{working_directory}}"
export GITHUB_USER="{{github_app}}"
export GITHUB_APP="{{github_app}}"

# Claude execution
echo "Starting Claude execution..."
CLAUDE_CMD="claude -p --output-format stream-json --verbose"

# Model is set via settings.json template, not CLI flag

# Safe mode toggle for debugging (prevents token consumption)
SAFE_MODE="false"  # Set to "false" for full docs generation

if [ "$SAFE_MODE" = "true" ]; then
    echo "🛡️ SAFE MODE ENABLED - Running simple test instead of full docs generation"
    echo "What time is it? Please answer this simple question and exit immediately." | $CLAUDE_CMD
    CLAUDE_EXIT_CODE=$?
    echo "Safe mode test completed with exit code: $CLAUDE_EXIT_CODE"
    
    # Exit successfully to prevent PR creation in safe mode
    echo "✅ Safe mode test complete, exiting without changes"
    exit 0
else
    if [ -f "prompt.md" ]; then
        $CLAUDE_CMD "$(cat prompt.md)"
        CLAUDE_EXIT_CODE=$?
        echo "Claude completed with exit code: $CLAUDE_EXIT_CODE"
    else
        echo "❌ No prompt.md found"
        exit 1
    fi
fi

# PR creation
echo "Creating pull request..."

# Check for documentation changes
if git diff --quiet HEAD -- .taskmaster/ 2>/dev/null && git diff --cached --quiet HEAD -- .taskmaster/ 2>/dev/null; then
    UNTRACKED_DOCS=$(git ls-files --others --exclude-standard .taskmaster/ 2>/dev/null | wc -l)
    if [ "$UNTRACKED_DOCS" -eq 0 ]; then
        echo "No documentation changes found"
        exit 0
    fi
fi

# Create PR branch
SOURCE_BRANCH=$(git rev-parse --abbrev-ref HEAD)
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
RANDOM_ID=$(date +%s | tail -c 6)
PR_BRANCH="docs/{{#if task_id}}task-{{task_id}}{{else}}auto-gen{{/if}}-${TIMESTAMP}-${RANDOM_ID}"

echo "Creating branch: $PR_BRANCH"
git checkout -b "$PR_BRANCH"

echo "Staging all .taskmaster changes..."
git add .taskmaster/

echo "Showing what will be committed:"
git status --porcelain

echo "Committing changes..."
git commit -m "docs: auto-generate Task Master documentation{{#if task_id}} for task {{task_id}}{{/if}}"

echo "Pushing branch..."
git push -u origin "$PR_BRANCH"

# Create PR
if command -v gh >/dev/null 2>&1; then
    # GitHub CLI should already be authenticated from the beginning of the script
    
    PR_TITLE="docs: auto-generate Task Master documentation{{#if task_id}} for task {{task_id}}{{/if}}"
    PR_BODY="Auto-generated Task Master documentation by orchestrator container script.

**Working Directory:** {{working_dir}}
**Branch:** \`$PR_BRANCH\` → \`$SOURCE_BRANCH\`
**Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
{{#if task_id}}**Target Task:** {{task_id}}{{/if}}

🤖 Auto-generated by Container Script"

    # Refresh GitHub token before PR creation (tokens expire after ~1 hour)
    echo "🔄 Refreshing GitHub App token before PR creation..."
    generate_github_token

    # Retry PR creation up to 3 times for transient failures
    PR_CREATED=false
    for attempt in 1 2 3; do
        echo "Creating PR (attempt $attempt/3)..."
        if gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base "$SOURCE_BRANCH" --head "$PR_BRANCH"; then
            echo "✓ Pull request created successfully"
            PR_CREATED=true
            break
        else
            echo "❌ PR creation attempt $attempt failed"
            if [ $attempt -lt 3 ]; then
                echo "⏳ Waiting 5 seconds before retry..."
                sleep 5
            fi
        fi
    done
    
    if [ "$PR_CREATED" = false ]; then
        echo "❌ Failed to create pull request after 3 attempts"
        echo "⚠️ Branch has been pushed, but PR creation failed"
        echo "💡 You can manually create a PR at: https://github.com/{{repository_url}}/pull/new/$PR_BRANCH"
        exit 1
    fi
else
    echo "⚠️ GitHub CLI not available - create PR manually"
fi

echo "Documentation generation completed successfully!"