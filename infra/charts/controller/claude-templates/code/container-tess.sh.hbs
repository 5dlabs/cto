#!/bin/sh

# Source Rust environment if available (fixes cargo not found issues)
if [ -f "$HOME/.cargo/env" ]; then
    . "$HOME/.cargo/env"
fi

echo '════════════════════════════════════════════════════════════════'
echo '║              TESS TESTING WORKFLOW STARTING                  ║'
echo '║         Quality Assurance & Deployment Testing Agent         ║'
echo '════════════════════════════════════════════════════════════════'
echo "🎯 Agent: {{github_app}}"
echo "🧪 Focus: Comprehensive testing, deployment validation, test coverage"
echo "📋 Task ID: {{task_id}}"
echo "✅ Mission: 120% satisfaction through exhaustive testing"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication for testing workflow"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."
    
    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"
    
    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"
    
    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "⚠️ Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "❌ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "Installation ID: $INSTALLATION_ID"
    
    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "❌ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "✅ Successfully authenticated with GitHub App"
    
    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"
    
    # Export the token for git to use
    export GITHUB_TOKEN
    
    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    
    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token
    
else
    echo "❌ GitHub App credentials not found"
    exit 1
fi

# Set working directory for the agent
# Set Working Directory (Critical for Claude Execution) - Match Rex pattern  
WORK_DIR="{{working_directory}}"
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
  CLAUDE_WORK_DIR="/workspace/$REPO_NAME"
else
  CLAUDE_WORK_DIR="/workspace/$REPO_NAME/$WORK_DIR"
fi
mkdir -p "$CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"

# Prepare environment for testing
echo "════════════════════════════════════════════════════════════════"
echo "🧪 PREPARING TESTING ENVIRONMENT"
echo "════════════════════════════════════════════════════════════════"

# Git configuration with proper GitHub App attribution
git config --global --add safe.directory /workspace

# Set GitHub App attribution - use generic format for all agents
GITHUB_APP="{{github_app}}"
# Generic attribution that works for any agent
GIT_AUTHOR_NAME="${GITHUB_APP} Agent (Claude Code)"
GIT_AUTHOR_EMAIL="${GITHUB_APP}[bot]@users.noreply.github.com"

# Configure git with proper GitHub App attribution
git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

# Set environment variables for Claude Code to use
export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
echo "✓ Git configured"

# Clone or update repository (directly to Claude working directory)
if [ -d "$CLAUDE_WORK_DIR/.git" ]; then
    echo "📁 Found existing repository at working directory, updating..."
    cd "$CLAUDE_WORK_DIR"
    git fetch origin --prune
else
    # Ensure parent directories exist
    mkdir -p "$(dirname "$CLAUDE_WORK_DIR")"
    
    # If directory exists but isn't a git repo, remove it first
    if [ -d "$CLAUDE_WORK_DIR" ] && [ ! -d "$CLAUDE_WORK_DIR/.git" ]; then
        echo "🧹 Removing non-git directory to prepare for clone..."
        # Change to parent directory before removing current directory
        cd "$(dirname "$CLAUDE_WORK_DIR")"
        rm -rf "$CLAUDE_WORK_DIR"
    fi
    
    echo "📥 Cloning repository to working directory..."
    REPO_HTTP_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO_OWNER}/${REPO_NAME}.git"
    if ! git clone "$REPO_HTTP_URL" "$CLAUDE_WORK_DIR"; then
        echo "❌ Failed to clone repository"
        echo "Debug: CLAUDE_WORK_DIR=$CLAUDE_WORK_DIR"
        echo "Debug: Parent directory exists: $(ls -la "$(dirname "$CLAUDE_WORK_DIR")" 2>/dev/null || echo 'No')"
        exit 1
    fi
    cd "$CLAUDE_WORK_DIR"
fi

# Checkout PR branch for testing review
if [ -n "$PR_NUMBER" ] && [ -n "$PR_URL" ]; then
    echo "🔄 Checking out PR #$PR_NUMBER for QA testing..."
    cd "$CLAUDE_WORK_DIR"
    git fetch origin --prune
    PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName' 2>/dev/null || echo "")
    if [ -n "$PR_BRANCH" ]; then
        git checkout "$PR_BRANCH" || git checkout -b "$PR_BRANCH" "origin/$PR_BRANCH"
        git pull origin "$PR_BRANCH" || echo "⚠️  Could not pull latest changes"
        echo "✓ Checked out PR branch: $PR_BRANCH"
    else
        echo "⚠️ Could not determine PR branch name, staying on default branch"
    fi
    
    # Add PR context to CLAUDE.md for reference
    echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "# PR Context for Testing" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "- **PR Number**: $PR_NUMBER" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "- **PR URL**: $PR_URL" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "- **Branch**: $PR_BRANCH" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
else
    echo "ℹ️ No PR context provided - working on default branch"
fi

echo "════════════════════════════════════════════════════════════════"
echo "🔧 TESTING INFRASTRUCTURE SETUP"
echo "════════════════════════════════════════════════════════════════"

# Setup Kubernetes admin access if available
if [ -f "/etc/kube/config" ]; then
    export KUBECONFIG=/etc/kube/config
    echo "✅ Kubernetes admin access configured"
    kubectl version --client 2>/dev/null || echo "⚠️ kubectl not available"
fi

# Setup database admin credentials if available
if [ -n "$POSTGRES_ADMIN_PASSWORD" ]; then
    export PGPASSWORD="$POSTGRES_ADMIN_PASSWORD"
    echo "✅ PostgreSQL admin credentials configured"
fi

if [ -n "$REDIS_ADMIN_PASSWORD" ]; then
    export REDIS_PASSWORD="$REDIS_ADMIN_PASSWORD"
    echo "✅ Redis admin credentials configured"
fi

# Setup Argo CD admin access if available
if [ -n "$ARGOCD_ADMIN_TOKEN" ]; then
    export ARGOCD_AUTH_TOKEN="$ARGOCD_ADMIN_TOKEN"
    echo "✅ Argo CD admin access configured"
fi

echo "════════════════════════════════════════════════════════════════"
echo "📋 TESTING WORKFLOW REQUIREMENTS"
echo "════════════════════════════════════════════════════════════════"
echo ""
echo "PHASE 1: Code Review"
echo "- Comprehensive review against acceptance criteria"
echo "- Verify implementation meets all requirements"
echo "- Add PR comments for any issues found"
echo ""
echo "PHASE 2: Live Deployment Testing"
echo "- Deploy application in Kubernetes environment"
echo "- Perform regression testing"
echo "- Validate endpoints, data consistency, pod health"
echo "- Integration testing across services"
echo ""
echo "PHASE 3: Test Coverage Enhancement"
echo "- Analyze current test coverage"
echo "- Identify missing unit and integration tests"
echo "- Implement tests to achieve near 100% coverage"
echo "- Ensure all new tests pass in CI/CD"
echo ""
echo "CRITICAL: Must be 120% satisfied before approval!"
echo "════════════════════════════════════════════════════════════════"

# Copy task files if docs repository is specified
{{#if docs_repository_url}}
echo "📋 Copying task files from documentation repository..."
DOCS_REPO_URL="{{docs_repository_url}}"
DOCS_BRANCH="{{#if docs_branch}}{{docs_branch}}{{else}}main{{/if}}"
DOCS_HTTP_URL=$(echo "$DOCS_REPO_URL" | sed "s|https://github.com/|https://x-access-token:${GITHUB_TOKEN}@github.com/|")

if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
    echo "❌ Failed to clone docs repository"
    exit 1
fi
cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd "$CLAUDE_WORK_DIR"

# Copy task files
mkdir -p "$CLAUDE_WORK_DIR/task"
{{#if docs_project_directory}}
if [ "{{docs_project_directory}}" = "." ]; then
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
else
    DOCS_PATH="/tmp/docs-repo/{{docs_project_directory}}/.taskmaster"
fi
{{else}}
DOCS_PATH="/tmp/docs-repo/.taskmaster"
{{/if}}

TASK_DIR="$DOCS_PATH/docs/task-{{task_id}}"
if [ -d "$TASK_DIR" ]; then
    cp "$TASK_DIR/task.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/acceptance-criteria.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/prompt.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/toolman-guide.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    echo "✓ Task {{task_id}} files copied"
fi

# Copy architecture.md
if [ -f "$DOCS_PATH/docs/architecture.md" ]; then
    cp "$DOCS_PATH/docs/architecture.md" "$CLAUDE_WORK_DIR/task/"
fi

# Clean up docs repo
rm -rf /tmp/docs-repo
{{/if}}

# Repository is now cloned directly to Claude working directory - no copy needed
echo "✓ Repository cloned directly to working directory"

# Check if we should continue previous session
{{#if continue_session}}
echo "📂 Continuing from previous session..."
# Preserve existing CLAUDE.md if it exists
if [ -f "/workspace/CLAUDE.md" ]; then
    echo "✓ Found existing CLAUDE.md, preserving session memory"
fi
{{else}}
{{#if overwrite_memory}}
echo "🔄 Overwriting session memory as requested..."
rm -f /workspace/CLAUDE.md
{{/if}}
{{/if}}

# Generate configuration files from templates
echo "🔧 Generating Tess-specific configuration files..."

# Enterprise managed settings are mounted directly from ConfigMap  
echo "=== ENTERPRISE MANAGED SETTINGS ==="
echo "✓ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
echo "✓ No copying needed - mount automatically reflects latest ConfigMap changes"

# Copy MCP client configuration from task files  
if [ -f "/task-files/client-config.json" ]; then
  cp /task-files/client-config.json "$CLAUDE_WORK_DIR/client-config.json"
  echo "✓ client-config.json copied from ConfigMap"
  export MCP_CLIENT_CONFIG="$CLAUDE_WORK_DIR/client-config.json"
  echo "✓ MCP_CLIENT_CONFIG set to: $MCP_CLIENT_CONFIG"
else
  echo "⚠️ client-config.json not found in task-files - MCP client may not work correctly"
fi

# Create initial CLAUDE.md if needed
if [ ! -f "/workspace/CLAUDE.md" ] || [ "{{overwrite_memory}}" = "true" ]; then
    cat > /workspace/CLAUDE.md << 'EOF'
# TESS - Quality Assurance & Testing Agent

## Agent Role
- **Primary**: Comprehensive testing and deployment validation
- **Secondary**: Test coverage enhancement
- **Critical**: Only approve PR when 120% satisfied

## Testing Workflow Phases

### Phase 1: Code Review
- Review implementation against acceptance criteria
- Verify all requirements are met
- Add PR comments for any issues found
- Trigger Rex restart if changes needed

### Phase 2: Live Deployment Testing
Prerequisites:
- Helm charts available
- Container image builds successfully
- Infrastructure components ready

Testing Areas:
- Deploy application in Kubernetes
- Endpoint response validation
- Data consistency checks
- Pod health and resource utilization
- Integration testing across services
- Performance and load testing

### Phase 3: Test Coverage Enhancement
After confirming functionality:
- Analyze current test coverage
- Identify missing unit tests
- Identify missing integration tests
- Implement tests for:
  - All new functions/methods
  - API endpoints
  - Edge cases and error conditions
  - Database interactions
- Push test additions to feature branch
- Ensure all tests pass in CI/CD

## Admin Access Capabilities
- Kubernetes cluster admin
- PostgreSQL admin access
- Redis admin access
- Argo CD admin access
- GitHub Actions access

## Success Criteria
- Must be 120% satisfied before approval
- Near 100% test coverage achieved
- All acceptance criteria verified
- Live environment testing successful
- No critical issues remaining

## Important Notes
- Only start work when PR has "ready-for-qa" label
- Do NOT merge PR - only approve
- Human (CTO) performs final merge

EOF

    # Copy base CLAUDE.md from ConfigMap if it exists (match Rex pattern)
    if [ -f "/task-files/CLAUDE.md" ]; then
        cat /task-files/CLAUDE.md >> "/workspace/CLAUDE.md"
        echo "✓ Appended base CLAUDE.md content from ConfigMap"
    fi
    
    # Copy to working directory for consistency with Rex pattern
    cp "/workspace/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
    echo "✓ Created Tess-specific CLAUDE.md memory"
fi

# Copy guidelines files to working directory (match Rex pattern)
if [ -f "/task-files/coding-guidelines.md" ]; then
  cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "✓ Copied coding-guidelines.md to working directory"
fi

if [ -f "/task-files/github-guidelines.md" ]; then
  cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "✓ Copied github-guidelines.md to working directory"  
fi

# Copy MCP configuration from ConfigMap to project root (project scope)
if [ -f "/task-files/mcp.json" ]; then
  cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
  echo "✓ Copied mcp.json to .mcp.json (project scope)"
else
  echo "⚠️ mcp.json template not found"
fi

# Setup hook scripts
echo "🔧 Setting up Tess-specific hook scripts..."
mkdir -p "$CLAUDE_WORK_DIR/hooks"

{{#each hook_scripts}}
cat > "$CLAUDE_WORK_DIR/hooks/{{@key}}" << 'EOF'
{{{this}}}
EOF
chmod +x "$CLAUDE_WORK_DIR/hooks/{{@key}}"
{{/each}}

# Export environment for Claude
export CLAUDE_WORK_DIR
export GITHUB_TOKEN
export REPO_OWNER
export REPO_NAME
# TARGET_REPO_DIR no longer needed - repository cloned directly to CLAUDE_WORK_DIR

echo "════════════════════════════════════════════════════════════════"
echo "✅ TESS TESTING AGENT READY"
echo "════════════════════════════════════════════════════════════════"
echo "📁 Working Directory: $CLAUDE_WORK_DIR"
echo "📦 Repository: $REPO_OWNER/$REPO_NAME"
echo "📋 Task: {{task_id}}"
echo "🧪 Focus: Comprehensive testing & deployment validation"
echo "⚠️  CRITICAL: Must be 120% satisfied before approval"
echo "════════════════════════════════════════════════════════════════"

# Start Claude with Tess-specific configuration
cd "$CLAUDE_WORK_DIR"

# Build Claude command
CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Look for agent-specific system prompt file from agents ConfigMap
if [ -f "/config/agents/{{github_app}}_system-prompt.md" ]; then
    echo "✓ Found system prompt file for {{github_app}}, adding to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /config/agents/{{github_app}}_system-prompt.md"
else
    echo "ℹ️ No system prompt file found for agent {{github_app}}, using defaults"
fi

# Add continue flag if this is a retry attempt or user requested continuation
{{#if continue_session}}
CLAUDE_CMD="$CLAUDE_CMD --continue"
echo 'Adding --continue flag (attempt {{attempts}}{{#if user_requested}} - user requested{{/if}})'
{{/if}}

echo "════════════════════════════════════════════════════════════════"
echo "║                    STARTING CLAUDE EXECUTION                  ║"
echo "════════════════════════════════════════════════════════════════"
echo "Command: $CLAUDE_CMD"
echo "Note: Claude will automatically read CLAUDE.md from the working directory"

# Tess uses her own system prompt and focuses on acceptance criteria
echo "✓ Starting Tess with specialized QA system prompt"
echo "✓ Tess will focus on acceptance criteria and comprehensive testing"

if [ -f "$CLAUDE_WORK_DIR/task/acceptance-criteria.md" ]; then
    echo "✓ Found acceptance-criteria.md - this is Tess's primary focus"
else
    echo "⚠️ No acceptance-criteria.md found - Tess may need to work with available task files"
fi

# Prepare initial guidance for Tess
INITIAL_GUIDANCE="🧪 **TESS QA TESTING WORKFLOW**

You are now starting QA testing for this task. Your focus areas are:

1. **Acceptance Criteria Review**: 
   - Check task/acceptance-criteria.md (if available)
   - Verify all requirements are implemented correctly

2. **Code Quality Assessment**:
   - Review the PR changes thoroughly 
   - Ensure code follows best practices

3. **Testing & Validation**:
   - Run existing tests and ensure they pass
   - Add missing test coverage where needed
   - Test the application functionality

4. **Live Deployment Testing** (if applicable):
   - Deploy to test environment
   - Validate endpoints and functionality
   - Check integration points

Remember: You must be 120% satisfied before approving this PR. Only add approval when everything meets the highest quality standards."

# Start Claude with initial guidance
echo "════════════════════════════════════════════════════════════════"
echo "║                    STARTING TESS QA EXECUTION                 ║"
echo "════════════════════════════════════════════════════════════════"

# Seed initial user turn via a FIFO
FIFO_PATH="/workspace/agent-input.jsonl"
rm -f "$FIFO_PATH" 2>/dev/null || true
mkfifo "$FIFO_PATH"
chmod 666 "$FIFO_PATH" || true

# Start Claude (reader) first in background
$CLAUDE_CMD < "$FIFO_PATH" &
CLAUDE_PID=$!

# Compose initial user turn
USER_COMBINED=$(printf "%s" "$INITIAL_GUIDANCE" | jq -Rs .)

# Send via sidecar HTTP endpoint
if printf '{"text":%s}\n' "$USER_COMBINED" | \
     curl -fsS -X POST http://127.0.0.1:8080/input \
       -H 'Content-Type: application/json' \
       --data-binary @- >/dev/null 2>&1; then
  echo "✓ Initial QA guidance sent via sidecar /input"
else
  echo "⚠️ Sidecar /input failed, falling back to direct FIFO write"
  exec 9>"$FIFO_PATH"
  printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}\n' "$USER_COMBINED" >&9
fi

# Wait for Claude process to complete
wait "$CLAUDE_PID"
# Close FIFO writer if it was opened
exec 9>&- 2>/dev/null || true

# Gracefully stop sidecar
if curl -fsS -X POST http://127.0.0.1:8080/shutdown >/dev/null 2>&1; then
  echo "✓ Requested sidecar shutdown"
else
  echo "⚠️ Failed to request sidecar shutdown (it may not be running)"
fi