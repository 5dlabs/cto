#!/bin/sh

# Source Rust environment if available (fixes cargo not found issues)
if [ -f "$HOME/.cargo/env" ]; then
    . "$HOME/.cargo/env"
fi

echo '════════════════════════════════════════════════════════════════'
echo '║              TESS TESTING WORKFLOW STARTING                  ║'
echo '║         Quality Assurance & Deployment Testing Agent         ║'
echo '════════════════════════════════════════════════════════════════'
echo "🎯 Agent: {{github_app}}"
echo "🧪 Focus: Comprehensive testing, deployment validation, test coverage"
echo "📋 Task ID: {{task_id}}"
echo "✅ Mission: 120% satisfaction through exhaustive testing"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication for testing workflow"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."
    
    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"
    
    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"
    
    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "⚠️ Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "❌ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "Installation ID: $INSTALLATION_ID"
    
    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "❌ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "✅ Successfully authenticated with GitHub App"
    
    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"
    
    # Export the token for git to use
    export GITHUB_TOKEN
    
    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    
    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token
    
else
    echo "❌ GitHub App credentials not found"
    exit 1
fi

# Set working directory for the agent
# Set Working Directory (Critical for Claude Execution) - Match Rex pattern  
WORK_DIR="{{working_directory}}"
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
  CLAUDE_WORK_DIR="/workspace/$REPO_NAME"
else
  CLAUDE_WORK_DIR="/workspace/$REPO_NAME/$WORK_DIR"
fi
mkdir -p "$CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"

# Prepare environment for testing
echo "════════════════════════════════════════════════════════════════"
echo "🧪 PREPARING TESTING ENVIRONMENT"
echo "════════════════════════════════════════════════════════════════"

# Git configuration with proper GitHub App attribution
git config --global --add safe.directory /workspace

# Set GitHub App attribution - use generic format for all agents
GITHUB_APP="{{github_app}}"
# Generic attribution that works for any agent
GIT_AUTHOR_NAME="${GITHUB_APP} Agent (Claude Code)"
GIT_AUTHOR_EMAIL="${GITHUB_APP}[bot]@users.noreply.github.com"

# Configure git with proper GitHub App attribution
git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

# Set environment variables for Claude Code to use
export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
echo "✓ Git configured"

# =============================================================================
# AUTHENTICATION VERIFICATION
# =============================================================================
echo ""
echo "═══════════════════════════════════════════════════════════════"
echo "🔐 AUTHENTICATION VERIFICATION"
echo "═══════════════════════════════════════════════════════════════"
echo ""

# Repository URLs - Handle both full URLs and org/repo format
# Check if repository_url already contains https://github.com/
if echo "{{repository_url}}" | grep -q "^https://github.com/"; then
    REPO_HTTP_URL="{{repository_url}}"
    if ! echo "{{repository_url}}" | grep -q "\.git$"; then
        REPO_HTTP_URL="${REPO_HTTP_URL}.git"
    fi
else
    REPO_HTTP_URL="https://github.com/{{repository_url}}.git"
fi

# Same for docs repository
if echo "{{docs_repository_url}}" | grep -q "^https://github.com/"; then
    DOCS_HTTP_URL="{{docs_repository_url}}"
    if ! echo "{{docs_repository_url}}" | grep -q "\.git$"; then
        DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
    fi
else
    DOCS_HTTP_URL="https://github.com/{{docs_repository_url}}.git"
fi

# DEBUG: Show what URLs are being constructed
echo "🔍 DEBUG: URL Construction & Parameters"
echo "  Input repository_url: '{{repository_url}}'"
echo "  Input docs_repository_url: '{{docs_repository_url}}'"
echo "  Input docs_project_directory: '{{docs_project_directory}}'"
echo "  Input working_directory: '{{working_directory}}'"
echo "  Input docs_branch: '{{docs_branch}}'"
echo "  Input github_app: '{{github_app}}'"
echo "  Input task_id: '{{task_id}}'"
echo "  Input service: '{{service}}'"
echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
echo "  Current working directory: $(pwd)"
echo "  Available environment variables:"
env | grep -E "(GITHUB|ANTHROPIC)" | sort

# Test HTTPS access to repository
echo "🔍 DEBUG: Testing HTTPS repository access..."
echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
  echo "✓ HTTPS repository access successful"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Output: $(cat /tmp/repo_test.out | head -1)"
else
  echo "❌ HTTPS repository access failed"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Error output: $(cat /tmp/repo_test.out)"
  echo "  Git credential helper status:"
  git config --list | grep credential || echo "  No credential helpers configured"
  echo ""
  echo "🚫 ABORTING: Cannot access repository via HTTPS"
  exit 1
fi

# Test docs repository access
echo "🔍 DEBUG: Testing docs repository access..."
echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
  echo "✓ Docs repository access successful"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Output: $(cat /tmp/docs_test.out | head -1)"
else
  echo "❌ Docs repository access failed"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Error output: $(cat /tmp/docs_test.out)"
  echo ""
  echo "🚫 ABORTING: Cannot access docs repository via HTTPS"
  exit 1
fi

# Clone or update repository (directly to Claude working directory)
if [ -d "$CLAUDE_WORK_DIR/.git" ]; then
    echo "📁 Found existing repository at working directory, updating..."
    cd "$CLAUDE_WORK_DIR"
    git fetch origin --prune
else
    # Ensure parent directories exist
    mkdir -p "$(dirname "$CLAUDE_WORK_DIR")"
    
    # If directory exists but isn't a git repo, remove it first
    if [ -d "$CLAUDE_WORK_DIR" ] && [ ! -d "$CLAUDE_WORK_DIR/.git" ]; then
        echo "🧹 Removing non-git directory to prepare for clone..."
        rm -rf "$CLAUDE_WORK_DIR"
    fi
    
    echo "📥 Cloning repository to working directory..."
    # Make sure parent directory exists and we're in a valid location
    PARENT_DIR="$(dirname "$CLAUDE_WORK_DIR")"
    mkdir -p "$PARENT_DIR"
    cd "$PARENT_DIR"
    
    # Use the REPO_HTTP_URL constructed in authentication verification section
    if ! git clone "$REPO_HTTP_URL" "$(basename "$CLAUDE_WORK_DIR")"; then
        echo "❌ Failed to clone repository"
        echo "Debug: CLAUDE_WORK_DIR=$CLAUDE_WORK_DIR"
        echo "Debug: Parent directory exists: $(ls -la "$PARENT_DIR" 2>/dev/null || echo 'No')"
        exit 1
    fi
    cd "$(basename "$CLAUDE_WORK_DIR")"
fi

# Checkout PR branch for testing review
if [ -n "$PR_NUMBER" ] && [ -n "$PR_URL" ]; then
    echo "🔄 Checking out PR #$PR_NUMBER for QA testing..."
    cd "$CLAUDE_WORK_DIR"
    git fetch origin --prune
    PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName' 2>/dev/null || echo "")
    if [ -n "$PR_BRANCH" ]; then
        git checkout "$PR_BRANCH" || git checkout -b "$PR_BRANCH" "origin/$PR_BRANCH"
        git pull origin "$PR_BRANCH" || echo "⚠️  Could not pull latest changes"
        echo "✓ Checked out PR branch: $PR_BRANCH"
    else
        echo "⚠️ Could not determine PR branch name, staying on default branch"
    fi
    
    # Add PR context to CLAUDE.md for reference
    echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "# PR Context for Testing" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "- **PR Number**: $PR_NUMBER" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "- **PR URL**: $PR_URL" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "- **Branch**: $PR_BRANCH" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
else
    echo "ℹ️ No PR context provided - working on default branch"
fi

echo "════════════════════════════════════════════════════════════════"
echo "🔧 TESTING INFRASTRUCTURE SETUP"
echo "════════════════════════════════════════════════════════════════"

# Setup Kubernetes admin access if available
if [ -f "/etc/kube/config" ]; then
    export KUBECONFIG=/etc/kube/config
    echo "✅ Kubernetes admin access configured"
    kubectl version --client 2>/dev/null || echo "⚠️ kubectl not available"
fi

# Setup database admin credentials if available
if [ -n "$POSTGRES_ADMIN_PASSWORD" ]; then
    export PGPASSWORD="$POSTGRES_ADMIN_PASSWORD"
    echo "✅ PostgreSQL admin credentials configured"
fi

if [ -n "$REDIS_ADMIN_PASSWORD" ]; then
    export REDIS_PASSWORD="$REDIS_ADMIN_PASSWORD"
    echo "✅ Redis admin credentials configured"
fi

# Setup Argo CD admin access if available
if [ -n "$ARGOCD_ADMIN_TOKEN" ]; then
    export ARGOCD_AUTH_TOKEN="$ARGOCD_ADMIN_TOKEN"
    echo "✅ Argo CD admin access configured"
fi

echo "════════════════════════════════════════════════════════════════"
echo "📋 TESTING WORKFLOW REQUIREMENTS"
echo "════════════════════════════════════════════════════════════════"
echo ""
echo "PHASE 0: CI/CD Setup (IMMEDIATE PRIORITY)"
echo "- Set up GitHub Actions CI pipeline if not exists"
echo "- Add test running and coverage reporting to CI"
echo "- Configure branch protection rules with test gates"
echo "- Ensure tests must pass before merge"
echo "- Do this AS SOON as there's enough code to test"
echo ""
echo "PHASE 1: Acceptance Criteria Validation"
echo "- Review implementation against acceptance criteria (NOT architecture)"
echo "- Verify ALL acceptance criteria are fully met"
echo "- Focus on task/acceptance-criteria.md requirements"
echo "- Add PR comments for any missing acceptance criteria"
echo ""
echo "PHASE 2: Test Writing (PRIMARY RESPONSIBILITY)"
echo "- Write comprehensive unit tests for all code"
echo "- Write integration tests for all features"
echo "- AIM FOR 100% TEST COVERAGE - this is critical!"
echo "- Ensure all tests pass before approval"
echo "- Push test files to the PR branch"
echo "- ONLY write test files (*_test.*, *.test.*, etc.)"
echo "- NEVER modify implementation/business logic code"
echo ""
echo "PHASE 3: Manual Testing & Validation"
echo "- Run the test suite and verify coverage"
echo "- Test application functionality manually"
echo "- Verify no regressions introduced"
echo "- Document findings in PR comments"
echo ""
echo "CRITICAL: Set up CI gates early & achieve 100% coverage!"
echo "════════════════════════════════════════════════════════════════"

# Copy task files if docs repository is specified
{{#if docs_repository_url}}
echo "📋 Copying task files from documentation repository..."
DOCS_REPO_URL="{{docs_repository_url}}"
DOCS_BRANCH="{{#if docs_branch}}{{docs_branch}}{{else}}main{{/if}}"
DOCS_HTTP_URL=$(echo "$DOCS_REPO_URL" | sed "s|https://github.com/|https://x-access-token:${GITHUB_TOKEN}@github.com/|")

if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
    echo "❌ Failed to clone docs repository"
    exit 1
fi
cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd "$CLAUDE_WORK_DIR"

# Copy task files
mkdir -p "$CLAUDE_WORK_DIR/task"
{{#if docs_project_directory}}
if [ "{{docs_project_directory}}" = "." ]; then
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
else
    DOCS_PATH="/tmp/docs-repo/{{docs_project_directory}}/.taskmaster"
fi
{{else}}
DOCS_PATH="/tmp/docs-repo/.taskmaster"
{{/if}}

TASK_DIR="$DOCS_PATH/docs/task-{{task_id}}"
if [ -d "$TASK_DIR" ]; then
    cp "$TASK_DIR/task.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/acceptance-criteria.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/prompt.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/toolman-guide.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    echo "✓ Task {{task_id}} files copied"
fi

# Copy architecture.md
if [ -f "$DOCS_PATH/docs/architecture.md" ]; then
    cp "$DOCS_PATH/docs/architecture.md" "$CLAUDE_WORK_DIR/task/"
fi

# Clean up docs repo
rm -rf /tmp/docs-repo
{{/if}}

# Repository is now cloned directly to Claude working directory - no copy needed
echo "✓ Repository cloned directly to working directory"

# Check if we should continue previous session
{{#if continue_session}}
echo "📂 Continuing from previous session..."
# Preserve existing CLAUDE.md if it exists
if [ -f "/workspace/CLAUDE.md" ]; then
    echo "✓ Found existing CLAUDE.md, preserving session memory"
fi
{{else}}
{{#if overwrite_memory}}
echo "🔄 Overwriting session memory as requested..."
rm -f /workspace/CLAUDE.md
{{/if}}
{{/if}}

# Generate configuration files from templates
echo "🔧 Generating Tess-specific configuration files..."

# Enterprise managed settings are mounted directly from ConfigMap  
echo "=== ENTERPRISE MANAGED SETTINGS ==="
echo "✓ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
echo "✓ No copying needed - mount automatically reflects latest ConfigMap changes"

# Copy MCP client configuration from task files  
if [ -f "/task-files/client-config.json" ]; then
  cp /task-files/client-config.json "$CLAUDE_WORK_DIR/client-config.json"
  echo "✓ client-config.json copied from ConfigMap"
  export MCP_CLIENT_CONFIG="$CLAUDE_WORK_DIR/client-config.json"
  echo "✓ MCP_CLIENT_CONFIG set to: $MCP_CLIENT_CONFIG"
else
  echo "⚠️ client-config.json not found in task-files - MCP client may not work correctly"
fi

# Create initial CLAUDE.md if needed
if [ ! -f "/workspace/CLAUDE.md" ] || [ "{{overwrite_memory}}" = "true" ]; then
    cat > /workspace/CLAUDE.md << 'EOF'
# TESS - Test Writing & Quality Assurance Agent

## Agent Role
- **Primary**: Write comprehensive tests to achieve 100% code coverage
- **Secondary**: Set up CI/CD testing gates and validate acceptance criteria
- **Critical**: Establish testing infrastructure early in development

## Testing Workflow Phases

### Phase 0: CI/CD Setup (DO THIS FIRST!)
- AS SOON as there's enough code to test, set up CI/CD:
  - Create `.github/workflows/test.yml` for GitHub Actions
  - Configure test running with coverage reporting
  - Set up coverage badges and reports
  - Add status checks that must pass before merge
  - Include linting, formatting, and type checking
- Example GitHub Actions workflow for each language:
  - Python: pytest + coverage + black + mypy
  - JavaScript: jest + eslint + prettier
  - Go: go test + golangci-lint + coverage
  - Rust: cargo test + clippy + fmt + tarpaulin

### Phase 1: Acceptance Criteria Verification
- Review implementation against task/acceptance-criteria.md (NOT architecture.md)
- Verify ALL acceptance criteria requirements are fully met
- Focus ONLY on what's defined in the acceptance criteria
- Post PR comments for any missing acceptance criteria items

### Phase 2: Test Writing (YOUR MAIN JOB!)
- Write comprehensive unit tests for ALL code
- Write integration tests for ALL features
- **TARGET: 100% TEST COVERAGE** - this is non-negotiable!
- Use appropriate testing frameworks for the language:
  - Python: pytest with coverage
  - JavaScript/TypeScript: jest with coverage
  - Go: go test with coverage
  - Rust: cargo test with tarpaulin
- Commit and push test files to the PR branch
- Run coverage reports and include results in PR comments

### Phase 3: Test Execution & Validation
- Run the complete test suite with coverage reporting
- Verify coverage meets or exceeds 95% (target 100%)
- Ensure all tests pass successfully
- Test application functionality manually if needed
- Document coverage percentages in PR comments

## CRITICAL RULES
- **CAN** write and push test files (*_test.*, *.test.*, spec.*, etc.)
- **CAN** create and modify CI/CD workflows (.github/workflows/*)
- **CAN** modify test configuration files (jest.config.js, pytest.ini, etc.)
- **CANNOT** modify implementation/business logic code
- **CANNOT** modify non-test files (except test configs and CI/CD)
- **MUST** set up CI gates as early as possible
- **MUST** achieve highest possible test coverage (target 100%)
- **MUST** validate against acceptance criteria ONLY (not architecture)

## Admin Access Capabilities
- Kubernetes cluster admin
- PostgreSQL admin access
- Redis admin access
- Argo CD admin access
- GitHub Actions access

## Success Criteria
- Must be 120% satisfied before approval
- Near 100% test coverage achieved
- All acceptance criteria verified
- Live environment testing successful
- No critical issues remaining

## Important Notes
- Only start work when PR has "ready-for-qa" label
- Do NOT merge PR - only approve
- Human (CTO) performs final merge

EOF

    # Copy base CLAUDE.md from ConfigMap if it exists (match Rex pattern)
    if [ -f "/task-files/CLAUDE.md" ]; then
        cat /task-files/CLAUDE.md >> "/workspace/CLAUDE.md"
        echo "✓ Appended base CLAUDE.md content from ConfigMap"
    fi
    
    # Copy to working directory for consistency with Rex pattern
    cp "/workspace/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
    echo "✓ Created Tess-specific CLAUDE.md memory"
fi

# Copy guidelines files to working directory (match Rex pattern)
if [ -f "/task-files/coding-guidelines.md" ]; then
  cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "✓ Copied coding-guidelines.md to working directory"
fi

if [ -f "/task-files/github-guidelines.md" ]; then
  cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "✓ Copied github-guidelines.md to working directory"  
fi

# Copy MCP configuration from ConfigMap to project root (project scope)
if [ -f "/task-files/mcp.json" ]; then
  cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
  echo "✓ Copied mcp.json to .mcp.json (project scope)"
else
  echo "⚠️ mcp.json template not found"
fi

# Setup hook scripts
echo "🔧 Setting up Tess-specific hook scripts..."
mkdir -p "$CLAUDE_WORK_DIR/hooks"

{{#each hook_scripts}}
cat > "$CLAUDE_WORK_DIR/hooks/{{@key}}" << 'EOF'
{{{this}}}
EOF
chmod +x "$CLAUDE_WORK_DIR/hooks/{{@key}}"
{{/each}}

# Export environment for Claude
export CLAUDE_WORK_DIR
export GITHUB_TOKEN
export REPO_OWNER
export REPO_NAME
# TARGET_REPO_DIR no longer needed - repository cloned directly to CLAUDE_WORK_DIR

echo "════════════════════════════════════════════════════════════════"
echo "✅ TESS TESTING AGENT READY"
echo "════════════════════════════════════════════════════════════════"
echo "📁 Working Directory: $CLAUDE_WORK_DIR"
echo "📦 Repository: $REPO_OWNER/$REPO_NAME"
echo "📋 Task: {{task_id}}"
echo "🧪 Focus: Comprehensive testing & deployment validation"
echo "⚠️  CRITICAL: Must be 120% satisfied before approval"
echo "════════════════════════════════════════════════════════════════"

# Start Claude with Tess-specific configuration
cd "$CLAUDE_WORK_DIR"

# Build Claude command
CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Look for agent-specific system prompt file from agents ConfigMap
if [ -f "/config/agents/{{github_app}}_system-prompt.md" ]; then
    echo "✓ Found system prompt file for {{github_app}}, adding to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /config/agents/{{github_app}}_system-prompt.md"
else
    echo "ℹ️ No system prompt file found for agent {{github_app}}, using defaults"
fi

# Add continue flag if this is a retry attempt or user requested continuation
{{#if continue_session}}
CLAUDE_CMD="$CLAUDE_CMD --continue"
echo 'Adding --continue flag (attempt {{attempts}}{{#if user_requested}} - user requested{{/if}})'
{{/if}}

echo "════════════════════════════════════════════════════════════════"
echo "║                    STARTING CLAUDE EXECUTION                  ║"
echo "════════════════════════════════════════════════════════════════"
echo "Command: $CLAUDE_CMD"
echo "Note: Claude will automatically read CLAUDE.md from the working directory"

# Tess uses her own system prompt and focuses on acceptance criteria
echo "✓ Starting Tess with specialized QA system prompt"
echo "✓ Tess will focus on acceptance criteria and comprehensive testing"

if [ -f "$CLAUDE_WORK_DIR/task/acceptance-criteria.md" ]; then
    echo "✓ Found acceptance-criteria.md - this is Tess's primary focus"
else
    echo "⚠️ No acceptance-criteria.md found - Tess may need to work with available task files"
fi

# Prepare initial guidance for Tess
INITIAL_GUIDANCE="🧪 **TESS QA TESTING WORKFLOW**

You are now starting QA testing for this task. Your role is VALIDATION ONLY - you do NOT make code changes.

**CRITICAL INSTRUCTIONS**:
- DO NOT modify any code files
- DO NOT push any changes to the repository
- DO NOT create new files or edit existing ones
- ONLY post comments to the PR with your findings

Your focus areas are:

1. **Acceptance Criteria Verification**: 
   - Check task/acceptance-criteria.md
   - Verify ALL requirements are fully implemented
   - Document any missing or incomplete items

2. **Manual Testing**:
   - Build and run the application locally
   - Test all functionality by hand
   - Verify the application works as expected
   - For APIs: test endpoints with curl/httpie
   - For CLIs: test commands and verify outputs

3. **Regression Testing**:
   - Run existing test suite
   - Verify no existing functionality is broken
   - Check that all tests pass

4. **PR Feedback**:
   - Post detailed comments on the PR about:
     - Any acceptance criteria not met
     - Any bugs or issues found
     - Any regressions discovered
     - Suggestions for improvements (for Rex to implement)
   - If critical issues found, request Rex to fix them
   - Only approve PR when 120% satisfied

**HOW TO POST PR REVIEW COMMENTS**:
Use GitHub CLI to create a REVIEW with comments (not just regular comments):
\`\`\`bash
# Start a review
gh pr review {{pr_number}} --comment --body \"Starting test review...\"

# Add review comments for specific issues
gh pr review {{pr_number}} --comment --body \"🔴 Missing test coverage for error handling in main.rs:45-60\"

# Submit final review (REQUEST_CHANGES if issues found, APPROVE if all good)
gh pr review {{pr_number}} --request-changes --body \"### Test Review Summary
❌ Coverage: 78% (target: 100%)
🔴 Missing tests for error scenarios
🔴 No integration tests found

Please add the missing tests.\"

# OR if everything passes:
gh pr review {{pr_number}} --approve --body \"### Test Review Summary
✅ Coverage: 100%
✅ All tests passing
✅ CI/CD configured
✅ Acceptance criteria met\"
\`\`\`

Use REVIEW comments (not regular comments) so they can be tracked and marked as resolved.
Submit REQUEST_CHANGES if any issues found, APPROVE only when 100% satisfied.

Remember: Your job is to TEST and provide FEEDBACK via PR review comments. Rex handles implementation changes."

# Start Claude with initial guidance
echo "════════════════════════════════════════════════════════════════"
echo "║                    STARTING TESS QA EXECUTION                 ║"
echo "════════════════════════════════════════════════════════════════"

# Seed initial user turn via a FIFO
FIFO_PATH="/workspace/agent-input.jsonl"
rm -f "$FIFO_PATH" 2>/dev/null || true
mkfifo "$FIFO_PATH"
chmod 666 "$FIFO_PATH" || true

# Start Claude (reader) first in background
$CLAUDE_CMD < "$FIFO_PATH" &
CLAUDE_PID=$!

# Compose initial user turn
USER_COMBINED=$(printf "%s" "$INITIAL_GUIDANCE" | jq -Rs .)

# Send via sidecar HTTP endpoint
if printf '{"text":%s}\n' "$USER_COMBINED" | \
     curl -fsS -X POST http://127.0.0.1:8080/input \
       -H 'Content-Type: application/json' \
       --data-binary @- >/dev/null 2>&1; then
  echo "✓ Initial QA guidance sent via sidecar /input"
else
  echo "⚠️ Sidecar /input failed, falling back to direct FIFO write"
  # Fallback: open FIFO writer, send prompt, and close immediately to send EOF
  exec 9>"$FIFO_PATH"
  printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}\n' "$USER_COMBINED" >&9
  exec 9>&-  # Close immediately to send EOF to Claude
fi

# Wait for Claude process to complete
wait "$CLAUDE_PID"
CLAUDE_EXIT_CODE=$?

# Close FIFO writer if it was opened
exec 9>&- 2>/dev/null || true

if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
  echo "✅ Tess QA testing completed successfully"
else
  echo "⚠️ Tess QA testing exited with code: $CLAUDE_EXIT_CODE"
fi

# Gracefully stop sidecar (with enhanced debugging and retries)
echo "🔧 Attempting sidecar shutdown..."
shutdown_attempts=0
max_shutdown_attempts=3

while [ $shutdown_attempts -lt $max_shutdown_attempts ]; do
  if curl -fsS -X POST http://127.0.0.1:8080/shutdown -m 5 2>/dev/null; then
    echo "✓ Sidecar shutdown request successful (attempt $((shutdown_attempts + 1)))"
    break
  else
    shutdown_attempts=$((shutdown_attempts + 1))
    echo "⚠️ Sidecar shutdown request failed (attempt $shutdown_attempts/$max_shutdown_attempts)"
    if [ $shutdown_attempts -lt $max_shutdown_attempts ]; then
      echo "Retrying in 2 seconds..."
      sleep 2
    fi
  fi
done

if [ $shutdown_attempts -eq $max_shutdown_attempts ]; then
  echo "❌ Failed to shutdown sidecar after $max_shutdown_attempts attempts"
  echo "🔧 Force terminating sidecar processes..."
  pkill -f "sidecar" || echo "No sidecar processes found to kill"
fi

# Wait for sidecar to actually terminate
echo "⏳ Waiting for sidecar termination..."
timeout=10
while [ $timeout -gt 0 ]; do
  if ! pgrep -f "sidecar" > /dev/null 2>&1; then
    echo "✅ Sidecar terminated successfully"
    break
  fi
  sleep 1
  timeout=$((timeout - 1))
done

if [ $timeout -eq 0 ]; then
  echo "⚠️ Sidecar still running after wait period"
fi

# Perform cleanup
echo "🔧 Performing cleanup..."

echo "════════════════════════════════════════════════════════════════"
echo "║                  TESS QA WORKFLOW COMPLETE                   ║"
echo "════════════════════════════════════════════════════════════════"
echo "📋 Task: {{task_id}}"
echo "🧪 Testing completed - check PR for feedback"
echo "════════════════════════════════════════════════════════════════"

# Final termination sequence
echo "════════════════════════════════════════════════════════════════"
echo "🔚 TERMINATING TESS CONTAINER"
echo "════════════════════════════════════════════════════════════════"
echo "Claude Exit Code: $CLAUDE_EXIT_CODE"
echo "Container PID: $$"
echo "Final Process Check:"
ps aux | head -5

# Write completion marker for workflow tracking
echo "tess-qa-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.tess-complete

# Cleanup FIFO
rm -f "$FIFO_PATH" 2>/dev/null || true

# Force exit to ensure container termination
echo "🔚 Force terminating container..."
exit $CLAUDE_EXIT_CODE