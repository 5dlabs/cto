#!/bin/sh

# Source Rust environment if available (fixes cargo not found issues)
if [ -f "$HOME/.cargo/env" ]; then
    . "$HOME/.cargo/env"
fi

echo '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'
echo '‚ïë              TESS TESTING WORKFLOW STARTING                  ‚ïë'
echo '‚ïë         Quality Assurance & Deployment Testing Agent         ‚ïë'
echo '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'
echo "üéØ Agent: {{github_app}}"
echo "üß™ Focus: Comprehensive testing, deployment validation, test coverage"
echo "üìã Task ID: {{task_id}}"
echo "‚úÖ Mission: 120% satisfaction through exhaustive testing"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication for testing workflow"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."
    
    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"
    
    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"
    
    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "‚ö†Ô∏è Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "‚ùå Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "Installation ID: $INSTALLATION_ID"
    
    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "‚ùå Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "‚úÖ Successfully authenticated with GitHub App"
    
    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"
    
    # Export the token for git to use
    export GITHUB_TOKEN
    
    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    
    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token
    
else
    echo "‚ùå GitHub App credentials not found"
    exit 1
fi

# Set working directory for the agent
# Set Working Directory (Critical for Claude Execution) - Match Rex pattern  
WORK_DIR="{{working_directory}}"
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
  CLAUDE_WORK_DIR="/workspace/$REPO_NAME"
else
  CLAUDE_WORK_DIR="/workspace/$REPO_NAME/$WORK_DIR"
fi
mkdir -p "$CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"

# Prepare environment for testing
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "üß™ PREPARING TESTING ENVIRONMENT"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

# Git configuration with proper GitHub App attribution
git config --global --add safe.directory /workspace

# Set GitHub App attribution - use generic format for all agents
GITHUB_APP="{{github_app}}"
# Generic attribution that works for any agent
GIT_AUTHOR_NAME="${GITHUB_APP} Agent (Claude Code)"
GIT_AUTHOR_EMAIL="${GITHUB_APP}[bot]@users.noreply.github.com"

# Configure git with proper GitHub App attribution
git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

# Set environment variables for Claude Code to use
export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
echo "‚úì Git configured"

# Clone or update repository (directly to Claude working directory)
if [ -d "$CLAUDE_WORK_DIR/.git" ]; then
    echo "üìÅ Found existing repository at working directory, updating..."
    cd "$CLAUDE_WORK_DIR"
    git fetch origin --prune
else
    # Ensure parent directories exist
    mkdir -p "$(dirname "$CLAUDE_WORK_DIR")"
    
    # If directory exists but isn't a git repo, remove it first
    if [ -d "$CLAUDE_WORK_DIR" ] && [ ! -d "$CLAUDE_WORK_DIR/.git" ]; then
        echo "üßπ Removing non-git directory to prepare for clone..."
        # Change to parent directory before removing current directory
        cd "$(dirname "$CLAUDE_WORK_DIR")"
        rm -rf "$CLAUDE_WORK_DIR"
    fi
    
    echo "üì• Cloning repository to working directory..."
    REPO_HTTP_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO_OWNER}/${REPO_NAME}.git"
    if ! git clone "$REPO_HTTP_URL" "$CLAUDE_WORK_DIR"; then
        echo "‚ùå Failed to clone repository"
        echo "Debug: CLAUDE_WORK_DIR=$CLAUDE_WORK_DIR"
        echo "Debug: Parent directory exists: $(ls -la "$(dirname "$CLAUDE_WORK_DIR")" 2>/dev/null || echo 'No')"
        exit 1
    fi
    cd "$CLAUDE_WORK_DIR"
fi

# Checkout PR branch for testing review
if [ -n "$PR_NUMBER" ] && [ -n "$PR_URL" ]; then
    echo "üîÑ Checking out PR #$PR_NUMBER for QA testing..."
    cd "$CLAUDE_WORK_DIR"
    git fetch origin --prune
    PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName' 2>/dev/null || echo "")
    if [ -n "$PR_BRANCH" ]; then
        git checkout "$PR_BRANCH" || git checkout -b "$PR_BRANCH" "origin/$PR_BRANCH"
        git pull origin "$PR_BRANCH" || echo "‚ö†Ô∏è  Could not pull latest changes"
        echo "‚úì Checked out PR branch: $PR_BRANCH"
    else
        echo "‚ö†Ô∏è Could not determine PR branch name, staying on default branch"
    fi
    
    # Add PR context to CLAUDE.md for reference
    echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "# PR Context for Testing" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "- **PR Number**: $PR_NUMBER" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "- **PR URL**: $PR_URL" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "- **Branch**: $PR_BRANCH" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
else
    echo "‚ÑπÔ∏è No PR context provided - working on default branch"
fi

echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "üîß TESTING INFRASTRUCTURE SETUP"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

# Setup Kubernetes admin access if available
if [ -f "/etc/kube/config" ]; then
    export KUBECONFIG=/etc/kube/config
    echo "‚úÖ Kubernetes admin access configured"
    kubectl version --client 2>/dev/null || echo "‚ö†Ô∏è kubectl not available"
fi

# Setup database admin credentials if available
if [ -n "$POSTGRES_ADMIN_PASSWORD" ]; then
    export PGPASSWORD="$POSTGRES_ADMIN_PASSWORD"
    echo "‚úÖ PostgreSQL admin credentials configured"
fi

if [ -n "$REDIS_ADMIN_PASSWORD" ]; then
    export REDIS_PASSWORD="$REDIS_ADMIN_PASSWORD"
    echo "‚úÖ Redis admin credentials configured"
fi

# Setup Argo CD admin access if available
if [ -n "$ARGOCD_ADMIN_TOKEN" ]; then
    export ARGOCD_AUTH_TOKEN="$ARGOCD_ADMIN_TOKEN"
    echo "‚úÖ Argo CD admin access configured"
fi

echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "üìã TESTING WORKFLOW REQUIREMENTS"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo ""
echo "PHASE 1: Code Review"
echo "- Comprehensive review against acceptance criteria"
echo "- Verify implementation meets all requirements"
echo "- Add PR comments for any issues found"
echo ""
echo "PHASE 2: Live Deployment Testing"
echo "- Deploy application in Kubernetes environment"
echo "- Perform regression testing"
echo "- Validate endpoints, data consistency, pod health"
echo "- Integration testing across services"
echo ""
echo "PHASE 3: Test Coverage Enhancement"
echo "- Analyze current test coverage"
echo "- Identify missing unit and integration tests"
echo "- Implement tests to achieve near 100% coverage"
echo "- Ensure all new tests pass in CI/CD"
echo ""
echo "CRITICAL: Must be 120% satisfied before approval!"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

# Copy task files if docs repository is specified
{{#if docs_repository_url}}
echo "üìã Copying task files from documentation repository..."
DOCS_REPO_URL="{{docs_repository_url}}"
DOCS_BRANCH="{{#if docs_branch}}{{docs_branch}}{{else}}main{{/if}}"
DOCS_HTTP_URL=$(echo "$DOCS_REPO_URL" | sed "s|https://github.com/|https://x-access-token:${GITHUB_TOKEN}@github.com/|")

if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
    echo "‚ùå Failed to clone docs repository"
    exit 1
fi
cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd "$CLAUDE_WORK_DIR"

# Copy task files
mkdir -p "$CLAUDE_WORK_DIR/task"
{{#if docs_project_directory}}
if [ "{{docs_project_directory}}" = "." ]; then
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
else
    DOCS_PATH="/tmp/docs-repo/{{docs_project_directory}}/.taskmaster"
fi
{{else}}
DOCS_PATH="/tmp/docs-repo/.taskmaster"
{{/if}}

TASK_DIR="$DOCS_PATH/docs/task-{{task_id}}"
if [ -d "$TASK_DIR" ]; then
    cp "$TASK_DIR/task.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/acceptance-criteria.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/prompt.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/toolman-guide.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    echo "‚úì Task {{task_id}} files copied"
fi

# Copy architecture.md
if [ -f "$DOCS_PATH/docs/architecture.md" ]; then
    cp "$DOCS_PATH/docs/architecture.md" "$CLAUDE_WORK_DIR/task/"
fi

# Clean up docs repo
rm -rf /tmp/docs-repo
{{/if}}

# Repository is now cloned directly to Claude working directory - no copy needed
echo "‚úì Repository cloned directly to working directory"

# Check if we should continue previous session
{{#if continue_session}}
echo "üìÇ Continuing from previous session..."
# Preserve existing CLAUDE.md if it exists
if [ -f "/workspace/CLAUDE.md" ]; then
    echo "‚úì Found existing CLAUDE.md, preserving session memory"
fi
{{else}}
{{#if overwrite_memory}}
echo "üîÑ Overwriting session memory as requested..."
rm -f /workspace/CLAUDE.md
{{/if}}
{{/if}}

# Generate configuration files from templates
echo "üîß Generating Tess-specific configuration files..."

# Enterprise managed settings are mounted directly from ConfigMap  
echo "=== ENTERPRISE MANAGED SETTINGS ==="
echo "‚úì Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
echo "‚úì No copying needed - mount automatically reflects latest ConfigMap changes"

# Copy MCP client configuration from task files  
if [ -f "/task-files/client-config.json" ]; then
  cp /task-files/client-config.json "$CLAUDE_WORK_DIR/client-config.json"
  echo "‚úì client-config.json copied from ConfigMap"
  export MCP_CLIENT_CONFIG="$CLAUDE_WORK_DIR/client-config.json"
  echo "‚úì MCP_CLIENT_CONFIG set to: $MCP_CLIENT_CONFIG"
else
  echo "‚ö†Ô∏è client-config.json not found in task-files - MCP client may not work correctly"
fi

# Create initial CLAUDE.md if needed
if [ ! -f "/workspace/CLAUDE.md" ] || [ "{{overwrite_memory}}" = "true" ]; then
    cat > /workspace/CLAUDE.md << 'EOF'
# TESS - Quality Assurance & Testing Agent

## Agent Role
- **Primary**: Comprehensive testing and deployment validation
- **Secondary**: Test coverage enhancement
- **Critical**: Only approve PR when 120% satisfied

## Testing Workflow Phases

### Phase 1: Code Review
- Review implementation against acceptance criteria
- Verify all requirements are met
- Add PR comments for any issues found
- Trigger Rex restart if changes needed

### Phase 2: Live Deployment Testing
Prerequisites:
- Helm charts available
- Container image builds successfully
- Infrastructure components ready

Testing Areas:
- Deploy application in Kubernetes
- Endpoint response validation
- Data consistency checks
- Pod health and resource utilization
- Integration testing across services
- Performance and load testing

### Phase 3: Test Coverage Enhancement
After confirming functionality:
- Analyze current test coverage
- Identify missing unit tests
- Identify missing integration tests
- Implement tests for:
  - All new functions/methods
  - API endpoints
  - Edge cases and error conditions
  - Database interactions
- Push test additions to feature branch
- Ensure all tests pass in CI/CD

## Admin Access Capabilities
- Kubernetes cluster admin
- PostgreSQL admin access
- Redis admin access
- Argo CD admin access
- GitHub Actions access

## Success Criteria
- Must be 120% satisfied before approval
- Near 100% test coverage achieved
- All acceptance criteria verified
- Live environment testing successful
- No critical issues remaining

## Important Notes
- Only start work when PR has "ready-for-qa" label
- Do NOT merge PR - only approve
- Human (CTO) performs final merge

EOF

    # Copy base CLAUDE.md from ConfigMap if it exists (match Rex pattern)
    if [ -f "/task-files/CLAUDE.md" ]; then
        cat /task-files/CLAUDE.md >> "/workspace/CLAUDE.md"
        echo "‚úì Appended base CLAUDE.md content from ConfigMap"
    fi
    
    # Copy to working directory for consistency with Rex pattern
    cp "/workspace/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
    echo "‚úì Created Tess-specific CLAUDE.md memory"
fi

# Copy guidelines files to working directory (match Rex pattern)
if [ -f "/task-files/coding-guidelines.md" ]; then
  cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "‚úì Copied coding-guidelines.md to working directory"
fi

if [ -f "/task-files/github-guidelines.md" ]; then
  cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "‚úì Copied github-guidelines.md to working directory"  
fi

# Copy MCP configuration from ConfigMap to project root (project scope)
if [ -f "/task-files/mcp.json" ]; then
  cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
  echo "‚úì Copied mcp.json to .mcp.json (project scope)"
else
  echo "‚ö†Ô∏è mcp.json template not found"
fi

# Setup hook scripts
echo "üîß Setting up Tess-specific hook scripts..."
mkdir -p "$CLAUDE_WORK_DIR/hooks"

{{#each hook_scripts}}
cat > "$CLAUDE_WORK_DIR/hooks/{{@key}}" << 'EOF'
{{{this}}}
EOF
chmod +x "$CLAUDE_WORK_DIR/hooks/{{@key}}"
{{/each}}

# Export environment for Claude
export CLAUDE_WORK_DIR
export GITHUB_TOKEN
export REPO_OWNER
export REPO_NAME
# TARGET_REPO_DIR no longer needed - repository cloned directly to CLAUDE_WORK_DIR

echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "‚úÖ TESS TESTING AGENT READY"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "üìÅ Working Directory: $CLAUDE_WORK_DIR"
echo "üì¶ Repository: $REPO_OWNER/$REPO_NAME"
echo "üìã Task: {{task_id}}"
echo "üß™ Focus: Comprehensive testing & deployment validation"
echo "‚ö†Ô∏è  CRITICAL: Must be 120% satisfied before approval"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

# Start Claude with Tess-specific configuration
cd "$CLAUDE_WORK_DIR"

# Build Claude command
CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Look for agent-specific system prompt file from agents ConfigMap
if [ -f "/config/agents/{{github_app}}_system-prompt.md" ]; then
    echo "‚úì Found system prompt file for {{github_app}}, adding to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /config/agents/{{github_app}}_system-prompt.md"
else
    echo "‚ÑπÔ∏è No system prompt file found for agent {{github_app}}, using defaults"
fi

# Add continue flag if this is a retry attempt or user requested continuation
{{#if continue_session}}
CLAUDE_CMD="$CLAUDE_CMD --continue"
echo 'Adding --continue flag (attempt {{attempts}}{{#if user_requested}} - user requested{{/if}})'
{{/if}}

echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "‚ïë                    STARTING CLAUDE EXECUTION                  ‚ïë"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "Command: $CLAUDE_CMD"
echo "Note: Claude will automatically read CLAUDE.md from the working directory"

# Tess uses her own system prompt and focuses on acceptance criteria
echo "‚úì Starting Tess with specialized QA system prompt"
echo "‚úì Tess will focus on acceptance criteria and comprehensive testing"

if [ -f "$CLAUDE_WORK_DIR/task/acceptance-criteria.md" ]; then
    echo "‚úì Found acceptance-criteria.md - this is Tess's primary focus"
else
    echo "‚ö†Ô∏è No acceptance-criteria.md found - Tess may need to work with available task files"
fi

# Prepare initial guidance for Tess
INITIAL_GUIDANCE="üß™ **TESS QA TESTING WORKFLOW**

You are now starting QA testing for this task. Your focus areas are:

1. **Acceptance Criteria Review**: 
   - Check task/acceptance-criteria.md (if available)
   - Verify all requirements are implemented correctly

2. **Code Quality Assessment**:
   - Review the PR changes thoroughly 
   - Ensure code follows best practices

3. **Testing & Validation**:
   - Run existing tests and ensure they pass
   - Add missing test coverage where needed
   - Test the application functionality

4. **Live Deployment Testing** (if applicable):
   - Deploy to test environment
   - Validate endpoints and functionality
   - Check integration points

Remember: You must be 120% satisfied before approving this PR. Only add approval when everything meets the highest quality standards."

# Start Claude with initial guidance
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "‚ïë                    STARTING TESS QA EXECUTION                 ‚ïë"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

# Seed initial user turn via a FIFO
FIFO_PATH="/workspace/agent-input.jsonl"
rm -f "$FIFO_PATH" 2>/dev/null || true
mkfifo "$FIFO_PATH"
chmod 666 "$FIFO_PATH" || true

# Start Claude (reader) first in background
$CLAUDE_CMD < "$FIFO_PATH" &
CLAUDE_PID=$!

# Compose initial user turn
USER_COMBINED=$(printf "%s" "$INITIAL_GUIDANCE" | jq -Rs .)

# Send via sidecar HTTP endpoint
if printf '{"text":%s}\n' "$USER_COMBINED" | \
     curl -fsS -X POST http://127.0.0.1:8080/input \
       -H 'Content-Type: application/json' \
       --data-binary @- >/dev/null 2>&1; then
  echo "‚úì Initial QA guidance sent via sidecar /input"
else
  echo "‚ö†Ô∏è Sidecar /input failed, falling back to direct FIFO write"
  exec 9>"$FIFO_PATH"
  printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}\n' "$USER_COMBINED" >&9
fi

# Wait for Claude process to complete
wait "$CLAUDE_PID"
# Close FIFO writer if it was opened
exec 9>&- 2>/dev/null || true

# Gracefully stop sidecar
if curl -fsS -X POST http://127.0.0.1:8080/shutdown >/dev/null 2>&1; then
  echo "‚úì Requested sidecar shutdown"
else
  echo "‚ö†Ô∏è Failed to request sidecar shutdown (it may not be running)"
fi