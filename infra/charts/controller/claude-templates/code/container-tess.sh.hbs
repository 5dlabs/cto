#!/bin/sh

echo '════════════════════════════════════════════════════════════════'
echo '║              TESS TESTING WORKFLOW STARTING                  ║'
echo '║         Quality Assurance & Deployment Testing Agent         ║'
echo '════════════════════════════════════════════════════════════════'
echo "🎯 Agent: {{github_app}}"
echo "🧪 Focus: Comprehensive testing, deployment validation, test coverage"
echo "📋 Task ID: {{task_id}}"
echo "✅ Mission: 120% satisfaction through exhaustive testing"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication for testing workflow"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."
    
    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"
    
    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"
    
    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "⚠️ Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "❌ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "Installation ID: $INSTALLATION_ID"
    
    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "❌ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "✅ Successfully authenticated with GitHub App"
    
    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"
    
    # Set global git config with token
    git config --global url."https://x-access-token:${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"
    git config --global url."https://x-access-token:${GITHUB_TOKEN}@github.com/".insteadOf "git@github.com:"
    
    # Configure GitHub CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token
    
else
    echo "❌ GitHub App credentials not found"
    exit 1
fi

# Set working directory for the agent
CLAUDE_WORK_DIR="/workspace/claude"
mkdir -p "$CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"

# Prepare environment for testing
echo "════════════════════════════════════════════════════════════════"
echo "🧪 PREPARING TESTING ENVIRONMENT"
echo "════════════════════════════════════════════════════════════════"

# Configure Git identity 
git config --global user.email "tess@5dlabs.com"
git config --global user.name "5DLabs-Tess"
git config --global init.defaultBranch main

# Target repository directory name
TARGET_REPO_DIR="{{#if working_directory}}{{working_directory}}{{else}}{{service}}{{/if}}"

# Clone or update repository
if [ -d "/workspace/$TARGET_REPO_DIR" ]; then
    echo "📁 Found existing repository '$TARGET_REPO_DIR', updating..."
    cd "/workspace/$TARGET_REPO_DIR"
    git fetch origin
    cd "$CLAUDE_WORK_DIR"
else
    echo "📥 Cloning repository..."
    REPO_HTTP_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO_OWNER}/${REPO_NAME}.git"
    if ! git clone "$REPO_HTTP_URL" "/workspace/$TARGET_REPO_DIR"; then
        echo "❌ Failed to clone repository"
        exit 1
    fi
fi

echo "════════════════════════════════════════════════════════════════"
echo "🔧 TESTING INFRASTRUCTURE SETUP"
echo "════════════════════════════════════════════════════════════════"

# Setup Kubernetes admin access if available
if [ -f "/etc/kube/config" ]; then
    export KUBECONFIG=/etc/kube/config
    echo "✅ Kubernetes admin access configured"
    kubectl version --client 2>/dev/null || echo "⚠️ kubectl not available"
fi

# Setup database admin credentials if available
if [ -n "$POSTGRES_ADMIN_PASSWORD" ]; then
    export PGPASSWORD="$POSTGRES_ADMIN_PASSWORD"
    echo "✅ PostgreSQL admin credentials configured"
fi

if [ -n "$REDIS_ADMIN_PASSWORD" ]; then
    export REDIS_PASSWORD="$REDIS_ADMIN_PASSWORD"
    echo "✅ Redis admin credentials configured"
fi

# Setup Argo CD admin access if available
if [ -n "$ARGOCD_ADMIN_TOKEN" ]; then
    export ARGOCD_AUTH_TOKEN="$ARGOCD_ADMIN_TOKEN"
    echo "✅ Argo CD admin access configured"
fi

echo "════════════════════════════════════════════════════════════════"
echo "📋 TESTING WORKFLOW REQUIREMENTS"
echo "════════════════════════════════════════════════════════════════"
echo ""
echo "PHASE 1: Code Review"
echo "- Comprehensive review against acceptance criteria"
echo "- Verify implementation meets all requirements"
echo "- Add PR comments for any issues found"
echo ""
echo "PHASE 2: Live Deployment Testing"
echo "- Deploy application in Kubernetes environment"
echo "- Perform regression testing"
echo "- Validate endpoints, data consistency, pod health"
echo "- Integration testing across services"
echo ""
echo "PHASE 3: Test Coverage Enhancement"
echo "- Analyze current test coverage"
echo "- Identify missing unit and integration tests"
echo "- Implement tests to achieve near 100% coverage"
echo "- Ensure all new tests pass in CI/CD"
echo ""
echo "CRITICAL: Must be 120% satisfied before approval!"
echo "════════════════════════════════════════════════════════════════"

# Copy task files if docs repository is specified
{{#if docs_repository_url}}
echo "📋 Copying task files from documentation repository..."
DOCS_REPO_URL="{{docs_repository_url}}"
DOCS_BRANCH="{{#if docs_branch}}{{docs_branch}}{{else}}main{{/if}}"
DOCS_HTTP_URL=$(echo "$DOCS_REPO_URL" | sed "s|https://github.com/|https://x-access-token:${GITHUB_TOKEN}@github.com/|")

if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
    echo "❌ Failed to clone docs repository"
    exit 1
fi
cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd "$CLAUDE_WORK_DIR"

# Copy task files
mkdir -p "/workspace/$TARGET_REPO_DIR/task"
{{#if docs_project_directory}}
if [ "{{docs_project_directory}}" = "." ]; then
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
else
    DOCS_PATH="/tmp/docs-repo/{{docs_project_directory}}/.taskmaster"
fi
{{else}}
DOCS_PATH="/tmp/docs-repo/.taskmaster"
{{/if}}

TASK_DIR="$DOCS_PATH/docs/task-{{task_id}}"
if [ -d "$TASK_DIR" ]; then
    cp "$TASK_DIR/task.md" "/workspace/$TARGET_REPO_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/acceptance-criteria.md" "/workspace/$TARGET_REPO_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/prompt.md" "/workspace/$TARGET_REPO_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/toolman-guide.md" "/workspace/$TARGET_REPO_DIR/task/" 2>/dev/null || true
    echo "✓ Task {{task_id}} files copied"
fi

# Copy architecture.md
if [ -f "$DOCS_PATH/docs/architecture.md" ]; then
    cp "$DOCS_PATH/docs/architecture.md" "/workspace/$TARGET_REPO_DIR/task/"
fi

# Clean up docs repo
rm -rf /tmp/docs-repo
{{/if}}

# Copy prepared files to Claude working directory
cp -r "/workspace/$TARGET_REPO_DIR/." "$CLAUDE_WORK_DIR/"

# Check if we should continue previous session
{{#if continue_session}}
echo "📂 Continuing from previous session..."
# Preserve existing CLAUDE.md if it exists
if [ -f "/workspace/CLAUDE.md" ]; then
    echo "✓ Found existing CLAUDE.md, preserving session memory"
fi
{{else}}
{{#if overwrite_memory}}
echo "🔄 Overwriting session memory as requested..."
rm -f /workspace/CLAUDE.md
{{/if}}
{{/if}}

# Generate configuration files from templates
echo "🔧 Generating Tess-specific configuration files..."

# Enterprise managed settings are mounted directly from ConfigMap  
echo "=== ENTERPRISE MANAGED SETTINGS ==="
echo "✓ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
echo "✓ No copying needed - mount automatically reflects latest ConfigMap changes"

# Create MCP client configuration with testing tools
cat > "$CLAUDE_WORK_DIR/client-config.json" << 'EOF'
{{> client-config.json.hbs}}
EOF

# Create initial CLAUDE.md if needed
if [ ! -f "/workspace/CLAUDE.md" ] || [ "{{overwrite_memory}}" = "true" ]; then
    cat > /workspace/CLAUDE.md << 'EOF'
# TESS - Quality Assurance & Testing Agent

## Agent Role
- **Primary**: Comprehensive testing and deployment validation
- **Secondary**: Test coverage enhancement
- **Critical**: Only approve PR when 120% satisfied

## Testing Workflow Phases

### Phase 1: Code Review
- Review implementation against acceptance criteria
- Verify all requirements are met
- Add PR comments for any issues found
- Trigger Rex restart if changes needed

### Phase 2: Live Deployment Testing
Prerequisites:
- Helm charts available
- Container image builds successfully
- Infrastructure components ready

Testing Areas:
- Deploy application in Kubernetes
- Endpoint response validation
- Data consistency checks
- Pod health and resource utilization
- Integration testing across services
- Performance and load testing

### Phase 3: Test Coverage Enhancement
After confirming functionality:
- Analyze current test coverage
- Identify missing unit tests
- Identify missing integration tests
- Implement tests for:
  - All new functions/methods
  - API endpoints
  - Edge cases and error conditions
  - Database interactions
- Push test additions to feature branch
- Ensure all tests pass in CI/CD

## Admin Access Capabilities
- Kubernetes cluster admin
- PostgreSQL admin access
- Redis admin access
- Argo CD admin access
- GitHub Actions access

## Success Criteria
- Must be 120% satisfied before approval
- Near 100% test coverage achieved
- All acceptance criteria verified
- Live environment testing successful
- No critical issues remaining

## Important Notes
- Only start work when PR has "ready-for-qa" label
- Do NOT merge PR - only approve
- Human (CTO) performs final merge

{{> claude.md.hbs}}
EOF
    echo "✓ Created Tess-specific CLAUDE.md memory"
fi

# Create coding guidelines
cat > "$CLAUDE_WORK_DIR/coding-guidelines.md" << 'EOF'
{{> coding-guidelines.md.hbs}}
EOF

# Create GitHub guidelines  
cat > "$CLAUDE_WORK_DIR/github-guidelines.md" << 'EOF'
{{> github-guidelines.md.hbs}}
EOF

# Create MCP configuration
cat > "$CLAUDE_WORK_DIR/mcp.json" << 'EOF'
{{> mcp.json.hbs}}
EOF

# Setup hook scripts
echo "🔧 Setting up Tess-specific hook scripts..."
mkdir -p "$CLAUDE_WORK_DIR/hooks"

{{#each hook_scripts}}
cat > "$CLAUDE_WORK_DIR/hooks/{{@key}}" << 'EOF'
{{{this}}}
EOF
chmod +x "$CLAUDE_WORK_DIR/hooks/{{@key}}"
{{/each}}

# Export environment for Claude
export CLAUDE_WORK_DIR
export GITHUB_TOKEN
export REPO_OWNER
export REPO_NAME
export TARGET_REPO_DIR

echo "════════════════════════════════════════════════════════════════"
echo "✅ TESS TESTING AGENT READY"
echo "════════════════════════════════════════════════════════════════"
echo "📁 Working Directory: $CLAUDE_WORK_DIR"
echo "📦 Repository: $REPO_OWNER/$REPO_NAME"
echo "📋 Task: {{task_id}}"
echo "🧪 Focus: Comprehensive testing & deployment validation"
echo "⚠️  CRITICAL: Must be 120% satisfied before approval"
echo "════════════════════════════════════════════════════════════════"

# Start Claude with Tess-specific configuration
cd "$CLAUDE_WORK_DIR"
exec /usr/local/bin/claude-cli "$@"