#!/bin/sh

# Source Rust environment if available (fixes cargo not found issues)
if [ -f "$HOME/.cargo/env" ]; then
    . "$HOME/.cargo/env"
fi

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘              TESS TESTING WORKFLOW STARTING                  â•‘'
echo 'â•‘         Quality Assurance & Deployment Testing Agent         â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo "ğŸ¯ Agent: {{github_app}}"
echo "ğŸ§ª Focus: Comprehensive testing, deployment validation, test coverage"
echo "ğŸ“‹ Task ID: {{task_id}}"
echo "âœ… Mission: 120% satisfaction through exhaustive testing"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication for testing workflow"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."
    
    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"
    
    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"
    
    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âš ï¸ Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âŒ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "Installation ID: $INSTALLATION_ID"
    
    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "âŒ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "âœ… Successfully authenticated with GitHub App"
    
    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"
    
    # Export the token for git to use
    export GITHUB_TOKEN
    
    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    
    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token
    
else
    echo "âŒ GitHub App credentials not found"
    exit 1
fi

# Set working directory for the agent
# Set Working Directory (Critical for Claude Execution) - Match Rex pattern  
WORK_DIR="{{working_directory}}"
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
  CLAUDE_WORK_DIR="/workspace/$REPO_NAME"
else
  CLAUDE_WORK_DIR="/workspace/$REPO_NAME/$WORK_DIR"
fi
mkdir -p "$CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"

# Prepare environment for testing
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ğŸ§ª PREPARING TESTING ENVIRONMENT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Git configuration with proper GitHub App attribution
git config --global --add safe.directory /workspace

# Set GitHub App attribution - use generic format for all agents
GITHUB_APP="{{github_app}}"
# Generic attribution that works for any agent
GIT_AUTHOR_NAME="${GITHUB_APP} Agent (Claude Code)"
GIT_AUTHOR_EMAIL="${GITHUB_APP}[bot]@users.noreply.github.com"

# Configure git with proper GitHub App attribution
git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

# Set environment variables for Claude Code to use
export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
echo "âœ“ Git configured"

# Clone or update repository (directly to Claude working directory)
if [ -d "$CLAUDE_WORK_DIR/.git" ]; then
    echo "ğŸ“ Found existing repository at working directory, updating..."
    cd "$CLAUDE_WORK_DIR"
    git fetch origin --prune
else
    # Ensure parent directories exist
    mkdir -p "$(dirname "$CLAUDE_WORK_DIR")"
    
    # If directory exists but isn't a git repo, remove it first
    if [ -d "$CLAUDE_WORK_DIR" ] && [ ! -d "$CLAUDE_WORK_DIR/.git" ]; then
        echo "ğŸ§¹ Removing non-git directory to prepare for clone..."
        rm -rf "$CLAUDE_WORK_DIR"
    fi
    
    echo "ğŸ“¥ Cloning repository to working directory..."
    # Make sure parent directory exists and we're in a valid location
    PARENT_DIR="$(dirname "$CLAUDE_WORK_DIR")"
    mkdir -p "$PARENT_DIR"
    cd "$PARENT_DIR"
    
    REPO_HTTP_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO_OWNER}/${REPO_NAME}.git"
    if ! git clone "$REPO_HTTP_URL" "$(basename "$CLAUDE_WORK_DIR")"; then
        echo "âŒ Failed to clone repository"
        echo "Debug: CLAUDE_WORK_DIR=$CLAUDE_WORK_DIR"
        echo "Debug: Parent directory exists: $(ls -la "$PARENT_DIR" 2>/dev/null || echo 'No')"
        exit 1
    fi
    cd "$(basename "$CLAUDE_WORK_DIR")"
fi

# Checkout PR branch for testing review
if [ -n "$PR_NUMBER" ] && [ -n "$PR_URL" ]; then
    echo "ğŸ”„ Checking out PR #$PR_NUMBER for QA testing..."
    cd "$CLAUDE_WORK_DIR"
    git fetch origin --prune
    PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName' 2>/dev/null || echo "")
    if [ -n "$PR_BRANCH" ]; then
        git checkout "$PR_BRANCH" || git checkout -b "$PR_BRANCH" "origin/$PR_BRANCH"
        git pull origin "$PR_BRANCH" || echo "âš ï¸  Could not pull latest changes"
        echo "âœ“ Checked out PR branch: $PR_BRANCH"
    else
        echo "âš ï¸ Could not determine PR branch name, staying on default branch"
    fi
    
    # Add PR context to CLAUDE.md for reference
    echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "# PR Context for Testing" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "- **PR Number**: $PR_NUMBER" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "- **PR URL**: $PR_URL" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "- **Branch**: $PR_BRANCH" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
    echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md" || true
else
    echo "â„¹ï¸ No PR context provided - working on default branch"
fi

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ğŸ”§ TESTING INFRASTRUCTURE SETUP"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Setup Kubernetes admin access if available
if [ -f "/etc/kube/config" ]; then
    export KUBECONFIG=/etc/kube/config
    echo "âœ… Kubernetes admin access configured"
    kubectl version --client 2>/dev/null || echo "âš ï¸ kubectl not available"
fi

# Setup database admin credentials if available
if [ -n "$POSTGRES_ADMIN_PASSWORD" ]; then
    export PGPASSWORD="$POSTGRES_ADMIN_PASSWORD"
    echo "âœ… PostgreSQL admin credentials configured"
fi

if [ -n "$REDIS_ADMIN_PASSWORD" ]; then
    export REDIS_PASSWORD="$REDIS_ADMIN_PASSWORD"
    echo "âœ… Redis admin credentials configured"
fi

# Setup Argo CD admin access if available
if [ -n "$ARGOCD_ADMIN_TOKEN" ]; then
    export ARGOCD_AUTH_TOKEN="$ARGOCD_ADMIN_TOKEN"
    echo "âœ… Argo CD admin access configured"
fi

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ğŸ“‹ TESTING WORKFLOW REQUIREMENTS"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "PHASE 1: Code Review"
echo "- Comprehensive review against acceptance criteria"
echo "- Verify implementation meets all requirements"
echo "- Add PR comments for any issues found"
echo ""
echo "PHASE 2: Live Deployment Testing"
echo "- Deploy application in Kubernetes environment"
echo "- Perform regression testing"
echo "- Validate endpoints, data consistency, pod health"
echo "- Integration testing across services"
echo ""
echo "PHASE 3: Test Coverage Enhancement"
echo "- Analyze current test coverage"
echo "- Identify missing unit and integration tests"
echo "- Implement tests to achieve near 100% coverage"
echo "- Ensure all new tests pass in CI/CD"
echo ""
echo "CRITICAL: Must be 120% satisfied before approval!"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Copy task files if docs repository is specified
{{#if docs_repository_url}}
echo "ğŸ“‹ Copying task files from documentation repository..."
DOCS_REPO_URL="{{docs_repository_url}}"
DOCS_BRANCH="{{#if docs_branch}}{{docs_branch}}{{else}}main{{/if}}"
DOCS_HTTP_URL=$(echo "$DOCS_REPO_URL" | sed "s|https://github.com/|https://x-access-token:${GITHUB_TOKEN}@github.com/|")

if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
    echo "âŒ Failed to clone docs repository"
    exit 1
fi
cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd "$CLAUDE_WORK_DIR"

# Copy task files
mkdir -p "$CLAUDE_WORK_DIR/task"
{{#if docs_project_directory}}
if [ "{{docs_project_directory}}" = "." ]; then
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
else
    DOCS_PATH="/tmp/docs-repo/{{docs_project_directory}}/.taskmaster"
fi
{{else}}
DOCS_PATH="/tmp/docs-repo/.taskmaster"
{{/if}}

TASK_DIR="$DOCS_PATH/docs/task-{{task_id}}"
if [ -d "$TASK_DIR" ]; then
    cp "$TASK_DIR/task.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/acceptance-criteria.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/prompt.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/toolman-guide.md" "$CLAUDE_WORK_DIR/task/" 2>/dev/null || true
    echo "âœ“ Task {{task_id}} files copied"
fi

# Copy architecture.md
if [ -f "$DOCS_PATH/docs/architecture.md" ]; then
    cp "$DOCS_PATH/docs/architecture.md" "$CLAUDE_WORK_DIR/task/"
fi

# Clean up docs repo
rm -rf /tmp/docs-repo
{{/if}}

# Repository is now cloned directly to Claude working directory - no copy needed
echo "âœ“ Repository cloned directly to working directory"

# Check if we should continue previous session
{{#if continue_session}}
echo "ğŸ“‚ Continuing from previous session..."
# Preserve existing CLAUDE.md if it exists
if [ -f "/workspace/CLAUDE.md" ]; then
    echo "âœ“ Found existing CLAUDE.md, preserving session memory"
fi
{{else}}
{{#if overwrite_memory}}
echo "ğŸ”„ Overwriting session memory as requested..."
rm -f /workspace/CLAUDE.md
{{/if}}
{{/if}}

# Generate configuration files from templates
echo "ğŸ”§ Generating Tess-specific configuration files..."

# Enterprise managed settings are mounted directly from ConfigMap  
echo "=== ENTERPRISE MANAGED SETTINGS ==="
echo "âœ“ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
echo "âœ“ No copying needed - mount automatically reflects latest ConfigMap changes"

# Copy MCP client configuration from task files  
if [ -f "/task-files/client-config.json" ]; then
  cp /task-files/client-config.json "$CLAUDE_WORK_DIR/client-config.json"
  echo "âœ“ client-config.json copied from ConfigMap"
  export MCP_CLIENT_CONFIG="$CLAUDE_WORK_DIR/client-config.json"
  echo "âœ“ MCP_CLIENT_CONFIG set to: $MCP_CLIENT_CONFIG"
else
  echo "âš ï¸ client-config.json not found in task-files - MCP client may not work correctly"
fi

# Create initial CLAUDE.md if needed
if [ ! -f "/workspace/CLAUDE.md" ] || [ "{{overwrite_memory}}" = "true" ]; then
    cat > /workspace/CLAUDE.md << 'EOF'
# TESS - Quality Assurance & Testing Agent

## Agent Role
- **Primary**: QA validation and acceptance criteria verification
- **Secondary**: Manual testing and regression testing
- **Critical**: Only approve PR when 120% satisfied
- **IMPORTANT**: NO CODE CHANGES - validation and feedback only

## Testing Workflow Phases

### Phase 1: Acceptance Criteria Verification
- Review implementation against acceptance criteria
- Verify ALL requirements are fully met
- Post PR comments for any missing items
- Request Rex to fix any issues found

### Phase 2: Manual Application Testing
- Build and run the application locally
- Test all functionality by hand:
  - For APIs: test endpoints with curl/httpie
  - For CLIs: test commands and verify outputs
  - For web apps: test UI interactions
- Verify the application works as expected
- Document any bugs or issues in PR comments

### Phase 3: Regression Testing
- Run existing test suite
- Verify no existing functionality is broken
- Check that all tests pass
- Report any test failures in PR comments

## CRITICAL RULES
- **DO NOT** modify any code files
- **DO NOT** push any changes to the repository
- **DO NOT** create new files or edit existing ones
- **ONLY** post comments to the PR with findings
- **ONLY** approve when 120% satisfied
- Rex handles ALL code changes and improvements

## Admin Access Capabilities
- Kubernetes cluster admin
- PostgreSQL admin access
- Redis admin access
- Argo CD admin access
- GitHub Actions access

## Success Criteria
- Must be 120% satisfied before approval
- Near 100% test coverage achieved
- All acceptance criteria verified
- Live environment testing successful
- No critical issues remaining

## Important Notes
- Only start work when PR has "ready-for-qa" label
- Do NOT merge PR - only approve
- Human (CTO) performs final merge

EOF

    # Copy base CLAUDE.md from ConfigMap if it exists (match Rex pattern)
    if [ -f "/task-files/CLAUDE.md" ]; then
        cat /task-files/CLAUDE.md >> "/workspace/CLAUDE.md"
        echo "âœ“ Appended base CLAUDE.md content from ConfigMap"
    fi
    
    # Copy to working directory for consistency with Rex pattern
    cp "/workspace/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
    echo "âœ“ Created Tess-specific CLAUDE.md memory"
fi

# Copy guidelines files to working directory (match Rex pattern)
if [ -f "/task-files/coding-guidelines.md" ]; then
  cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "âœ“ Copied coding-guidelines.md to working directory"
fi

if [ -f "/task-files/github-guidelines.md" ]; then
  cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "âœ“ Copied github-guidelines.md to working directory"  
fi

# Copy MCP configuration from ConfigMap to project root (project scope)
if [ -f "/task-files/mcp.json" ]; then
  cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
  echo "âœ“ Copied mcp.json to .mcp.json (project scope)"
else
  echo "âš ï¸ mcp.json template not found"
fi

# Setup hook scripts
echo "ğŸ”§ Setting up Tess-specific hook scripts..."
mkdir -p "$CLAUDE_WORK_DIR/hooks"

{{#each hook_scripts}}
cat > "$CLAUDE_WORK_DIR/hooks/{{@key}}" << 'EOF'
{{{this}}}
EOF
chmod +x "$CLAUDE_WORK_DIR/hooks/{{@key}}"
{{/each}}

# Export environment for Claude
export CLAUDE_WORK_DIR
export GITHUB_TOKEN
export REPO_OWNER
export REPO_NAME
# TARGET_REPO_DIR no longer needed - repository cloned directly to CLAUDE_WORK_DIR

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "âœ… TESS TESTING AGENT READY"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ğŸ“ Working Directory: $CLAUDE_WORK_DIR"
echo "ğŸ“¦ Repository: $REPO_OWNER/$REPO_NAME"
echo "ğŸ“‹ Task: {{task_id}}"
echo "ğŸ§ª Focus: Comprehensive testing & deployment validation"
echo "âš ï¸  CRITICAL: Must be 120% satisfied before approval"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Start Claude with Tess-specific configuration
cd "$CLAUDE_WORK_DIR"

# Build Claude command
CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Look for agent-specific system prompt file from agents ConfigMap
if [ -f "/config/agents/{{github_app}}_system-prompt.md" ]; then
    echo "âœ“ Found system prompt file for {{github_app}}, adding to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /config/agents/{{github_app}}_system-prompt.md"
else
    echo "â„¹ï¸ No system prompt file found for agent {{github_app}}, using defaults"
fi

# Add continue flag if this is a retry attempt or user requested continuation
{{#if continue_session}}
CLAUDE_CMD="$CLAUDE_CMD --continue"
echo 'Adding --continue flag (attempt {{attempts}}{{#if user_requested}} - user requested{{/if}})'
{{/if}}

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                    STARTING CLAUDE EXECUTION                  â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "Command: $CLAUDE_CMD"
echo "Note: Claude will automatically read CLAUDE.md from the working directory"

# Tess uses her own system prompt and focuses on acceptance criteria
echo "âœ“ Starting Tess with specialized QA system prompt"
echo "âœ“ Tess will focus on acceptance criteria and comprehensive testing"

if [ -f "$CLAUDE_WORK_DIR/task/acceptance-criteria.md" ]; then
    echo "âœ“ Found acceptance-criteria.md - this is Tess's primary focus"
else
    echo "âš ï¸ No acceptance-criteria.md found - Tess may need to work with available task files"
fi

# Prepare initial guidance for Tess
INITIAL_GUIDANCE="ğŸ§ª **TESS QA TESTING WORKFLOW**

You are now starting QA testing for this task. Your role is VALIDATION ONLY - you do NOT make code changes.

**CRITICAL INSTRUCTIONS**:
- DO NOT modify any code files
- DO NOT push any changes to the repository
- DO NOT create new files or edit existing ones
- ONLY post comments to the PR with your findings

Your focus areas are:

1. **Acceptance Criteria Verification**: 
   - Check task/acceptance-criteria.md
   - Verify ALL requirements are fully implemented
   - Document any missing or incomplete items

2. **Manual Testing**:
   - Build and run the application locally
   - Test all functionality by hand
   - Verify the application works as expected
   - For APIs: test endpoints with curl/httpie
   - For CLIs: test commands and verify outputs

3. **Regression Testing**:
   - Run existing test suite
   - Verify no existing functionality is broken
   - Check that all tests pass

4. **PR Feedback**:
   - Post detailed comments on the PR about:
     - Any acceptance criteria not met
     - Any bugs or issues found
     - Any regressions discovered
     - Suggestions for improvements (for Rex to implement)
   - If critical issues found, request Rex to fix them
   - Only approve PR when 120% satisfied

Remember: Your job is to TEST and provide FEEDBACK. Rex handles all code changes."

# Start Claude with initial guidance
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                    STARTING TESS QA EXECUTION                 â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Seed initial user turn via a FIFO
FIFO_PATH="/workspace/agent-input.jsonl"
rm -f "$FIFO_PATH" 2>/dev/null || true
mkfifo "$FIFO_PATH"
chmod 666 "$FIFO_PATH" || true

# Start Claude (reader) first in background
$CLAUDE_CMD < "$FIFO_PATH" &
CLAUDE_PID=$!

# Compose initial user turn
USER_COMBINED=$(printf "%s" "$INITIAL_GUIDANCE" | jq -Rs .)

# Send via sidecar HTTP endpoint
if printf '{"text":%s}\n' "$USER_COMBINED" | \
     curl -fsS -X POST http://127.0.0.1:8080/input \
       -H 'Content-Type: application/json' \
       --data-binary @- >/dev/null 2>&1; then
  echo "âœ“ Initial QA guidance sent via sidecar /input"
else
  echo "âš ï¸ Sidecar /input failed, falling back to direct FIFO write"
  exec 9>"$FIFO_PATH"
  printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}\n' "$USER_COMBINED" >&9
fi

# Wait for Claude process to complete
wait "$CLAUDE_PID"
CLAUDE_EXIT_CODE=$?

# Close FIFO writer if it was opened
exec 9>&- 2>/dev/null || true

if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
  echo "âœ… Tess QA testing completed successfully"
else
  echo "âš ï¸ Tess QA testing exited with code: $CLAUDE_EXIT_CODE"
fi

# Gracefully stop sidecar
if curl -fsS -X POST http://127.0.0.1:8080/shutdown >/dev/null 2>&1; then
  echo "âœ“ Requested sidecar shutdown"
else
  echo "âš ï¸ Failed to request sidecar shutdown (it may not be running)"
fi

# Perform cleanup
echo "ğŸ”§ Performing cleanup..."
rm -f "$FIFO_PATH" 2>/dev/null || true

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                  TESS QA WORKFLOW COMPLETE                   â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ğŸ“‹ Task: {{task_id}}"
echo "ğŸ§ª Testing completed - check PR for feedback"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Exit with Claude's exit code
exit $CLAUDE_EXIT_CODE