#!/bin/sh

echo '════════════════════════════════════════════════════════════════'
echo '║              CLEO CODE QUALITY WORKFLOW STARTING             ║'
echo '║        Code Quality & Documentation Enforcement Agent        ║'
echo '════════════════════════════════════════════════════════════════'
echo "🎯 Agent: {{github_app}}"
echo "🔍 Focus: Code quality, formatting, and documentation verification"
echo "📋 Task ID: {{task_id}}"
echo "✅ Mission: Relentless pursuit of 100% code quality and proper documentation"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication for code quality checks"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."
    
    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"
    
    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"
    
    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "⚠️ Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "❌ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "Installation ID: $INSTALLATION_ID"
    
    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "❌ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "✅ Successfully authenticated with GitHub App"
    
    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"
    
    # Set global git config with token
    git config --global url."https://x-access-token:${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"
    git config --global url."https://x-access-token:${GITHUB_TOKEN}@github.com/".insteadOf "git@github.com:"
    
    # Configure GitHub CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token
    
else
    echo "❌ GitHub App credentials not found"
    exit 1
fi

# Set working directory for the agent
CLAUDE_WORK_DIR="/workspace/claude"
mkdir -p "$CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"

# Prepare environment for QA checks
echo "════════════════════════════════════════════════════════════════"
echo "📊 PREPARING CODE QUALITY ENVIRONMENT"
echo "════════════════════════════════════════════════════════════════"

# Configure Git identity 
git config --global user.email "cleo@5dlabs.com"
git config --global user.name "5DLabs-Cleo"
git config --global init.defaultBranch main

# Target repository directory name
TARGET_REPO_DIR="{{#if working_directory}}{{working_directory}}{{else}}{{service}}{{/if}}"

# Clone or update repository
if [ -d "/workspace/$TARGET_REPO_DIR" ]; then
    echo "📁 Found existing repository '$TARGET_REPO_DIR', updating..."
    cd "/workspace/$TARGET_REPO_DIR"
    git fetch origin
    cd "$CLAUDE_WORK_DIR"
else
    echo "📥 Cloning repository..."
    REPO_HTTP_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO_OWNER}/${REPO_NAME}.git"
    if ! git clone "$REPO_HTTP_URL" "/workspace/$TARGET_REPO_DIR"; then
        echo "❌ Failed to clone repository"
        exit 1
    fi
fi

echo "════════════════════════════════════════════════════════════════"
echo "🔍 QA DOCUMENTATION ENFORCEMENT CHECK"
echo "════════════════════════════════════════════════════════════════"
echo ""
echo "CRITICAL MISSION: Before approving any PR, verify that:"
echo "1. Implementation changes are reflected in documentation"
echo "2. Or a rationale is provided when docs are not needed"
echo ""
echo "Detection logic:"
echo "- controller/** → engineering and controller references required"
echo "- infra/** (charts/CRDs) → infra docs and references required"
echo "- mcp/** → CLI/tooling docs required"
echo "- API/config changes → README/examples updates required"
echo ""
echo "If docs missing, must:"
echo "- Post structured PR comment with required docs checklist"
echo "- Block approval until docs updated or rationale provided"
echo "- Exit non-zero to fail QA step"
echo ""
echo "════════════════════════════════════════════════════════════════"

# Copy task files if docs repository is specified
{{#if docs_repository_url}}
echo "📋 Copying task files from documentation repository..."
DOCS_REPO_URL="{{docs_repository_url}}"
DOCS_BRANCH="{{#if docs_branch}}{{docs_branch}}{{else}}main{{/if}}"
DOCS_HTTP_URL=$(echo "$DOCS_REPO_URL" | sed "s|https://github.com/|https://x-access-token:${GITHUB_TOKEN}@github.com/|")

if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
    echo "❌ Failed to clone docs repository"
    exit 1
fi
cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd "$CLAUDE_WORK_DIR"

# Copy task files
mkdir -p "/workspace/$TARGET_REPO_DIR/task"
{{#if docs_project_directory}}
if [ "{{docs_project_directory}}" = "." ]; then
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
else
    DOCS_PATH="/tmp/docs-repo/{{docs_project_directory}}/.taskmaster"
fi
{{else}}
DOCS_PATH="/tmp/docs-repo/.taskmaster"
{{/if}}

TASK_DIR="$DOCS_PATH/docs/task-{{task_id}}"
if [ -d "$TASK_DIR" ]; then
    cp "$TASK_DIR/task.md" "/workspace/$TARGET_REPO_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/acceptance-criteria.md" "/workspace/$TARGET_REPO_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/prompt.md" "/workspace/$TARGET_REPO_DIR/task/" 2>/dev/null || true
    cp "$TASK_DIR/toolman-guide.md" "/workspace/$TARGET_REPO_DIR/task/" 2>/dev/null || true
    echo "✓ Task {{task_id}} files copied"
fi

# Copy architecture.md
if [ -f "$DOCS_PATH/docs/architecture.md" ]; then
    cp "$DOCS_PATH/docs/architecture.md" "/workspace/$TARGET_REPO_DIR/task/"
fi

# Clean up docs repo
rm -rf /tmp/docs-repo
{{/if}}

# Copy prepared files to Claude working directory
cp -r "/workspace/$TARGET_REPO_DIR/." "$CLAUDE_WORK_DIR/"

# Check if we should continue previous session
{{#if continue_session}}
echo "📂 Continuing from previous session..."
# Preserve existing CLAUDE.md if it exists
if [ -f "/workspace/CLAUDE.md" ]; then
    echo "✓ Found existing CLAUDE.md, preserving session memory"
fi
{{else}}
{{#if overwrite_memory}}
echo "🔄 Overwriting session memory as requested..."
rm -f /workspace/CLAUDE.md
{{/if}}
{{/if}}

# Generate configuration files from templates
echo "🔧 Generating Cleo-specific configuration files..."

# Create settings.json for Claude Desktop
cat > "$CLAUDE_WORK_DIR/settings.json" << 'EOF'
{{> settings.json.hbs}}
EOF

# Create MCP client configuration
cat > "$CLAUDE_WORK_DIR/client-config.json" << 'EOF'
{{> client-config.json.hbs}}
EOF

# Create initial CLAUDE.md if needed
if [ ! -f "/workspace/CLAUDE.md" ] || [ "{{overwrite_memory}}" = "true" ]; then
    cat > /workspace/CLAUDE.md << 'EOF'
# CLEO - Code Quality & Documentation Enforcement Agent

## Agent Role
- **Primary**: Code quality enforcement (Clippy pedantic, formatting)
- **Secondary**: Documentation verification and enforcement
- **Critical**: Add "ready-for-qa" label when satisfied with quality AND tests pass

## QA Documentation Enforcement Requirements

### Detection Logic
Map code changes to required documentation:
- `controller/**` → `docs/engineering/*` and `docs/references/*`
- `infra/charts/**` → chart docs and `docs/references/*`
- `workflows/sensors` → `docs/references/argo-events/*`
- API/config changes → `docs/README.md`, `docs/examples/*`

### Enforcement Process
1. Parse git diff for implementation changes
2. Check if corresponding docs were updated
3. If missing docs:
   - Post structured PR comment with checklist
   - Include suggested doc paths and sections
   - Provide rationale template option
   - Exit non-zero to block approval

### PR Comment Template
```
🔍 QA Documentation Check

**Detected change areas requiring documentation:**
- [List areas detected]

**Required documentation updates:**
- [ ] Path: suggested/doc/path.md - Section to update
- [ ] Path: another/doc/path.md - Another section

**Actions:**
- [ ] I have updated the documentation listed above
- [ ] Documentation not required for this change
  > Rationale: [provide brief explanation]

**Note:** PR approval blocked until documentation is verified or rationale provided.
```

## Success Criteria
- 95% of behavior-changing PRs include docs or rationale
- <1% false positives on doc requirements
- <10s analysis time for typical PRs
- Zero tolerance for quality issues

{{> claude.md.hbs}}
EOF
    echo "✓ Created Cleo-specific CLAUDE.md memory"
fi

# Create coding guidelines
cat > "$CLAUDE_WORK_DIR/coding-guidelines.md" << 'EOF'
{{> coding-guidelines.md.hbs}}
EOF

# Create GitHub guidelines  
cat > "$CLAUDE_WORK_DIR/github-guidelines.md" << 'EOF'
{{> github-guidelines.md.hbs}}
EOF

# Create MCP configuration
cat > "$CLAUDE_WORK_DIR/mcp.json" << 'EOF'
{{> mcp.json.hbs}}
EOF

# Setup hook scripts
echo "🔧 Setting up Cleo-specific hook scripts..."
mkdir -p "$CLAUDE_WORK_DIR/hooks"

{{#each hook_scripts}}
cat > "$CLAUDE_WORK_DIR/hooks/{{@key}}" << 'EOF'
{{{this}}}
EOF
chmod +x "$CLAUDE_WORK_DIR/hooks/{{@key}}"
{{/each}}

# Export environment for Claude
export CLAUDE_WORK_DIR
export GITHUB_TOKEN
export REPO_OWNER
export REPO_NAME
export TARGET_REPO_DIR

echo "════════════════════════════════════════════════════════════════"
echo "✅ CLEO CODE QUALITY AGENT READY"
echo "════════════════════════════════════════════════════════════════"
echo "📁 Working Directory: $CLAUDE_WORK_DIR"
echo "📦 Repository: $REPO_OWNER/$REPO_NAME"
echo "📋 Task: {{task_id}}"
echo "🎯 Focus: Code quality + Documentation enforcement"
echo "⚠️  CRITICAL: Must verify docs before adding 'ready-for-qa' label"
echo "════════════════════════════════════════════════════════════════"

# Start Claude with Cleo-specific configuration
cd "$CLAUDE_WORK_DIR"
exec /usr/local/bin/claude-cli "$@"