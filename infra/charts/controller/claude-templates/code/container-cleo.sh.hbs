#!/bin/sh

# Source Rust environment if available (fixes cargo not found issues)
if [ -f "$HOME/.cargo/env" ]; then
    . "$HOME/.cargo/env"
fi

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘              CLEO CODE QUALITY WORKFLOW STARTING             â•‘'
echo 'â•‘        Code Quality & Documentation Enforcement Agent        â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo "ðŸŽ¯ Agent: {{github_app}}"
echo "ðŸ” Focus: Code quality, formatting, and documentation verification"
echo "ðŸ“‹ Task ID: {{task_id}}"
echo "âœ… Mission: Relentless pursuit of 100% code quality and proper documentation"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication for code quality checks"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."
    
    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"
    
    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"
    
    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âš ï¸ Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âŒ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "Installation ID: $INSTALLATION_ID"
    
    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "âŒ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "âœ… Successfully authenticated with GitHub App"
    
    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"
    
    # Export the token for git to use
    export GITHUB_TOKEN
    
    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    
    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token
    
else
    echo "âŒ GitHub App credentials not found"
    exit 1
fi

# Target repository directory name - this is where the git repo will be
TARGET_REPO_DIR="{{#if working_directory}}{{working_directory}}{{else}}{{service}}{{/if}}"

# Set working directory for the agent - should match the repository location
CLAUDE_WORK_DIR="/workspace/$TARGET_REPO_DIR"
mkdir -p "$CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"
echo "ðŸ”§ Working directory set to: $CLAUDE_WORK_DIR"

# Prepare environment for QA checks
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ“Š PREPARING CODE QUALITY ENVIRONMENT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Configure Git identity 
git config --global user.email "cleo@5dlabs.com"
git config --global user.name "5DLabs-Cleo"
git config --global init.defaultBranch main

# =============================================================================
# AUTHENTICATION VERIFICATION
# =============================================================================
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” AUTHENTICATION VERIFICATION"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Repository URLs - Handle both full URLs and org/repo format
# Check if repository_url already contains https://github.com/
if echo "{{repository_url}}" | grep -q "^https://github.com/"; then
    REPO_HTTP_URL="{{repository_url}}"
    if ! echo "{{repository_url}}" | grep -q "\.git$"; then
        REPO_HTTP_URL="${REPO_HTTP_URL}.git"
    fi
else
    REPO_HTTP_URL="https://github.com/{{repository_url}}.git"
fi

# Same for docs repository
if echo "{{docs_repository_url}}" | grep -q "^https://github.com/"; then
    DOCS_HTTP_URL="{{docs_repository_url}}"
    if ! echo "{{docs_repository_url}}" | grep -q "\.git$"; then
        DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
    fi
else
    DOCS_HTTP_URL="https://github.com/{{docs_repository_url}}.git"
fi

# DEBUG: Show what URLs are being constructed
echo "ðŸ” DEBUG: URL Construction & Parameters"
echo "  Input repository_url: '{{repository_url}}'"
echo "  Input docs_repository_url: '{{docs_repository_url}}'"
echo "  Input docs_project_directory: '{{docs_project_directory}}'"
echo "  Input working_directory: '{{working_directory}}'"
echo "  Input docs_branch: '{{docs_branch}}'"
echo "  Input github_app: '{{github_app}}'"
echo "  Input task_id: '{{task_id}}'"
echo "  Input service: '{{service}}'"
echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
echo "  Current working directory: $(pwd)"
echo "  Available environment variables:"
env | grep -E "(GITHUB|ANTHROPIC)" | sort

# Test HTTPS access to repository
echo "ðŸ” DEBUG: Testing HTTPS repository access..."
echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
  echo "âœ“ HTTPS repository access successful"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Output: $(cat /tmp/repo_test.out | head -1)"
else
  echo "âŒ HTTPS repository access failed"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Error output: $(cat /tmp/repo_test.out)"
  echo "  Git credential helper status:"
  git config --list | grep credential || echo "  No credential helpers configured"
  echo ""
  echo "ðŸš« ABORTING: Cannot access repository via HTTPS"
  exit 1
fi

# Test docs repository access
echo "ðŸ” DEBUG: Testing docs repository access..."
echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
  echo "âœ“ Docs repository access successful"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Output: $(cat /tmp/docs_test.out | head -1)"
else
  echo "âŒ Docs repository access failed"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Error output: $(cat /tmp/docs_test.out)"
  echo ""
  echo "ðŸš« ABORTING: Cannot access docs repository via HTTPS"
  exit 1
fi

# Clone or update repository
if [ -d "$CLAUDE_WORK_DIR" ] && [ -d "$CLAUDE_WORK_DIR/.git" ]; then
    echo "ðŸ“ Found existing repository at '$CLAUDE_WORK_DIR', updating..."
    cd "$CLAUDE_WORK_DIR"
    git fetch origin
else
    echo "ðŸ“¥ Cloning repository to '$CLAUDE_WORK_DIR'..."
    REPO_HTTP_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO_OWNER}/${REPO_NAME}.git"
    if ! git clone "$REPO_HTTP_URL" "$CLAUDE_WORK_DIR"; then
        echo "âŒ Failed to clone repository"
        exit 1
    fi
    cd "$CLAUDE_WORK_DIR"
fi

# Checkout PR branch for quality review
if [ -n "$PR_NUMBER" ] && [ -n "$PR_URL" ]; then
    echo "ðŸ”„ Checking out PR #$PR_NUMBER for quality review..."
    cd "$CLAUDE_WORK_DIR"
    
    # Fetch all latest changes including PR branches
    git fetch origin --prune
    
    # Get PR branch information and checkout
    PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName' 2>/dev/null || echo "")
    if [ -n "$PR_BRANCH" ]; then
        echo "ðŸ“¦ Checking out PR branch: $PR_BRANCH"
        if git checkout "$PR_BRANCH" 2>/dev/null; then
            echo "ðŸ“¥ Pulling latest changes from $PR_BRANCH..."
            git pull origin "$PR_BRANCH" || echo "âš ï¸  Could not pull latest changes"
        elif git checkout -b "$PR_BRANCH" "origin/$PR_BRANCH" 2>/dev/null; then
            echo "âœ… Created and checked out tracking branch for $PR_BRANCH"
        else
            echo "âš ï¸  Branch checkout failed, trying GitHub CLI method..."
            gh pr checkout "$PR_NUMBER" || echo "âŒ Failed to checkout PR via gh CLI"
        fi
    else
        echo "âš ï¸  Could not determine PR branch name, using GitHub CLI to checkout PR directly"
        gh pr checkout "$PR_NUMBER" || echo "âŒ Failed to checkout PR"
    fi
    
    # Verify we're on the right commit
    CURRENT_SHA=$(git rev-parse HEAD)
    echo "ðŸ“ Current commit: $CURRENT_SHA"
    
    # Don't change directory yet - we'll cd to CLAUDE_WORK_DIR at the end
    echo "âœ… Repository positioned at PR #$PR_NUMBER with latest changes"
else
    echo "âš ï¸  No PR context found (PR_NUMBER=$PR_NUMBER, PR_URL=$PR_URL)"
    echo "ðŸ“‹ Will perform quality review on current repository state"
fi

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” CODE QUALITY ANALYSIS PREPARATION"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "MISSION: Enforce rigorous code quality standards:"
echo "1. Run Clippy pedantic checks on all Rust code changes"
echo "2. Verify code formatting with cargo fmt --check"
echo "3. Execute all tests with cargo test"
echo "4. Lint YAML files when YAML changes are detected"
echo "5. Add 'ready-for-qa' label only when all quality checks pass"
echo ""
echo "Quality Standards:"
echo "- Zero clippy warnings (pedantic level)"
echo "- Perfect code formatting"
echo "- 100% test passing rate"
echo "- Clean YAML syntax and structure"
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Task files should already be present in the project repository at /task
echo "ðŸ“‹ Checking for task files in project repository..."
if [ -d "$CLAUDE_WORK_DIR/task" ]; then
    echo "âœ“ Found task directory in project repository"
    ls -la "$CLAUDE_WORK_DIR/task/"
else
    echo "âš ï¸ No /task directory found in project repository"
fi

# Ensure we're in the git repository working directory  
echo "âœ“ Working directly in git repository at: $CLAUDE_WORK_DIR"

# Check if we should continue previous session
{{#if continue_session}}
echo "ðŸ“‚ Continuing from previous session..."
# Preserve existing CLAUDE.md if it exists
if [ -f "/workspace/CLAUDE.md" ]; then
    echo "âœ“ Found existing CLAUDE.md, preserving session memory"
fi
{{else}}
{{#if overwrite_memory}}
echo "ðŸ”„ Overwriting session memory as requested..."
rm -f /workspace/CLAUDE.md
{{/if}}
{{/if}}

# Generate configuration files from templates
echo "ðŸ”§ Generating Cleo-specific configuration files..."

# Enterprise managed settings are mounted directly from ConfigMap  
echo "=== ENTERPRISE MANAGED SETTINGS ==="
echo "âœ“ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
echo "âœ“ No copying needed - mount automatically reflects latest ConfigMap changes"

# Copy MCP client configuration from task files
if [ -f "/task-files/client-config.json" ]; then
  cp /task-files/client-config.json "$CLAUDE_WORK_DIR/client-config.json"
  echo "âœ“ client-config.json copied from ConfigMap"
  export MCP_CLIENT_CONFIG="$CLAUDE_WORK_DIR/client-config.json"
  echo "âœ“ MCP_CLIENT_CONFIG set to: $MCP_CLIENT_CONFIG"
else
  echo "âš ï¸ client-config.json not found in task-files - MCP client may not work correctly"
fi

# Check if CLAUDE.md already exists (created by controller)
if [ -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
    echo "âœ“ CLAUDE.md already exists (from controller), using existing file"
elif [ -f "/workspace/CLAUDE.md" ]; then
    echo "âœ“ Found CLAUDE.md in workspace, copying to working directory"
    cp "/workspace/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
else
    echo "ðŸ“ Creating Cleo-specific CLAUDE.md memory file"
    cat > "$CLAUDE_WORK_DIR/CLAUDE.md" << 'EOF'
# CLEO - Code Quality Enforcement Agent

## Agent Role
- **Primary**: Rigorous code quality enforcement and CI/CD maintenance
- **Focus**: Fix CI failures, resolve merge conflicts, enforce quality standards
- **Secondary**: YAML linting for infrastructure changes
- **Critical**: Add "ready-for-qa" label only when ALL quality checks pass

## PRIORITY TASKS

### 1. Merge Conflict Resolution (DO FIRST!)
Check for merge conflicts and resolve them immediately:
```bash
# Check if PR has conflicts
gh pr view {{pr_number}} --json mergeable,mergeStateStatus

# If conflicts exist:
git fetch origin main
git merge origin/main
# Resolve conflicts intelligently, preserving functionality
git add -A
git commit -m "fix: resolve merge conflicts with main"
git push
```

### 2. CI/CD Failure Fixes (HIGH PRIORITY)
Monitor CI status and fix any failures:
```bash
# Check CI status
gh pr checks {{pr_number}}

# Common fixes:
# - Fix linting errors (cargo fmt, black, eslint --fix)
# - Fix type errors
# - Update dependencies if needed
# - Fix test failures
# - Adjust CI configuration if needed
```

## Code Quality Requirements

### Change Detection Logic
Analyze git diff to determine appropriate quality checks:
```bash
RUST_CHANGES=$(git diff --name-only origin/main...HEAD | grep -E '\.(rs|toml)$' || true)
YAML_CHANGES=$(git diff --name-only origin/main...HEAD | grep -E '\.(yaml|yml)$' || true)
```

### Quality Check Execution
**For Rust Changes:**
1. `cargo clippy -- -D warnings -D clippy::pedantic` (zero tolerance)
2. `cargo fmt` (auto-fix formatting)
3. `cargo test` (all tests must pass)

**For YAML Changes:**
1. YAML syntax validation with yamllint
2. Auto-fix trailing spaces and formatting issues

### Error Handling
- Automatically fix formatting and linting issues
- Fix compilation errors if straightforward
- Update outdated dependencies if causing CI failures
- Never approve when quality checks fail after fixes

### GitHub Integration
- Monitor PR for CI failures and merge conflicts
- Fix issues proactively without waiting
- Post PR comments about fixes made
- Add "ready-for-qa" label only when CI is green
- Use GitHub CLI for all PR operations

## Success Criteria
- PR has no merge conflicts
- All CI checks passing (green)
- Zero clippy warnings at pedantic level
- Perfect code formatting consistency
- 100% test pass rate
- Clean YAML syntax and structure
EOF

    # Append base CLAUDE.md from ConfigMap if it exists
    if [ -f "/task-files/CLAUDE.md" ]; then
        echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md"
        cat "/task-files/CLAUDE.md" >> "$CLAUDE_WORK_DIR/CLAUDE.md"
        echo "âœ“ Appended base CLAUDE.md content from ConfigMap"
    fi
fi

# Copy guidelines files to working directory (match Rex pattern)
if [ -f "/task-files/coding-guidelines.md" ]; then
  cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "âœ“ Copied coding-guidelines.md to working directory"
fi

if [ -f "/task-files/github-guidelines.md" ]; then
  cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "âœ“ Copied github-guidelines.md to working directory"  
fi

# Copy MCP configuration from ConfigMap to project root (project scope)
if [ -f "/task-files/mcp.json" ]; then
  cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
  echo "âœ“ Copied mcp.json to .mcp.json (project scope)"
else
  echo "âš ï¸ mcp.json template not found"
fi

# Setup hook scripts
echo "ðŸ”§ Setting up Cleo-specific hook scripts..."
mkdir -p "$CLAUDE_WORK_DIR/hooks"

{{#each hook_scripts}}
cat > "$CLAUDE_WORK_DIR/hooks/{{@key}}" << 'EOF'
{{{this}}}
EOF
chmod +x "$CLAUDE_WORK_DIR/hooks/{{@key}}"
{{/each}}

# Export environment for Claude
export CLAUDE_WORK_DIR
export GITHUB_TOKEN
export REPO_OWNER
export REPO_NAME
export TARGET_REPO_DIR

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "âœ… CLEO CODE QUALITY AGENT READY"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ“ Working Directory: $CLAUDE_WORK_DIR"
echo "ðŸ“¦ Repository: $REPO_OWNER/$REPO_NAME"
echo "ðŸ“‹ Task: {{task_id}}"
echo "ðŸŽ¯ Focus: Rigorous code quality enforcement"
echo "âš ï¸  CRITICAL: Must pass all quality checks before adding 'ready-for-qa' label"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Export necessary variables for Claude execution
export SERVICE_NAME="{{service}}"
export TASK_ID="{{task_id}}"
export GITHUB_APP="{{github_app}}"

# Start Claude with Cleo-specific configuration
cd "$CLAUDE_WORK_DIR"

# Build Claude command
CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Create Cleo's static prompt
echo "âœ“ Creating Cleo's static code quality enforcement prompt"

# Build static prompt with task context
CLEO_PROMPT="# Code Quality Review Assignment

You are Cleo, a rigorous code quality enforcement agent. Your mission is to ensure zero-tolerance quality standards for this pull request.

## Your Role
- **Primary Focus**: Code quality enforcement using automated tools
- **Quality Tools**: Clippy (pedantic), cargo fmt, cargo test, YAML linting
- **Decision Authority**: Add 'ready-for-qa' label only when ALL quality checks pass
- **Standards**: Zero warnings, perfect formatting, 100% test pass rate

## Current Context

### Pull Request Information
- **PR Number**: ${PR_NUMBER:-"Not specified"}
- **PR URL**: ${PR_URL:-"Not specified"}  
- **Repository**: $REPO_OWNER/$REPO_NAME
- **Working Directory**: $CLAUDE_WORK_DIR"

# Add task context if available
if [ -f "$CLAUDE_WORK_DIR/task/task.md" ]; then
    CLEO_PROMPT="$CLEO_PROMPT

### Task Information (for context)
$(cat "$CLAUDE_WORK_DIR/task/task.md")

### Task Requirements (Rex was asked to implement)
$(cat "$CLAUDE_WORK_DIR/task/prompt.md" 2>/dev/null || echo "No prompt.md found")

### Acceptance Criteria (what Rex needed to achieve)  
$(cat "$CLAUDE_WORK_DIR/task/acceptance-criteria.md" 2>/dev/null || echo "No acceptance-criteria.md found")

### Architecture Reference (if available)
$(cat "$CLAUDE_WORK_DIR/task/architecture.md" 2>/dev/null || echo "No architecture.md found")"
else
    CLEO_PROMPT="$CLEO_PROMPT

### Task Information
No task files found in /task directory - proceeding with general code quality review."
fi

# Complete the prompt
CLEO_PROMPT="$CLEO_PROMPT

## Your Instructions
1. **Analyze the PR changes**: The repository has been automatically positioned at the PR branch with latest changes
2. **Detect change types**: Identify Rust files (.rs, .toml) and YAML files (.yml, .yaml) 
3. **Run quality checks**:
   - For Rust: cargo clippy (pedantic), cargo fmt --check, cargo test
   - For YAML: YAML linting and validation
4. **Fix any issues found**:
   - If formatting issues: Run cargo fmt to fix them
   - If minor code issues: Fix them directly
   - Commit and push all fixes to the current feature branch
5. **Review against task requirements**: Verify implementation matches acceptance criteria
6. **Report results**: Provide detailed summary of checks performed and any fixes applied
7. **Success criteria**: Quality checks must pass (after any fixes) for approval

## Quality Standards
- **Zero tolerance** for clippy warnings (even at pedantic level)
- **Perfect formatting** required (cargo fmt --check must pass)
- **All tests pass** (cargo test must succeed)
- **Clean YAML** syntax and structure
- **Task compliance** (implementation should meet acceptance criteria)

Begin your code quality review now."

# Debug: Print the actual prompt and CLAUDE.md content
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” DEBUG: CLEO PROMPT CONTENT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "$CLEO_PROMPT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” DEBUG: CLAUDE.md MEMORY CONTENT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
if [ -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
    cat "$CLAUDE_WORK_DIR/CLAUDE.md"
else
    echo "âŒ No CLAUDE.md found at $CLAUDE_WORK_DIR/CLAUDE.md"
fi
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Send the static prompt to Claude
FIFO_PATH="/workspace/agent-input.jsonl"
rm -f "$FIFO_PATH" 2>/dev/null || true
mkfifo "$FIFO_PATH"
chmod 666 "$FIFO_PATH" || true

# Start Claude (reader) first in background
$CLAUDE_CMD < "$FIFO_PATH" &
CLAUDE_PID=$!

# Compose initial user turn with the static prompt
USER_COMBINED=$(printf "%s" "$CLEO_PROMPT" | jq -Rs .)

# Send via sidecar HTTP endpoint
if printf '{"text":%s}\n' "$USER_COMBINED" | \
     curl -fsS -X POST http://127.0.0.1:8080/input \
       -H 'Content-Type: application/json' \
       --data-binary @- >/dev/null 2>&1; then
  echo "âœ“ Static Cleo prompt sent via sidecar /input"
else
  echo "âš ï¸ Sidecar /input failed, falling back to direct FIFO write"
  exec 9>"$FIFO_PATH"
  printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}\n' "$USER_COMBINED" >&9
  exec 9>&- 2>/dev/null || true  # Close immediately
fi

# Wait for Claude process to complete
wait "$CLAUDE_PID"
CLAUDE_EXIT_CODE=$?

# Add ready-for-qa label if Claude completed successfully
if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
  echo "âœ… Claude quality review completed successfully"
  
  # Determine OWNER/REPO slug for gh -R
  REPO_INPUT="{{repository_url}}"
  if echo "$REPO_INPUT" | grep -q "^https://github.com/"; then
    REPO_SLUG=$(echo "$REPO_INPUT" | sed -E 's|https://github.com/([^/]+/[^/.]+)(\.git)?$|\1|')
  else
    REPO_SLUG="$REPO_INPUT"
  fi

  # Post quality review comment to PR
  if [ -n "$PR_NUMBER" ] || [ -n "$PR_URL" ]; then
    echo "ðŸ’¬ Posting quality review comment to PR..."
    
    # Create comment body with quality review summary
    COMMENT_BODY="## ðŸ” Code Quality Review by Cleo

âœ… **Quality checks completed successfully**

### Review Summary
- Code has been reviewed for quality standards
- All required checks have passed
- Ready for QA testing

---
*Reviewed by Cleo - 5DLabs Code Quality Agent*"
    
    # Post comment using PR number or URL
    if [ -n "$PR_NUMBER" ]; then
      if echo "$COMMENT_BODY" | gh pr comment "$PR_NUMBER" -R "$REPO_SLUG" --body-file - 2>/dev/null; then
        echo "âœ… Successfully posted quality review comment"
      else
        echo "âš ï¸ Failed to post comment using PR number"
      fi
    elif [ -n "$PR_URL" ]; then
      if echo "$COMMENT_BODY" | gh pr comment "$PR_URL" --body-file - 2>/dev/null; then
        echo "âœ… Successfully posted quality review comment"
      else
        echo "âš ï¸ Failed to post comment"
      fi
    fi
  fi

  # Add the ready-for-qa label using PR number if available; fallback to PR URL
  if [ -n "$PR_NUMBER" ]; then
    echo "ðŸ·ï¸ Adding 'ready-for-qa' label to PR #$PR_NUMBER..."
    if gh pr edit "$PR_NUMBER" -R "$REPO_SLUG" --add-label "ready-for-qa" 2>/dev/null; then
      echo "âœ… Successfully added 'ready-for-qa' label"
    else
      echo "âš ï¸ Failed to add label using PR number - attempting with PR URL..."
      if [ -n "$PR_URL" ]; then
        if gh pr edit "$PR_URL" --add-label "ready-for-qa" 2>/dev/null; then
          echo "âœ… Successfully added 'ready-for-qa' label using PR URL"
        else
          echo "âŒ Failed to add 'ready-for-qa' label"
        fi
      fi
    fi
  elif [ -n "$PR_URL" ]; then
    echo "ðŸ·ï¸ Adding 'ready-for-qa' label using PR URL..."
    if gh pr edit "$PR_URL" --add-label "ready-for-qa" 2>/dev/null; then
      echo "âœ… Successfully added 'ready-for-qa' label"
    else
      echo "âŒ Failed to add 'ready-for-qa' label"
    fi
  else
    echo "âš ï¸ No PR_NUMBER or PR_URL available, cannot add label"
  fi
else
  echo "âš ï¸ Claude process exited with code: $CLAUDE_EXIT_CODE - not adding label"
fi

# Gracefully stop sidecar (with enhanced debugging and retries)
echo "ðŸ”§ Attempting sidecar shutdown..."
shutdown_attempts=0
max_shutdown_attempts=3

while [ $shutdown_attempts -lt $max_shutdown_attempts ]; do
  if curl -fsS -X POST http://127.0.0.1:8080/shutdown -m 5 2>/dev/null; then
    echo "âœ“ Sidecar shutdown request successful (attempt $((shutdown_attempts + 1)))"
    break
  else
    shutdown_attempts=$((shutdown_attempts + 1))
    echo "âš ï¸ Sidecar shutdown request failed (attempt $shutdown_attempts/$max_shutdown_attempts)"
    if [ $shutdown_attempts -lt $max_shutdown_attempts ]; then
      echo "Retrying in 2 seconds..."
      sleep 2
    fi
  fi
done

if [ $shutdown_attempts -eq $max_shutdown_attempts ]; then
  echo "âŒ Failed to shutdown sidecar after $max_shutdown_attempts attempts"
  echo "ðŸ”§ Force terminating sidecar processes..."
  pkill -f "sidecar" || echo "No sidecar processes found to kill"
fi

# Wait for sidecar to actually terminate
echo "â³ Waiting for sidecar termination..."
timeout=10
while [ $timeout -gt 0 ]; do
  if ! pgrep -f "sidecar" > /dev/null 2>&1; then
    echo "âœ… Sidecar terminated successfully"
    break
  fi
  sleep 1
  timeout=$((timeout - 1))
done

if [ $timeout -eq 0 ]; then
  echo "âš ï¸ Sidecar still running after wait period"
fi

# Cleanup and exit
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                  CLEO CODE QUALITY COMPLETE                  â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ“‹ Task: {{task_id}}"
echo "âœ… Code quality checks completed"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Final termination sequence
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ”š TERMINATING CLEO CONTAINER"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "Claude Exit Code: $CLAUDE_EXIT_CODE"
echo "Container PID: $$"
echo "Final Process Check:"
ps aux | head -5

# Write completion marker for workflow tracking
echo "cleo-quality-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.cleo-complete

# Cleanup FIFO
rm -f "$FIFO_PATH" 2>/dev/null || true

# Force exit to ensure container termination
echo "ðŸ”š Force terminating container..."
exit $CLAUDE_EXIT_CODE