#!/bin/sh

# Ensure Rust environment is always properly set up
echo "ðŸ”§ Setting up Rust environment..."

# Source Rust environment if available (fixes cargo not found issues)
if [ -f "$HOME/.cargo/env" ]; then
    . "$HOME/.cargo/env"
    echo "âœ“ Sourced Rust environment from $HOME/.cargo/env"
fi

# Also try root cargo env as fallback
if [ -f "/root/.cargo/env" ]; then
    . "/root/.cargo/env"
    echo "âœ“ Sourced Rust environment from /root/.cargo/env"
fi

# Ensure rustup has a default toolchain set
if command -v rustup >/dev/null 2>&1; then
    rustup default stable 2>/dev/null || true
    echo "âœ“ Ensured stable Rust toolchain is default"
else
    echo "âš ï¸ rustup not found in PATH"
fi

# Verify Rust is available
if command -v cargo >/dev/null 2>&1; then
    echo "âœ“ Cargo is available: $(cargo --version)"
else
    echo "âŒ Cargo not found in PATH"
    echo "Current PATH: $PATH"
    echo "Attempting to find cargo..."
    find /usr -name cargo 2>/dev/null | head -5 || echo "No cargo found in /usr"
    find /home -name cargo 2>/dev/null | head -5 || echo "No cargo found in /home"
fi

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘              CLEO CODE QUALITY WORKFLOW STARTING             â•‘'
echo 'â•‘     Code Quality & CI/CD Pipeline Enforcement Agent          â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo "ðŸŽ¯ Agent: {{github_app}}"
echo "ðŸ” Focus: Code quality, CI/CD setup, and Docker image building"
echo "ðŸ“‹ Task ID: {{task_id}}"
echo "âœ… Mission: Perfect code quality AND working CI/CD pipeline with Docker builds"

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication for code quality checks"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."
    
    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"
    
    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    
    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"
    
    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"
    
    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."
    
    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âš ï¸ Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "âŒ Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "Installation ID: $INSTALLATION_ID"
    
    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
    
    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
    
    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "âŒ Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi
    
    echo "âœ… Successfully authenticated with GitHub App"
    
    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"
    
    # Export the token for git to use
    export GITHUB_TOKEN
    
    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    
    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token
    
else
    echo "âŒ GitHub App credentials not found"
    exit 1
fi

# Target repository directory name - this is where the git repo will be
TARGET_REPO_DIR="{{#if working_directory}}{{working_directory}}{{else}}{{service}}{{/if}}"

# Set working directory for the agent - should match the repository location
CLAUDE_WORK_DIR="/workspace/$TARGET_REPO_DIR"
mkdir -p "$CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"
echo "ðŸ”§ Working directory set to: $CLAUDE_WORK_DIR"

# Prepare environment for QA checks
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ“Š PREPARING CODE QUALITY ENVIRONMENT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Configure Git identity 
git config --global user.email "cleo@5dlabs.com"
git config --global user.name "5DLabs-Cleo"
git config --global init.defaultBranch main

# =============================================================================
# AUTHENTICATION VERIFICATION
# =============================================================================
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” AUTHENTICATION VERIFICATION"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Repository URLs - Handle both full URLs and org/repo format
# Check if repository_url already contains https://github.com/
if echo "{{repository_url}}" | grep -q "^https://github.com/"; then
    REPO_HTTP_URL="{{repository_url}}"
    if ! echo "{{repository_url}}" | grep -q "\.git$"; then
        REPO_HTTP_URL="${REPO_HTTP_URL}.git"
    fi
else
    REPO_HTTP_URL="https://github.com/{{repository_url}}.git"
fi

# Same for docs repository
if echo "{{docs_repository_url}}" | grep -q "^https://github.com/"; then
    DOCS_HTTP_URL="{{docs_repository_url}}"
    if ! echo "{{docs_repository_url}}" | grep -q "\.git$"; then
        DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
    fi
else
    DOCS_HTTP_URL="https://github.com/{{docs_repository_url}}.git"
fi

# DEBUG: Show what URLs are being constructed
echo "ðŸ” DEBUG: URL Construction & Parameters"
echo "  Input repository_url: '{{repository_url}}'"
echo "  Input docs_repository_url: '{{docs_repository_url}}'"
echo "  Input docs_project_directory: '{{docs_project_directory}}'"
echo "  Input working_directory: '{{working_directory}}'"
echo "  Input docs_branch: '{{docs_branch}}'"
echo "  Input github_app: '{{github_app}}'"
echo "  Input task_id: '{{task_id}}'"
echo "  Input service: '{{service}}'"
echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
echo "  Current working directory: $(pwd)"
echo "  Available environment variables:"
env | grep -E "(GITHUB|ANTHROPIC)" | sort

# Test HTTPS access to repository
echo "ðŸ” DEBUG: Testing HTTPS repository access..."
echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
  echo "âœ“ HTTPS repository access successful"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Output: $(cat /tmp/repo_test.out | head -1)"
else
  echo "âŒ HTTPS repository access failed"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Error output: $(cat /tmp/repo_test.out)"
  echo "  Git credential helper status:"
  git config --list | grep credential || echo "  No credential helpers configured"
  echo ""
  echo "ðŸš« ABORTING: Cannot access repository via HTTPS"
  exit 1
fi

# Test docs repository access
echo "ðŸ” DEBUG: Testing docs repository access..."
echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
  echo "âœ“ Docs repository access successful"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Output: $(cat /tmp/docs_test.out | head -1)"
else
  echo "âŒ Docs repository access failed"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Error output: $(cat /tmp/docs_test.out)"
  echo ""
  echo "ðŸš« ABORTING: Cannot access docs repository via HTTPS"
  exit 1
fi

# Clone or update repository
if [ -d "$CLAUDE_WORK_DIR" ] && [ -d "$CLAUDE_WORK_DIR/.git" ]; then
    echo "ðŸ“ Found existing repository at '$CLAUDE_WORK_DIR', updating..."
    cd "$CLAUDE_WORK_DIR"
    git fetch origin
else
    echo "ðŸ“¥ Cloning repository to '$CLAUDE_WORK_DIR'..."
    # Use the REPO_HTTP_URL constructed in authentication verification section
    if ! git clone "$REPO_HTTP_URL" "$CLAUDE_WORK_DIR"; then
        echo "âŒ Failed to clone repository"
        exit 1
    fi
    cd "$CLAUDE_WORK_DIR"
fi

# Checkout PR branch for quality review
if [ -n "$PR_NUMBER" ] && [ -n "$PR_URL" ]; then
    echo "ðŸ”„ Checking out PR #$PR_NUMBER for quality review..."
    cd "$CLAUDE_WORK_DIR"
    
    # Fetch all latest changes including PR branches
    git fetch origin --prune
    
    # Get PR branch information and checkout
    PR_BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName' 2>/dev/null || echo "")
    if [ -n "$PR_BRANCH" ]; then
        echo "ðŸ“¦ Checking out PR branch: $PR_BRANCH"
        if git checkout "$PR_BRANCH" 2>/dev/null; then
            echo "ðŸ“¥ Pulling latest changes from $PR_BRANCH..."
            git pull origin "$PR_BRANCH" || echo "âš ï¸  Could not pull latest changes"
        elif git checkout -b "$PR_BRANCH" "origin/$PR_BRANCH" 2>/dev/null; then
            echo "âœ… Created and checked out tracking branch for $PR_BRANCH"
        else
            echo "âš ï¸  Branch checkout failed, trying GitHub CLI method..."
            gh pr checkout "$PR_NUMBER" || echo "âŒ Failed to checkout PR via gh CLI"
        fi
    else
        echo "âš ï¸  Could not determine PR branch name, using GitHub CLI to checkout PR directly"
        gh pr checkout "$PR_NUMBER" || echo "âŒ Failed to checkout PR"
    fi
    
    # Verify we're on the right commit
    CURRENT_SHA=$(git rev-parse HEAD)
    echo "ðŸ“ Current commit: $CURRENT_SHA"
    
    # Don't change directory yet - we'll cd to CLAUDE_WORK_DIR at the end
    echo "âœ… Repository positioned at PR #$PR_NUMBER with latest changes"
else
    echo "âš ï¸  No PR context found (PR_NUMBER=$PR_NUMBER, PR_URL=$PR_URL)"
    echo "ðŸ“‹ Will perform quality review on current repository state"
fi

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” CODE QUALITY ANALYSIS PREPARATION"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "MISSION: Enforce rigorous code quality standards:"
echo "1. Run Clippy pedantic checks on all Rust code changes"
echo "2. Verify code formatting with cargo fmt --check"
echo "3. Execute all tests with cargo test"
echo "4. Lint YAML files when YAML changes are detected"
echo "5. Add 'ready-for-qa' label only when all quality checks pass"
echo ""
echo "Quality Standards:"
echo "- Zero clippy warnings (pedantic level)"
echo "- Perfect code formatting"
echo "- 100% test passing rate"
echo "- Clean YAML syntax and structure"
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Task files should already be present in the project repository at /task
echo "ðŸ“‹ Checking for task files in project repository..."
if [ -d "$CLAUDE_WORK_DIR/task" ]; then
    echo "âœ“ Found task directory in project repository"
    ls -la "$CLAUDE_WORK_DIR/task/"
else
    echo "âš ï¸ No /task directory found in project repository"
fi

# Ensure we're in the git repository working directory  
echo "âœ“ Working directly in git repository at: $CLAUDE_WORK_DIR"

# Check if we should continue previous session
{{#if continue_session}}
echo "ðŸ“‚ Continuing from previous session..."
# Preserve existing CLAUDE.md if it exists
if [ -f "/workspace/CLAUDE.md" ]; then
    echo "âœ“ Found existing CLAUDE.md, preserving session memory"
fi
{{else}}
{{#if overwrite_memory}}
echo "ðŸ”„ Overwriting session memory as requested..."
rm -f /workspace/CLAUDE.md
{{/if}}
{{/if}}

# Generate configuration files from templates
echo "ðŸ”§ Generating Cleo-specific configuration files..."

# Enterprise managed settings are mounted directly from ConfigMap  
echo "=== ENTERPRISE MANAGED SETTINGS ==="
echo "âœ“ Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
echo "âœ“ No copying needed - mount automatically reflects latest ConfigMap changes"

# Copy MCP client configuration from task files
if [ -f "/task-files/client-config.json" ]; then
  cp /task-files/client-config.json "$CLAUDE_WORK_DIR/client-config.json"
  echo "âœ“ client-config.json copied from ConfigMap"
  export MCP_CLIENT_CONFIG="$CLAUDE_WORK_DIR/client-config.json"
  echo "âœ“ MCP_CLIENT_CONFIG set to: $MCP_CLIENT_CONFIG"
else
  echo "âš ï¸ client-config.json not found in task-files - MCP client may not work correctly"
fi

# Check if CLAUDE.md already exists (created by controller)
if [ -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
    echo "âœ“ CLAUDE.md already exists (from controller), using existing file"
elif [ -f "/workspace/CLAUDE.md" ]; then
    echo "âœ“ Found CLAUDE.md in workspace, copying to working directory"
    cp "/workspace/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
else
    echo "ðŸ“ Creating Cleo-specific CLAUDE.md memory file"
    cat > "$CLAUDE_WORK_DIR/CLAUDE.md" << 'EOF'
# CLEO - Code Quality Enforcement Agent

## Agent Role
- **Primary**: Rigorous code quality enforcement and CI/CD maintenance
- **Focus**: Fix CI failures, resolve merge conflicts, enforce quality standards
- **Secondary**: YAML linting for infrastructure changes
- **Critical**: Add "ready-for-qa" label only when ALL quality checks pass

## PRIORITY TASKS

### 1. Merge Conflict Resolution (DO FIRST!)
Check for merge conflicts and resolve them immediately:
```bash
# Check if PR has conflicts
gh pr view {{pr_number}} --json mergeable,mergeStateStatus

# If conflicts exist:
git fetch origin main
git merge origin/main
# Resolve conflicts intelligently, preserving functionality
git add -A
git commit -m "fix: resolve merge conflicts with main"
git push
```

### 2. CI/CD Failure Fixes (HIGH PRIORITY)
Monitor CI status and fix any failures OR stuck jobs:
```bash
# Check CI status - look for BOTH failures AND stuck jobs
gh pr checks {{pr_number}}
# Get PR branch dynamically
PR_BRANCH=$(gh pr view {{pr_number}} --json headRefName -q .headRefName)
gh run list --branch="$PR_BRANCH" --limit 5

# If jobs are stuck/not starting:
# 1. Check workflow syntax:
cat .github/workflows/*.yml | head -50
# 2. Verify runner labels exist
# 3. Check for workflow errors in GitHub UI

# Common fixes for stuck jobs:
# - Fix 'runs-on:' to use valid runner (ubuntu-latest, ubuntu-22.04, etc.)
# - Fix action versions (e.g., actions/checkout@v4)
# - Ensure workflow triggers match (push, pull_request)
# - Remove or fix invalid workflow syntax

# Common fixes for failed jobs:
# - Fix linting errors (cargo fmt, black, eslint --fix)
# - Fix type errors
# - Update dependencies if needed
# - Fix test failures
# - Adjust CI configuration if needed
```

## Code Quality Requirements

### Change Detection Logic
Analyze git diff to determine appropriate quality checks:
```bash
RUST_CHANGES=$(git diff --name-only origin/main...HEAD | grep -E '\.(rs|toml)$' || true)
YAML_CHANGES=$(git diff --name-only origin/main...HEAD | grep -E '\.(yaml|yml)$' || true)
```

### Quality Check Execution
**For Rust Changes:**
1. `cargo clippy -- -D warnings -D clippy::pedantic` (zero tolerance)
2. `cargo fmt` (auto-fix formatting)
3. `cargo test` (all tests must pass)

**For YAML Changes:**
1. YAML syntax validation with yamllint
2. Auto-fix trailing spaces and formatting issues

### Error Handling
- Automatically fix formatting and linting issues
- Fix compilation errors if straightforward
- Update outdated dependencies if causing CI failures
- Never approve when quality checks fail after fixes

### GitHub Integration
- Monitor PR for CI failures and merge conflicts
- Fix issues proactively without waiting
- Post PR comments about fixes made
- Add "ready-for-qa" label only when CI is green
- Use GitHub CLI for all PR operations

## Success Criteria
- PR has no merge conflicts
- All CI checks passing (green)
- Zero clippy warnings at pedantic level
- Perfect code formatting consistency
- 100% test pass rate
- Clean YAML syntax and structure
EOF

    # Append base CLAUDE.md from ConfigMap if it exists
    if [ -f "/task-files/CLAUDE.md" ]; then
        echo "" >> "$CLAUDE_WORK_DIR/CLAUDE.md"
        cat "/task-files/CLAUDE.md" >> "$CLAUDE_WORK_DIR/CLAUDE.md"
        echo "âœ“ Appended base CLAUDE.md content from ConfigMap"
    fi
fi

# Copy guidelines files to working directory (match Rex pattern)
if [ -f "/task-files/coding-guidelines.md" ]; then
  cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "âœ“ Copied coding-guidelines.md to working directory"
fi

if [ -f "/task-files/github-guidelines.md" ]; then
  cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
  echo "âœ“ Copied github-guidelines.md to working directory"  
fi

# Copy MCP configuration from ConfigMap to project root (project scope)
if [ -f "/task-files/mcp.json" ]; then
  cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
  echo "âœ“ Copied mcp.json to .mcp.json (project scope)"
else
  echo "âš ï¸ mcp.json template not found"
fi

# Setup hook scripts
echo "ðŸ”§ Setting up Cleo-specific hook scripts..."
mkdir -p "$CLAUDE_WORK_DIR/hooks"

{{#each hook_scripts}}
cat > "$CLAUDE_WORK_DIR/hooks/{{@key}}" << 'EOF'
{{{this}}}
EOF
chmod +x "$CLAUDE_WORK_DIR/hooks/{{@key}}"
{{/each}}

# Export environment for Claude
export CLAUDE_WORK_DIR
export GITHUB_TOKEN
export REPO_OWNER
export REPO_NAME
export TARGET_REPO_DIR

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "âœ… CLEO CODE QUALITY AGENT READY"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ“ Working Directory: $CLAUDE_WORK_DIR"
echo "ðŸ“¦ Repository: $REPO_OWNER/$REPO_NAME"
echo "ðŸ“‹ Task: {{task_id}}"
echo "ðŸŽ¯ Focus: Rigorous code quality enforcement"
echo "âš ï¸  CRITICAL: Must pass all quality checks before adding 'ready-for-qa' label"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Export necessary variables for Claude execution
export SERVICE_NAME="{{service}}"
export TASK_ID="{{task_id}}"
export GITHUB_APP="{{github_app}}"

# Start Claude with Cleo-specific configuration
cd "$CLAUDE_WORK_DIR"

# Build Claude command
CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Create Cleo's static prompt
echo "âœ“ Creating Cleo's static code quality enforcement prompt"

# Build static prompt with task context
CLEO_PROMPT="# Code Quality Review Assignment

You are Cleo, a rigorous code quality enforcement agent. Your mission is to ensure zero-tolerance quality standards for this pull request.

## Your Role
- **Primary Focus**: Code quality enforcement AND CI/CD pipeline setup
- **Quality Tools**: Clippy (pedantic), cargo fmt, cargo test, YAML linting
- **DevOps Setup**: GitHub Actions workflows, Docker image building, CI verification
- **Decision Authority**: Add 'ready-for-qa' label only when ALL quality checks AND CI builds pass
- **Standards**: Zero warnings, perfect formatting, 100% test pass rate, working Docker builds

## Current Context

### Pull Request Information
- **PR Number**: ${PR_NUMBER:-"Not specified"}
- **PR URL**: ${PR_URL:-"Not specified"}  
- **Repository**: $REPO_OWNER/$REPO_NAME
- **Working Directory**: $CLAUDE_WORK_DIR"

# Add task context if available
if [ -f "$CLAUDE_WORK_DIR/task/task.md" ]; then
    CLEO_PROMPT="$CLEO_PROMPT

### Task Information (for context)
$(cat "$CLAUDE_WORK_DIR/task/task.md")

### Task Requirements (Rex was asked to implement)
$(cat "$CLAUDE_WORK_DIR/task/prompt.md" 2>/dev/null || echo "No prompt.md found")

### Acceptance Criteria (what Rex needed to achieve)  
$(cat "$CLAUDE_WORK_DIR/task/acceptance-criteria.md" 2>/dev/null || echo "No acceptance-criteria.md found")

### Architecture Reference (if available)
$(cat "$CLAUDE_WORK_DIR/task/architecture.md" 2>/dev/null || echo "No architecture.md found")"
else
    CLEO_PROMPT="$CLEO_PROMPT

### Task Information
No task files found in /task directory - proceeding with general code quality review."
fi

# Complete the prompt
CLEO_PROMPT="$CLEO_PROMPT

## Your Instructions
1. **Analyze the PR changes**: The repository has been automatically positioned at the PR branch with latest changes
2. **Detect change types**: Identify Rust files (.rs, .toml) and YAML files (.yml, .yaml) 
3. **Run quality checks**:
   - For Rust: cargo clippy -- -D warnings -W clippy::pedantic
   - Run cargo fmt to fix any formatting issues
   - For YAML: YAML linting and validation
   - IMPORTANT: Commit and push ALL fixes immediately (don't wait until the end)
   - NOTE: Do NOT write tests - Tess handles all testing
4. **Set up CI/CD Pipeline (CRITICAL - Use These EXACT Patterns)**:
   - Check if .github/workflows/ci.yml exists (or similar CI workflow)
   - If not, create using these PROVEN TEMPLATES:
   
   **a) Dockerfile (Runtime-only, expects pre-built binary):**
   ```dockerfile
   FROM debian:bookworm-slim
   RUN apt-get update && apt-get install -y \
       ca-certificates libssl3 wget --no-install-recommends \
       && rm -rf /var/lib/apt/lists/* && apt-get clean
   RUN useradd -r -u 1000 -m -d /app -s /bin/bash app
   WORKDIR /app
   COPY <binary-name> /app/<binary-name>
   RUN chmod +x /app/<binary-name> && chown -R app:app /app
   USER app
   EXPOSE 8080
   HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
       CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1
   CMD ["./<binary-name>"]
   ```
   
   **b) CI Workflow (.github/workflows/ci.yml):**
   ```yaml
   name: Continuous Integration
   on:
     push:
       branches: [main]
     pull_request:
       branches: [main]
   
   jobs:
     lint-rust:
       runs-on: ubuntu-22.04
       steps:
         - uses: actions/checkout@v4
         - uses: actions-rust-lang/setup-rust-toolchain@v1
           with:
             toolchain: stable
             components: rustfmt, clippy
         - uses: Swatinem/rust-cache@v2
           with:
             workspaces: . -> target
             shared-key: "rust-cache-ci"
         - name: Format check
           run: cargo fmt --all -- --check
         - name: Clippy
           run: cargo clippy --all-targets --all-features -- -D warnings -W clippy::pedantic
   
     test-rust:
       runs-on: ubuntu-22.04
       steps:
         - uses: actions/checkout@v4
         - uses: actions-rust-lang/setup-rust-toolchain@v1
           with:
             toolchain: stable
         - uses: Swatinem/rust-cache@v2
           with:
             workspaces: . -> target
             shared-key: "rust-cache-ci"
         - name: Run tests
           run: cargo test --all-features --all-targets
   ```
   
   **c) Deploy Workflow (.github/workflows/deploy.yml) for k8s-runner:**
   ```yaml
   name: Deploy
   on:
     push:
       branches: [main, develop, feature/*, feat/*, fix/*]
   
   env:
     REGISTRY: ghcr.io
     IMAGE_BASE: ${{ github.repository_owner }}
   
   jobs:
     build:
       runs-on: [k8s-runner]  # Use self-hosted runner for speed
       permissions:
         contents: read
         packages: write
       steps:
         - uses: actions/checkout@v4
         - name: Build binary
           env:
             RUSTC_WRAPPER: "sccache"
             CARGO_TARGET_DIR: "$HOME/cache/target"
           run: |
             cargo build --release
             cp $HOME/cache/target/release/<binary> ./<binary>
         - uses: docker/setup-buildx-action@v3
         - uses: docker/login-action@v3
           with:
             registry: ghcr.io
             username: ${{ github.actor }}
             password: ${{ secrets.GITHUB_TOKEN }}
         - uses: docker/build-push-action@v5
           with:
             context: .
             file: ./Dockerfile
             platforms: linux/amd64,linux/arm64
             push: true
             tags: |
               ghcr.io/${{ github.repository }}:latest
               ghcr.io/${{ github.repository }}:${{ github.sha }}
             cache-from: type=gha
             cache-to: type=gha,mode=max
   ```
   
   - Commit and push the CI configuration
   - Push any code fixes you made locally
   - Use 'gh workflow run' to trigger the build if needed
   - Use 'gh run list' and 'gh run view' to monitor status
   - **WATCH FOR STUCK JOBS**: If jobs show "Waiting" > 2 min:
     * Check runner availability and labels
     * Verify workflow syntax is correct
     * Fix any workflow configuration issues
   - KEEP ITERATING: Fix issues, push, check CI, repeat until ALL JOBS RUN AND PASS
5. **Verify CI Success (THE ONLY MEASURE OF SUCCESS)**:
   - Use 'gh pr checks {{pr_number}}' to confirm ALL checks are passing
   - **CRITICAL: Check for stuck/pending jobs**:
     * Look for jobs showing "Waiting" or "Pending" for > 2 minutes
     * Check 'gh run list --branch=$(gh pr view {{pr_number}} --json headRefName -q .headRefName)' for workflow status
     * If jobs aren't starting, investigate:
       - Missing runner labels? Check 'runs-on:' in workflow
       - Workflow syntax errors? Validate with 'actionlint' or GitHub UI
       - Missing workflow triggers? Check 'on:' section
       - Concurrency limits? Check workflow 'concurrency:' settings
   - **Common fixes for stuck jobs**:
     * Add/fix 'runs-on: ubuntu-latest' (or appropriate runner)
     * Remove invalid actions or fix version tags
     * Ensure workflow file is in .github/workflows/
     * Check if workflow needs to be enabled in Actions settings
   - Specifically verify 'cargo clippy -- -D warnings -W clippy::pedantic' passes in CI
   - SUCCESS = ALL jobs completed successfully (not just "not failed")
   - Do NOT proceed until GitHub shows ALL green checks
6. **Review against task requirements**: Verify implementation matches acceptance criteria
7. **Report results**: Provide detailed summary of checks performed, CI setup, and any fixes applied
8. **Success criteria**: Quality checks AND Docker build must pass for approval

## Quality Standards (MUST PASS IN GITHUB ACTIONS, NOT JUST LOCALLY!)
- **Zero tolerance** for clippy warnings at pedantic level IN GITHUB ACTIONS
- **Perfect formatting** required (cargo fmt --check must pass IN CI)
- **All tests pass** (cargo test must succeed IN CI)
- **Clean YAML** syntax and structure
- **CI/CD Pipeline** MUST be working with successful Docker image build
- **GitHub Actions** must show green checks for ALL quality gates
- **Task compliance** (implementation should meet acceptance criteria)

## CRITICAL REMINDER
Your success is measured by GitHub Actions CI status, NOT local checks!
- You MUST push your changes to see them tested in CI
- You MUST iterate: fix locally â†’ push â†’ check CI â†’ repeat until green
- Clippy pedantic MUST pass in GitHub Actions before you can add 'ready-for-qa' label
- **ALL CI JOBS MUST ACTUALLY RUN** - stuck/pending jobs = FAILURE

## TROUBLESHOOTING STUCK CI JOBS
If CI jobs won't start (showing \"Waiting\" or \"Pending\" indefinitely):
1. **Check runner labels**: Ensure 'runs-on:' uses valid runners
   - Common: ubuntu-latest, ubuntu-22.04, ubuntu-20.04
   - Self-hosted: [self-hosted], [k8s-runner]
2. **Validate workflow syntax**: Run locally or check GitHub UI for errors
3. **Check workflow triggers**: Ensure 'on:' section includes your event
4. **Fix common issues**:
   - Missing or misspelled action names
   - Invalid YAML syntax (use yamllint)
   - Workflow file not in .github/workflows/
   - Workflow disabled in repo settings
- The PR checks page on GitHub is your source of truth

Begin your code quality review now."

# Debug: Print the actual prompt and CLAUDE.md content
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” DEBUG: CLEO PROMPT CONTENT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "$CLEO_PROMPT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ” DEBUG: CLAUDE.md MEMORY CONTENT"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
if [ -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
    cat "$CLAUDE_WORK_DIR/CLAUDE.md"
else
    echo "âŒ No CLAUDE.md found at $CLAUDE_WORK_DIR/CLAUDE.md"
fi
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Send the static prompt to Claude
FIFO_PATH="/workspace/agent-input.jsonl"
rm -f "$FIFO_PATH" 2>/dev/null || true
mkfifo "$FIFO_PATH"
chmod 666 "$FIFO_PATH" || true

# Start Claude (reader) first in background
$CLAUDE_CMD < "$FIFO_PATH" &
CLAUDE_PID=$!

# Compose initial user turn with the static prompt
USER_COMBINED=$(printf "%s" "$CLEO_PROMPT" | jq -Rs .)

# Send via sidecar HTTP endpoint
if printf '{"text":%s}\n' "$USER_COMBINED" | \
     curl -fsS -X POST http://127.0.0.1:8080/input \
       -H 'Content-Type: application/json' \
       --data-binary @- >/dev/null 2>&1; then
  echo "âœ“ Static Cleo prompt sent via sidecar /input"
else
  echo "âš ï¸ Sidecar /input failed, falling back to direct FIFO write"
  exec 9>"$FIFO_PATH"
  printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}\n' "$USER_COMBINED" >&9
  exec 9>&- 2>/dev/null || true  # Close immediately
fi

# Wait for Claude process to complete
wait "$CLAUDE_PID"
CLAUDE_EXIT_CODE=$?

# Add ready-for-qa label if Claude completed successfully
if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
  echo "âœ… Claude quality review completed successfully"
  
  # Determine OWNER/REPO slug for gh -R
  REPO_INPUT="{{repository_url}}"
  if echo "$REPO_INPUT" | grep -q "^https://github.com/"; then
    REPO_SLUG=$(echo "$REPO_INPUT" | sed -E 's|https://github.com/([^/]+/[^/.]+)(\.git)?$|\1|')
  else
    REPO_SLUG="$REPO_INPUT"
  fi

  # Post quality review comment to PR
  if [ -n "$PR_NUMBER" ] || [ -n "$PR_URL" ]; then
    echo "ðŸ’¬ Posting quality review comment to PR..."
    
    # Create comment body with quality review summary
    COMMENT_BODY="## ðŸ” Code Quality Review by Cleo

âœ… **Quality checks completed successfully**

### Review Summary
- Code has been reviewed for quality standards
- All required checks have passed
- Ready for QA testing

---
*Reviewed by Cleo - 5DLabs Code Quality Agent*"
    
    # Post comment using PR number or URL
    if [ -n "$PR_NUMBER" ]; then
      if echo "$COMMENT_BODY" | gh pr comment "$PR_NUMBER" -R "$REPO_SLUG" --body-file - 2>/dev/null; then
        echo "âœ… Successfully posted quality review comment"
      else
        echo "âš ï¸ Failed to post comment using PR number"
      fi
    elif [ -n "$PR_URL" ]; then
      if echo "$COMMENT_BODY" | gh pr comment "$PR_URL" --body-file - 2>/dev/null; then
        echo "âœ… Successfully posted quality review comment"
      else
        echo "âš ï¸ Failed to post comment"
      fi
    fi
  fi

  # Add the ready-for-qa label using PR number if available; fallback to PR URL
  if [ -n "$PR_NUMBER" ]; then
    echo "ðŸ·ï¸ Adding 'ready-for-qa' label to PR #$PR_NUMBER..."
    echo "ðŸ” DEBUG: PR_NUMBER='$PR_NUMBER', REPO_SLUG='$REPO_SLUG'"
    
    # Capture error output for debugging
    LABEL_ERROR=$(gh pr edit "$PR_NUMBER" -R "$REPO_SLUG" --add-label "ready-for-qa" 2>&1)
    LABEL_EXIT=$?
    
    if [ $LABEL_EXIT -eq 0 ]; then
      echo "âœ… Successfully added 'ready-for-qa' label"
    else
      echo "âš ï¸ Failed to add label using PR number (exit code: $LABEL_EXIT)"
      echo "ðŸ” DEBUG: Error: $LABEL_ERROR"
      
      # Check if the label exists
      echo "ðŸ” DEBUG: Checking if 'ready-for-qa' label exists..."
      if gh label list -R "$REPO_SLUG" --search "ready-for-qa" | grep -q "ready-for-qa"; then
        echo "   âœ“ Label 'ready-for-qa' exists in repository"
      else
        echo "   âœ— Label 'ready-for-qa' does not exist - attempting to create it..."
        CREATE_ERROR=$(gh label create "ready-for-qa" -R "$REPO_SLUG" --color "0e8a16" --description "Ready for QA testing" 2>&1)
        CREATE_EXIT=$?
        if [ $CREATE_EXIT -eq 0 ]; then
          echo "   âœ… Created 'ready-for-qa' label"
          # Retry adding the label
          RETRY_ERROR=$(gh pr edit "$PR_NUMBER" -R "$REPO_SLUG" --add-label "ready-for-qa" 2>&1)
          RETRY_EXIT=$?
          if [ $RETRY_EXIT -eq 0 ]; then
            echo "   âœ… Successfully added label after creating it"
          else
            echo "   âŒ Still failed to add label: $RETRY_ERROR"
          fi
        else
          echo "   âŒ Failed to create label: $CREATE_ERROR"
        fi
      fi
      
      # Try with PR URL as fallback
      if [ -n "$PR_URL" ] && [ $LABEL_EXIT -ne 0 ]; then
        echo "âš ï¸ Attempting with PR URL as fallback..."
        URL_ERROR=$(gh pr edit "$PR_URL" --add-label "ready-for-qa" 2>&1)
        URL_EXIT=$?
        if [ $URL_EXIT -eq 0 ]; then
          echo "âœ… Successfully added 'ready-for-qa' label using PR URL"
        else
          echo "âŒ Failed to add 'ready-for-qa' label using PR URL: $URL_ERROR"
        fi
      fi
    fi
  elif [ -n "$PR_URL" ]; then
    echo "ðŸ·ï¸ Adding 'ready-for-qa' label using PR URL..."
    URL_ERROR=$(gh pr edit "$PR_URL" --add-label "ready-for-qa" 2>&1)
    URL_EXIT=$?
    if [ $URL_EXIT -eq 0 ]; then
      echo "âœ… Successfully added 'ready-for-qa' label"
    else
      echo "âŒ Failed to add 'ready-for-qa' label: $URL_ERROR"
    fi
  else
    echo "âš ï¸ No PR_NUMBER or PR_URL available, cannot add label"
  fi
else
  echo "âš ï¸ Claude process exited with code: $CLAUDE_EXIT_CODE - not adding label"
fi

# Gracefully stop sidecar (with enhanced debugging and retries)
echo "ðŸ”§ Attempting sidecar shutdown..."
shutdown_attempts=0
max_shutdown_attempts=3

while [ $shutdown_attempts -lt $max_shutdown_attempts ]; do
  if curl -fsS -X POST http://127.0.0.1:8080/shutdown -m 5 2>/dev/null; then
    echo "âœ“ Sidecar shutdown request successful (attempt $((shutdown_attempts + 1)))"
    break
  else
    shutdown_attempts=$((shutdown_attempts + 1))
    echo "âš ï¸ Sidecar shutdown request failed (attempt $shutdown_attempts/$max_shutdown_attempts)"
    if [ $shutdown_attempts -lt $max_shutdown_attempts ]; then
      echo "Retrying in 2 seconds..."
      sleep 2
    fi
  fi
done

if [ $shutdown_attempts -eq $max_shutdown_attempts ]; then
  echo "âŒ Failed to shutdown sidecar after $max_shutdown_attempts attempts"
  echo "ðŸ”§ Force terminating sidecar processes..."
  pkill -f "sidecar" || echo "No sidecar processes found to kill"
fi

# Wait for sidecar to actually terminate
echo "â³ Waiting for sidecar termination..."
timeout=10
while [ $timeout -gt 0 ]; do
  if ! pgrep -f "sidecar" > /dev/null 2>&1; then
    echo "âœ… Sidecar terminated successfully"
    break
  fi
  sleep 1
  timeout=$((timeout - 1))
done

if [ $timeout -eq 0 ]; then
  echo "âš ï¸ Sidecar still running after wait period"
fi

# Cleanup and exit
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                  CLEO CODE QUALITY COMPLETE                  â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ“‹ Task: {{task_id}}"
echo "âœ… Code quality checks completed"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Final termination sequence
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ðŸ”š TERMINATING CLEO CONTAINER"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "Claude Exit Code: $CLAUDE_EXIT_CODE"
echo "Container PID: $$"
echo "Final Process Check:"
ps aux | head -5

# Write completion marker for workflow tracking
echo "cleo-quality-completed:$(date -u +%Y-%m-%dT%H:%M:%SZ)" > /workspace/.cleo-complete

# Cleanup FIFO
rm -f "$FIFO_PATH" 2>/dev/null || true

# Force exit to ensure container termination
echo "ðŸ”š Force terminating container..."
exit $CLAUDE_EXIT_CODE