#!/bin/sh

# Ensure Rust environment is always properly set up
echo "üîß Setting up Rust environment..."

# Source Rust environment if available (fixes cargo not found issues)
if [ -f "$HOME/.cargo/env" ]; then
    . "$HOME/.cargo/env"
    echo "‚úì Sourced Rust environment from $HOME/.cargo/env"
fi

# Also try root cargo env as fallback
if [ -f "/root/.cargo/env" ]; then
    . "/root/.cargo/env"
    echo "‚úì Sourced Rust environment from /root/.cargo/env"
fi

# Ensure rustup has a default toolchain set
if command -v rustup >/dev/null 2>&1; then
    rustup default stable 2>/dev/null || true
    echo "‚úì Ensured stable Rust toolchain is default"
else
    echo "‚ö†Ô∏è rustup not found in PATH"
fi

# Verify Rust is available
if command -v cargo >/dev/null 2>&1; then
    echo "‚úì Cargo is available: $(cargo --version)"
else
    echo "‚ùå Cargo not found in PATH"
    echo "Current PATH: $PATH"
    echo "Attempting to find cargo..."
    find /usr -name cargo 2>/dev/null | head -5 || echo "No cargo found in /usr"
    find /home -name cargo 2>/dev/null | head -5 || echo "No cargo found in /home"
fi

echo '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'
echo '‚ïë                 IMPLEMENTATION TASK STARTING                 ‚ïë'
echo '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Repository URL
REPO_URL="{{repository_url}}"

# GitHub App authentication is configured via environment variables
echo "Using GitHub App authentication"

# Authenticate with GitHub App
if [ -n "$GITHUB_APP_PRIVATE_KEY" ] && [ -n "$GITHUB_APP_ID" ]; then
    echo "Authenticating with GitHub App..."

    # Create temporary private key file (support escaped newlines)
    TEMP_KEY_FILE="/tmp/github-app-key.pem"
    printf '%b' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"

    # Generate JWT token for GitHub App (fixed JWT generation for Linux containers)
    # JWT header
    JWT_HEADER=$(printf '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # JWT payload with current time and expiration (10 minutes)
    NOW=$(date +%s)
    EXP=$((NOW + 600))
    JWT_PAYLOAD=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$NOW" "$EXP" "$GITHUB_APP_ID" | base64 -w 0 | tr '+/' '-_' | tr -d '=')

    # Sign the JWT
    JWT_SIGNATURE=$(printf '%s.%s' "$JWT_HEADER" "$JWT_PAYLOAD" | openssl dgst -sha256 -sign "$TEMP_KEY_FILE" -binary | base64 -w 0 | tr '+/' '-_' | tr -d '=')
    JWT_TOKEN="$JWT_HEADER.$JWT_PAYLOAD.$JWT_SIGNATURE"

    # Get installation ID for the repository (robust parsing of owner/repo)
    INPUT_REPO="{{repository_url}}"
    REPO_OWNER=""
    REPO_NAME=""

    if echo "$INPUT_REPO" | grep -qE '^https://github.com/'; then
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|https://github.com/[^/]+/([^/]+)(\.git)?|\1|')
    elif echo "$INPUT_REPO" | grep -qE '^git@github.com:'; then
        # SSH format git@github.com:owner/repo(.git)
        REPO_OWNER=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        REPO_NAME=$(echo "$INPUT_REPO" | sed -E 's|git@github.com:[^/]+/([^/]+)(\.git)?|\1|')
    else
        # Fallback: assume slug owner/repo (possibly with .git)
        SLUG=$(echo "$INPUT_REPO" | sed -E 's|\.git$||')
        REPO_OWNER=$(echo "$SLUG" | cut -d'/' -f1)
        REPO_NAME=$(echo "$SLUG" | cut -d'/' -f2)
    fi

    echo "DEBUG: Parsed repository - Owner: '$REPO_OWNER', Name: '$REPO_NAME'"

    echo "Getting installation ID for $REPO_OWNER/$REPO_NAME..."

    # Get the installation ID (retry and follow redirects). Fallback to org installation.
    INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
        --connect-timeout 5 --max-time 12 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/installation")

    INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "‚ö†Ô∏è Repo installation not found, trying org installation..."
        ORG_INSTALLATION_RESPONSE=$(curl -s -L --retry 5 --retry-delay 2 --retry-connrefused \
            --connect-timeout 5 --max-time 12 \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/$REPO_OWNER/installation")
        INSTALLATION_ID=$(echo "$ORG_INSTALLATION_RESPONSE" | jq -r '.id')
    fi

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        echo "‚ùå Failed to get installation ID for $REPO_OWNER/$REPO_NAME"
        echo "Response (repo): $INSTALLATION_RESPONSE"
        echo "Response (org):  ${ORG_INSTALLATION_RESPONSE:-[none]}"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    echo "Installation ID: $INSTALLATION_ID"

    # Get installation access token
    TOKEN_RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        echo "‚ùå Failed to get installation access token"
        echo "Response: $TOKEN_RESPONSE"
        rm -f "$TEMP_KEY_FILE"
        exit 1
    fi

    # Clean up temporary key file
    rm -f "$TEMP_KEY_FILE"

    # Export the token for git to use
    export GITHUB_TOKEN

    # Configure git to use the token (use --replace-all to handle multiple existing helpers)
    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials

    # Also authenticate gh CLI with the token
    echo "$GITHUB_TOKEN" | gh auth login --with-token

    echo "‚úì GitHub App authenticated successfully"

else
    echo "‚ùå GITHUB_APP_PRIVATE_KEY or GITHUB_APP_ID not found"
    exit 1
fi

# Git configuration with proper GitHub App attribution
git config --global --add safe.directory /workspace

# Set GitHub App attribution - use generic format for all agents
GITHUB_APP="{{github_app}}"
# Generic attribution that works for any agent
GIT_AUTHOR_NAME="${GITHUB_APP} Agent (Claude Code)"
GIT_AUTHOR_EMAIL="${GITHUB_APP}[bot]@users.noreply.github.com"

# Configure git with proper GitHub App attribution
git config --global user.name "$GIT_AUTHOR_NAME"
git config --global user.email "$GIT_AUTHOR_EMAIL"

# Set environment variables for Claude Code to use
export GIT_AUTHOR_NAME="$GIT_AUTHOR_NAME"
export GIT_AUTHOR_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
echo "‚úì Git configured"

# =============================================================================
# AUTHENTICATION VERIFICATION
# =============================================================================
echo ""
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "üîê AUTHENTICATION VERIFICATION"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo ""

# Repository URLs - Handle both full URLs and org/repo format
# Check if repository_url already contains https://github.com/
if echo "{{repository_url}}" | grep -q "^https://github.com/"; then
    REPO_HTTP_URL="{{repository_url}}"
    if ! echo "{{repository_url}}" | grep -q "\.git$"; then
        REPO_HTTP_URL="${REPO_HTTP_URL}.git"
    fi
else
    REPO_HTTP_URL="https://github.com/{{repository_url}}.git"
fi

# Same for docs repository
if echo "{{docs_repository_url}}" | grep -q "^https://github.com/"; then
    DOCS_HTTP_URL="{{docs_repository_url}}"
    if ! echo "{{docs_repository_url}}" | grep -q "\.git$"; then
        DOCS_HTTP_URL="${DOCS_HTTP_URL}.git"
    fi
else
    DOCS_HTTP_URL="https://github.com/{{docs_repository_url}}.git"
fi

# DEBUG: Show what URLs are being constructed
echo "üîç DEBUG: URL Construction & Parameters"
echo "  Input repository_url: '{{repository_url}}'"
echo "  Input docs_repository_url: '{{docs_repository_url}}'"
echo "  Input docs_project_directory: '{{docs_project_directory}}'"
echo "  Input working_directory: '{{working_directory}}'"
echo "  Input docs_branch: '{{docs_branch}}'"
echo "  Input github_app: '{{github_app}}'"
echo "  Input task_id: '{{task_id}}'"
echo "  Input service: '{{service}}'"
echo "  Constructed REPO_HTTP_URL: '$REPO_HTTP_URL'"
echo "  Constructed DOCS_HTTP_URL: '$DOCS_HTTP_URL'"
echo "  Current working directory: $(pwd)"
echo "  Available environment variables:"
env | grep -E "(GITHUB|ANTHROPIC)" | sort

# Test HTTPS access to repository
echo "üîç DEBUG: Testing HTTPS repository access..."
echo "  Command: git ls-remote \"$REPO_HTTP_URL\" HEAD"
if git ls-remote "$REPO_HTTP_URL" HEAD > /tmp/repo_test.out 2>&1; then
  echo "‚úì HTTPS repository access successful"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Output: $(cat /tmp/repo_test.out | head -1)"
else
  echo "‚ùå HTTPS repository access failed"
  echo "  Repository: {{repository_url}} ($REPO_HTTP_URL)"
  echo "  Error output: $(cat /tmp/repo_test.out)"
  echo "  Git credential helper status:"
  git config --list | grep credential || echo "  No credential helpers configured"
  echo ""
  echo "üö´ ABORTING: Cannot access repository via HTTPS"
  exit 1
fi

# Test docs repository access
echo "üîç DEBUG: Testing docs repository access..."
echo "  Command: git ls-remote \"$DOCS_HTTP_URL\" HEAD"
if git ls-remote "$DOCS_HTTP_URL" HEAD > /tmp/docs_test.out 2>&1; then
  echo "‚úì Docs repository access successful"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Output: $(cat /tmp/docs_test.out | head -1)"
else
  echo "‚ùå Docs repository access failed"
  echo "  Repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
  echo "  Error output: $(cat /tmp/docs_test.out)"
  echo ""
  echo "üö´ ABORTING: Cannot access docs repository via HTTPS"
  exit 1
fi

# Dual Repository Setup - Platform repo for docs, Target repo for implementation
echo ""
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "‚ïë                 DUAL REPOSITORY SETUP                        ‚ïë"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

# Repository Information
DOCS_BRANCH="{{docs_branch}}"
GITHUB_APP="{{github_app}}"

# Helper: derive safe workspace directory name from repo input (URL, SSH, or slug)
sanitize_repo_dir() {
    input="$1"
    if echo "$input" | grep -qE '^https://github.com/'; then
        owner=$(echo "$input" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        name=$(echo "$input" | sed -E 's|https://github.com/[^/]+/([^/]+)(\\.git)?|\1|')
        printf '%s-%s' "$owner" "$name"
    elif echo "$input" | grep -qE '^git@github.com:'; then
        owner=$(echo "$input" | sed -E 's|git@github.com:([^/]+)/.*|\1|')
        name=$(echo "$input" | sed -E 's|git@github.com:[^/]+/([^/]+)(\\.git)?|\1|')
        printf '%s-%s' "$owner" "$name"
    else
        # Assume owner/repo (optionally with .git)
        slug=$(echo "$input" | sed -E 's|\\.git$||')
        echo "$slug" | tr '/' '-'
    fi
}

# Derive workspace directory names (owner-repo)
DOCS_REPO_DIR=$(sanitize_repo_dir "{{docs_repository_url}}")
TARGET_REPO_DIR=$(sanitize_repo_dir "{{repository_url}}")

echo "=== REPOSITORY SETUP ==="
echo "Docs repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
echo "Target repository: {{repository_url}} ($REPO_HTTP_URL)"
echo "Docs branch: $DOCS_BRANCH"
echo "GitHub App: $GITHUB_APP"

# Determine workflow type
echo "üîç DEBUG: Workflow type detection"
echo "  docs_repository_url: '{{docs_repository_url}}'"
echo "  repository_url: '{{repository_url}}'"
echo "  Comparison result: $( [ "{{docs_repository_url}}" = "{{repository_url}}" ] && echo 'EQUAL' || echo 'DIFFERENT' )"

if [ "{{docs_repository_url}}" = "{{repository_url}}" ]; then
    echo "‚úì Single-repo workflow detected (same repository for docs and implementation)"
    WORKFLOW_TYPE="single-repo"
    echo "  ‚îî‚îÄ TaskMaster files expected at repository root"
else
    echo "‚úì Multi-repo workflow detected (separate docs and target repositories)"
    WORKFLOW_TYPE="multi-repo"
    echo "  ‚îî‚îÄ TaskMaster files expected in docs repo at: {{docs_project_directory}}"
fi
echo "üîç DEBUG: WORKFLOW_TYPE set to: $WORKFLOW_TYPE"

# Repository Setup Based on Workflow Type
if [ "$WORKFLOW_TYPE" = "single-repo" ]; then
    echo "=== SINGLE-REPO WORKFLOW ==="
    # Check if repository already exists (retry scenario)
    echo "üîç DEBUG: Checking for existing repository directory: $TARGET_REPO_DIR"
    echo "  Workspace contents: $(ls -la /workspace/ | grep -v '^total')"

    if [ -d "$TARGET_REPO_DIR" ]; then
        echo "üîÑ REPOSITORY: UPDATE - directory already exists"
        echo "üìÅ Found existing repository '$TARGET_REPO_DIR', updating..."
        echo "  Directory contents: $(ls -la $TARGET_REPO_DIR | head -5)"
        cd "$TARGET_REPO_DIR"
        echo "  Current branch: $(git branch --show-current 2>/dev/null || echo 'unknown')"
        echo "  Git status before update: $(git status --porcelain | wc -l) files changed"
        git fetch origin
        git checkout "$DOCS_BRANCH"
        git reset --hard "origin/$DOCS_BRANCH"
        cd /workspace
        echo "‚úì Repository updated successfully to $DOCS_BRANCH"
    else
        echo "üì• REPOSITORY: CLONING - first time setup"
        echo "  Clone command: git clone \"$REPO_HTTP_URL\" \"$TARGET_REPO_DIR\""
        if ! git clone "$REPO_HTTP_URL" "$TARGET_REPO_DIR"; then
            echo "‚ùå Failed to clone repository: {{repository_url}} ($REPO_HTTP_URL)"
            echo "  Last git error: $(git config --get-regexp 'credential|remote')"
            exit 1
        fi
        echo "  Clone successful, changing to directory and checking out $DOCS_BRANCH"
        cd "$TARGET_REPO_DIR" && git checkout "$DOCS_BRANCH" && cd /workspace
        echo "‚úì Repository cloned successfully"
        echo "  Final directory structure: $(ls -la $TARGET_REPO_DIR | head -5)"
    fi

    # Preserve Task Master files before branch switching (single-repo workflow)
    echo "üîÑ Preserving Task Master files from docs branch before switching to feature branch..."
    TEMP_TASK_DIR="/tmp/taskmaster-preserve"
    rm -rf "$TEMP_TASK_DIR"
    mkdir -p "$TEMP_TASK_DIR"

    cd "/workspace/$TARGET_REPO_DIR"
    echo "üîç DEBUG: TaskMaster file preservation"
    echo "  docs_project_directory: '{{docs_project_directory}}'"
    echo "  task_id: '{{task_id}}'"

    # Copy Task Master files from docs branch to temporary location
    {{#if docs_project_directory}}
    if [ "{{docs_project_directory}}" = "." ]; then
        PRESERVE_FROM="/workspace/$TARGET_REPO_DIR/.taskmaster/docs/task-{{task_id}}"
        echo "  ‚îî‚îÄ Using root taskmaster path (docs_project_directory='.')"
    else
        PRESERVE_FROM="/workspace/$TARGET_REPO_DIR/{{docs_project_directory}}/.taskmaster/docs/task-{{task_id}}"
        echo "  ‚îî‚îÄ Using project subdirectory: {{docs_project_directory}}"
    fi
    {{else}}
    PRESERVE_FROM="/workspace/$TARGET_REPO_DIR/.taskmaster/docs/task-{{task_id}}"
    echo "  ‚îî‚îÄ Using default root taskmaster path (no docs_project_directory)"
    {{/if}}

    echo "  PRESERVE_FROM resolved to: $PRESERVE_FROM"

    echo "üîç DEBUG: Attempting to preserve Task Master files from: $PRESERVE_FROM"
    echo "  Checking if directory exists..."
    if [ -d "$PRESERVE_FROM" ]; then
        echo "  ‚úì TaskMaster directory found!"
        echo "  Directory contents: $(ls -la "$PRESERVE_FROM" | wc -l) items"
        ls -la "$PRESERVE_FROM"
        cp -r "$PRESERVE_FROM"/* "$TEMP_TASK_DIR/" 2>/dev/null && echo "‚úì Task Master files preserved to temporary location" || echo "‚ö†Ô∏è Some files may not have been preserved"

        # Also preserve architecture.md from docs directory (one level up from task directory)
        {{#if docs_project_directory}}
        if [ "{{docs_project_directory}}" = "." ]; then
            ARCH_SOURCE="/workspace/$TARGET_REPO_DIR/.taskmaster/docs/architecture.md"
        else
            ARCH_SOURCE="/workspace/$TARGET_REPO_DIR/{{docs_project_directory}}/.taskmaster/docs/architecture.md"
        fi
        {{else}}
        ARCH_SOURCE="/workspace/$TARGET_REPO_DIR/.taskmaster/docs/architecture.md"
        {{/if}}

        if [ -f "$ARCH_SOURCE" ]; then
            cp "$ARCH_SOURCE" "$TEMP_TASK_DIR/" && echo "‚úì architecture.md preserved from docs branch" || echo "‚ö†Ô∏è Failed to preserve architecture.md"
        else
            echo "‚ö†Ô∏è architecture.md not found at: $ARCH_SOURCE"
        fi

        echo "üîç DEBUG: Preserved files:"
        ls -la "$TEMP_TASK_DIR/" || echo "No files in temp directory"
    else
        echo "‚ùå Task Master directory not found at: $PRESERVE_FROM"
        echo "‚ùå CRITICAL: TaskMaster files must exist at the specified location"
        echo "‚ùå Expected location: $PRESERVE_FROM"
        echo "‚ùå This job cannot continue without the specified TaskMaster files"
        echo "‚ùå Verify that:"
        echo "   1. The docs-project-directory parameter is correct"
        echo "   2. The task-id exists in the TaskMaster directory"
        echo "   3. The docs-branch contains the TaskMaster files"
        exit 1
    fi
    cd /workspace

    # Set working directory to the repository root
    REPO_NAME="$TARGET_REPO_DIR"
    echo "‚úì Working directory: /workspace/$REPO_NAME"
    echo "‚úì Task files preserved from docs branch"

else
    echo "=== MULTI-REPO WORKFLOW ==="

    # Step 1: Clone or update docs repository temporarily
    if [ -d "/tmp/docs-repo" ]; then
        echo "üîÑ DOCS REPOSITORY: UPDATE - temporary directory exists"
        cd /tmp/docs-repo
        git fetch origin
        git checkout "$DOCS_BRANCH"
        git reset --hard "origin/$DOCS_BRANCH"
        cd /workspace
        echo "‚úì Docs repository updated"
    else
        echo "üì• DOCS REPOSITORY: CLONING - extracting task files"
        if ! git clone "$DOCS_HTTP_URL" /tmp/docs-repo; then
            echo "‚ùå Failed to clone docs repository: {{docs_repository_url}} ($DOCS_HTTP_URL)"
            exit 1
        fi
        cd /tmp/docs-repo && git checkout "$DOCS_BRANCH" && cd /workspace
        echo "‚úì Docs repository cloned to temporary location"
    fi

    # Step 2: Clone or update target repository
    if [ -d "$TARGET_REPO_DIR" ]; then
        echo "üîÑ TARGET REPOSITORY: UPDATE - directory already exists"
        echo "üìÅ Found existing target repository '$TARGET_REPO_DIR', updating..."
        cd "$TARGET_REPO_DIR"
        git fetch origin main
        git reset --hard origin/main
        cd /workspace
        echo "‚úì Target repository updated successfully"
    else
        echo "üì• TARGET REPOSITORY: CLONING - first time setup"
        if ! git clone "$REPO_HTTP_URL" "$TARGET_REPO_DIR"; then
            echo "‚ùå Failed to clone target repository: {{repository_url}} ($REPO_HTTP_URL)"
            exit 1
        fi
        echo "‚úì Target repository cloned successfully"
    fi

    # Step 3: Copy task files from docs repo to target repo
    echo "üìã TASK FILES: COPYING from docs to target repository"
    mkdir -p "/workspace/$TARGET_REPO_DIR/task"

    # Determine docs project directory path
    {{#if docs_project_directory}}
    if [ "{{docs_project_directory}}" = "." ]; then
        DOCS_PATH="/tmp/docs-repo/.taskmaster"
    else
        DOCS_PATH="/tmp/docs-repo/{{docs_project_directory}}/.taskmaster"
    fi
    {{else}}
    DOCS_PATH="/tmp/docs-repo/.taskmaster"
    {{/if}}

    # Copy specific task files
    TASK_DIR="$DOCS_PATH/docs/task-{{task_id}}"
    echo "üîç DEBUG: Looking for task files at: $TASK_DIR"
    echo "üîç DEBUG: Docs path is: $DOCS_PATH"
    echo "üîç DEBUG: Contents of docs temp directory:"
    ls -la /tmp/docs-repo/.taskmaster/ || echo "No .taskmaster found"
    echo "üîç DEBUG: Contents of docs directory:"
    ls -la /tmp/docs-repo/.taskmaster/docs/ || echo "No docs directory found"

    if [ -d "$TASK_DIR" ]; then
        echo "üîç DEBUG: Task directory found, contents:"
        ls -la "$TASK_DIR"

        echo "‚úÖ Copying task.md..."
        cp "$TASK_DIR/task.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "‚úì task.md copied" || echo "‚ùå task.md copy failed"

        echo "‚úÖ Copying acceptance-criteria.md..."
        cp "$TASK_DIR/acceptance-criteria.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "‚úì acceptance-criteria.md copied" || echo "‚ùå acceptance-criteria.md copy failed"

        echo "‚úÖ Copying prompt.md..."
        cp "$TASK_DIR/prompt.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "‚úì prompt.md copied" || echo "‚ùå prompt.md copy failed"

        echo "‚úÖ Copying client-config.json..."
        if [ -f "$TASK_DIR/client-config.json" ]; then
            cp "$TASK_DIR/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" && echo "‚úì client-config.json copied to Claude working directory" || echo "‚ùå client-config.json copy failed"
        else
            echo "‚ö†Ô∏è client-config.json not found - MCP client may not be configured"
        fi

        echo "‚úÖ Copying toolman-guide.md..."
        if [ -f "$TASK_DIR/toolman-guide.md" ]; then
            cp "$TASK_DIR/toolman-guide.md" "/workspace/$TARGET_REPO_DIR/task/" && echo "‚úì toolman-guide.md copied" || echo "‚ùå toolman-guide.md copy failed"
        else
            echo "‚ö†Ô∏è toolman-guide.md not found - code agent won't have tool usage guidance"
        fi

        echo "‚úì Task {{task_id}} files copied from $TASK_DIR"
    else
        echo "‚ùå CRITICAL: Task {{task_id}} directory not found at: $TASK_DIR"
        echo "üîç DEBUG: Available directories in docs:"
        find /tmp/docs-repo -name "task-*" -type d || echo "No task directories found"
    fi

    # Copy architecture.md from docs root
    ARCH_FILE="$DOCS_PATH/docs/architecture.md"
    if [ -f "$ARCH_FILE" ]; then
        cp "$ARCH_FILE" "/workspace/$TARGET_REPO_DIR/task/"
        echo "‚úì Architecture documentation copied"
    else
        echo "‚ö†Ô∏è architecture.md not found at: $ARCH_FILE"
    fi

    # Copy tasks.json if it exists
    if [ -f "$DOCS_PATH/tasks.json" ]; then
        cp "$DOCS_PATH/tasks.json" "/workspace/$TARGET_REPO_DIR/task/"
        echo "‚úì tasks.json copied"
    fi

    echo "‚úì Task files copied to target repository"

    # DEBUG: Verify files were copied successfully
    echo "üîç DEBUG: Contents of target task directory after copy:"
    ls -la "/workspace/$TARGET_REPO_DIR/task/" || echo "Task directory not found"
    echo "üîç DEBUG: Checking if prompt.md exists:"
    [ -f "/workspace/$TARGET_REPO_DIR/task/prompt.md" ] && echo "‚úÖ prompt.md exists" || echo "‚ùå prompt.md missing"

    # Step 4: Clean up docs repository
    echo "üßπ CLEANUP: Removing temporary docs repository"
    rm -rf /tmp/docs-repo
    echo "‚úì Docs repository cleaned up"

    # Set working directory to the target repository root
    REPO_NAME="$TARGET_REPO_DIR"
    echo "‚úì Working directory: /workspace/$REPO_NAME"
fi

# Setup feature branch for implementation
echo "=== BRANCH SETUP ==="
cd "/workspace/$REPO_NAME"

# Sync with latest main to prevent conflicts
echo "üîÑ Syncing with latest main to prevent conflicts..."
git fetch origin main 2>/dev/null || git fetch origin master 2>/dev/null || echo "‚ö†Ô∏è Could not fetch main/master branch"

# Create or checkout feature branch
FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
BRANCH_EXISTS="false"

    if git show-ref --verify --quiet refs/heads/$FEATURE_BRANCH; then
        BRANCH_EXISTS="true"
        echo "Feature branch '$FEATURE_BRANCH' exists, checking out..."
        git checkout $FEATURE_BRANCH

        echo "üì• Merging latest main into $FEATURE_BRANCH..."
        if git merge origin/main --no-edit; then
            echo "‚úì Successfully merged latest main into feature branch"
        else
            echo "‚ö†Ô∏è MERGE CONFLICT: Cannot auto-merge main into $FEATURE_BRANCH"
            echo "‚ùó Manual conflict resolution required by Claude agent"
            echo ""
            echo "üìã Conflict files:"
            git status --porcelain | grep "^UU\|^AA\|^DD" || echo "   (Use 'git status' to see details)"
            echo ""
            echo "üîß Claude will need to resolve conflicts manually before proceeding"
            # Don't exit - let Claude handle the conflicts
        fi
    else
        # Create new feature branch from latest main
        echo "Creating new feature branch '$FEATURE_BRANCH' from latest main..."
        git checkout -b $FEATURE_BRANCH origin/main
        echo "‚úì Created feature branch: $FEATURE_BRANCH"
    fi

# 5. Set Working Directory (Critical for Claude Execution)
WORK_DIR="{{working_directory}}"
if [ "$WORK_DIR" = "." ] || [ -z "$WORK_DIR" ]; then
  CLAUDE_WORK_DIR="/workspace/$REPO_NAME"
else
  CLAUDE_WORK_DIR="/workspace/$REPO_NAME/$WORK_DIR"
fi
mkdir -p "$CLAUDE_WORK_DIR" && cd "$CLAUDE_WORK_DIR"
echo "‚úì Set working directory: $CLAUDE_WORK_DIR"
echo "üîë CRITICAL: Claude will be launched from this directory"

# Working directory setup completed above

# Configure git user after successful clone
echo "=== POST-CLONE GIT CONFIGURATION ==="
# Fix dubious ownership issues
git config --global --add safe.directory "/workspace/$REPO_NAME"
echo "‚úì Added repository to safe directories"

# Set git config locally in the working repository (persistent on PVC)
if [ -d "/workspace/$REPO_NAME/.git" ]; then
    cd "/workspace/$REPO_NAME"
    git config --local user.name "$GIT_AUTHOR_NAME"
    git config --local user.email "$GIT_AUTHOR_EMAIL"
    # Set up automatic upstream for new branches
    git config --local push.autoSetupRemote true
    echo "‚úì Configured git user in target repository: $GIT_AUTHOR_NAME"
    echo "‚úì Enabled automatic upstream setup for new branches"
fi

cd /workspace

# Copy ConfigMap files to working directory (AFTER repository clone)
echo "=== CONFIGMAP FILE SETUP ==="

# Claude working directory already set above during repository setup

echo "Setting up files in Claude working directory: $CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"

# Copy all files from ConfigMap to working directory
if [ -d "/task-files" ]; then
  echo "Copying ConfigMap files to working directory..."

  # CLAUDE.md Memory Persistence Logic (controlled by overwriteMemory CRD field)
        OVERWRITE_MEMORY="{{overwrite_memory}}"

  # Handle CLAUDE.md based on overwriteMemory setting
        if [ "$OVERWRITE_MEMORY" = "true" ]; then
          # Overwrite mode: Always replace CLAUDE.md with fresh template
    cp "/task-files/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
    cp "/task-files/CLAUDE.md" "/workspace/CLAUDE.md"
          echo "‚úì Overwrote CLAUDE.md memory file (fresh start requested)"
          echo "‚úì Copied CLAUDE.md to workspace root for easy access"
        else
          # Preserve mode (default): Only copy if doesn't exist
          if [ ! -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
      # Initial creation - copy from ConfigMap
      cp "/task-files/CLAUDE.md" "$CLAUDE_WORK_DIR/CLAUDE.md"
      cp "/task-files/CLAUDE.md" "/workspace/CLAUDE.md"
            echo "‚úì Created initial CLAUDE.md memory file"
            echo "‚úì Copied CLAUDE.md to workspace root for easy access"
          else
            echo "‚úì Preserved existing CLAUDE.md memory file (maintaining accumulated context)"
            # Still copy to workspace root for consistency
            cp "$CLAUDE_WORK_DIR/CLAUDE.md" "/workspace/CLAUDE.md"
            echo "‚úì Synced CLAUDE.md to workspace root"
          fi
        fi

  # Copy client-config.json to workspace root for MCP configuration
  if [ -f "/task-files/client-config.json" ]; then
    cp "/task-files/client-config.json" "/workspace/client-config.json"
    echo "‚úì Copied client-config.json to workspace root for MCP configuration"
  else
    echo "‚ö†Ô∏è client-config.json not found in task-files, using defaults"
  fi

  # Copy all other markdown files (excluding CLAUDE.md)
  for md_file in /task-files/*.md; do
    if [ -f "$md_file" ]; then
      basename_file=$(basename "$md_file")
      # Skip CLAUDE.md since we handled it above
      if [ "$basename_file" != "CLAUDE.md" ]; then
        cp "$md_file" "$CLAUDE_WORK_DIR/"
        echo "‚úì Updated $basename_file"
      fi
    fi
  done

  # Verify enterprise settings (mounted directly from ConfigMap)
  if [ -f "/etc/claude-code/managed-settings.json" ]; then
    echo "‚úì Enterprise settings verified"
    if ! jq empty /etc/claude-code/managed-settings.json 2>/dev/null; then
      echo "‚ùå Invalid enterprise settings JSON"
      exit 1
    fi
  else
    echo "‚ùå Enterprise settings not found"
    exit 1
  fi

  # Copy guidelines files to working directory
  if [ -f "/task-files/coding-guidelines.md" ]; then
    cp /task-files/coding-guidelines.md "$CLAUDE_WORK_DIR/"
    echo "‚úì Copied coding-guidelines.md to working directory"
  fi

  if [ -f "/task-files/github-guidelines.md" ]; then
    cp /task-files/github-guidelines.md "$CLAUDE_WORK_DIR/"
    echo "‚úì Copied github-guidelines.md to working directory"
  fi

  # System prompt will be rendered inline (no file copying needed)
  echo "‚úì System prompt template will be rendered inline"

  # Hook copying disabled
  echo "! Hook scripts disabled - no hooks will be copied"

  # Set up MCP configuration
  echo "Setting up MCP configuration..."

  # Copy MCP configuration from ConfigMap to project root (project scope)
  if [ -f "/task-files/mcp.json" ]; then
    cp /task-files/mcp.json "$CLAUDE_WORK_DIR/.mcp.json"
    echo "‚úì Copied mcp.json to .mcp.json (project scope)"
  else
    echo "‚ö†Ô∏è  mcp.json template not found"
  fi

  # Enterprise managed settings are mounted directly from ConfigMap
  echo "=== ENTERPRISE MANAGED SETTINGS ==="
  echo "‚úì Settings mounted directly from ConfigMap at: /etc/claude-code/managed-settings.json"
  echo "‚úì No copying needed - mount automatically reflects latest ConfigMap changes"

  echo "‚úì ConfigMap files copied to $CLAUDE_WORK_DIR"
else
  echo "‚ö†Ô∏è  Warning: /task-files directory not found (ConfigMap not mounted?)"
fi


# Copy Current Task Documentation to Working Directory
echo "=== TASK DOCUMENTATION SETUP ==="
echo "üîç DEBUG: WORKFLOW_TYPE is: $WORKFLOW_TYPE"
echo "üîç DEBUG: REPO_NAME is: $REPO_NAME"
echo "üîç DEBUG: CLAUDE_WORK_DIR is: $CLAUDE_WORK_DIR"
echo "üîç DEBUG: Task ID is: {{task_id}}"

# Task directory should already exist from multi-repo workflow or be created as needed
mkdir -p "$CLAUDE_WORK_DIR/task"
echo "‚úì Created task directory at: $CLAUDE_WORK_DIR/task"

# Task documentation should already be available in the task/ directory
if [ "$WORKFLOW_TYPE" = "single-repo" ]; then
    echo "‚úì Restoring task documentation from preserved temporary location"

    # Use the preserved Task Master files from temporary location
    TEMP_TASK_DIR="/tmp/taskmaster-preserve"
    echo "üîç DEBUG: Restoring task files from: $TEMP_TASK_DIR"

    if [ -d "$TEMP_TASK_DIR" ] && [ "$(ls -A $TEMP_TASK_DIR 2>/dev/null)" ]; then
        echo "‚úì Preserved Task Master files found"
        echo "üîç DEBUG: Preserved task files:"
        ls -la "$TEMP_TASK_DIR/"

        echo "‚úÖ Copying all preserved files to task directory..."

        # Copy all files from preserved directory to task directory
        if cp -r "$TEMP_TASK_DIR"/* "$CLAUDE_WORK_DIR/task/" 2>/dev/null; then
            echo "‚úì All task files copied from preserved temporary location"
        else
            echo "‚ùå Failed to copy task files from preserved location"
            exit 1
        fi

        # Copy task.txt as task.md if it exists (specific rename needed)
        if [ -f "$CLAUDE_WORK_DIR/task/task.txt" ]; then
            cp "$CLAUDE_WORK_DIR/task/task.txt" "$CLAUDE_WORK_DIR/task/task.md" && echo "‚úì task.txt copied as task.md" || echo "‚ùå task.txt copy failed"
        fi

        # Move client-config.json to Claude working directory (not in task/ subdirectory)
        if [ -f "$CLAUDE_WORK_DIR/task/client-config.json" ]; then
            mv "$CLAUDE_WORK_DIR/task/client-config.json" "$CLAUDE_WORK_DIR/client-config.json" && echo "‚úì client-config.json moved to Claude working directory" || echo "‚ùå client-config.json move failed"
        else
            echo "‚ö†Ô∏è client-config.json not found - MCP client may not be configured"
        fi

        echo "‚úì Task {{task_id}} files copied from preserved temporary location"

        # Clean up temporary directory
        rm -rf "$TEMP_TASK_DIR"
        echo "‚úì Cleaned up temporary preservation directory"
    else
        echo "‚ùå CRITICAL: No preserved Task Master files found at: $TEMP_TASK_DIR"
        echo "üîç DEBUG: This indicates the Task Master preservation step failed earlier"
        echo "‚ùå Task {{task_id}} files are not available for this job"
        exit 1
    fi

    # DEBUG: Verify files were copied successfully
    echo "üîç DEBUG: Contents of target task directory after copy:"
    ls -la "$CLAUDE_WORK_DIR/task/" || echo "Task directory not found"
    echo "üîç DEBUG: Checking if prompt.md exists:"
    [ -f "$CLAUDE_WORK_DIR/task/prompt.md" ] && echo "‚úÖ prompt.md exists" || echo "‚ùå prompt.md missing"

else
    echo "‚úì Task documentation copied from docs repository during multi-repo setup"
fi

# Verify client-config.json is available in Claude's working directory
echo "=== TOOLMAN CONFIG SETUP ==="
CLAUDE_CONFIG="$CLAUDE_WORK_DIR/client-config.json"

if [ -f "$CLAUDE_CONFIG" ]; then
  echo "‚úì client-config.json found in Claude working directory"
  # Set MCP_CLIENT_CONFIG environment variable for MCP server/bridge
  export MCP_CLIENT_CONFIG="$CLAUDE_CONFIG"
  echo "‚úì MCP_CLIENT_CONFIG set to: $MCP_CLIENT_CONFIG"
else
  echo "‚ö†Ô∏è client-config.json not found in Claude working directory - MCP client may not work correctly"
fi

echo '=== WORKSPACE VALIDATION ==='

# Check for required files in Claude's working directory
MISSING_FILES=""
REQUIRED_FILES="CLAUDE.md"

echo "Checking for required files..."
for file in $REQUIRED_FILES; do
  if [ ! -f "$CLAUDE_WORK_DIR/$file" ]; then
    echo "ERROR: Missing required file: $CLAUDE_WORK_DIR/$file"
    MISSING_FILES="$MISSING_FILES $file"
  else
    echo "‚úì Found: $CLAUDE_WORK_DIR/$file"
    # Show file size for verification
    size=$(wc -c < "$CLAUDE_WORK_DIR/$file" 2>/dev/null || echo "0")
    echo "  File size: $size bytes"
  fi
done

# Check git repository (REQUIRED for implementation tasks)
if [ ! -d "/workspace/$REPO_NAME/.git" ]; then
  echo "‚úó CRITICAL ERROR: No target git repository found!"
  MISSING_FILES="$MISSING_FILES git-repository"
else
  echo "‚úì Found: target git repository"
fi

# If any files are missing, abort
if [ -n "$MISSING_FILES" ]; then
  echo ""
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo "‚ïë                 WORKSPACE VALIDATION FAILED                  ‚ïë"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo ""
  echo "The following required files are missing:"
  for missing in $MISSING_FILES; do
    case "$missing" in
      "CLAUDE.md")
        echo "  ‚ùå $missing - Main task instructions for Claude"
        ;;
      "git-repository")
        echo "  ‚ùå $missing - Required for committing implementation changes"
        ;;
      *)
        echo "  ‚ùå $missing"
        ;;
    esac
  done
  echo ""
  echo "These files should have been created by the ConfigMap setup process."
  echo "Claude will NOT be started to avoid wasting API credits."
  echo ""
  exit 1
fi

echo "‚úì All required files present. Workspace is valid."

echo '=== IMPLEMENTATION TASK DIAGNOSTICS ==='
echo "Project directory: $CLAUDE_WORK_DIR"
echo "Project directory contents:"
ls -la "$CLAUDE_WORK_DIR"
echo ""

# Show git status
echo "Git status:"
git status 2>/dev/null || echo "Git status unavailable"
echo ""

echo '=== CLAUDE EXECUTION ==='

# Export necessary variables
export SERVICE_NAME="{{service}}"
export TASK_ID="{{task_id}}"
export GITHUB_APP="{{github_app}}"

# Change to project directory before running Claude
cd "$CLAUDE_WORK_DIR"
echo "Changed to directory: $(pwd)"

# Verify we're in the correct directory and have required files
echo "=== WORKING DIRECTORY VERIFICATION ==="
echo "Current working directory: $(pwd)"
echo "Expected directory: $CLAUDE_WORK_DIR"
if [ "$(pwd)" != "$CLAUDE_WORK_DIR" ]; then
  echo "‚ùå ERROR: Failed to change to correct working directory!"
  echo "Attempting to change directory again..."
  cd "$CLAUDE_WORK_DIR" || exit 1
  echo "‚úì Successfully changed to: $(pwd)"
fi

# Verify setup
echo "‚úì Code implementation environment ready"

# Build Claude command
CLAUDE_CMD="claude -p --output-format stream-json --input-format stream-json --verbose"

# Look for agent-specific system prompt file from agents ConfigMap
# The system prompt should be in the agents ConfigMap if configured
if [ -f "/config/agents/{{github_app}}_system-prompt.md" ]; then
    echo "‚úì Found system prompt file for {{github_app}}, adding to Claude command"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /config/agents/{{github_app}}_system-prompt.md"
    if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
        echo "[DEBUG] System prompt path: /config/agents/{{github_app}}_system-prompt.md"
        echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "/config/agents/{{github_app}}_system-prompt.md" | sed 's/^/[DEBUG] /'
        echo "[DEBUG] ----"
    fi
elif [ -f "/task-files/{{github_app}}_system-prompt.md" ]; then
    # Fallback to task-files if included inline
    echo "‚úì Found system prompt in task ConfigMap for {{github_app}}"
    CLAUDE_CMD="$CLAUDE_CMD --system-prompt /task-files/{{github_app}}_system-prompt.md"
    if [ "${DEBUG_PROMPT:-false}" = "true" ]; then
        echo "[DEBUG] System prompt path: /task-files/{{github_app}}_system-prompt.md"
        echo "[DEBUG] System prompt first 10 lines:"; head -n 10 "/task-files/{{github_app}}_system-prompt.md" | sed 's/^/[DEBUG] /'
        echo "[DEBUG] ----"
    fi
else
    echo "‚ÑπÔ∏è No system prompt file found for agent {{github_app}}, using defaults"
fi

# Model is set via settings.json template, not CLI flag

# Add continue flag if this is a retry attempt or user requested continuation
{{#if continue_session}}
CLAUDE_CMD="$CLAUDE_CMD --continue"
echo 'Adding --continue flag (attempt {{attempts}}{{#if user_requested}} - user requested{{/if}})'
{{/if}}

echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "‚ïë                    STARTING CLAUDE EXECUTION                  ‚ïë"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "Command: $CLAUDE_CMD"
echo "Note: Claude will automatically read CLAUDE.md from the working directory"

# Inline system prompt (static content)
SYSTEM_PROMPT='## üö® CRITICAL SYSTEM REQUIREMENTS üö®

**‚õî OVERCONFIDENCE MITIGATION - MANDATORY VERIFICATION ‚õî**

You have a DANGEROUS tendency to declare task completion before actually verifying everything works. This is ABSOLUTELY UNACCEPTABLE.

**MANDATORY VERIFICATION REQUIREMENTS:**
- ‚úÖ **MUST** actually run and test your code - never assume it works
- ‚úÖ **MUST** verify ALL acceptance criteria through actual testing
- ‚úÖ **MUST** confirm your changes don'\''t break existing functionality
- ‚úÖ **MUST** test end-to-end workflows and edge cases
- ‚úÖ **MUST** run all linters and build checks successfully
- ‚úÖ **CANNOT** claim completion based on code appearance alone

**YOU ARE PROHIBITED FROM CLAIMING SUCCESS UNTIL:**
1. You have executed and verified every piece of functionality
2. You have tested integration with existing systems
3. You have confirmed all acceptance criteria pass through testing
4. All automated tests pass (linting, builds, unit tests)
5. You have verified the solution works end-to-end in practice

**IF YOU DECLARE SUCCESS WITHOUT VERIFICATION, YOU HAVE FAILED.**

## üîß ORCHESTRATOR EXECUTION CONTEXT

- **Service**: {{service}}
- **Task ID**: {{task_id}}
- **Repository**: {{repository_url}}
- **Docs Repository**: {{docs_repository_url}}
- **Working Directory**: {{working_directory}}
- **GitHub App**: {{github_app}}

{{#if continue_session}}
## üîÑ CONTINUE SESSION - PR COMMENT RESOLUTION PRIORITY

**‚ö†Ô∏è MANDATORY FIRST STEP: Before proceeding with any other work, you MUST:**

1. **Check for unresolved PR comments**: Use `gh pr view --json reviews` or check the PR directly
2. **Resolve ALL pending comments first**: Address reviewer feedback, fix issues, respond to questions
3. **Push comment resolutions**: Commit and push any fixes for reviewer concerns
4. **Only then proceed**: After ALL PR comments are resolved, continue with the main task

**This ensures reviewer feedback takes priority and maintains collaborative workflow quality.**

{{/if}}
## ‚ö†Ô∏è EXECUTION REQUIREMENTS

- **Follow patterns**: Use @coding-guidelines.md and @github-guidelines.md
- **Pre-PR quality gates (MANDATORY)**: Do NOT open a PR unless all of these pass locally:
  - `cargo fmt --all -- --check`
  - `cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic`
  - `cargo test --workspace --all-features` and high coverage (aim ‚â•95%, target ~100% on critical paths)
- **GitHub workflow**: Read @github-guidelines.md for commit standards and **üö® MANDATORY: CREATE A PULL REQUEST USING `gh pr create` - THE TASK IS NOT COMPLETE WITHOUT THIS STEP üö®**
- **Verify continuously**: Run tests and checks after each significant change
- **Commit incrementally**: Don'\''t save all changes for the end
- **Test thoroughly**: Validate against acceptance criteria before completion

**Remember**: Focus on thorough implementation and verification.'

echo "Starting Claude execution (stream-json via FIFO)..."
echo "=========================="

# Safe mode toggle for debugging (prevents token consumption)
SAFE_MODE="false"  # Set to "false" for full task execution

if [ "$SAFE_MODE" = "true" ]; then
    echo "üõ°Ô∏è SAFE MODE ENABLED - Running simple test instead of full task"
    FIFO_PATH="/workspace/agent-input.jsonl"
    rm -f "$FIFO_PATH" 2>/dev/null || true
    mkfifo "$FIFO_PATH"
    chmod 666 "$FIFO_PATH" || true
    # Keep a persistent writer open and start Claude in background to avoid EOF race
    exec 9>"$FIFO_PATH"
    $CLAUDE_CMD < "$FIFO_PATH" &
    CLAUDE_PID=$!
    printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":"What time is it? Please answer this simple question and exit immediately."}]}}\n' >&9
    # Close writer so reader can exit cleanly
    exec 9>&-
    wait $CLAUDE_PID
else
    # Debug: Show what's actually in the task directory before checking for prompt.md
    echo "üîç DEBUG: About to check for prompt.md at: $CLAUDE_WORK_DIR/task/prompt.md"
    echo "üîç DEBUG: Contents of task directory:"
    ls -la "$CLAUDE_WORK_DIR/task/" || echo "Task directory not found or empty"
    echo "üîç DEBUG: Current working directory contents:"
    ls -la "$CLAUDE_WORK_DIR/" || echo "Working directory not accessible"

    # Check if prompt.md exists and use it as main prompt
    if [ -f "$CLAUDE_WORK_DIR/task/prompt.md" ]; then
        echo "‚úì Using task-specific prompt from docs service: task/prompt.md"

        echo "startingTask:{{task_id}}"
        echo ""

        # DEBUG: Print MCP_CLIENT_CONFIG for troubleshooting client config issues
        echo "üîç DEBUG: MCP_CLIENT_CONFIG is set to: '$MCP_CLIENT_CONFIG'"
        if [ -f "$MCP_CLIENT_CONFIG" ]; then
            echo "üîç DEBUG: MCP_CLIENT_CONFIG file exists and is readable"
            echo "üîç DEBUG: First few lines of client config:"
            head -10 "$MCP_CLIENT_CONFIG" 2>/dev/null || echo "Could not read client config file"
        else
            echo "üîç DEBUG: MCP_CLIENT_CONFIG file does NOT exist or is not readable"
        fi
        echo ""

        # Prepare prompt prefix for toolman guidance
        PROMPT_PREFIX=""
        if [ -f "$CLAUDE_WORK_DIR/task/toolman-guide.md" ]; then
            PROMPT_PREFIX="üîß **CRITICAL: Tool Usage Reference**

Before starting implementation, you MUST read and follow the task-specific tool guidance in the file \`task/toolman-guide.md\`. This file contains:
- Selected tools for this specific task
- When and how to use each tool
- Tool arguments, parameters, and configuration options
- Implementation workflow and best practices
- Tool relationships and sequencing

**The toolman-guide.md is your authoritative reference for tool usage in this task.**

---

"
            echo "‚úì Including toolman guidance prefix"
        else
            echo "‚ö†Ô∏è No toolman-guide.md found - proceeding without tool guidance"
        fi

        # Seed initial user turn via a FIFO (system prompts are set via CLI flags, not streamed)
        FIFO_PATH="/workspace/agent-input.jsonl"
        rm -f "$FIFO_PATH" 2>/dev/null || true
        mkfifo "$FIFO_PATH"
        chmod 666 "$FIFO_PATH" || true

        # Start Claude (reader) first in background to avoid writer-open blocking
        $CLAUDE_CMD < "$FIFO_PATH" &
        CLAUDE_PID=$!

        # Compose initial user turn
        USER_COMBINED=$(printf "%s" "${PROMPT_PREFIX}$(cat "$CLAUDE_WORK_DIR/task/prompt.md")" | jq -Rs .)

        # Prefer sending via sidecar HTTP endpoint (opens-writes-closes per request)
        if printf '{"text":%s}\n' "$USER_COMBINED" | \
             curl -fsS -X POST http://127.0.0.1:8080/input \
               -H 'Content-Type: application/json' \
               --data-binary @- >/dev/null 2>&1; then
          echo "‚úì Initial prompt sent via sidecar /input"
        else
          echo "‚ö†Ô∏è Sidecar /input failed, falling back to direct FIFO write"
          # Fallback: open FIFO writer and keep it open until Claude exits
          exec 9>"$FIFO_PATH"
          printf '{"type":"user","message":{"role":"user","content":[{"type":"text","text":%s}]}}\n' "$USER_COMBINED" >&9
        fi

        # Optional debug: dump FIFO holders if requested
        if [ "${DEBUG_FIFO:-false}" = "true" ]; then
          echo "[DEBUG] Dumping FIFO holders for $FIFO_PATH"
          for p in /proc/[0-9]*; do
            pid=${p##*/}
            [ -d "$p/fd" ] || continue
            for fd in "$p"/fd/*; do
              tgt=$(readlink "$fd" 2>/dev/null || true)
              case "$tgt" in *agent-input.jsonl*)
                fdnum=${fd##*/}
                comm=$(cat "$p/comm" 2>/dev/null || echo "?")
                echo "  PID=$pid COMM=$comm FD=$fdnum -> $tgt"
              ;;
              esac
            done
          done
        fi

        # Optional hang diagnostics without enforcing a timeout
        if [ -n "${HANG_DIAG_SECONDS:-}" ] && [ "$HANG_DIAG_SECONDS" -gt 0 ] 2>/dev/null; then
          (
            sleep "$HANG_DIAG_SECONDS"
            if kill -0 "$CLAUDE_PID" 2>/dev/null; then
              echo "[DEBUG] Hang diag after ${HANG_DIAG_SECONDS}s: dumping FIFO holders and ps"
              for p in /proc/[0-9]*; do
                pid=${p##*/}; [ -d "$p/fd" ] || continue
                for fd in "$p"/fd/*; do tgt=$(readlink "$fd" 2>/dev/null || true); case "$tgt" in *agent-input.jsonl*) fdnum=${fd##*/}; comm=$(cat "$p/comm" 2>/dev/null || echo "?"); echo "  PID=$pid COMM=$comm FD=$fdnum -> $tgt";; esac; done
              done
              ps -eo pid,ppid,comm,args | head -200 || true
            fi
          ) & HANG_DIAG_PID=$!
        fi

        # Wait for Claude process to complete, then stop diagnostics if running
        wait "$CLAUDE_PID"
        if [ -n "${HANG_DIAG_PID:-}" ]; then kill "$HANG_DIAG_PID" 2>/dev/null || true; fi
        # Close FIFO writer if it was opened (in fallback) now that Claude has exited
        exec 9>&- 2>/dev/null || true

        # Gracefully stop sidecar to allow Job to complete (all containers must exit)
        if curl -fsS -X POST http://127.0.0.1:8080/shutdown >/dev/null 2>&1; then
          echo "‚úì Requested sidecar shutdown"
        else
          echo "‚ö†Ô∏è Failed to request sidecar shutdown (it may not be running)"
        fi
    else
        echo "‚ùå ERROR: No prompt.md found from docs service"
        echo "The docs service should always provide task/prompt.md"
        echo "Check docs repository and task configuration"
        exit 1
    fi
fi

echo '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'
echo '‚ïë                 IMPLEMENTATION TASK COMPLETE                 ‚ïë'
echo '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'

# Claude execution completed - no hooks configured
echo "Claude has completed successfully."

# Write sentinel file to signal sidecar to stop (Kubernetes-native file watch)
touch /workspace/.agent_done 2>/dev/null || true

# Exit to terminate the pod
exit 0