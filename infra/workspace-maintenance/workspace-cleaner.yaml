---
# ServiceAccount for workspace PVC cleanup
apiVersion: v1
kind: ServiceAccount
metadata:
  name: workspace-cleaner
  namespace: cto
  labels:
    app.kubernetes.io/name: workspace-cleaner
    app.kubernetes.io/part-of: platform
---
# Minimal RBAC for deleting stale workspace PVCs
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: workspace-cleaner
  namespace: cto
  labels:
    app.kubernetes.io/name: workspace-cleaner
    app.kubernetes.io/part-of: platform
rules:
  - apiGroups: [""]
    resources: ["persistentvolumeclaims"]
    verbs: ["get", "list", "delete"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["get", "list", "delete"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: workspace-cleaner
  namespace: cto
  labels:
    app.kubernetes.io/name: workspace-cleaner
    app.kubernetes.io/part-of: platform
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: workspace-cleaner
subjects:
  - kind: ServiceAccount
    name: workspace-cleaner
    namespace: cto
---
# CronJob that removes stale workspace PVCs that are no longer mounted
apiVersion: batch/v1
kind: CronJob
metadata:
  name: workspace-pvc-cleaner
  namespace: cto
  labels:
    app.kubernetes.io/name: workspace-pvc-cleaner
    app.kubernetes.io/part-of: platform
spec:
  # Run once per hour
  schedule: "15 * * * *"
  concurrencyPolicy: Forbid
  failedJobsHistoryLimit: 1
  successfulJobsHistoryLimit: 1
  startingDeadlineSeconds: 300
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app.kubernetes.io/name: workspace-pvc-cleaner
        spec:
          serviceAccountName: workspace-cleaner
          securityContext:
            runAsNonRoot: true
            runAsUser: 1001
            runAsGroup: 1001
            fsGroup: 1001
            seccompProfile:
              type: RuntimeDefault
          restartPolicy: OnFailure
          containers:
            - name: cleaner
              image: bitnami/kubectl:latest
              imagePullPolicy: IfNotPresent
              securityContext:
                allowPrivilegeEscalation: false
                capabilities:
                  drop:
                    - ALL
              env:
                - name: RETENTION_HOURS
                  value: "12"
                - name: MAX_DELETIONS
                  value: "15"
              command:
                - /bin/bash
                - -c
                - |
                  set -euo pipefail

                  # Busybox-compatible ISO 8601 to Unix epoch converter
                  iso_to_epoch() {
                    local ts="$1"
                    # Use awk to parse ISO 8601 and convert to epoch
                    # Input format: 2025-11-25T12:34:56Z or 2025-11-25T12:34:56.123456Z
                    echo "$ts" | awk '{
                      # Remove Z suffix and split on T
                      gsub(/Z$/, "")
                      split($0, dt, "T")
                      
                      # Parse date part: YYYY-MM-DD
                      split(dt[1], d, "-")
                      year = d[1]; month = d[2]; day = d[3]
                      
                      # Parse time part: HH:MM:SS (ignore fractional seconds)
                      split(dt[2], t, ":")
                      hour = t[1]; min = t[2]
                      # Remove fractional seconds if present
                      split(t[3], sec_parts, ".")
                      sec = sec_parts[1]
                      
                      # Days per month (non-leap year)
                      days[1]=31; days[2]=28; days[3]=31; days[4]=30; days[5]=31; days[6]=30
                      days[7]=31; days[8]=31; days[9]=30; days[10]=31; days[11]=30; days[12]=31
                      
                      # Calculate total days since epoch (1970-01-01)
                      total_days = 0
                      
                      # Add days for complete years
                      for (y = 1970; y < year; y++) {
                        if (y % 400 == 0 || (y % 4 == 0 && y % 100 != 0))
                          total_days += 366
                        else
                          total_days += 365
                      }
                      
                      # Add days for complete months in current year
                      for (m = 1; m < month; m++) {
                        total_days += days[m]
                        # Add leap day for February if needed
                        if (m == 2 && (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)))
                          total_days += 1
                      }
                      
                      # Add remaining days (subtract 1 because day 1 = 0 days elapsed)
                      total_days += day - 1
                      
                      # Convert to seconds and add time components
                      epoch = (total_days * 86400) + (hour * 3600) + (min * 60) + sec
                      print epoch
                    }'
                  }

                  RETENTION_HOURS="${RETENTION_HOURS:-12}"
                  MAX_DELETIONS="${MAX_DELETIONS:-15}"
                  RETENTION_SECONDS=$((RETENTION_HOURS * 3600))
                  NOW=$(date -u +%s)

                  echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Looking for workspace PVCs older than ${RETENTION_HOURS}h..."

                  ACTIVE_CLAIMS="$(kubectl get pods -n cto \
                    --field-selector=status.phase!=Succeeded,status.phase!=Failed \
                    -o json | jq -r '.items[]? | .spec.volumes[]? | select(.persistentVolumeClaim != null) | .persistentVolumeClaim.claimName' | sort -u)"

                  DELETE_COUNT=0

                  while read -r PVC_NAME PVC_TIMESTAMP SKIP_FLAG; do
                    if [ -z "${PVC_NAME:-}" ]; then
                      continue
                    fi

                    CREATED_TS=$(iso_to_epoch "$PVC_TIMESTAMP")
                    AGE=$((NOW - CREATED_TS))

                    if [ "${SKIP_FLAG:-false}" = "true" ]; then
                      echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Skipping PVC $PVC_NAME (opt-out label set)"
                      continue
                    fi

                    if [ "$AGE" -lt "$RETENTION_SECONDS" ]; then
                      continue
                    fi

                    if printf '%s\n' "$ACTIVE_CLAIMS" | grep -qx "$PVC_NAME"; then
                      echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Skipping active workspace PVC $PVC_NAME"
                      continue
                    fi

                    if [ "$DELETE_COUNT" -ge "$MAX_DELETIONS" ]; then
                      echo "Reached MAX_DELETIONS=$MAX_DELETIONS limit; exiting early."
                      break
                    fi

                    AGE_HOURS=$((AGE / 3600))
                    echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Deleting stale workspace PVC $PVC_NAME (age=${AGE_HOURS}h)"
                    if kubectl delete pvc "$PVC_NAME" -n cto --ignore-not-found --wait=false; then
                      DELETE_COUNT=$((DELETE_COUNT + 1))
                    fi
                  done < <(kubectl get pvc -n cto -l workspace-type=shared -o json \
                    | jq -r '.items[] | "\(.metadata.name) \(.metadata.creationTimestamp) \(.metadata.labels["workspace.cleanup/skip"] // "false")"')

                  echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Workspace PVC cleanup finished (deleted ${DELETE_COUNT})"
---
# CronJob that removes old Kubernetes events to prevent accumulation
apiVersion: batch/v1
kind: CronJob
metadata:
  name: event-cleaner
  namespace: cto
  labels:
    app.kubernetes.io/name: event-cleaner
    app.kubernetes.io/part-of: platform
spec:
  # Run every 30 minutes
  schedule: "*/30 * * * *"
  concurrencyPolicy: Forbid
  failedJobsHistoryLimit: 1
  successfulJobsHistoryLimit: 1
  startingDeadlineSeconds: 300
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app.kubernetes.io/name: event-cleaner
        spec:
          serviceAccountName: workspace-cleaner
          securityContext:
            runAsNonRoot: true
            runAsUser: 1001
            runAsGroup: 1001
            fsGroup: 1001
            seccompProfile:
              type: RuntimeDefault
          restartPolicy: OnFailure
          containers:
            - name: cleaner
              image: bitnami/kubectl:latest
              imagePullPolicy: IfNotPresent
              securityContext:
                allowPrivilegeEscalation: false
                capabilities:
                  drop:
                    - ALL
              env:
                - name: RETENTION_MINUTES
                  value: "60"
              command:
                - /bin/bash
                - -c
                - |
                  set -euo pipefail

                  # Busybox-compatible ISO 8601 to Unix epoch converter
                  iso_to_epoch() {
                    local ts="$1"
                    # Use awk to parse ISO 8601 and convert to epoch
                    # Input format: 2025-11-25T12:34:56Z or 2025-11-25T12:34:56.123456Z
                    echo "$ts" | awk '{
                      # Remove Z suffix and split on T
                      gsub(/Z$/, "")
                      split($0, dt, "T")
                      
                      # Parse date part: YYYY-MM-DD
                      split(dt[1], d, "-")
                      year = d[1]; month = d[2]; day = d[3]
                      
                      # Parse time part: HH:MM:SS (ignore fractional seconds)
                      split(dt[2], t, ":")
                      hour = t[1]; min = t[2]
                      # Remove fractional seconds if present
                      split(t[3], sec_parts, ".")
                      sec = sec_parts[1]
                      
                      # Days per month (non-leap year)
                      days[1]=31; days[2]=28; days[3]=31; days[4]=30; days[5]=31; days[6]=30
                      days[7]=31; days[8]=31; days[9]=30; days[10]=31; days[11]=30; days[12]=31
                      
                      # Calculate total days since epoch (1970-01-01)
                      total_days = 0
                      
                      # Add days for complete years
                      for (y = 1970; y < year; y++) {
                        if (y % 400 == 0 || (y % 4 == 0 && y % 100 != 0))
                          total_days += 366
                        else
                          total_days += 365
                      }
                      
                      # Add days for complete months in current year
                      for (m = 1; m < month; m++) {
                        total_days += days[m]
                        # Add leap day for February if needed
                        if (m == 2 && (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)))
                          total_days += 1
                      }
                      
                      # Add remaining days (subtract 1 because day 1 = 0 days elapsed)
                      total_days += day - 1
                      
                      # Convert to seconds and add time components
                      epoch = (total_days * 86400) + (hour * 3600) + (min * 60) + sec
                      print epoch
                    }'
                  }

                  RETENTION_MINUTES="${RETENTION_MINUTES:-60}"
                  NOW=$(date -u +%s)
                  RETENTION_SECONDS=$((RETENTION_MINUTES * 60))

                  echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Starting event cleanup (retention: ${RETENTION_MINUTES}m)..."

                  DELETE_COUNT=0
                  TOTAL_EVENTS=$(kubectl get events -n cto --no-headers 2>/dev/null | wc -l)
                  echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Found ${TOTAL_EVENTS} total events"

                  # Delete events older than retention period
                  while read -r EVENT_NAME EVENT_TIMESTAMP; do
                    if [ -z "${EVENT_NAME:-}" ]; then
                      continue
                    fi

                    EVENT_TS=$(iso_to_epoch "$EVENT_TIMESTAMP" 2>/dev/null || echo "0")
                    if [ "$EVENT_TS" = "0" ]; then
                      continue
                    fi

                    AGE=$((NOW - EVENT_TS))
                    if [ "$AGE" -gt "$RETENTION_SECONDS" ]; then
                      if kubectl delete event "$EVENT_NAME" -n cto --ignore-not-found --wait=false 2>/dev/null; then
                        DELETE_COUNT=$((DELETE_COUNT + 1))
                      fi
                    fi
                  done < <(kubectl get events -n cto -o json 2>/dev/null \
                    | jq -r '.items[] | "\(.metadata.name) \(.lastTimestamp // .eventTime // .metadata.creationTimestamp)"')

                  echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] Event cleanup finished (deleted ${DELETE_COUNT} old events)"

