# Discord-Based Remote Agent Monitoring & Control PRD

## Overview
Build a lightweight, zero-impact monitoring and control plane for headless AI agent runs, using Discord as the primary interface. The system streams agent progress to a dedicated Discord channel per run and supports optional operator input routing back to the running agent. Core design is an independent Rust watcher (sidecar) tailing Claude‚Äôs append-only JSONL transcript.

## Goals
- Real-time, reliable, low-overhead visibility into agent activity
- One dedicated Discord channel per run; nicely formatted embeds (tool calls, thinking, results, errors, cost/tokens)
- Simple, decoupled architecture (no hooks/status-line required)
- Optional operator input path via Discord bot ‚Üí pod-local bridge

## Non-Goals
- No vendor lock-in to a specific LLM provider beyond reading transcript JSONL
- No persistent Discord thread analytics or cross-run dashboards (out of scope for MVP)

## Users
- Operators monitoring CI-style AI jobs
- Engineers needing run-by-run visibility and ad-hoc guidance input

## High-Level Architecture
- Sidecar Rust binary tails `~/.claude/projects/<encoded-workspace>/<session>.jsonl`
- Formats significant transcript events into Discord embeds (‚ö° tool_use, üí≠ assistant text, ‚úÖ completion, ‚ùå errors)
- Uses a channel-specific Discord webhook for output
- A Discord Bot (App) manages run channels and (optionally) forwards messages from that channel to an HTTP bridge in the pod for input

## Functional Requirements
1) Channel Lifecycle
   - Create channel per run: `run-{taskId}-{attempt}-{shortId}` in ‚ÄúAgent Runs‚Äù category
   - Post initial header embed (run metadata)
   - Archive or delete channel after retention window

2) Output Streaming (Watcher ‚Üí Webhook)
   - Tail transcript JSONL with at most 100ms latency
   - Filter/format events:
     - tool_use (Bash/Write/Edit/Read/WebSearch)
     - assistant text (significant messages only)
     - tool_result (stdout/stderr)
     - result/summary (final)
   - Include fields: tokens in/out, estimated cost, tool counts, error counts, timestamps, model
   - Batch up to 10 embeds per request; handle rate limits/backoff

3) Optional Input (Bot ‚Üí Bridge ‚Üí Agent)
   - Only accept messages/slash commands in the run‚Äôs channel
   - Forward JSON payload to a pod-local HTTP bridge (POST /input)
   - Bridge writes streaming JSON to agent FIFO/stdin

4) Security & Isolation
   - Pods never hold a bot token; they only get a channel-scoped webhook URL
   - One webhook per run; revoke by deleting webhook
   - Validate channel/run mapping in the bot to prevent cross-run injection

## Non-Functional Requirements
- Overhead: <1% CPU, <64Mi memory per watcher
- Latency: ‚â§100ms average from transcript append to Discord post (network permitting)
- Reliability: watcher restarts independently; no impact on agent

## Deliverables (MVP)
- Rust watcher binary with JSONL tailing, event parsing, embed formatting, batching, rate limiting
- Discord bot service for channel lifecycle; creates channel + webhook and returns {channelId, webhookUrl}
- K8s sidecar deploy template; ENV: DISCORD_WEBHOOK_URL, WORKSPACE_PATH
- Helm values for enabling the watcher and basic filters
- Documentation (architecture.md, deploy steps)

## Implementation Phases
1) Basic Visibility
   - Sidecar watcher ‚Üí webhook posting (tool_use, assistant messages, errors, final)
   - Static channel/webhook (pre-created) for validation
2) Bot Lifecycle
   - Bot creates per-run channel + webhook; injects into pod env
   - Final summary + channel archive
3) Optional Input
   - Pod-local bridge + bot message forwarding within channel
4) Hardening
   - Robust rate limiting/backoff, error logging, metrics, health checks

## Acceptance Criteria
- Live run creates (or uses) a dedicated Discord channel and streams events as embeds
- Errors and significant stdout/stderr are visible and readable
- Final summary embed with tokens, cost estimate, tool count, error count
- No measurable slowdown of agent (no hooks/status-line required)

## Risks & Mitigations
- Discord rate limiting ‚Üí batch + backoff
- Transcript path variance ‚Üí discovery logic and retry loop
- Bot outage ‚Üí output still works (webhook), input disabled temporarily

## Config (Helm Values Sketch)
discord:
  monitoring:
    enabled: true
    image: discord-monitor:latest
    polling:
      interval: 100
      batchSize: 10
    filters:
      includeTools: ["Bash", "Write", "Edit"]
      includePatterns: ["Error", "Success", "Complete", "Starting"]
      minStdoutLength: 50
    stats:
      trackCost: true
      trackTokens: true
      trackErrors: true
    resources:
      requests: { cpu: "10m", memory: "32Mi" }
      limits:   { cpu: "100m", memory: "64Mi" }

