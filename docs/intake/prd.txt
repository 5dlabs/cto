# Discord-Based Remote Agent Monitoring & Control PRD

## Overview
Build a lightweight, zero-impact monitoring and control plane for headless AI agent runs, using Discord as the primary interface. The system streams agent progress to a dedicated Discord channel per run and supports optional operator input routing back to the running agent. Core design is an independent Rust watcher (sidecar) tailing Claude’s append-only JSONL transcript.

## Goals
- Real-time, reliable, low-overhead visibility into agent activity
- One dedicated Discord channel per run; nicely formatted embeds (tool calls, thinking, results, errors, cost/tokens)
- Simple, decoupled architecture (no hooks/status-line required)
- Optional operator input path via Discord bot → pod-local bridge

## Non-Goals
- No vendor lock-in to a specific LLM provider beyond reading transcript JSONL
- No persistent Discord thread analytics or cross-run dashboards (out of scope for MVP)

## Users
- Operators monitoring CI-style AI jobs
- Engineers needing run-by-run visibility and ad-hoc guidance input

## High-Level Architecture
- Sidecar Rust binary tails `~/.claude/projects/<encoded-workspace>/<session>.jsonl`
- Formats significant transcript events into Discord embeds (⚡ tool_use, 💭 assistant text, ✅ completion, ❌ errors)
- Uses a channel-specific Discord webhook for output
- A Discord Bot (App) manages run channels and (optionally) forwards messages from that channel to an HTTP bridge in the pod for input

### Discord Bot SDK (Rust)
- Bot implementation uses the `serenity` crate for Discord API integration, slash commands, components, threads, and webhooks.
- References: serenity library and examples [serenity-rs/serenity](https://github.com/serenity-rs/serenity)

Example (message relay skeleton):
```rust
use serenity::{async_trait, prelude::*, model::channel::Message};

struct Handler;

#[async_trait]
impl EventHandler for Handler {
    async fn message(&self, ctx: Context, msg: Message) {
        if msg.content.starts_with("/send ") {
            let payload = msg.content[6..].to_string();
            // forward to pod-local bridge (POST /input)
            let _ = reqwest::Client::new()
                .post("http://input-bridge/input")
                .json(&serde_json::json!({"text": payload, "author": msg.author.name}))
                .send().await;
            let _ = msg.channel_id.say(&ctx.http, "✅ forwarded").await;
        }
    }
}
```

## Functional Requirements
1) Channel Lifecycle
   - Create channel per run: `run-{taskId}-{attempt}-{shortId}` in “Agent Runs” category
   - Post initial header embed (run metadata)
   - Archive or delete channel after retention window

2) Output Streaming (Watcher → Webhook)
   - Tail transcript JSONL with at most 100ms latency
   - Filter/format events:
     - tool_use (Bash/Write/Edit/Read/WebSearch)
     - assistant text (stream the agent's dialogue/thoughts as they appear)
     - tool_result (stdout/stderr)
     - result/summary (final)
   - Include fields: tokens in/out, estimated cost, tool counts, error counts, timestamps, model
   - Batch up to 10 embeds per request; handle rate limits/backoff

3) Optional Input (Bot → Bridge → Agent)
   - Only accept messages/slash commands in the run’s channel
   - Forward JSON payload to a pod-local HTTP bridge (POST /input)
   - Bridge writes streaming JSON to agent FIFO/stdin

4) Security & Isolation
   - Pods never hold a bot token; they only get a channel-scoped webhook URL
   - One webhook per run; revoke by deleting webhook
   - Validate channel/run mapping in the bot to prevent cross-run injection

## Discord Formatting & UX Requirements

- General
  - Every agent action should render clearly in Discord as it would appear in a terminal/editor, but formatted for readability.
  - Prefer embeds for structure (title, description, fields, footer, timestamp, color) and standard Markdown for content.
  - Batch up to 10 embeds per message to respect Discord limits; backoff on rate limits.

- Code and Diffs
  - Use fenced code blocks with language for syntax highlighting:
    - Commands: ```bash
    - JSON payloads: ```json
    - Source snippets: ```ts, ```rs, ```py, etc. by file extension
    - Diffs and patches: ```diff (use leading "+"/"-" for additions/removals)
  - For Write/Edit events:
    - Include a compact inline diff (contextual hunk; max ~40-60 lines).
    - If larger, truncate and attach full diff as a file via webhook attachments; include a summary field linking filename and size.
  - For stdout/stderr:
    - Render significant output in ```text blocks; truncate beyond ~800-1200 chars with “(truncated)” note and attach full output.

- Embed Templates (baseline)
  - tool_use (Bash): title="⚡ Bash", fields: Command (code-fenced), Working Dir (inline), Tool Count (inline), color=0xF39C12
  - tool_use (Write/Edit/Read): title="📝 Write"/"👁️ Read", fields: File, Summary, Tool Count, color=0xF39C12
  - assistant message: title optional, description=message text (trimmed), fields: Tokens (In/Out), Session Cost, Model, color=0x3498DB
  - tool_result error: title="❌ Error", description=stderr (trimmed, code-fenced), fields: Total Errors, color=0xE74C3C
  - completion: title="✅ Complete", fields: Cost, Duration (if available), Tokens (total), Tools Used, color=0x27AE60

- Limits & Truncation (to avoid render failures)
  - Respect Discord constraints:
    - Message content ~2000 chars; embed description up to 4096; at most 25 fields per embed; 10 embeds per message.
  - Implement safe truncation with ellipses and file attachments for overflow.
  - Sanitize code fences to avoid accidental fence termination.

- Navigation & Threads (optional enhancements)
  - Use threads for sub-topics (e.g., “Helper analysis”, “Long logs”).
  - Add buttons/slash commands later for /pause, /resume, /note; keep MVP output-only.

- Parity Mode
  - Provide a configuration flag to emit “all events” (no filtering, minimal truncation) to mirror non-interactive console output as closely as possible.

### Assistant Dialogue Example

```text
┌────────────────────────────────────────────┐
│ 💭 "Analyzing repository structure…"        │
├────────────────────────────────────────────┤
│ Tokens: In: 1,204 | Out: 256               │
│ Session Cost: $0.002134                    │
│ Model: claude-3-opus                       │
└────────────────────────────────────────────┘

┌────────────────────────────────────────────┐
│ 💭 "I will install task-master and parse   │
│     the PRD next."                         │
├────────────────────────────────────────────┤
│ Tokens: In: 1,478 | Out: 190               │
│ Session Cost: $0.002821                    │
│ Model: claude-3-opus                       │
└────────────────────────────────────────────┘
```

## Non-Functional Requirements
- Overhead: <1% CPU, <64Mi memory per watcher
- Latency: ≤100ms average from transcript append to Discord post (network permitting)
- Reliability: watcher restarts independently; no impact on agent

## Deliverables (MVP)
- Rust watcher binary with JSONL tailing, event parsing, embed formatting, batching, rate limiting
- Discord bot service for channel lifecycle; creates channel + webhook and returns {channelId, webhookUrl}
- K8s sidecar deploy template; ENV: DISCORD_WEBHOOK_URL, WORKSPACE_PATH
- Helm values for enabling the watcher and basic filters
- Documentation (architecture.md, deploy steps)
 - Bot crate using serenity with minimal slash command and channel creation examples

## Implementation Phases
1) Basic Visibility
   - Sidecar watcher → webhook posting (tool_use, assistant messages, errors, final)
   - Static channel/webhook (pre-created) for validation
2) Bot Lifecycle
   - Bot creates per-run channel + webhook; injects into pod env
   - Final summary + channel archive
3) Optional Input
   - Pod-local bridge + bot message forwarding within channel
4) Hardening
   - Robust rate limiting/backoff, error logging, metrics, health checks

## Acceptance Criteria
- Live run creates (or uses) a dedicated Discord channel and streams events as embeds
- Errors and significant stdout/stderr are visible and readable
- Final summary embed with tokens, cost estimate, tool count, error count
- No measurable slowdown of agent (no hooks/status-line required)

## Risks & Mitigations
- Discord rate limiting → batch + backoff
- Transcript path variance → discovery logic and retry loop
- Bot outage → output still works (webhook), input disabled temporarily

## Config (Helm Values Sketch)
discord:
  monitoring:
    enabled: true
    image: discord-monitor:latest
    polling:
      interval: 100
      batchSize: 10
    filters:
      includeTools: ["Bash", "Write", "Edit"]
      includePatterns: ["Error", "Success", "Complete", "Starting"]
      minStdoutLength: 50
    stats:
      trackCost: true
      trackTokens: true
      trackErrors: true
    resources:
      requests: { cpu: "10m", memory: "32Mi" }
      limits:   { cpu: "100m", memory: "64Mi" }

