# Task ID: 4
# Title: PR validation DAG WorkflowTemplate (Clippy → QA) with compliance gates
# Status: pending
# Dependencies: None
# Priority: medium
# Description: Implement the PR validation flow as an Argo DAG that runs Clippy then QA, enforcing fmt/clippy pedantic/zero warnings and QA verification in Kubernetes with proof.
# Details:
Implementation:
- Create WorkflowTemplate pr-validation with entrypoint dag:
  dag:
    tasks:
      - name: clippy-format
        templateRef: {name: coderun-template, template: coderun-main}
        arguments:
          parameters:
            - {name: github-app, value: clippy}
      - name: qa-testing
        dependencies: [clippy-format]
        templateRef: {name: coderun-template, template: coderun-main}
        arguments:
          parameters:
            - {name: github-app, value: qa}
      - name: verify-compliance
        dependencies: [clippy-format]
        template: verify-compliance
      - name: verify-k8s-proof
        dependencies: [qa-testing]
        template: verify-k8s-proof
- Add verify-compliance template (container step) to independently enforce gates:
  - Runs: `cargo fmt --check && cargo clippy -- -D warnings` (or language-specific equivalents) based on repo language; use a language detector or project config to choose toolchain.
  - Fails the DAG if non-zero warnings.
- Add verify-k8s-proof template to parse QA artifacts for proof of Kubernetes verification (logs, curl responses), and ensure artifacts exist (e.g., /artifacts/qa/proof/*.log). If missing, fail.
- Expose outputs: links to PR, CI runs, and artifacts via workflow.outputs.parameters.
- Ensure both verify-compliance and verify-k8s-proof are required; the overall workflow fails if they fail.
Pseudocode (verify-k8s-proof):
- Check existence of /artifacts/qa/proof/summary.json; validate fields: cluster, namespace, testCases[], evidence[].
- kubectl get pods/services for the namespace and include into artifacts for auditability.

# Test Strategy:
E2E: Open a PR; trigger pr-validation via event (or manual). Validate that Clippy agent modifies code and pushes commits; verify-compliance fails when warnings introduced and passes when clean. QA step must generate artifacts; verify-k8s-proof fails if artifacts missing. Confirm PR remains unmerged and QA agent posts review comments. Collect logs and confirm correlation labels are present.

# Subtasks:
## 1. DAG skeleton: pr-validation WorkflowTemplate (Clippy → QA) via coderun-template [pending]
### Dependencies: None
### Description: Create the pr-validation WorkflowTemplate with a DAG entrypoint wiring clippy-format → qa-testing, plus verify-compliance and verify-k8s-proof tasks.
### Details:
- Define WorkflowTemplate: name pr-validation, entrypoint dag.
- DAG tasks:
  - clippy-format: templateRef coderun-template/coderun-main with parameter github-app=clippy.
  - qa-testing: depends on clippy-format; templateRef coderun-template/coderun-main with github-app=qa.
  - verify-compliance: depends on clippy-format; template verify-compliance (added in subtask 2).
  - verify-k8s-proof: depends on qa-testing; template verify-k8s-proof (added in subtask 3).
- Inputs/params: accept repo, owner, prNumber, ref, event payload pointer (as needed by coderun-template).
- Volumes/artifacts: mount a shared /artifacts workspace (emptyDir or artifact repository) accessible by all tasks.
- Acceptance criteria:
  - kubectl apply of the template is valid.
  - argo lint passes.
  - Submitting the workflow creates four tasks with correct dependencies.

## 2. verify-compliance template: language detection + fmt/lint/clippy gates [pending]
### Dependencies: 4.1
### Description: Add a container template that enforces zero warnings and format compliance, with language detection and repo-config overrides.
### Details:
- Container image: ghcr.io/your-org/ci-multilang:latest (includes: bash, git, jq, yq, rustup/cargo/rustfmt/clippy, node/npm/npx/eslint/prettier, go/gofmt/golangci-lint, python3/pip/black/ruff, shellcheck).
- Command (entry script outline):
  - Detect language:
    - If .pr-validation.yml exists, read language and custom commands.
    - Else: Rust if Cargo.toml; Node if package.json; Go if go.mod; Python if pyproject.toml or requirements.txt; fallback to shell lint only.
  - Rust:
    - rustup component add rustfmt clippy || true
    - cargo fmt --all -- --check
    - cargo clippy --workspace --all-targets --all-features -- -D warnings -W clippy::pedantic
  - Node:
    - npm ci
    - npx prettier -c .
    - npx eslint . --max-warnings=0
  - Go:
    - test -z "$(gofmt -l .)" || { echo 'gofmt issues'; exit 1; }
    - golangci-lint run --timeout 5m
  - Python:
    - pip install -U pip
    - pip install black ruff
    - black --check .
    - ruff check --no-cache
  - On success, write /artifacts/compliance/summary.json with fields: {language, tools: {name,version}, fmtStatus, lintStatus, warningsCount, timestamp}.
- Config override: .pr-validation.yml supports keys: language, fmtCommand, lintCommand, workingDir.
- Artifact schema (summary.json):
  - language: string
  - tools: array of {name:string, version:string}
  - fmtStatus: "passed"|"failed"
  - lintStatus: "passed"|"failed"
  - warningsCount: integer (0 required)
  - timestamp: RFC3339 string
- Acceptance criteria:
  - Fails when warningsCount > 0 or any fmt check fails.
  - Produces summary.json with populated tool versions.

## 3. verify-k8s-proof template: validate QA artifacts and collect cluster evidence [pending]
### Dependencies: 4.1
### Description: Add a container template that validates /artifacts/qa/proof/summary.json and evidence logs, and captures kubectl inventory into artifacts.
### Details:
- Container image: ghcr.io/your-org/kubectl-jq:1.30 (kubectl 1.30, jq, bash, tar).
- Inputs: expects QA step to write /artifacts/qa/proof/summary.json and evidence files under /artifacts/qa/proof/.
- Validation steps:
  - Check existence of summary.json.
  - jq validation: require fields: cluster (string), namespace (string), testCases (array of {name,status,details?}), evidence (array of {path,type}). Ensure testCases[].status ∈ {passed,failed,skipped}.
  - Verify each evidence[].path exists (e.g., *.log, *.json, screenshots) under /artifacts/qa/proof/.
  - Fail if any required field missing or any evidence path missing.
- Cluster audit capture:
  - kubectl get pods -n "$NAMESPACE" -o json > /artifacts/qa/proof/cluster-pods.json
  - kubectl get services -n "$NAMESPACE" -o json > /artifacts/qa/proof/cluster-services.json
  - Optional: kubectl get events -n "$NAMESPACE" -o json > /artifacts/qa/proof/cluster-events.json
- Derive NAMESPACE from summary.json (.namespace) and export as env.
- Output: write /artifacts/qa/proof/verification.json with fields: {valid:true|false, missingEvidence:[], counts:{tests:int,passed:int,failed:int}, timestamp}.
- Acceptance criteria:
  - Fails if summary.json missing/invalid or evidence files absent.
  - Succeeds when schema valid and evidence present; emits cluster inventory artifacts.

## 4. Artifact wiring and workflow outputs (PR/CI links, artifact paths) [pending]
### Dependencies: 4.1, 4.2, 4.3
### Description: Wire artifacts between tasks and expose workflow outputs with links to PR, CI runs, and artifact locations.
### Details:
- Shared artifact path: mount /artifacts for all tasks (emptyDir or artifact repository). Ensure coderun-template writes QA outputs under /artifacts/qa/.
- Expose outputs via workflow.outputs.parameters:
  - pr-url: from event payload or coderun-template outputs file (/tmp/pr-url).
  - ci-run-url: from coderun-template output (/tmp/ci-run-url) if available.
  - compliance-summary: path reference /artifacts/compliance/summary.json.
  - qa-proof-summary: path reference /artifacts/qa/proof/summary.json.
- Add artifact outputs (S3/Artifactory configured in Argo):
  - name: compliance-summary, path: /artifacts/compliance/summary.json
  - name: qa-proof, path: /artifacts/qa/proof/
- Template snippets:
  - Use outputs.parameters.from to read files (e.g., '{{tasks.verify-compliance.outputs.parameters.compliance-summary}}').
- Acceptance criteria:
  - argo get shows outputs parameters populated.
  - Downloaded artifacts contain compliance summary and QA proof folder.

## 5. Failure policies and gates: ensure both verify-* tasks block success [pending]
### Dependencies: 4.1, 4.2, 4.3, 4.4
### Description: Configure DAG behavior so both verification steps are required, with explicit gating and appropriate retries.
### Details:
- Add a final gates-passed task (template: script that echoes success) depending on [verify-compliance, verify-k8s-proof].
- Do not set continueOn: failed on verification tasks; allow DAG-level failFast: false so both branches run and surface errors concurrently.
- Overall success requires gates-passed to run; overall failure occurs if any verify-* fails (Argo prevents gates-passed from running).
- Retry strategy:
  - clippy-format and qa-testing: retries: 1-2 with exponential backoff.
  - verify-compliance and verify-k8s-proof: no retry (logic errors should fail fast).
- Acceptance criteria:
  - If either verify-* fails, workflow status is Failed and gates-passed does not execute.
  - If both pass, workflow status is Succeeded and gates-passed executed.

## 6. Test data and E2E scenarios [pending]
### Dependencies: 4.1, 4.2, 4.3, 4.4, 4.5
### Description: Create fixtures and end-to-end tests covering clean and failing paths, including missing artifacts and introduced warnings.
### Details:
- Test repos/fixtures:
  - Rust project (clean): no clippy warnings; QA step writes valid proof summary and logs.
  - Rust project (warning): introduce allow(dead_code) removal to trigger warning; expect verify-compliance fail.
  - QA missing artifacts: run QA without writing /artifacts/qa/proof/summary.json; expect verify-k8s-proof fail.
- E2E flows:
  - Submit workflow with parameters referencing test repo/PR; verify task sequence and outcomes.
  - Validate workflow outputs parameters and artifact contents.
- Commands:
  - argo submit --from wftmpl/pr-validation -p owner=... -p repo=... -p prNumber=...
  - argo watch <wf-name>
- Acceptance criteria:
  - Clean case: all tasks succeed; gates-passed runs; outputs populated.
  - Warning case: verify-compliance fails with logs showing -D warnings; workflow fails.
  - Missing artifact case: verify-k8s-proof fails citing missing summary.json/evidence.

## 7. Documentation and required repo/configs [pending]
### Dependencies: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6
### Description: Document required repository structure, configuration, artifact schemas, images, and acceptance criteria for teams.
### Details:
- Required repo elements:
  - For Rust: Cargo.toml, rust-toolchain (optional), rustfmt/clippy configs; ensure code compiles for clippy.
  - QA step must write /artifacts/qa/proof/summary.json and evidence files; provide example generator script.
  - Optional .pr-validation.yml to override language and commands:
    - keys: language, fmtCommand, lintCommand, workingDir.
- Artifact schema references:
  - compliance summary: {language, tools[], fmtStatus, lintStatus, warningsCount, timestamp}.
  - QA proof summary: {cluster, namespace, testCases[], evidence[]}.
- Container images used:
  - ghcr.io/your-org/ci-multilang:latest
  - ghcr.io/your-org/kubectl-jq:1.30
- RBAC and environment:
  - ServiceAccount with read-only access to target namespaces for kubectl get pods/services/events.
  - Variables required by templates (e.g., GITHUB_* from token generator in Task 2; namespace resolution from summary.json).
- Acceptance criteria:
  - README with setup steps and examples.
  - Example .pr-validation.yml and QA proof summary.json templates included.
  - Teams can adopt the workflow by adding QA artifact generation and optional config file.

