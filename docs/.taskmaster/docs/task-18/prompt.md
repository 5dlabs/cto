# Task 18: Test Coverage Requirements - Autonomous Implementation Prompt

## Objective
Implement a comprehensive test coverage enforcement workflow integrated directly into the `container-tess.sh.hbs` script. Create an automated system that analyzes code coverage, generates missing tests, and provides GitHub PR approval based on coverage metrics with 95% threshold for existing code and 100% for new code.

## Context
You are building an automated testing agent (Tess) that ensures code quality through comprehensive test coverage analysis. This system must be fully integrated into the container workflow, automatically generate tests for uncovered code, and interface with GitHub for PR approval automation.

## Core Implementation Requirements

### 1. Enhanced Container-Tess Script
**Location**: `templates/container-tess.sh.hbs`

The script must implement a complete 9-stage workflow:
1. **Acceptance Criteria Review**: Analyze changes against defined criteria
2. **Test Execution**: Run existing test suite with coverage instrumentation  
3. **Coverage Analysis**: Generate detailed coverage reports using cargo llvm-cov
4. **Uncovered Code Identification**: Find specific lines/branches lacking coverage
5. **Test Generation**: Create tests for uncovered code paths
6. **Full Test Suite**: Execute complete test suite including generated tests
7. **Report Generation**: Create HTML, Cobertura, and JSON coverage reports
8. **Trend Analysis**: Track coverage improvements over time
9. **GitHub Integration**: Automatically approve/reject PRs based on coverage

### 2. Coverage Tool Installation and Setup
Install and configure cargo llvm-cov:
```bash
rustup component add llvm-tools-preview
cargo install cargo-llvm-cov --version 0.5.36
```

Configure coverage collection:
- Set up CARGO_LLVM_COV_TARGET_DIR for organized output
- Generate multiple report formats (LCOV, HTML, Cobertura, JSON)
- Ensure proper instrumentation for accurate coverage measurement

### 3. Coverage Analysis Implementation
Implement comprehensive coverage analysis:
- **Line Coverage**: Track which lines are executed during tests
- **Branch Coverage**: Identify uncovered conditional branches
- **Function Coverage**: Ensure all functions have test coverage
- **Integration Coverage**: Measure coverage across module boundaries

Generate detailed coverage metrics:
```python
{
    "total_lines": 1500,
    "covered_lines": 1425,
    "coverage_percentage": 95.0,
    "meets_threshold": true,
    "uncovered_files": {...},
    "branch_coverage": 92.5
}
```

### 4. Automated Test Generation
Create intelligent test generation for uncovered code:
- **Analysis**: Examine uncovered functions and code paths
- **Template Generation**: Create comprehensive test templates
- **Edge Cases**: Generate tests for boundary conditions and error paths
- **Integration Tests**: Create tests for module interactions
- **Mock Generation**: Generate mocks for external dependencies

Test generation template structure:
```rust
//! Generated tests for {source_file}
//! Auto-generated by Tess coverage workflow

#[cfg(test)]
mod generated_tests {
    use super::*;
    
    #[test]
    fn test_uncovered_function() {
        // Generated test for specific uncovered function
    }
    
    #[test] 
    fn test_error_conditions() {
        // Test error handling paths
    }
    
    #[test]
    fn test_boundary_conditions() {
        // Test edge cases and boundary conditions
    }
}
```

### 5. GitHub API Integration
**Location**: `controller/src/github/coverage_integration.rs`

Implement complete GitHub integration:
- **Authentication**: Secure GitHub token handling
- **PR Review Creation**: Submit approval/rejection reviews
- **Comment Updates**: Provide detailed coverage information
- **Status Checks**: Update PR status based on coverage results

Review creation logic:
```rust
pub async fn submit_coverage_review(
    &self,
    repo_info: &RepoInfo,
    pr_number: u32,
    coverage_report: &CoverageReport,
) -> Result<()> {
    let meets_thresholds = coverage_report.meets_existing_threshold 
        && coverage_report.meets_new_code_threshold;
    
    let review = if meets_thresholds {
        self.create_approval_review(coverage_report)
    } else {
        self.create_changes_requested_review(coverage_report)
    };
    
    self.submit_github_review(repo_info, pr_number, &review).await
}
```

### 6. Coverage Threshold Configuration
Implement configurable coverage thresholds:
- **Existing Code**: Default 95% coverage requirement
- **New Code**: Default 100% coverage requirement  
- **Configurable**: Allow per-project threshold customization
- **Gradual Improvement**: Support progressive coverage improvement targets

Configuration structure:
```rust
pub struct CoverageConfig {
    pub existing_code_threshold: f64,    // 95.0
    pub new_code_threshold: f64,         // 100.0
    pub enable_automatic_approval: bool,  // true
    pub enable_test_generation: bool,     // true
    pub report_formats: Vec<ReportFormat>,
}
```

### 7. Coverage Report Generation
Generate comprehensive coverage reports:
- **HTML Reports**: Interactive coverage visualization
- **Cobertura XML**: CI/CD integration format
- **LCOV Format**: Tool chain compatibility
- **JSON Data**: Programmatic access to metrics

Report structure:
```json
{
    "timestamp": "2024-01-15T10:30:00Z",
    "repository": "owner/repo",
    "pr_number": 123,
    "coverage": {
        "initial": 87.5,
        "final": 95.2,
        "improvement": 7.7,
        "meets_thresholds": true
    },
    "files": {
        "src/main.rs": {"coverage": 100.0, "lines": 150},
        "src/lib.rs": {"coverage": 92.0, "lines": 200}
    }
}
```

### 8. Trend Analysis and Historical Tracking
Implement coverage trend tracking:
- **Historical Data**: Store coverage metrics over time
- **Trend Analysis**: Identify improving/declining coverage
- **Regression Detection**: Alert on coverage decreases
- **Progress Tracking**: Monitor gradual coverage improvements

## Technical Requirements

### Error Handling and Recovery
- **Robust Error Handling**: Handle test failures gracefully
- **Partial Completion**: Continue workflow even if some tests fail
- **Rollback Capability**: Revert generated tests if they cause issues
- **Detailed Logging**: Comprehensive logging for debugging

### Performance Optimization
- **Incremental Analysis**: Only analyze changed code when possible
- **Parallel Execution**: Run tests in parallel where safe
- **Caching**: Cache coverage data and generated tests
- **Resource Management**: Manage memory usage for large codebases

### Integration Points
- **Argo Workflows**: Integrate with existing workflow system
- **Container Environment**: Ensure all tools work in container context
- **File System**: Proper file handling and cleanup
- **Network Access**: GitHub API and external tool access

## Testing Strategy

### Unit Tests
Test all components individually:
- Coverage calculation logic
- GitHub API integration
- Test generation algorithms
- Report generation functions
- Threshold evaluation logic

### Integration Tests
Test the complete workflow:
- End-to-end coverage analysis
- GitHub integration with test repository
- Report generation and artifact creation
- Error scenarios and recovery

### Performance Tests
Validate performance characteristics:
- Large codebase handling (10,000+ lines)
- Memory usage under load
- Coverage analysis speed
- Report generation performance

## Success Criteria

### Functional Requirements
1. **Coverage Analysis**: Accurately measure and report code coverage
2. **Test Generation**: Generate meaningful tests for uncovered code
3. **GitHub Integration**: Successfully approve/reject PRs based on coverage
4. **Report Quality**: Generate comprehensive, useful coverage reports
5. **Threshold Enforcement**: Correctly enforce 95%/100% thresholds

### Performance Requirements
1. **Analysis Speed**: Complete coverage analysis in < 5 minutes for typical projects
2. **Memory Usage**: Operate within 2GB memory limit
3. **Report Generation**: Generate all reports in < 2 minutes
4. **GitHub API**: API calls complete within 30 seconds

### Reliability Requirements
1. **Error Recovery**: Gracefully handle and recover from failures
2. **Data Integrity**: Ensure coverage data accuracy and consistency
3. **Tool Stability**: Handle tool failures and environment issues
4. **GitHub Integration**: Robust API interaction with proper retry logic

## Implementation Checklist

### Phase 1: Coverage Infrastructure
- [ ] Install and configure cargo llvm-cov in container
- [ ] Implement coverage analysis pipeline
- [ ] Create report generation system
- [ ] Validate coverage accuracy

### Phase 2: Test Generation
- [ ] Develop uncovered code identification
- [ ] Implement test template generation
- [ ] Create test execution pipeline  
- [ ] Validate generated test quality

### Phase 3: GitHub Integration
- [ ] Implement GitHub API client
- [ ] Create PR review system
- [ ] Add status update functionality
- [ ] Test with real GitHub repositories

### Phase 4: Workflow Integration
- [ ] Integrate all components into container script
- [ ] Add proper error handling and logging
- [ ] Implement performance optimizations
- [ ] Create comprehensive testing suite

## Configuration and Deployment

### Environment Variables
```bash
export COVERAGE_THRESHOLD_EXISTING=95
export COVERAGE_THRESHOLD_NEW=100
export ENABLE_AUTO_APPROVAL=true
export ENABLE_TEST_GENERATION=true
export GITHUB_TOKEN=<secure-token>
```

### Container Integration
Ensure the enhanced container-tess.sh.hbs script:
- Runs in the existing container environment
- Has access to all required tools and dependencies
- Produces artifacts in expected locations
- Integrates with existing workflow parameters

### Monitoring and Observability
- Structured logging for all operations
- Metrics export for coverage trends
- Error tracking and alerting
- Performance monitoring and profiling

## Dependencies and Prerequisites
- Existing Task Master workflow system (Tasks 6, 11)
- Container-tess.sh.hbs template foundation
- GitHub API access and authentication
- Rust toolchain with LLVM tools
- Argo Workflows execution environment