# Task ID: 26
# Title: Implement comprehensive task association validation using multi-method approach
# Status: pending
# Dependencies: 5, 3, 7
# Priority: high
# Description: Create a robust validation system that correlates workflows with tasks using three complementary methods (PR labels, branch naming, and marker files) with mandatory agreement between all methods to prevent workflow execution errors.
# Details:
Implement a three-tier validation approach for task-workflow association:

1. **Primary Method - PR Labels**: Extract task ID from PR labels using pattern 'task-{id}'. Implement in Sensor using JQ: '.pull_request.labels[] | select(.name | startswith("task-")) | .name | split("-")[1]'.

2. **Secondary Method - Branch Naming**: Parse branch names following pattern 'task-{id}-{description}' or 'feature/task-{id}'. Use regex: '^(?:feature/)?task-(\d+)(?:-.*)?$'. Extract task ID from pull_request.head.ref field.

3. **Fallback Method - Marker File**: Read docs/.taskmaster/current-task.json containing: {"task_id": "26", "started_at": "2024-01-15T10:00:00Z", "agent": "rex"}.

**Validation Logic Implementation**:
```yaml
# In Sensor trigger logic
validation:
  - name: extract-from-label
    template: '{{.Input.pull_request.labels | tojson | fromjson | map(select(.name | startswith("task-"))) | first | .name | split("-")[1]}}'
  - name: extract-from-branch
    template: '{{.Input.pull_request.head.ref | capture("task-(\\d+)") | .1}}'
  - name: read-marker-file
    resource:
      action: get
      manifest: |
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: task-marker-{{.Input.pull_request.head.sha}}
```

**Validation Enforcement**:
- All three methods must return the same task ID or workflow fails
- Implement comparison logic in Sensor using CEL expressions or Lua script
- On mismatch, create GitHub comment with validation error details
- Block workflow progression until validation passes

**Workflow Template Enhancement**:
```yaml
spec:
  entrypoint: validate-and-execute
  templates:
  - name: validate-and-execute
    steps:
    - - name: create-marker-file
        template: marker-file-creator
        arguments:
          parameters:
          - name: task-id
            value: "{{workflow.parameters.task-id}}"
    - - name: validate-association
        template: validation-checker
        arguments:
          parameters:
          - name: pr-label-id
            value: "{{tasks.extract-from-label.outputs.result}}"
          - name: branch-id
            value: "{{tasks.extract-from-branch.outputs.result}}"
          - name: marker-id
            value: "{{tasks.read-marker-file.outputs.result}}"
```

**Marker File Creation Template**:
```yaml
- name: marker-file-creator
  container:
    image: alpine/git
    command: [sh, -c]
    args:
    - |
      cat > /workspace/docs/.taskmaster/current-task.json <<EOF
      {
        "task_id": "{{inputs.parameters.task-id}}",
        "started_at": "$(date -Iseconds)",
        "agent": "{{workflow.parameters.implementation-agent}}",
        "workflow_id": "{{workflow.name}}",
        "commit_sha": "$(git rev-parse HEAD)"
      }
      EOF
      git add docs/.taskmaster/current-task.json
      git commit -m "chore: Set current task marker for task-{{inputs.parameters.task-id}}"
```

**Error Handling**:
- If validation fails, post GitHub comment with discrepancy details
- Log validation attempts to workflow annotations
- Implement retry mechanism with 3 attempts before permanent failure
- Create ValidationError CRD to track validation failures for debugging

# Test Strategy:
1. **Unit Testing**: Create test cases with various combinations of label/branch/marker values. Test scenarios: all match (pass), label missing (fail), branch mismatch (fail), marker file absent (fail), all different (fail).

2. **Integration Testing**: Submit test PRs with deliberate mismatches. Verify workflow suspension and error reporting. Test with concurrent PRs for same task ID.

3. **Validation Logic Testing**: Mock webhook payloads with different label configurations. Test regex patterns with edge cases: 'task-1-fix', 'feature/task-123-description', 'hotfix/task-45'.

4. **Marker File Testing**: Verify marker file creation at workflow start. Test file persistence across workflow stages. Validate JSON structure and required fields.

5. **Error Recovery Testing**: Test retry mechanism after validation failures. Verify GitHub comment creation with proper error details. Test workflow cleanup after validation rejection.

6. **Performance Testing**: Measure validation latency with large label sets. Test marker file I/O performance. Monitor Sensor processing time for validation logic.

7. **Security Testing**: Verify no sensitive data exposed in validation errors. Test injection attempts in branch names and labels. Validate marker file permissions and access controls.
