# Task ID: 8
# Title: Parallelism and workspace isolation using git worktrees or PVCs
# Status: pending
# Dependencies: None
# Priority: medium
# Description: Enable safe batching/parallelization of independent tasks using git worktrees as working directories with optional PVC isolation; apply rate limits.
# Details:
Implementation:
- In coderun-template init step, prepare a base repo clone and a unique worktree per taskId/PR:
  - git clone --no-checkout https://github.com/$OWNER/$REPO.git /work/base
  - git -C /work/base fetch origin $REF
  - git -C /work/base worktree add /work/trees/${TASK_ID} $REF
  - Set workspace.path in CodeRun spec to the worktree path
- For complete isolation option, mount separate PVC per parallel task:
  - Use volumeClaimTemplates in Workflow spec to create per-pod PVCs; gate behind a parameter usePVC=true.
- Concurrency controls:
  - Set spec.parallelism on workflows; add per-repo mutex via Argo Workflow Semaphore or ConfigMap-based lock to limit concurrent writes per repo/branch.
  - Apply Sensors rate limiting and debounce windows.
- Cleanup: delete worktrees post-run, prune refs; ensure finalizers clean PVCs.
Pseudocode:
TASK_ID=${PRNR:-$(date +%s)}
mkdir -p /work/trees
# create worktree, set env WORKSPACE=/work/trees/$TASK_ID



# Test Strategy:
Spawn N parallel workflows against the same repo/branch and verify each runs in a distinct worktree directory; ensure no file handle collisions. Validate semaphore limits when set to 1, only one writer proceeds. PVC mode: confirm persistent volume attaches and is cleaned post-run. Measure performance vs full clones.

# Subtasks:
## 1. Init base clone and per-task git worktree [pending]
### Dependencies: None
### Description: Create a reusable init step that prepares a shared base clone and a unique git worktree per taskId/PR under /work/trees/${TASK_ID}.
### Details:
Implementation notes:
- Directory layout: /work/base (shared clone), /work/trees/${TASK_ID} (per-task worktree)
- Exact commands (bash):
  set -euxo pipefail
  OWNER=${OWNER:?}
  REPO=${REPO:?}
  REF=${REF:-"refs/heads/main"}
  TASK_ID=${TASK_ID:-${PRNR:-$(date +%s)}}
  mkdir -p /work/base /work/trees
  if [ ! -d /work/base/.git ]; then
    git clone --no-checkout https://github.com/${OWNER}/${REPO}.git /work/base
  fi
  git -C /work/base fetch --no-tags --depth=1 origin "$REF"
  git -C /work/base worktree add "/work/trees/${TASK_ID}" FETCH_HEAD
  git config --global --add safe.directory /work/base
  git config --global --add safe.directory "/work/trees/${TASK_ID}"
  echo "/work/trees/${TASK_ID}" > /work/workspace_path
- Argo template example (init):
  templates:
  - name: init-worktree
    inputs:
      parameters:
      - {name: owner}
      - {name: repo}
      - {name: ref}
      - {name: taskId}
    script:
      image: alpine/git:2.44.0
      command: [sh, -c]
      source: |
        OWNER={{inputs.parameters.owner}}
        REPO={{inputs.parameters.repo}}
        REF={{inputs.parameters.ref}}
        TASK_ID={{inputs.parameters.taskId}}
        set -euxo pipefail
        mkdir -p /work/base /work/trees
        if [ ! -d /work/base/.git ]; then
          git clone --no-checkout https://github.com/${OWNER}/${REPO}.git /work/base
        fi
        git -C /work/base fetch --no-tags --depth=1 origin "$REF"
        git -C /work/base worktree add "/work/trees/${TASK_ID}" FETCH_HEAD
        git config --global --add safe.directory /work/base
        git config --global --add safe.directory "/work/trees/${TASK_ID}"
        echo "/work/trees/${TASK_ID}" > /work/workspace_path
      volumeMounts:
      - name: work
        mountPath: /work
- Acceptance criteria:
  - Given OWNER/REPO/REF/TASK_ID, init step creates /work/trees/${TASK_ID} and checks out the ref via worktree.
  - Running N instances in parallel creates N distinct directories with no collisions.
  - /work/workspace_path file contains the expected path.

## 2. Parameterize TASK_ID/REF and wire workspace.path in CodeRun [pending]
### Dependencies: 8.1
### Description: Expose parameters for owner, repo, ref, taskId; compute sane defaults; set CodeRun spec.workspace.path to the worktree path.
### Details:
Parameters:
- owner (required), repo (required)
- ref (default: refs/heads/main)
- taskId (default: {{workflow.parameters.prNumber}} or timestamp)
- workspacePath derived: /work/trees/{{inputs.parameters.taskId}}
Exact WorkflowTemplate snippet:
  apiVersion: argoproj.io/v1alpha1
  kind: WorkflowTemplate
  metadata:
    name: coderun-template
  spec:
    arguments:
      parameters:
      - {name: owner}
      - {name: repo}
      - {name: ref, value: "refs/heads/main"}
      - {name: taskId, value: "{{=sprig.default(nowEpoch, workflow.parameters.prNumber)}}"}
      - {name: github-app}
      - {name: usePVC, value: "false"}
      - {name: parallelism, value: "5"}
    parallelism: "{{workflow.parameters.parallelism}}"
    templates:
    - name: coderun-main
      inputs:
        parameters:
        - {name: owner}
        - {name: repo}
        - {name: ref}
        - {name: taskId}
        - {name: github-app}
      dag:
        tasks:
        - name: init
          template: init-worktree
          arguments:
            parameters:
            - {name: owner, value: "{{inputs.parameters.owner}}"}
            - {name: repo,  value: "{{inputs.parameters.repo}}"}
            - {name: ref,   value: "{{inputs.parameters.ref}}"}
            - {name: taskId,value: "{{inputs.parameters.taskId}}"}
        - name: run
          dependencies: [init]
          template: create-coderun
          arguments:
            parameters:
            - {name: workspacePath, value: "/work/trees/{{inputs.parameters.taskId}}"}
            - {name: github-app, value: "{{inputs.parameters.github-app}}"}
    - name: create-coderun
      inputs:
        parameters:
        - {name: workspacePath}
        - {name: github-app}
      resource:
        action: create
        manifest: |
          apiVersion: platform.example.io/v1alpha1
          kind: CodeRun
          metadata:
            generateName: coderun-
          spec:
            githubApp: {{inputs.parameters.github-app}}
            workspace:
              path: {{inputs.parameters.workspacePath}}
- Acceptance criteria:
  - workspace.path equals the init worktree path for the same taskId.
  - Ref and taskId are overridable via parameters and default sensibly.

## 3. Optional PVC isolation via volumeClaimTemplates gated by usePVC [pending]
### Dependencies: 8.1, 8.2
### Description: Provide per-pod PVC option to isolate /work using volumeClaimTemplates when usePVC=true; default to emptyDir when false.
### Details:
Volume specs:
- PVC template (10Gi, RWO, storageClass configurable):
  spec:
    volumeClaimTemplates:
    - metadata:
        name: work
        labels:
          workflow: {{workflow.name}}
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 10Gi
        storageClassName: fast-ssd
- Ephemeral fallback:
  spec:
    volumes:
    - name: work
      emptyDir: {}
Gating approach using podSpecPatch parameter:
- Add parameter pvcPodSpecPatch computed from usePVC.
- Example template usage:
  templates:
  - name: init-worktree
    podSpecPatch: "{{workflow.parameters.pvcPodSpecPatch}}"
    ...
- Example patch for PVC mode:
  pvcPodSpecPatch (string parameter value):
  |
    {
      "volumes": [
        {"name": "work", "persistentVolumeClaim": {"claimName": "work"}}
      ],
      "containers": [{
        "name": "main",
        "volumeMounts": [{"name": "work", "mountPath": "/work"}]
      }]
    }
- Example patch for emptyDir mode:
  |
    {
      "volumes": [
        {"name": "work", "emptyDir": {}}
      ],
      "containers": [{
        "name": "main",
        "volumeMounts": [{"name": "work", "mountPath": "/work"}]
      }]
    }
Controller-side:
- For usePVC=true workflows, include volumeClaimTemplates as above at Workflow (or WorkflowTemplate) spec level.
- For usePVC=false, omit volumeClaimTemplates and rely on emptyDir via podSpecPatch.
Acceptance criteria:
- When usePVC=true, pods mount a unique PVC named work and /work persists within pod lifecycle; PVC labeled workflow={{workflow.name}} exists during run.
- When usePVC=false, /work is emptyDir and no PVC resource is created.
- Both modes successfully run init-worktree and subsequent steps.

## 4. Concurrency controls: parallelism and per-repo/branch semaphore [pending]
### Dependencies: 8.2
### Description: Set spec.parallelism and enforce a per-repo/branch mutex using Argo Workflows synchronization via ConfigMap-based semaphore.
### Details:
Workflow parallelism:
- WorkflowTemplate.spec.parallelism: "{{workflow.parameters.parallelism}}"
Per-repo/branch semaphore (ConfigMap):
- Create ConfigMap to hold semaphore limits:
  apiVersion: v1
  kind: ConfigMap
  metadata:
    name: workflow-semaphores
    namespace: argo
  data:
    # key format: owner-repo-branch (sanitized)
    exampleorg-sample-main: "1"
- Ensure key exists for each repo/branch (command):
  BRANCH_SAFE=$(echo "$REF" | sed -E 's#^refs/(heads|tags)/##; s#[^a-zA-Z0-9_.-]#-#g' | tr '[:upper:]' '[:lower:]')
  KEY="${OWNER}-${REPO}-${BRANCH_SAFE}"
  kubectl -n argo get configmap workflow-semaphores >/dev/null 2>&1 || kubectl -n argo create configmap workflow-semaphores
  kubectl -n argo patch configmap workflow-semaphores --type merge -p "{\"data\":{\"${KEY}\":\"1\"}}"
WorkflowTemplate synchronization snippet:
  templates:
  - name: coderun-main
    synchronization:
      semaphore:
        configMapKeyRef:
          name: workflow-semaphores
          key: "{{=sprig.lower (regexReplaceAll "[^a-zA-Z0-9_.-]" (replace (replace inputs.parameters.owner \"\" \"\") | cat \"-\" inputs.parameters.repo | cat \"-\" (regexReplaceAll \"^refs/(heads|tags)/\" inputs.parameters.ref \"\") ) \"-\")}}"
Acceptance criteria:
- With semaphore key limit set to 1, only one workflow referencing the same repo/branch proceeds concurrently; additional ones wait.
- Increasing the key value increases concurrency accordingly.
- spec.parallelism caps overall parallel pods as configured.

## 5. Cleanup: delete worktrees and prune refs; PVC cleanup on completion [pending]
### Dependencies: 8.1, 8.3
### Description: Add onExit cleanup to remove worktrees, prune refs, and ensure PVCs are cleaned when enabled.
### Details:
Cleanup commands (bash):
  set -euxo pipefail
  TASK_ID=${TASK_ID:?}
  BASE=/work/base
  TREE=/work/trees/${TASK_ID}
  if [ -d "$TREE/.git" ] || [ -d "$TREE" ]; then
    git -C "$BASE" worktree remove --force "$TREE" || true
  fi
  git -C "$BASE" worktree prune || true
  git -C "$BASE" remote prune origin || true
  git -C "$BASE" gc --prune=now --aggressive || true
  rm -rf "$TREE" || true
PVC cleanup:
- Label PVC in volumeClaimTemplates with workflow={{workflow.name}}.
- onExit template deletes PVCs only when usePVC=true:
  kubectl delete pvc -l workflow={{workflow.name}} || true
Workflow onExit wiring example:
  spec:
    onExit: cleanup
  templates:
  - name: cleanup
    inputs:
      parameters:
      - {name: taskId}
      - {name: usePVC}
    script:
      image: alpine/git:2.44.0
      command: [sh, -c]
      source: |
        TASK_ID={{inputs.parameters.taskId}}
        {{- if eq inputs.parameters.usePVC "true" -}}
        kubectl delete pvc -l workflow={{workflow.name}} || true
        {{- end -}}
        set -euxo pipefail
        BASE=/work/base
        TREE=/work/trees/${TASK_ID}
        git -C "$BASE" worktree remove --force "$TREE" || true
        git -C "$BASE" worktree prune || true
        git -C "$BASE" remote prune origin || true
        git -C "$BASE" gc --prune=now || true
      volumeMounts:
      - name: work
        mountPath: /work
Acceptance criteria:
- After workflow completion, no /work/trees/${TASK_ID} directory remains.
- Base repo has pruned worktree metadata; subsequent runs succeed.
- When usePVC=true, the PVC(s) created for the run are deleted automatically by onExit.

## 6. Sensors: rate limiting and debounce windows [pending]
### Dependencies: 8.4
### Description: Configure Argo Events Sensor to limit trigger rate and debounce bursts of events for the same repo/ref.
### Details:
Sensor YAML (example):
  apiVersion: argoproj.io/v1alpha1
  kind: Sensor
  metadata:
    name: repo-workflow-sensor
    namespace: argo-events
  spec:
    eventBusName: default
    rateLimit:
      unit: minute
      requestsPerUnit: 30
    template:
      serviceAccountName: argo-events-sa
    eventDependencies:
    - name: github-pr
      eventSourceName: github
      eventName: pull_request
      filters:
        data:
        - path: body.action
          type: string
          value: [opened, synchronize, reopened]
        # Debounce: only pass an event if at least 15s since the last accepted one per repo/ref (requires CEL filter support)
        expr:
          expression: "debounce(event.repo.full_name + ':' + event.body.pull_request.base.ref, duration('15s'))"
    triggers:
    - template:
        name: submit-workflow
        k8s:
          group: argoproj.io
          version: v1alpha1
          resource: workflows
          operation: create
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: pr-validate-
              spec:
                workflowTemplateRef:
                  name: coderun-template
                arguments:
                  parameters:
                  - name: owner
                    value: "{{(jsonpath "$.body.repository.owner.login")}}"
                  - name: repo
                    value: "{{(jsonpath "$.body.repository.name")}}"
                  - name: ref
                    value: "refs/heads/{{(jsonpath "$.body.pull_request.base.ref")}}"
                  - name: taskId
                    value: "pr-{{(jsonpath "$.body.pull_request.number")}}-{{(jsonpath "$.headers.X-GitHub-Delivery")}}"
Acceptance criteria:
- Sensor enforces max 30 workflow submissions per minute.
- Multiple rapid synchronize events on the same PR are collapsed so at most one workflow is created in a 15s window.

## 7. Performance and correctness testing under N parallel runs [pending]
### Dependencies: 8.1, 8.2, 8.3, 8.4, 8.5, 8.6
### Description: Benchmark worktree approach vs full clones and validate correctness under high parallelism and semaphore limits.
### Details:
Test plan:
- Correctness tests:
  - Submit N parallel workflows (e.g., N=20) with the same repo/ref and distinct taskIds.
  - Verify each workflow uses a unique path and no file descriptor collisions occur.
  - With semaphore limit=1 for the repo/ref, confirm only one active writer; others wait.
- Performance benchmark (worktree vs full clone):
  - Worktree time: measure duration of init-worktree step.
  - Full clone time: run `time git clone --depth=1 https://github.com/${OWNER}/${REPO}.git /tmp/full-${TASK_ID}` as a control.
  - Record CPU, network bytes, and wall clock for M runs (M>=10) and compute averages.
- Automation commands:
  OWNER=exampleorg; REPO=sample; REF=refs/heads/main; N=20
  for i in $(seq 1 $N); do \
    argo submit --from workflowtemplate/coderun-template \
      -p owner=$OWNER -p repo=$REPO -p ref=$REF -p taskId="bench-$i-$(date +%s)" \
      -p github-app=rex -p usePVC=false &
  done; wait
  # Set semaphore to 1 and repeat to validate mutex
  kubectl -n argo patch configmap workflow-semaphores --type merge -p "{\"data\":{\"${OWNER}-${REPO}-main\":\"1\"}}"
Acceptance criteria:
- With N parallel runs, all succeed with distinct worktree paths and without git index corruption.
- Worktree init is measurably faster (>2x) and transfers fewer bytes than full clones on average.
- With semaphore=1, at most one active workflow step enters the critical section concurrently.

## 8. Documentation and operational runbook [pending]
### Dependencies: 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7
### Description: Document setup, parameters, failure modes, and SRE runbook for isolation, concurrency, and cleanup.
### Details:
Content outline:
- Overview: rationale for git worktrees, optional PVCs, and concurrency controls.
- Setup steps:
  - Install/upgrade coderun-template WorkflowTemplate.
  - Create workflow-semaphores ConfigMap and how to add keys (commands provided in subtask 4).
  - Configure Sensor (rateLimit and debounce) and GitHub webhook secrets.
- Parameters and defaults: owner, repo, ref, taskId, github-app, usePVC, parallelism.
- Volume modes: when to usePVC; storageClass guidance; default sizes.
- Concurrency: how to set parallelism; how to tune semaphore limits per repo/branch.
- Cleanup behavior: onExit logic; how to recover stuck PVCs or orphaned worktrees.
- Troubleshooting:
  - git safe.directory errors; permissions; shallow fetch issues; worktree remove force.
  - Semaphore key missing or mis-sanitized; how to inspect waiting workflows.
  - Sensor rate limits and debounce tuning.
- Acceptance criteria:
  - Docs enable a new operator to deploy and operate the flow in a fresh namespace within 30 minutes.
  - Runbook contains concrete kubectl/argo commands for common ops (scale up/down, drain, cleanup).

