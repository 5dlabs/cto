# Task ID: 2
# Title: Low-latency JSONL Tailer (≤100ms) with Inotify + Fallback
# Status: pending
# Dependencies: 1
# Priority: medium
# Description: Implement append-only JSONL tailing from Claude transcript with ≤100ms average latency and low CPU.
# Details:
- Use Linux inotify (inotify-rs) for write/close_write/modify events; fall back to polling every poll_interval_ms when inotify unsupported
- Handle file rotation and session discovery: watch directory ~/.claude/projects/<encoded-workspace>/ for new <session>.jsonl; pick latest mtime
- Maintain an async file reader with an internal offset; when notified, read to EOF, splitting by newline; tolerate partial lines
- Backpressure-safe channel to downstream parser
- Pseudo-code:
  struct Tail { file: File, path: PathBuf, pos: u64, watcher: Option<InotifyWatcher>, poll: Interval }
  impl Tail { async fn next_line(&mut self)->Option<String>{ loop { if let Some(line)=read_if_available(){ return Some(line) } if let Some(evt)=self.watcher.next_event().await { if evt.is_write(){ continue } if evt.is_move_or_rename(){ reopen_latest()? } } else { self.poll.tick().await; continue } } }}
- Optimize reads with BufReader and read_to_end chunking; ensure minimal allocations
- Ensure CPU usage <1% by event-driven approach; when idle, sleep


# Test Strategy:
- Integration test: write N JSONL lines in a temp file with random intervals; assert tailer emits each within ≤100ms on average; use tokio time::pause for deterministic timing
- Rotation test: move file and create new file; ensure Tail reopens and continues
- Large line test: long JSON line (>10KB) to ensure no truncation before parse
- Linux-only inotify test gated by cfg(target_os)
- Measure CPU usage with a load test and ensure budget met

# Subtasks:
## 1. Tail core: async reader and offset management [pending]
### Dependencies: None
### Description: Define Tail struct and core async logic to read from an append-only JSONL file while tracking an internal byte offset.
### Details:
- Implement struct Tail { file: tokio::fs::File, path: PathBuf, pos: u64, poll: Option<tokio::time::Interval>, watcher: Option<InotifyHandle>, buf: Vec<u8>, line_buf: Vec<u8> }
- Provide async methods: Tail::open(path), Tail::reopen(path), Tail::read_available() -> Reads from current pos to EOF without blocking when no data
- Ensure pos advances only by bytes successfully consumed into complete lines; partial trailing bytes remain in line_buf
- Do not spin when idle: yield on no data; integrate with event/poll signals (wired in subtasks 2/3)
- Config: poll_interval_ms, max_read_chunk (e.g., 64–256 KiB), workspace_dir
- Acceptance: Can open an existing file, start at EOF, and read new appends without re-reading old content; no busy-loop when idle

## 2. Inotify watcher for write/close/rename [pending]
### Dependencies: 2.1
### Description: Integrate inotify-rs to receive low-latency notifications for file and directory events that indicate new data or rotation.
### Details:
- Use inotify (or notify crate with inotify backend) on Linux; masks: MODIFY, CLOSE_WRITE, MOVED_TO, MOVED_FROM, MOVE_SELF, DELETE_SELF, CREATE
- Watch both the active file and its parent directory to catch rotations and new sessions
- Map events to actions: write/close_write => read_available; move/rename/delete => trigger reopen discovery
- Handle queue overflow (IN_Q_OVERFLOW): fall back to a full resync by stat/reopen latest and fast-forward pos safely
- If inotify init fails, set watcher=None so polling fallback (Subtask 3) drives progress
- Acceptance: On a single append, an event arrives and triggers a read cycle within one wake; errors are surfaced but do not crash the loop

## 3. Polling fallback with tokio Interval [pending]
### Dependencies: 2.1
### Description: Provide a low-CPU polling path when inotify is unavailable or disabled.
### Details:
- Create tokio::time::Interval with configurable poll_interval_ms (default 50ms) to check for file growth or rotation
- On each tick, stat file size/inode; if size > pos, read_available; if inode changed or size < pos, treat as rotation/truncate and reopen
- Ensure sleep when idle; no tight loops; jitter option (+/- 10%) to avoid phase lock across many instances
- Acceptance: With only polling enabled, average end-to-end line latency ≤100ms when poll_interval_ms ≤50ms; idle CPU <1%

## 4. Session discovery and latest-by-mtime selection [pending]
### Dependencies: 2.1, 2.2, 2.3
### Description: Discover and track the current session JSONL file under ~/.claude/projects/<encoded-workspace>/, switching to the most recent by mtime.
### Details:
- Monitor the workspace directory for new *.jsonl files (inotify CREATE/MOVED_TO) and maintain a sorted view by mtime
- On startup, pick the latest mtime file; when new session appears or active file is moved/deleted, reopen the latest
- Normalize and resolve symlinks; ensure permissions and existence checks
- Provide helper: fn latest_session(dir) -> Option<PathBuf>
- Acceptance: When a new session file is created, tailer switches within ≤100ms (inotify) or within one poll tick (polling fallback); always selects the newest mtime

## 5. Robust JSONL line splitting with partial buffering and minimal allocations [pending]
### Dependencies: 2.1
### Description: Implement efficient newline-delimited parsing that tolerates partial lines and large JSON strings.
### Details:
- Use tokio::io::BufReader<File> with a tuned capacity (e.g., 64–256 KiB); read_to_end-style chunking into a reusable Vec<u8>
- Maintain a reusable line_buf for partial trailing data; scan for '\n' and emit complete lines; retain remainder across reads/rotations
- Support very large lines (>10 KiB, up to several MB) without quadratic copies; grow buffers with amortized strategy
- Validate UTF-8; if invalid, buffer until newline and attempt lossy decode or drop with error metric (configurable)
- Acceptance: No panics on long lines; per-line allocations minimized (≤2 Vec growths on average for typical lines); preserves partial lines until completion

## 6. Backpressure-safe channel to downstream parser [pending]
### Dependencies: 2.1, 2.5
### Description: Expose a bounded mpsc channel for lines, ensuring producer backpressure and bounded memory.
### Details:
- Use tokio::sync::mpsc::channel with configurable capacity (e.g., 1024)
- Producer awaits send when full; optionally expose try_send with metrics for drops if a drop policy is enabled by config
- Surface a graceful shutdown signal; on receiver drop, tailer stops reading and closes cleanly
- Emit metrics: queue depth, send wait time, dropped count (if enabled)
- Acceptance: Under a slow consumer, memory remains bounded, no busy-waiting, and CPU stays <1% idle

## 7. File rotation and truncate handling [pending]
### Dependencies: 2.1, 2.2, 2.3, 2.4, 2.5
### Description: Detect and handle file moves/renames/truncates without duplicating or losing lines.
### Details:
- On MOVE/RENAME/DELETE or inode change/size shrink, flush any complete lines from buffers, then reopen latest session
- If the same path is recreated, detect new inode; reset pos to 0; if truncated (size < pos), reset pos accordingly
- Preserve partial trailing bytes logically only if the same inode continues; on rotation to a new file, discard incomplete fragment (configurable) to avoid corrupt JSON
- Ensure duplicate-suppression: do not re-emit already read bytes; verify via inode+pos tracking
- Acceptance: Rotation test passes with zero duplicates/loss; switching happens within ≤100ms (inotify) or one poll tick; handles rapid successive rotations

## 8. Tests and benchmarks: latency, rotation, large lines, Linux-gated inotify [pending]
### Dependencies: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7
### Description: Build comprehensive tests and simple benches to validate latency, correctness, and resource usage; gate inotify tests to Linux.
### Details:
- Integration: write N JSONL lines to a temp file with random 10–50ms intervals; assert average end-to-end latency ≤100ms; measure from write completion to receive
- Rotation: move active file, create a new one, continue writing; assert no duplicates/misses and fast switch
- Large line: emit >10 KiB and >1 MiB lines; ensure memory remains bounded and no panic
- Inotify gating: cfg(target_os="linux") for inotify-specific tests; ensure polling path tests run on all platforms
- CPU idle check: when idle for 30s, process CPU <1% (approximate via /proc sampling on Linux or coarse wall-clock vs CPU time)
- Benchmark sanity: sustained 100 lines/sec for 10s without backlog; queue depth stays below capacity
- Acceptance: All tests green; metrics meet latency ≤100ms avg and idle CPU <1%

