# Task ID: 2
# Title: External Secrets for GitHub App credentials and token generation pattern
# Status: pending
# Dependencies: None
# Priority: medium
# Description: Configure External Secrets to source GitHub App app-id and private key and expose them to workflows; implement a lightweight token generator to exchange for installation tokens without using PATs.
# Details:
Implementation:
- Create ExternalSecret resources (backed by your chosen SecretStore) to project secrets:
  - Name: github-app-rex, keys: appId, privateKey
  - Name: github-app-clippy, keys: appId, privateKey
  - Name: github-app-qa, keys: appId, privateKey
  - Name: github-app-triage, keys: appId, privateKey
  - Name: github-app-security, keys: appId, privateKey
- Define a common initContainer (or sidecar) image (tiny Go/Node) that:
  - Reads APP_ID and PRIVATE_KEY from mounted secret
  - Reads INSTALLATION_ID (passed via param or detected from repo) via GitHub API /app/installations
  - Creates a JWT with RS256 for the GitHub App
  - Exchanges JWT for installation token via POST /app/installations/{id}/access_tokens
  - Exports GITHUB_TOKEN to a shared emptyDir for steps that need GitHub access
- Mount: /var/run/github (emptyDir) shared between initContainer and main container(s).
- WorkflowTemplate adds env:
  - GITHUB_APP_ID, GITHUB_APP_PRIVATE_KEY from secret
  - GITHUB_TOKEN_FILE=/var/run/github/token
- Permissions: Lock down RBAC to only read the secrets; least privilege scopes for the Apps (contents:read/write, pull_requests:read/write, issues:read/write, checks:read, security_events:read as needed).
Pseudocode (token generator in Node.js):
const jwt = createAppJWT(appId, privateKey)
const inst = await gh('/app/installations',{auth: jwt})
const token = await gh(`/app/installations/${instId}/access_tokens`, {method:'POST', auth: jwt})
fs.writeFileSync('/var/run/github/token', token.token)
process.env.GITHUB_TOKEN = token.token

# Test Strategy:
Deploy ExternalSecrets and verify Kubernetes secrets are synced. Run a dry-run Workflow that mounts a GitHub App secret and prints `gh auth status` using the token. Confirm no PAT usage. Rotate secrets in the backend and verify refresh. Negative test: invalid key should fail fast.

# Subtasks:
## 1. SecretStore wiring and ExternalSecret manifests for GitHub Apps [pending]
### Dependencies: None
### Description: Configure External Secrets to sync appId and privateKey for rex, clippy, qa, triage, security GitHub Apps from the chosen SecretStore.
### Details:
Manifests (example using External Secrets Operator with AWS Secrets Manager):
- SecretStore:
  apiVersion: external-secrets.io/v1beta1
  kind: SecretStore
  metadata:
    name: aws-secrets
    namespace: workflows
  spec:
    provider:
      aws:
        service: SecretsManager
        region: us-east-1
        auth:
          jwt:
            serviceAccountRef:
              name: external-secrets-sa
              namespace: workflows
- ExternalSecret (repeat for each app: rex, clippy, qa, triage, security):
  apiVersion: external-secrets.io/v1beta1
  kind: ExternalSecret
  metadata:
    name: github-app-rex
    namespace: workflows
  spec:
    refreshInterval: 1h
    secretStoreRef:
      name: aws-secrets
      kind: SecretStore
    target:
      name: github-app-rex
      template:
        type: Opaque
    data:
      - secretKey: appId
        remoteRef: { key: /github-apps/rex/appId }
      - secretKey: privateKey
        remoteRef: { key: /github-apps/rex/privateKey }
Repeat with keys under /github-apps/{clippy|qa|triage|security}/.
Command lines:
- kubectl apply -f secretstore.yaml
- kubectl apply -f externalsecret-github-app-*.yaml
Security notes:
- No PATs; only GitHub App credentials. Restrict SecretStore IAM to read exact secret ARNs/paths. Ensure privateKey stored base64-encoded or plain PEM per provider guidance and is never logged.
Acceptance criteria:
- K8s Secrets github-app-{rex,clippy,qa,triage,security} exist with keys appId and privateKey.
- ExternalSecret status Synced with no errors.
- Rotating a value in the backend reflects into the K8s Secret within refreshInterval.

## 2. Minimal token generator implementation (JWT + installation token) [pending]
### Dependencies: None
### Description: Build a tiny Node.js or Go service/CLI that creates a GitHub App JWT and exchanges it for an installation token.
### Details:
Implementation outline (Node.js):
- Inputs: APP_ID, PRIVATE_KEY (PEM), INSTALLATION_ID (optional), GITHUB_API_URL (default https://api.github.com), OUTPUT_PATH (/var/run/github/token).
- Steps:
  1) Create JWT (RS256) with claims: iss=APP_ID, iat=now-60s, exp=now+540s.
  2) If INSTALLATION_ID unset, call GET /app/installations (requires JWT) and select the correct installation (by repo/org if provided via params REPO/OWNER).
  3) Exchange JWT for installation token: POST /app/installations/{id}/access_tokens.
  4) Write token.token to OUTPUT_PATH with 0600 perms; optionally export to stdout if requested.
- API endpoints used:
  - GET https://api.github.com/app
  - GET https://api.github.com/app/installations
  - POST https://api.github.com/app/installations/{installation_id}/access_tokens
- Security notes:
  - Do not log PRIVATE_KEY or tokens. Use memory-only variables; zero buffers when possible. Set file mode 0600 and atomic write.
  - Do not use PATs. Limit scopes via App permissions only.
Acceptance criteria:
- Running locally with env vars produces a valid token file and gh auth status recognizes it.
- Handles errors with clear exit codes/messages for 401/403, 404, 5xx.

## 3. Containerization and CI publish for the generator [pending]
### Dependencies: 2.2
### Description: Create Docker image for the token generator and set up CI to build, tag, scan, and publish.
### Details:
Containerization:
- Dockerfile (Node.js example):
  FROM node:20-alpine AS build
  WORKDIR /app
  COPY package*.json .
  RUN npm ci --omit=dev
  COPY . .
  RUN npm run build || true
  FROM gcr.io/distroless/nodejs20-debian12
  WORKDIR /app
  COPY --from=build /app /app
  USER 65532:65532
  ENV NODE_ENV=production
  ENTRYPOINT ["node","/app/index.js"]
CI (GitHub Actions example):
- Trigger on push to main and tags.
- Steps: checkout, set up QEMU+Buildx, docker/login-action, docker/metadata-action, docker/build-push-action with SBOM and provenance, trivy scan.
Command lines:
- docker build -t ghcr.io/ORG/ghapp-token-gen:0.1.0 .
- docker push ghcr.io/ORG/ghapp-token-gen:0.1.0
Security notes:
- Run as non-root, read-only rootfs if possible, drop NET_RAW.
- Publish SBOM and sign image (cosign).
Acceptance criteria:
- Image is published (e.g., ghcr.io/ORG/ghapp-token-gen:TAG) and <50MB compressed if feasible.
- CI passes with vulnerability scan clean or justified.

## 4. Env/secret mounts and parameterization (APP_ID, PRIVATE_KEY, INSTALLATION_ID) [pending]
### Dependencies: 2.1
### Description: Define how workflows pass GitHub App credentials and installation parameters to the generator using secrets and params.
### Details:
Workflow wiring patterns:
- Mount K8s Secret for the chosen App and export env to the generator:
  env:
    - name: APP_ID
      valueFrom: { secretKeyRef: { name: github-app-rex, key: appId } }
    - name: PRIVATE_KEY
      valueFrom: { secretKeyRef: { name: github-app-rex, key: privateKey } }
    - name: INSTALLATION_ID
      value: "{{workflow.parameters.installationId}}"  # optional
    - name: OUTPUT_PATH
      value: /var/run/github/token
    - name: GITHUB_API_URL
      value: https://api.github.com
- Alternatively, mount secret as volume for large PEMs:
  volumeMounts: [{ name: github-app-secret, mountPath: /secrets/github, readOnly: true }]
  volumes:
    - name: github-app-secret
      secret: { secretName: github-app-rex }
  Then set PRIVATE_KEY by reading /secrets/github/privateKey inside the container.
Parameters:
- workflow.parameters.githubApp: one of {rex, clippy, qa, triage, security} to select which Secret to mount.
- workflow.parameters.installationId: optional; if empty, generator will auto-discover via /app/installations.
Security notes:
- Avoid printing env with secrets. Prefer secret volume + file read for PRIVATE_KEY to minimize env exposure. Use least-privileged App per workflow role.
Acceptance criteria:
- A template can switch GitHub App by parameter and receives correct APP_ID/PRIVATE_KEY.
- PRIVATE_KEY accessible to generator with no logs or leaks.

## 5. Workflow/initContainer or sidecar integration writing token to /var/run/github/token [pending]
### Dependencies: 2.3, 2.4
### Description: Integrate the token generator as an initContainer or sidecar that writes token to a shared emptyDir consumed by main steps.
### Details:
Argo WorkflowTemplate snippet (initContainer pattern):
- volumes:
  - name: github-tmp
    emptyDir: {}
- initContainers:
  - name: gh-token
    image: ghcr.io/ORG/ghapp-token-gen:TAG
    env: [APP_ID, PRIVATE_KEY, INSTALLATION_ID, OUTPUT_PATH=/var/run/github/token, GITHUB_API_URL=https://api.github.com]
    volumeMounts:
      - { name: github-tmp, mountPath: /var/run/github }
      - { name: github-app-secret, mountPath: /secrets/github, readOnly: true }
- containers (main):
  - name: runner
    image: alpine:3.20
    env:
      - name: GITHUB_TOKEN_FILE
        value: /var/run/github/token
    volumeMounts:
      - { name: github-tmp, mountPath: /var/run/github }
Security notes:
- Token file mode 0600; do not echo token. Consider sidecar with periodic refresh for long-running jobs; initContainer is sufficient for <60 min tasks.
Acceptance criteria:
- Main step can read /var/run/github/token and successfully call GitHub APIs.
- Token is not present in container logs or env dumps.

## 6. RBAC scoping for reading secrets only [pending]
### Dependencies: 2.1
### Description: Create ServiceAccount, Role, and RoleBinding to allow workflow pods to read only the specific GitHub App secrets.
### Details:
Manifests:
- ServiceAccount: workflows-sa (namespace: workflows).
- Role (namespace-scoped):
  kind: Role
  metadata: { name: github-app-secrets-read, namespace: workflows }
  rules:
    - apiGroups: [""]
      resources: ["secrets"]
      resourceNames: ["github-app-rex","github-app-clippy","github-app-qa","github-app-triage","github-app-security"]
      verbs: ["get"]
- RoleBinding:
  kind: RoleBinding
  metadata: { name: workflows-sa-secrets-read, namespace: workflows }
  subjects: [{ kind: ServiceAccount, name: workflows-sa }]
  roleRef: { kind: Role, name: github-app-secrets-read, apiGroup: rbac.authorization.k8s.io }
Argo config:
- Set the Workflow defaultServiceAccount to workflows-sa or reference per WorkflowTemplate.
Security notes:
- Principle of least privilege: no list/watch on secrets, no cluster-wide access.
- Ensure External Secrets Operator has separate, appropriate RBAC/IAM for SecretStore access.
Acceptance criteria:
- Workflow pods using workflows-sa can mount/read only the listed secrets; attempts to access other secrets are forbidden.

## 7. Rotation and failure handling (fast-fail, retries, backoff) [pending]
### Dependencies: 2.2, 2.5
### Description: Implement token generator retry/backoff and document secret/token rotation behavior.
### Details:
Generator behavior:
- Retries: exponential backoff for 5xx/429 (e.g., 5 attempts, base 500ms, max 5s, jitter). Fast-fail on 401/403 with clear message.
- Token TTL management: respect expires_at; for sidecar mode, refresh at 80% TTL; for init mode, exit after write.
- Atomic token write: write to temp file then rename; chmod 0600.
ExternalSecret rotation:
- Set refreshInterval (e.g., 1h). Rotating backend secrets should update K8s Secret; new workflows pick up new credentials.
- For live rotation needs, mount secrets as volumes and signal sidecar to reload (optional enhancement).
Command lines:
- Rotate backend secret (provider-specific) then observe K8s Secret update: kubectl get secret github-app-rex -o jsonpath='{.metadata.resourceVersion}'.
Security notes:
- On rotation failure, do not continue with stale or partial tokens. Never fall back to PATs.
Acceptance criteria:
- 5xx transient errors are retried with backoff; 401/403 fail fast (non-zero exit).
- After backend key rotation, new workflow runs succeed using refreshed secrets.

## 8. Tests and documentation (dry-run workflow, gh auth status, rotation test) [pending]
### Dependencies: 2.1, 2.3, 2.5, 2.6, 2.7
### Description: Add validation workflows and docs to verify token generation and secret rotation, and ensure no PAT usage.
### Details:
Tests:
- Dry-run Workflow: mount a GitHub App secret, run initContainer to write token, then main step runs:
  - apk add gh (or use gh CLI image) and executes: GH_TOKEN=$(cat /var/run/github/token) gh auth status -h github.com -t "$GH_TOKEN"
  - Call a read API (GET /rate_limit) to confirm access.
- Negative test: inject invalid privateKey to confirm fast-fail and clear error.
- Rotation test: update backend secret value; wait for ExternalSecret sync; rerun dry-run workflow and confirm success with new credentials.
Docs:
- README with: architecture diagram, security notes (no PATs; key handling; RBAC), how to choose init vs sidecar, parameters, troubleshooting matrix, and acceptance criteria.
Acceptance criteria:
- Dry-run workflow passes and prints authenticated status for the selected App account.
- Negative test fails quickly with 401/403.
- Rotation test demonstrates refreshed credentials being used in a subsequent run.

