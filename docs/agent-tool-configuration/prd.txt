<context>
# Overview
The Agent Tool Configuration system transforms tool management from a task-based dynamic generation approach to an agent-centric static configuration model. Currently, each task requires the docs agent to analyze requirements and generate custom tool configurations, consuming significant tokens. The new system treats tools as inherent capabilities of agents, similar to how employees have standard toolsets, reducing token usage by 70% and improving consistency.

# Core Features
## Agent-Centric Tool Profiles
- **Static Tool Assignment**: Each agent has predefined tools based on their role
- **Role-Based Toolsets**: Rex gets development tools, Cleo gets quality tools, Tess gets testing tools
- **Inheritance System**: Base tools shared across agents with role-specific additions
- **No Dynamic Generation**: Eliminate per-task tool configuration generation

## Tool Management System
- **Tool Catalog**: Central registry of all available tools with descriptions
- **Agent Profiles**: Predefined configurations for each agent type
- **Version Control**: Track tool versions and compatibility
- **Easy Updates**: Modify agent tools without changing task logic

## Configuration Architecture
- **Values-Based Config**: Tool assignments in Helm values.yaml
- **Template Simplification**: Remove dynamic client-config generation
- **Consistent Experience**: Same agent always has same tools
- **Performance Optimization**: No generation delay for client-config.json

# User Experience
## User Personas
- **Platform Engineers**: Configure agent tool profiles centrally
- **DevOps Teams**: Manage tool availability and versions
- **AI Agents**: Receive consistent toolsets for their role
- **Development Teams**: Benefit from predictable agent capabilities

## Key User Flows
1. **Agent Initialization**: Agent starts with predefined tools immediately
2. **Tool Discovery**: Agents can query their available tools
3. **Profile Updates**: Platform engineers modify agent capabilities
4. **Task Execution**: No tool generation step, immediate task processing
</context>

<PRD>
# Technical Architecture

## System Components

### Core Infrastructure
- **Tool Catalog**: Registry of all available MCP tools and their specifications
- **Agent Profiles**: Static configurations defining each agent's toolset
- **ConfigMap Generation**: Build client-config.json from agent profiles
- **Template System**: Simplified templates without dynamic generation

### Agent Tool Profile Architecture
```yaml
Agent Profiles Structure:
  Base Profile:
    - Common tools all agents need
    - Memory management
    - Basic file operations
    
  Role Profiles:
    - Developer: Code generation, git, documentation access
    - Quality: Linting, formatting, test execution
    - Testing: Deployment, validation, monitoring
    
  Agent-Specific:
    - Rex: Extends developer profile
    - Cleo: Extends quality profile  
    - Tess: Extends testing profile
```

### Tool Inheritance Model
```yaml
toolProfiles:
  base:
    remote:
      - "memory_create_entities"
      - "memory_query_entities"
    local:
      filesystem:
        - "read_file"
        - "write_file"
        - "list_directory"

  developer:
    extends: base
    remote:
      - "rustdocs_query_rust_docs"
      - "github_create_pr"
      - "brave-search_brave_web_search"
    local:
      filesystem:
        - "edit_file"
        - "search_files"
      git:
        - "git_status"
        - "git_diff"
        - "git_commit"

  quality:
    extends: base
    remote:
      - "rustdocs_query_rust_docs"
      - "github_create_check"
    local:
      linting:
        - "clippy_check"
        - "rustfmt_format"
      testing:
        - "cargo_test"
        - "cargo_build"
```

## Data Models

### Agent Configuration Schema
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct AgentConfig {
    pub name: String,
    pub role: String,
    pub expertise: Vec<String>,
    pub tools: AgentTools,
    pub resources: ResourceRequirements,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AgentTools {
    pub extends: Option<String>,  // Parent profile
    pub remote: Vec<String>,       // Remote MCP tools
    pub local: LocalTools,         // Local server tools
    pub custom: Vec<CustomTool>,   // Agent-specific tools
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LocalTools {
    pub filesystem: Vec<String>,
    pub git: Vec<String>,
    pub database: Vec<String>,
    pub testing: Vec<String>,
    pub linting: Vec<String>,
}
```

### Client Config Generation
```rust
impl AgentConfig {
    fn generate_client_config(&self) -> ClientConfig {
        let mut config = ClientConfig::default();
        
        // Add remote tools
        config.remote_tools = self.resolve_remote_tools();
        
        // Configure local servers
        if !self.tools.local.filesystem.is_empty() {
            config.local_servers.insert(
                "filesystem".to_string(),
                LocalServer {
                    command: "npx".to_string(),
                    args: vec![
                        "-y".to_string(),
                        "@modelcontextprotocol/server-filesystem".to_string(),
                        "/workspace".to_string()
                    ],
                    tools: self.tools.local.filesystem.clone(),
                }
            );
        }
        
        // Add other local servers
        self.configure_git_server(&mut config);
        self.configure_database_server(&mut config);
        self.configure_testing_server(&mut config);
        
        config
    }
    
    fn resolve_remote_tools(&self) -> Vec<String> {
        let mut tools = Vec::new();
        
        // Resolve inheritance chain
        if let Some(parent) = &self.tools.extends {
            tools.extend(self.get_parent_tools(parent));
        }
        
        // Add agent-specific tools
        tools.extend(self.tools.remote.clone());
        
        // Deduplicate
        tools.sort();
        tools.dedup();
        
        tools
    }
}
```

## APIs and Integrations

### Tool Discovery API
```rust
Tool {
    name: "get_agent_capabilities",
    description: "Query available tools for an agent",
    parameters: json!({
        "agent": {
            "type": "string",
            "description": "Agent name (rex, cleo, tess)"
        },
        "include_descriptions": {
            "type": "boolean",
            "description": "Include tool descriptions",
            "default": false
        }
    })
}

// Response structure
{
    "agent": "rex",
    "role": "Implementation Specialist",
    "tools": {
        "remote": [
            {
                "name": "rustdocs_query_rust_docs",
                "description": "Query Rust documentation"
            },
            {
                "name": "github_create_pr",
                "description": "Create GitHub pull request"
            }
        ],
        "local": {
            "filesystem": ["read_file", "write_file", "edit_file"],
            "git": ["git_status", "git_diff", "git_commit"]
        }
    }
}
```

### ConfigMap Template
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: agent-tools-config
  namespace: agent-platform
data:
  rex-tools.yaml: |
    name: Rex
    role: Senior Implementation Specialist
    extends: developer
    tools:
      remote:
        - rustdocs_query_rust_docs
        - brave-search_brave_web_search
        - memory_create_entities
        - memory_query_entities
        - github_create_pr
      local:
        filesystem:
          - read_file
          - write_file
          - edit_file
          - search_files
          - create_directory
        git:
          - git_status
          - git_diff
          - git_commit
          - git_push
          
  cleo-tools.yaml: |
    name: Cleo
    role: Code Quality Specialist
    extends: quality
    tools:
      remote:
        - rustdocs_query_rust_docs
        - github_create_check
        - github_update_check
      local:
        filesystem:
          - read_file
          - write_file
          - edit_file
        linting:
          - clippy_check
          - rustfmt_format
        testing:
          - cargo_test
          - cargo_build
```

## Infrastructure Requirements

### Helm Values Structure
```yaml
agents:
  rex:
    name: "Rex"
    role: "Senior Implementation Specialist"
    expertise:
      - backend
      - architecture
      - implementation
    tools:
      extends: developer
      remote:
        - rustdocs_query_rust_docs
        - brave-search_brave_web_search
        - memory_create_entities
        - github_create_pr
      local:
        filesystem: [read_file, write_file, edit_file, search_files]
        git: [git_status, git_diff, git_commit, git_push]
    
  cleo:
    name: "Cleo"
    role: "Code Quality Specialist"
    expertise:
      - quality
      - testing
      - formatting
    tools:
      extends: quality
      remote:
        - github_create_check
        - github_update_check
      local:
        linting: [clippy_check, rustfmt_format]
        testing: [cargo_test, cargo_build]
```

### Controller Modifications
```rust
// controller/src/agents/config.rs
impl AgentConfigManager {
    pub async fn load_agent_config(&self, agent_name: &str) -> Result<AgentConfig> {
        // Load from ConfigMap instead of generating
        let cm_api: Api<ConfigMap> = Api::namespaced(
            self.client.clone(),
            "agent-platform"
        );
        
        let cm = cm_api.get("agent-tools-config").await?;
        let config_yaml = cm.data
            .and_then(|d| d.get(&format!("{}-tools.yaml", agent_name)))
            .ok_or_else(|| anyhow!("Agent config not found"))?;
        
        let config: AgentConfig = serde_yaml::from_str(config_yaml)?;
        Ok(config)
    }
    
    pub async fn generate_client_config(&self, agent_name: &str) -> Result<String> {
        let agent_config = self.load_agent_config(agent_name).await?;
        let client_config = agent_config.generate_client_config();
        
        Ok(serde_json::to_string_pretty(&client_config)?)
    }
}
```

# Development Roadmap

## Phase 1: Analysis & Design (Days 1-2)
### Current System Analysis
- Map all existing tool usage patterns
- Identify common tool sets across tasks
- Document token usage for generation
- Analyze agent-specific requirements

### Tool Catalog Creation
- Inventory all MCP tools
- Document tool capabilities
- Create tool dependency map
- Define tool categories

### Deliverables
- Complete tool inventory
- Agent role analysis
- Token usage baseline
- Migration plan

## Phase 2: Profile Development (Days 2-3)
### Base Profile Creation
- Define universal tools all agents need
- Create base configuration structure
- Implement inheritance system
- Test profile resolution

### Agent-Specific Profiles
- Create Rex developer profile
- Create Cleo quality profile
- Create Tess testing profile
- Define custom tool additions

### Deliverables
- Working profile system
- Agent configurations
- Inheritance validation
- Tool resolution logic

## Phase 3: Implementation (Days 3-4)
### ConfigMap Integration
- Create agent-tools-config ConfigMap
- Update controller to load configs
- Remove dynamic generation code
- Simplify templates

### Client Config Generation
- Implement static generation from profiles
- Update container scripts
- Test with all agents
- Validate tool availability

### Deliverables
- Static configuration system
- Updated controller logic
- Simplified templates
- Working client configs

## Phase 4: Migration & Testing (Days 4-5)
### Migration Process
- Convert existing dynamic configs to static
- Update all agent deployments
- Test backward compatibility
- Validate tool functionality

### Performance Validation
- Measure token reduction
- Compare generation times
- Test agent effectiveness
- Monitor resource usage

### Deliverables
- Migrated configurations
- Performance metrics
- Test results
- Documentation updates

# Risks and Mitigations

## Technical Challenges

### Tool Discovery Issues
**Risk**: Agents may need tools not in their profile
**Mitigation**: Support for task-specific tool additions, monitoring of tool usage patterns

### Profile Complexity
**Risk**: Inheritance chains become difficult to manage
**Mitigation**: Limit inheritance depth to 2 levels, clear documentation, validation tools

### Breaking Changes
**Risk**: Existing workflows may break with static configs
**Mitigation**: Gradual rollout, backward compatibility mode, extensive testing

## Resource Constraints

### Migration Effort
**Challenge**: Converting all existing configurations
**Approach**: Automated migration scripts, phased rollout, parallel running

### Testing Coverage
**Challenge**: Validating all agent-tool combinations
**Approach**: Automated testing framework, staged deployment, monitoring

## Minimum Viable Product Definition

### MVP Scope
- Static profiles for Rex, Cleo, Tess
- Base + role inheritance
- ConfigMap-based storage
- Basic tool discovery API

### MVP Success Criteria
- 70% reduction in token usage
- No degradation in agent capabilities
- Consistent tool availability
- Simplified configuration management

# Appendix

## Tool Usage Analysis
| Agent | Common Tools | Usage Frequency | Token Cost |
|-------|-------------|-----------------|------------|
| Rex | filesystem, git, rustdocs | 95% | ~500 tokens |
| Cleo | linting, testing, github | 90% | ~400 tokens |
| Tess | kubernetes, testing, monitoring | 85% | ~600 tokens |

## Profile Examples

### Minimal Documentation Agent
```yaml
agents:
  lexie:
    name: "Lexie"
    role: "Documentation Writer"
    tools:
      remote:
        - "brave-search_brave_web_search"
      local:
        filesystem:
          - "read_file"
          - "write_file"
          - "list_directory"
```

### Full-Stack Developer Agent
```yaml
agents:
  nova:
    name: "Nova"
    role: "Full-Stack Developer"
    extends: developer
    tools:
      remote:
        - "rustdocs_query_rust_docs"
        - "mdn_web_docs_search"
        - "npm_package_search"
      local:
        filesystem: [read_file, write_file, edit_file, search_files]
        git: [git_status, git_diff, git_commit, git_push]
        npm: [npm_install, npm_run, npm_test]
```

## Migration Script
```bash
#!/bin/bash
# Analyze existing client-config.json files
find . -name "client-config.json" -exec jq '.remoteTools' {} \; | \
  jq -s 'flatten | group_by(.) | map({tool: .[0], count: length}) | sort_by(.count) | reverse'

# Generate agent profiles from analysis
for agent in rex cleo tess; do
  echo "Analyzing $agent tool usage..."
  kubectl logs -l agent=$agent --tail=10000 | \
    grep -o 'tool:[^ ]*' | \
    sort | uniq -c | sort -rn > $agent-tools.txt
done
```

## Success Metrics
- Token reduction: Target 70% decrease
- Configuration time: < 100ms vs 2-3s
- Agent satisfaction: Same capabilities maintained
- Maintenance effort: 50% reduction
- Error rate: < 1% tool availability issues

## Additional Features

### Agent Avatar Generation
**Requirements:**
- Auto-generate unique avatars for each agent using Imagine.art API
- Maintain consistent visual motif across all agent avatars
- Store avatar images securely and associate with agent profiles
- Support avatar customization and regeneration
- Integrate avatars into agent identification and branding

**Success Criteria:**
- Unique, professional avatars generated for Rex, Cleo, Tess, and Blaze
- Consistent visual style matching platform branding
- Avatar storage and retrieval system working
- Avatar integration in agent containers and documentation
- API integration with Imagine.art functioning properly

### Blaze Agent Specialization
**Requirements:**
- Create dedicated Blaze agent for front-end engineering (Svelte focus)
- Separate Blaze from Rex's general development responsibilities
- Define Blaze-specific MCP tools and capabilities
- Create Blaze documentation and tool profiles
- Integrate Blaze into landing page development workflow

**Success Criteria:**
- Blaze agent container fully operational and separate from Rex
- Svelte-focused tool configuration implemented
- Blaze documentation and capabilities defined
- Landing page development using Blaze agent
- Clear role separation between Rex and Blaze

### Cypher Agent Security Specialization
**Requirements:**
- Create dedicated Cypher agent for automated security scanning and remediation
- Implement automatic security advisory download using GitHub CLI
- Prioritize security vulnerabilities by severity and impact
- Automate remediation processes for common security issues
- Generate comprehensive security reports and publish to GitHub
- Integrate with existing CI/CD pipeline after test completion

**Success Criteria:**
- Cypher agent container fully operational and specialized for security
- GitHub CLI integration for security advisory downloads working
- Automated vulnerability prioritization and remediation implemented
- Security reports generated and published to GitHub automatically
- Integration with post-test workflow functioning properly
- Clear role separation and security-focused tool configuration

### Standalone Agent Workflows
**Requirements:**
- **Bug Remediation Agent**: Automatically triggered by GitHub issues with "bug" label
  - Detect bug issues via webhook triggers
  - Attempt to reproduce the reported issue
  - Create comprehensive remediation plan
  - Generate pull request on feature branch with fixes
  - Trigger existing QA process for validation
- **Feature Request Agent**: Process issues labeled as "feature request"
  - Detect feature request issues via webhook triggers
  - Create PRD and architecture documentation
  - Follow existing intake process for new features
  - Generate task documentation for implementation
  - Integrate with current documentation workflow
- **CI Failure Remediation Agent**: Automatically respond to CI failures
  - Monitor CI/CD pipeline for failures
  - Detect common failure patterns (Actions, linting, etc.)
  - Implement immediate remediation without QA process
  - Handle single-agent remediation for CI issues
  - Provide failure analysis and resolution reports

**Success Criteria:**
- Bug remediation agent successfully reproduces and fixes reported issues
- Feature request agent creates proper PRD/architecture documentation
- CI failure agent resolves common CI issues automatically
- All agents integrate seamlessly with existing workflows
- Webhook triggers function reliably for all agent types
- QA process integration works correctly for bug fixes

### Agent Container ASCII Art
**Requirements:**
- Display agent name and avatar in ASCII art on container startup
- Create visually appealing startup banners for each agent
- Include agent identification and role information
- Support both text-based and visual avatar representations
- Maintain consistent branding across all agent containers

**Success Criteria:**
- ASCII art banners displayed on container startup
- Agent names clearly visible and branded
- Visual avatar representation (where possible)
- Consistent startup experience across all agents
- Professional and engaging container identification
</PRD>
