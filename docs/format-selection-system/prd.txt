<context>
# Overview
The Format Selection System enables dynamic selection between XML and Markdown formats for task documentation and agent communication. While Markdown has been the primary format, XML provides structured data advantages for certain workflows. This system allows format specification at runtime via the MCP server, with Markdown remaining the default for backward compatibility.

# Core Features
## Multi-Format Support
- **XML Format**: Structured, validated, schema-based documentation
- **Markdown Format**: Human-readable, flexible, current default
- **Runtime Selection**: Choose format when submitting tasks via MCP
- **Format Conversion**: Bidirectional conversion between formats

## Format-Specific Processing
- **XML Validation**: DTD/XSD schema validation for XML documents
- **Markdown Parsing**: Existing markdown processor with enhancements
- **Template Adaptation**: Handlebars templates support both formats
- **Response Handling**: Parse agent responses in either format

## A/B Testing Capabilities
- **Performance Comparison**: Compare token usage between formats
- **Accuracy Testing**: Validate output quality across formats
- **Metrics Collection**: Track format-specific success rates
- **Gradual Migration**: Test XML with specific task types first

# User Experience
## User Personas
- **Platform Engineers**: Configure format preferences and defaults
- **Development Teams**: Unaware of format differences, seamless experience
- **QA Teams**: Test format parity and validate outputs
- **Performance Engineers**: Analyze format efficiency metrics

## Key User Flows
1. **Default Usage**: Tasks use Markdown by default, no changes needed
2. **Explicit Selection**: User specifies XML format for structured tasks
3. **A/B Testing**: Same task runs with both formats for comparison
4. **Format Migration**: Gradual transition from Markdown to XML where beneficial
</context>

<PRD>
# Technical Architecture

## System Components

### Core Infrastructure
- **Format Router**: Determines which format to use based on parameters
- **Format Processors**: XML and Markdown parsing/generation engines
- **Validation Engine**: Schema validation for XML, structure validation for Markdown
- **Conversion Service**: Bidirectional format transformation

### Format Processing Architecture
```yaml
Format Handlers:
  XML:
    - Schema validation (XSD/DTD)
    - DOM parsing
    - XPath queries
    - Structured output
    
  Markdown:
    - Section parsing
    - Metadata extraction
    - Template variables
    - Flexible structure
    
  Conversion:
    - MD → XML transformation
    - XML → MD transformation
    - Information preservation
    - Fallback handling
```

## Data Models

### Format Selection Schema
```rust
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "lowercase")]
pub enum DocumentFormat {
    Markdown,
    Xml,
}

impl Default for DocumentFormat {
    fn default() -> Self {
        DocumentFormat::Markdown
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FormatConfig {
    pub default_format: DocumentFormat,
    pub task_format_overrides: HashMap<String, DocumentFormat>,
    pub agent_format_preferences: HashMap<String, DocumentFormat>,
    pub validation_enabled: bool,
}
```

### XML Task Structure
```xml
<?xml version="1.0" encoding="UTF-8"?>
<task>
    <metadata>
        <id>42</id>
        <priority>high</priority>
        <agent>rex</agent>
        <format>xml</format>
    </metadata>
    <requirements>
        <requirement type="functional">
            <description>Implement user authentication</description>
            <acceptance_criteria>
                <criterion>JWT tokens are generated</criterion>
                <criterion>Refresh tokens are supported</criterion>
                <criterion>Session management works</criterion>
            </acceptance_criteria>
        </requirement>
    </requirements>
    <context>
        <files>
            <file path="src/auth.rs" action="modify"/>
            <file path="tests/auth_test.rs" action="create"/>
        </files>
        <dependencies>
            <dependency>task-41</dependency>
        </dependencies>
    </context>
    <implementation_notes>
        Use RS256 algorithm for JWT signing.
        Store refresh tokens in Redis with 7-day TTL.
    </implementation_notes>
</task>
```

### Markdown Task Structure (Current)
```markdown
# Task 42

## Metadata
- ID: 42
- Priority: high
- Agent: rex
- Format: markdown

## Requirements

### Functional Requirements
- Implement user authentication
  - [ ] JWT tokens are generated
  - [ ] Refresh tokens are supported
  - [ ] Session management works

## Context

### Files to Modify
- `src/auth.rs` (modify)
- `tests/auth_test.rs` (create)

### Dependencies
- task-41

## Implementation Notes
Use RS256 algorithm for JWT signing.
Store refresh tokens in Redis with 7-day TTL.
```

## APIs and Integrations

### MCP Tool Updates
```rust
Tool {
    name: "mcp_cto_code",
    parameters: json!({
        // Existing parameters...
        "format": {
            "type": "string",
            "description": "Documentation format to use (markdown or xml)",
            "enum": ["markdown", "xml"],
            "default": "markdown"
        }
    })
}

Tool {
    name: "mcp_cto_docs",
    parameters: json!({
        // Existing parameters...
        "format": {
            "type": "string",
            "description": "Documentation format to use (markdown or xml)",
            "enum": ["markdown", "xml"],
            "default": "markdown"
        }
    })
}
```

### Format Processing Implementation
```rust
pub trait DocumentFormatter {
    fn format_task(&self, task: &Task) -> Result<String>;
    fn parse_response(&self, response: &str) -> Result<TaskResponse>;
    fn validate(&self, content: &str) -> Result<()>;
    fn convert_to(&self, content: &str, target: DocumentFormat) -> Result<String>;
}

pub struct MarkdownFormatter;

impl DocumentFormatter for MarkdownFormatter {
    fn format_task(&self, task: &Task) -> Result<String> {
        let mut md = String::new();
        
        // Title
        md.push_str(&format!("# Task {}\n\n", task.id));
        
        // Metadata
        md.push_str("## Metadata\n");
        md.push_str(&format!("- ID: {}\n", task.id));
        md.push_str(&format!("- Priority: {}\n", task.priority));
        md.push_str(&format!("- Agent: {}\n\n", task.agent));
        
        // Requirements
        md.push_str("## Requirements\n\n");
        for req in &task.requirements {
            md.push_str(&format!("### {}\n", req.requirement_type));
            md.push_str(&format!("- {}\n", req.description));
            
            for criterion in &req.acceptance_criteria {
                md.push_str(&format!("  - [ ] {}\n", criterion));
            }
        }
        
        Ok(md)
    }
    
    fn validate(&self, content: &str) -> Result<()> {
        // Check for required sections
        let required_sections = ["# Task", "## Metadata", "## Requirements"];
        
        for section in required_sections {
            if !content.contains(section) {
                return Err(anyhow!("Missing required section: {}", section));
            }
        }
        
        Ok(())
    }
}

pub struct XmlFormatter {
    schema: Option<Schema>,
}

impl DocumentFormatter for XmlFormatter {
    fn format_task(&self, task: &Task) -> Result<String> {
        let doc = Document::new();
        let root = doc.create_element("task");
        
        // Metadata
        let metadata = doc.create_element("metadata");
        metadata.add_child(create_text_element(&doc, "id", &task.id.to_string()));
        metadata.add_child(create_text_element(&doc, "priority", &task.priority));
        metadata.add_child(create_text_element(&doc, "agent", &task.agent));
        root.add_child(metadata);
        
        // Requirements
        let requirements = doc.create_element("requirements");
        for req in &task.requirements {
            let requirement = doc.create_element("requirement");
            requirement.set_attribute("type", &req.requirement_type);
            
            requirement.add_child(create_text_element(&doc, "description", &req.description));
            
            let criteria = doc.create_element("acceptance_criteria");
            for criterion in &req.acceptance_criteria {
                criteria.add_child(create_text_element(&doc, "criterion", criterion));
            }
            requirement.add_child(criteria);
            
            requirements.add_child(requirement);
        }
        root.add_child(requirements);
        
        doc.set_root_element(root);
        Ok(doc.to_string())
    }
    
    fn validate(&self, content: &str) -> Result<()> {
        let doc = Document::parse(content)?;
        
        if let Some(schema) = &self.schema {
            schema.validate(&doc)?;
        }
        
        // Check required elements
        let root = doc.root_element();
        if root.name() != "task" {
            return Err(anyhow!("Root element must be 'task'"));
        }
        
        // Validate structure
        let metadata = root.find_child("metadata")
            .ok_or_else(|| anyhow!("Missing metadata element"))?;
        
        let required_metadata = ["id", "priority", "agent"];
        for field in required_metadata {
            metadata.find_child(field)
                .ok_or_else(|| anyhow!("Missing metadata field: {}", field))?;
        }
        
        Ok(())
    }
}
```

## Infrastructure Requirements

### CRD Modifications
```rust
#[derive(CustomResource, Deserialize, Serialize, Clone, Debug, JsonSchema)]
pub struct CodeRunSpec {
    // Existing fields...
    
    /// Documentation format to use
    #[serde(default = "default_format")]
    pub format: DocumentFormat,
}

#[derive(CustomResource, Deserialize, Serialize, Clone, Debug, JsonSchema)]
pub struct DocsRunSpec {
    // Existing fields...
    
    /// Documentation format to use
    #[serde(default = "default_format")]
    pub format: DocumentFormat,
}

fn default_format() -> DocumentFormat {
    DocumentFormat::Markdown
}
```

### Container Script Updates
```bash
#!/bin/bash
# Format detection and processing

DOC_FORMAT="${DOC_FORMAT:-markdown}"

process_documentation() {
    local format="$1"
    local input_file="$2"
    local output_file="$3"
    
    case "$format" in
        xml)
            echo "📄 Processing XML documentation format"
            xmllint --format "$input_file" > "$output_file"
            
            # Validate against schema if available
            if [ -f "/schemas/task.xsd" ]; then
                xmllint --schema /schemas/task.xsd "$input_file" --noout || {
                    echo "XML validation failed"
                    exit 1
                }
            fi
            ;;
            
        markdown|*)
            echo "📝 Processing Markdown documentation format"
            cp "$input_file" "$output_file"
            ;;
    esac
}

# Generate format-specific prompt
generate_prompt() {
    local format="$1"
    local task_id="$2"
    
    case "$format" in
        xml)
            cat > prompt.xml << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<prompt>
    <task_id>${task_id}</task_id>
    <instructions>
        <!-- Task-specific instructions -->
    </instructions>
    <requirements>
        <!-- Requirements in XML structure -->
    </requirements>
</prompt>
EOF
            ;;
            
        markdown|*)
            cat > prompt.md << 'EOF'
# Task ${task_id}

## Instructions
<!-- Task-specific instructions -->

## Requirements
<!-- Requirements in Markdown -->
EOF
            ;;
    esac
}
```

# Development Roadmap

## Phase 1: XML Support Implementation (Days 1-2)
### XML Infrastructure
- Create XML formatter implementation
- Add XSD schema for task validation
- Implement XML parsing and generation
- Add XML validation to controller

### Template Updates
- Modify Handlebars templates for format support
- Add format-specific sections
- Test XML generation

### Deliverables
- Working XML formatter
- Task XSD schema
- XML validation tests
- Template modifications

## Phase 2: Format Selection Logic (Day 3)
### MCP Integration
- Add format parameter to MCP tools
- Update controller to handle format parameter
- Pass format through to containers
- Default to Markdown if not specified

### CRD Updates
- Add format field to CodeRun/DocsRun
- Update controller reconciliation
- Modify ConfigMap generation

### Deliverables
- Updated MCP tools
- Modified CRDs
- Controller changes
- Format routing logic

## Phase 3: Conversion Service (Day 4)
### Bidirectional Conversion
- Implement Markdown to XML converter
- Implement XML to Markdown converter
- Handle information preservation
- Add conversion validation

### Fallback Handling
- Graceful degradation for unsupported elements
- Warning generation for lost information
- Format compatibility checking

### Deliverables
- Working converters
- Conversion tests
- Fallback mechanisms
- Validation suite

## Phase 4: Testing & Metrics (Day 5)
### A/B Testing Framework
- Run same task with both formats
- Compare token usage
- Measure processing time
- Validate output equivalence

### Metrics Collection
- Format usage tracking
- Performance comparisons
- Error rate monitoring
- Success metrics

### Deliverables
- A/B test results
- Performance metrics
- Bug fixes
- Documentation

# Risks and Mitigations

## Technical Challenges

### Information Loss in Conversion
**Risk**: Some information may be lost when converting between formats
**Mitigation**: Comprehensive mapping, warning generation, validation tests

### Schema Evolution
**Risk**: XML schema changes may break existing documents
**Mitigation**: Version schemas, backward compatibility, migration tools

### Performance Impact
**Risk**: XML processing may be slower than Markdown
**Mitigation**: Caching, lazy parsing, format-specific optimizations

## Resource Constraints

### Testing Coverage
**Challenge**: Testing all format combinations and conversions
**Approach**: Automated test generation, property-based testing

### Documentation Updates
**Challenge**: Updating docs for both formats
**Approach**: Auto-generate examples, clear format guidelines

## Minimum Viable Product Definition

### MVP Scope
- XML format support for tasks
- Basic format selection via MCP
- Markdown ↔ XML conversion
- Default to Markdown

### MVP Success Criteria
- Successfully process tasks in XML format
- No degradation for Markdown users
- Clean conversion between formats
- Metrics showing format performance

# Appendix

## XML Schema Example (task.xsd)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:element name="task">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="metadata" type="MetadataType"/>
                <xs:element name="requirements" type="RequirementsType"/>
                <xs:element name="context" type="ContextType" minOccurs="0"/>
                <xs:element name="implementation_notes" type="xs:string" minOccurs="0"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    
    <xs:complexType name="MetadataType">
        <xs:sequence>
            <xs:element name="id" type="xs:integer"/>
            <xs:element name="priority" type="PriorityType"/>
            <xs:element name="agent" type="xs:string"/>
            <xs:element name="format" type="FormatType"/>
        </xs:sequence>
    </xs:complexType>
    
    <xs:simpleType name="PriorityType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="low"/>
            <xs:enumeration value="medium"/>
            <xs:enumeration value="high"/>
            <xs:enumeration value="critical"/>
        </xs:restriction>
    </xs:simpleType>
    
    <xs:simpleType name="FormatType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="xml"/>
            <xs:enumeration value="markdown"/>
        </xs:restriction>
    </xs:simpleType>
</xs:schema>
```

## Format Comparison
| Aspect | Markdown | XML |
|--------|----------|-----|
| Readability | High | Medium |
| Structure | Flexible | Rigid |
| Validation | Runtime | Schema-based |
| Token Usage | Variable | Potentially lower |
| Parsing | Pattern-based | DOM/SAX |
| Agent Comprehension | Good | Better for structured data |

## Success Metrics
- Format adoption rate
- Token reduction with XML: Target 20%
- Conversion fidelity: >99%
- Processing time difference: <10%
- Error rates by format
</PRD>
