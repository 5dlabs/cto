# Task ID: 10
# Title: Develop Terminal-Based User Interface (TUI)
# Status: pending
# Dependencies: 5, 7
# Priority: medium
# Description: Create a terminal-based interface using Rust's ratatui library with real-time updates and visual feedback
# Details:
1. Implement TUI framework using ratatui:
   - Create layout with portfolio summary, positions, trades, and system health
   - Implement keyboard-driven navigation
   - Support 10Hz refresh rate via Redis Streams

2. Create visual components:
   - P&L sparkline charts with color coding
   - Position list with real-time updates
   - Trade history with MEV status indicators
   - System health dashboard with circuit breaker state

3. Implement real-time data integration:
   - Subscribe to Redis Streams for updates
   - Fetch portfolio data and positions
   - Display node health and latency metrics

Example implementation:
```rust
pub struct TradingTui {
    terminal: Terminal<CrosstermBackend<Stdout>>,
    portfolio: Arc<RwLock<VirtualPortfolio>>,
    event_subscriber: EventSubscriber,
    system_health: Arc<SystemHealth>,
    active_tab: Tab,
}

pub enum Tab {
    Portfolio,
    Trades,
    OrderEntry,
    SystemHealth,
}

impl TradingTui {
    pub async fn run(&mut self) -> Result<()> {
        let mut events = self.event_subscriber.subscribe().await?;
        let mut refresh_interval = tokio::time::interval(Duration::from_millis(100)); // 10Hz
        
        loop {
            // Process any pending events
            while let Ok(Some(event)) = events.try_next() {
                self.handle_event(event).await?;
            }
            
            // Handle keyboard input
            if crossterm::event::poll(Duration::from_millis(10))? {
                if let Event::Key(key) = crossterm::event::read()? {
                    if key.kind == KeyEventKind::Press {
                        self.handle_key(key).await?;
                    }
                }
            }
            
            // Render UI at 10Hz
            refresh_interval.tick().await;
            self.render().await?;
        }
    }
    
    async fn render(&mut self) -> Result<()> {
        self.terminal.draw(|f| {
            let size = f.size();
            let chunks = Layout::default()
                .direction(Direction::Vertical)
                .constraints([
                    Constraint::Length(3),  // Header
                    Constraint::Min(10),    // Main content
                    Constraint::Length(3),  // Footer
                ])
                .split(size);
            
            // Render header with portfolio summary
            self.render_header(f, chunks[0]).await;
            
            // Render main content based on active tab
            match self.active_tab {
                Tab::Portfolio => self.render_portfolio(f, chunks[1]).await,
                Tab::Trades => self.render_trades(f, chunks[1]).await,
                Tab::OrderEntry => self.render_order_entry(f, chunks[1]).await,
                Tab::SystemHealth => self.render_system_health(f, chunks[1]).await,
            }
            
            // Render footer with help text
            self.render_footer(f, chunks[2]);
        })?;
        
        Ok(())
    }
    
    async fn render_portfolio(&self, f: &mut Frame, area: Rect) {
        let portfolio = self.portfolio.read().await;
        let pnl = portfolio.calculate_pnl().await.unwrap_or_default();
        
        // Create sparkline data for P&L
        let sparkline_data: Vec<u64> = portfolio.pnl_history.iter()
            .map(|p| (p.total * Decimal::from(100)).to_u64().unwrap_or(0))
            .collect();
        
        let positions_block = Block::default()
            .title("Positions")
            .borders(Borders::ALL);
        
        let positions: Vec<ListItem> = portfolio.positions.iter()
            .map(|(token, position)| {
                // Format position with color based on P&L
                // ...
            })
            .collect();
        
        let positions_list = List::new(positions)
            .block(positions_block)
            .highlight_style(Style::default().bg(Color::DarkGray));
        
        f.render_widget(positions_list, area);
        
        // Render P&L sparkline
        // ...
    }
}
```

# Test Strategy:
Create unit tests for TUI components with mocked data. Test keyboard navigation and event handling. Verify correct rendering of portfolio data, trades, and system health. Test integration with Redis Streams for real-time updates. Verify 10Hz refresh rate performance. Test sparkline chart rendering with various data patterns. Ensure correct color coding of P&L values.

# Subtasks:
## 1. Implement Core TUI Framework [pending]
### Dependencies: None
### Description: Develop the foundational terminal UI framework with layout management and keyboard navigation capabilities
### Details:
Create a modular TUI framework using a library like tui-rs or similar. Implement a layout system that divides the terminal screen into panels. Add keyboard input handling for navigation between panels and within components. Ensure the framework supports a minimum 10Hz refresh rate. Include support for common UI elements like tables, charts, and text boxes that will be needed by other components.

## 2. Build Portfolio and Position Visualization [pending]
### Dependencies: 10.1
### Description: Create real-time portfolio and position visualization components with data integration
### Details:
Implement portfolio summary view showing total value, P&L, and allocation. Create position detail views with current holdings, entry prices, and unrealized P&L. Develop chart components for visualizing position performance over time. Integrate with Redis Streams to receive real-time updates. Ensure visualizations update smoothly at the required 10Hz refresh rate without flickering.

## 3. Develop Trade History and Order Entry Interfaces [pending]
### Dependencies: 10.1
### Description: Create interfaces for viewing trade history and submitting new orders
### Details:
Implement a scrollable trade history view showing executed trades with timestamps, symbols, prices, and quantities. Create an order entry form with validation for submitting new trades. Add support for different order types (market, limit, etc.). Implement keyboard shortcuts for quick order entry. Ensure the interface provides clear feedback on order submission status and errors.

## 4. Create System Health Dashboard [pending]
### Dependencies: 10.1
### Description: Implement a dashboard for monitoring system health, circuit breaker status, and performance metrics
### Details:
Develop a system health panel showing key performance indicators. Create visual indicators for circuit breaker status with color coding. Implement performance metrics displays including latency, throughput, and error rates. Add alerts for critical system events. Ensure the dashboard updates in real-time and provides clear visibility of system status at a glance.

