# Task ID: 11
# Title: Implement Stop-Loss and Take-Profit Monitoring
# Status: pending
# Dependencies: 7, 9
# Priority: medium
# Description: Create a system that continuously monitors positions and executes orders when stop-loss or take-profit conditions are met
# Details:
1. Implement position monitoring service:
   - Monitor positions every 100ms as specified in the PRD
   - Check current prices against stop-loss and take-profit levels
   - Trigger orders when conditions are met

2. Create order condition system:
   - Support for stop-loss orders with absolute or percentage thresholds
   - Support for take-profit orders with absolute or percentage thresholds
   - Allow for trailing stop-loss with configurable distance

3. Integrate with paper trade executor:
   - Execute trades automatically when conditions are met
   - Record triggered orders with reason in trade history

Example implementation:
```rust
pub struct OrderMonitor {
    portfolio: Arc<RwLock<VirtualPortfolio>>,
    price_cache: Arc<PriceCache>,
    trade_executor: Arc<PaperTradeExecutor>,
    orders: RwLock<HashMap<String, Vec<ConditionalOrder>>>,
}

pub enum OrderCondition {
    StopLoss {
        price: Decimal,
        is_trailing: bool,
        trail_distance: Option<Decimal>,
    },
    TakeProfit {
        price: Decimal,
    },
}

pub struct ConditionalOrder {
    id: Uuid,
    token: String,
    condition: OrderCondition,
    action: TradeAction,
    amount: Decimal,
    created_at: DateTime<Utc>,
}

impl OrderMonitor {
    pub async fn start_monitoring(&self) -> JoinHandle<()> {
        let portfolio = self.portfolio.clone();
        let price_cache = self.price_cache.clone();
        let trade_executor = self.trade_executor.clone();
        let orders = self.orders.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_millis(100)); // 100ms as specified
            
            loop {
                interval.tick().await;
                
                // Get current portfolio positions
                let positions = portfolio.read().await.get_positions();
                
                // Check each position against its orders
                for (token, position) in positions {
                    let current_price = match price_cache.get_price(&token).await {
                        Ok(price) => price,
                        Err(_) => continue, // Skip if price not available
                    };
                    
                    // Get orders for this token
                    let mut orders_write = orders.write().await;
                    let token_orders = orders_write.entry(token.clone()).or_insert_with(Vec::new);
                    
                    // Check each order condition
                    let mut triggered_orders = Vec::new();
                    for (i, order) in token_orders.iter().enumerate() {
                        let is_triggered = match &order.condition {
                            OrderCondition::StopLoss { price, is_trailing, trail_distance } => {
                                if *is_trailing {
                                    // Trailing stop-loss logic
                                    // ...
                                    false // Placeholder
                                } else {
                                    current_price <= *price
                                }
                            },
                            OrderCondition::TakeProfit { price } => current_price >= *price,
                        };
                        
                        if is_triggered {
                            triggered_orders.push(i);
                        }
                    }
                    
                    // Execute triggered orders (in reverse to preserve indices)
                    for i in triggered_orders.into_iter().rev() {
                        let order = token_orders.remove(i);
                        
                        // Execute the order
                        let params = TradeParams {
                            action: order.action,
                            base_token: token.clone(),
                            quote_token: "USDC".to_string(), // Assuming USDC as quote
                            amount: order.amount,
                            is_base_input: true,
                            simulate_mev: true,
                            priority_fee: 5000, // Default priority fee
                        };
                        
                        if let Err(e) = trade_executor.execute_trade(params).await {
                            eprintln!("Failed to execute triggered order: {}", e);
                        }
                    }
                }
            }
        })
    }
    
    pub async fn add_stop_loss(&self, token: &str, price: Decimal, is_trailing: bool, trail_distance: Option<Decimal>) -> Result<Uuid> {
        let id = Uuid::new_v4();
        let order = ConditionalOrder {
            id,
            token: token.to_string(),
            condition: OrderCondition::StopLoss {
                price,
                is_trailing,
                trail_distance,
            },
            action: TradeAction::Sell,
            amount: Decimal::ZERO, // Will be filled with full position amount when triggered
            created_at: Utc::now(),
        };
        
        self.orders.write().await
            .entry(token.to_string())
            .or_insert_with(Vec::new)
            .push(order);
        
        Ok(id)
    }
    
    pub async fn add_take_profit(&self, token: &str, price: Decimal) -> Result<Uuid> {
        // Similar to add_stop_loss
        // ...
    }
}
```

# Test Strategy:
Create unit tests for order condition evaluation with various price scenarios. Test stop-loss and take-profit triggering with fixed prices. Test trailing stop-loss with moving prices. Implement integration tests that simulate price movements and verify order execution. Test monitoring frequency to ensure 100ms intervals are maintained. Verify correct order execution when conditions are met.

# Subtasks:
## 1. Implement Position Monitoring Service [pending]
### Dependencies: None
### Description: Create a high-frequency position monitoring service that checks positions every 100ms
### Details:
Develop a service that monitors open positions at 100ms intervals. This should include: 1) Setting up an efficient data structure to store position information, 2) Implementing a timer mechanism for precise 100ms intervals, 3) Creating methods to fetch current market prices, 4) Building a performance-optimized loop that can handle the high-frequency checks without causing system slowdowns, and 5) Adding logging and error handling for monitoring reliability.

## 2. Develop Order Condition System [pending]
### Dependencies: 11.1
### Description: Create a system that supports various stop-loss and take-profit order types
### Details:
Design and implement an order condition system that supports: 1) Basic stop-loss orders at fixed price points, 2) Take-profit orders at target prices, 3) Trailing stop-loss orders that adjust based on price movements, 4) Percentage-based and absolute price-based conditions, 5) Time-based conditions (e.g., execute after X minutes), and 6) Composite conditions combining multiple criteria. Include unit tests for each order type to verify correct behavior under various market conditions.

## 3. Integrate with Paper Trade Executor [pending]
### Dependencies: 11.1, 11.2
### Description: Connect the monitoring service and order condition system with the paper trade executor for automatic order execution
### Details:
Integrate the position monitoring service and order condition system with the paper trade executor to enable automatic order execution when conditions are met. This includes: 1) Creating an interface between the condition system and trade executor, 2) Implementing the execution logic that triggers when conditions are satisfied, 3) Adding confirmation and verification mechanisms to ensure orders were properly executed, 4) Implementing retry logic for failed executions, and 5) Creating comprehensive logging for audit purposes. Test the complete system with various market scenarios to ensure reliable execution.

