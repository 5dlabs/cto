# Task ID: 24
# Title: Implement gRPC Trade Execution Service Interface
# Status: pending
# Dependencies: 1, 9, 17, 18
# Priority: high
# Description: Create a gRPC service that accepts trade requests from external decision services and executes them using either paper or live trading modes, serving as the interface between external systems and trade execution engines.
# Details:
1. Define gRPC service protocol:
   - Create protocol buffer definitions for the service:
     ```protobuf
     syntax = "proto3";
     package trade_execution;
     
     service TradeExecutionService {
       rpc ExecuteTrade(TradeRequest) returns (TradeResult);
       rpc StreamExecutionStatus(TradeRequest) returns (stream ExecutionStatus);
       rpc GetTradeHistory(HistoryRequest) returns (HistoryResponse);
     }
     
     message TradeRequest {
       string request_id = 1;
       string token_in = 2;
       string token_out = 3;
       string amount = 4;
       bool is_exact_in = 5;
       double slippage_tolerance = 6;
       bool enable_mev_protection = 7;
       TradingMode mode = 8;
       string auth_token = 9;
     }
     
     enum TradingMode {
       PAPER = 0;
       LIVE = 1;
     }
     
     message TradeResult {
       string request_id = 1;
       ExecutionStatus status = 2;
       string transaction_id = 3;
       string executed_amount_in = 4;
       string executed_amount_out = 5;
       double execution_price = 6;
       double slippage = 7;
       int64 timestamp = 8;
     }
     
     message ExecutionStatus {
       string request_id = 1;
       string status_code = 2;
       string status_message = 3;
       double completion_percentage = 4;
       int64 timestamp = 5;
     }
     
     message HistoryRequest {
       int64 start_time = 1;
       int64 end_time = 2;
       int32 limit = 3;
       string auth_token = 4;
     }
     
     message HistoryResponse {
       repeated TradeResult trades = 1;
     }
     ```

2. Implement gRPC service:
   - Create a Rust implementation of the service using tonic:
     ```rust
     use tonic::{transport::Server, Request, Response, Status};
     use trade_execution::trade_execution_service_server::{TradeExecutionService, TradeExecutionServiceServer};
     use trade_execution::{TradeRequest, TradeResult, ExecutionStatus, HistoryRequest, HistoryResponse, TradingMode};
     
     pub struct TradeExecutionServiceImpl {
         paper_executor: Arc<PaperTradeExecutor>,
         live_executor: Arc<LiveTradeExecutor>,
         auth_service: Arc<AuthService>,
         metrics: Arc<MetricsCollector>,
     }
     
     #[tonic::async_trait]
     impl TradeExecutionService for TradeExecutionServiceImpl {
         async fn execute_trade(
             &self,
             request: Request<TradeRequest>
         ) -> Result<Response<TradeResult>, Status> {
             // Implementation
         }
         
         type StreamExecutionStatusStream = Pin<Box<dyn Stream<Item = Result<ExecutionStatus, Status>> + Send + 'static>>;
         
         async fn stream_execution_status(
             &self,
             request: Request<TradeRequest>
         ) -> Result<Response<Self::StreamExecutionStatusStream>, Status> {
             // Implementation
         }
         
         async fn get_trade_history(
             &self,
             request: Request<HistoryRequest>
         ) -> Result<Response<HistoryResponse>, Status> {
             // Implementation
         }
     }
     ```

3. Implement request validation and authentication:
   - Create a validation layer that checks all incoming requests:
     ```rust
     struct RequestValidator {
         auth_service: Arc<AuthService>,
     }
     
     impl RequestValidator {
         fn validate_trade_request(&self, request: &TradeRequest) -> Result<(), ValidationError> {
             // Validate token addresses
             // Validate amount format and value
             // Validate slippage tolerance is within acceptable range
             // Check authentication token
         }
     }
     ```

4. Implement trade execution routing:
   - Create a router that directs requests to the appropriate executor:
     ```rust
     struct ExecutionRouter {
         paper_executor: Arc<PaperTradeExecutor>,
         live_executor: Arc<LiveTradeExecutor>,
     }
     
     impl ExecutionRouter {
         async fn route_and_execute(&self, request: TradeRequest) -> Result<TradeResult, ExecutionError> {
             match request.mode {
                 TradingMode::Paper => self.paper_executor.execute(request).await,
                 TradingMode::Live => self.live_executor.execute(request).await,
             }
         }
     }
     ```

5. Implement real-time status streaming:
   - Create a streaming system for execution status updates:
     ```rust
     async fn create_status_stream(
         request_id: String,
         status_updates: mpsc::Receiver<ExecutionStatus>,
     ) -> impl Stream<Item = Result<ExecutionStatus, Status>> {
         ReceiverStream::new(status_updates)
             .map(Ok)
             .map_err(|e| Status::internal(format!("Stream error: {}", e)))
     }
     ```

6. Implement comprehensive error handling:
   - Create a detailed error mapping system:
     ```rust
     fn map_execution_error(error: ExecutionError) -> Status {
         match error {
             ExecutionError::InsufficientFunds => Status::failed_precondition("Insufficient funds for trade"),
             ExecutionError::ExcessiveSlippage => Status::aborted("Trade aborted due to excessive slippage"),
             ExecutionError::CircuitBreakerOpen => Status::unavailable("Trading paused due to circuit breaker"),
             ExecutionError::ValidationFailed(reason) => Status::invalid_argument(reason),
             ExecutionError::AuthenticationFailed => Status::unauthenticated("Invalid authentication token"),
             ExecutionError::Internal(details) => Status::internal(details),
         }
     }
     ```

7. Implement request/response logging:
   - Create a logging middleware for audit trails:
     ```rust
     struct RequestLogger {
         quest_db: Arc<QuestDbClient>,
     }
     
     impl RequestLogger {
         async fn log_request(&self, request: &TradeRequest) {
             // Log request details to QuestDB
         }
         
         async fn log_response(&self, request: &TradeRequest, result: &TradeResult) {
             // Log response details to QuestDB
         }
     }
     ```

8. Implement performance monitoring:
   - Create metrics collection for the service:
     ```rust
     struct MetricsCollector {
         prometheus: Arc<PrometheusRegistry>,
     }
     
     impl MetricsCollector {
         fn new() -> Self {
             let prometheus = Arc::new(PrometheusRegistry::new());
             let request_counter = prometheus.register_counter("trade_requests_total", "Total number of trade requests");
             let latency_histogram = prometheus.register_histogram("request_latency_ms", "Request latency in milliseconds");
             // Register other metrics
             
             Self { prometheus }
         }
         
         fn record_request(&self) {
             self.request_counter.inc();
         }
         
         fn record_latency(&self, latency_ms: f64) {
             self.latency_histogram.observe(latency_ms);
         }
     }
     ```

9. Implement graceful shutdown handling:
   - Create a shutdown manager for in-flight requests:
     ```rust
     struct ShutdownManager {
         in_flight_requests: Arc<RwLock<HashMap<String, RequestStatus>>>,
     }
     
     impl ShutdownManager {
         async fn initiate_shutdown(&self) {
             // Wait for in-flight requests to complete or timeout
             // Log any incomplete requests
         }
         
         fn register_request(&self, request_id: String) {
             // Add request to in-flight tracking
         }
         
         fn complete_request(&self, request_id: &str) {
             // Remove request from in-flight tracking
         }
     }
     ```

10. Implement testing utilities:
    - Create helper functions for integration testing:
      ```rust
      #[cfg(test)]
      mod test_utils {
          pub struct TestClient {
              client: TradeExecutionServiceClient<Channel>,
          }
          
          impl TestClient {
              pub async fn new() -> Self {
                  let channel = Channel::from_static("http://localhost:50051")
                      .connect()
                      .await
                      .expect("Failed to connect to test server");
                  
                  let client = TradeExecutionServiceClient::new(channel);
                  Self { client }
              }
              
              pub async fn execute_test_trade(&mut self) -> TradeResult {
                  // Create and send a test trade request
              }
          }
      }
      ```

11. Implement main service entry point:
    - Create the main service initialization and startup:
      ```rust
      pub async fn run_service(config: ServiceConfig) -> Result<(), Box<dyn Error>> {
          let addr = config.bind_address.parse()?;
          
          let paper_executor = Arc::new(PaperTradeExecutor::new(config.paper_config));
          let live_executor = Arc::new(LiveTradeExecutor::new(config.live_config));
          let auth_service = Arc::new(AuthService::new(config.auth_config));
          let metrics = Arc::new(MetricsCollector::new());
          
          let service = TradeExecutionServiceImpl {
              paper_executor,
              live_executor,
              auth_service,
              metrics,
          };
          
          println!("Starting gRPC service on {}", addr);
          
          Server::builder()
              .add_service(TradeExecutionServiceServer::new(service))
              .serve_with_shutdown(addr, shutdown_signal())
              .await?;
              
          Ok(())
      }
      
      async fn shutdown_signal() {
          tokio::signal::ctrl_c()
              .await
              .expect("Failed to install CTRL+C signal handler");
      }
      ```

# Test Strategy:
1. Unit testing:
   - Create comprehensive unit tests for all service components:
     ```rust
     #[tokio::test]
     async fn test_request_validation() {
         let validator = RequestValidator::new(Arc::new(MockAuthService::new()));
         
         // Test valid request
         let valid_request = TradeRequest {
             request_id: "test-123".to_string(),
             token_in: "So11111111111111111111111111111111111111112".to_string(),
             token_out: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v".to_string(),
             amount: "1000000000".to_string(),
             is_exact_in: true,
             slippage_tolerance: 0.5,
             enable_mev_protection: true,
             mode: TradingMode::Paper as i32,
             auth_token: "valid-token".to_string(),
         };
         
         assert!(validator.validate_trade_request(&valid_request).is_ok());
         
         // Test invalid token address
         let mut invalid_request = valid_request.clone();
         invalid_request.token_in = "invalid-address".to_string();
         
         assert!(validator.validate_trade_request(&invalid_request).is_err());
         
         // Test other validation cases
     }
     
     #[tokio::test]
     async fn test_execution_router() {
         let paper_executor = Arc::new(MockPaperTradeExecutor::new());
         let live_executor = Arc::new(MockLiveTradeExecutor::new());
         
         let router = ExecutionRouter {
             paper_executor: paper_executor.clone(),
             live_executor: live_executor.clone(),
         };
         
         let paper_request = TradeRequest {
             mode: TradingMode::Paper as i32,
             // Other fields
         };
         
         let live_request = TradeRequest {
             mode: TradingMode::Live as i32,
             // Other fields
         };
         
         router.route_and_execute(paper_request.clone()).await.unwrap();
         router.route_and_execute(live_request.clone()).await.unwrap();
         
         assert_eq!(paper_executor.execution_count(), 1);
         assert_eq!(live_executor.execution_count(), 1);
     }
     ```

2. Integration testing:
   - Create tests that verify the complete service functionality:
     ```rust
     #[tokio::test]
     async fn test_service_integration() {
         // Start test server
         let server_handle = tokio::spawn(async {
             let config = ServiceConfig {
                 bind_address: "127.0.0.1:50051".to_string(),
                 // Other config
             };
             
             run_service(config).await.unwrap();
         });
         
         // Wait for server to start
         tokio::time::sleep(Duration::from_millis(100)).await;
         
         // Create test client
         let mut client = TestClient::new().await;
         
         // Execute test trade
         let result = client.execute_test_trade().await;
         
         // Verify result
         assert_eq!(result.status.status_code, "SUCCESS");
         
         // Test streaming
         let mut stream = client.stream_execution_status().await;
         
         let status_updates = collect_stream_items(&mut stream, 3).await;
         assert_eq!(status_updates.len(), 3);
         
         // Shutdown test server
         server_handle.abort();
     }
     ```

3. Performance testing:
   - Create benchmarks to verify service performance:
     ```rust
     #[tokio::test]
     async fn test_service_performance() {
         // Start test server
         let server_handle = start_test_server().await;
         
         // Create test client
         let client = TestClient::new().await;
         
         // Measure request latency
         let start = Instant::now();
         for _ in 0..100 {
             client.clone().execute_test_trade().await;
         }
         let elapsed = start.elapsed();
         
         println!("Average request latency: {}ms", elapsed.as_millis() / 100);
         
         // Verify latency is within acceptable range
         assert!(elapsed.as_millis() / 100 < 50); // Less than 50ms per request
         
         // Shutdown test server
         server_handle.abort();
     }
     ```

4. Error handling testing:
   - Test various error conditions and verify correct responses:
     ```rust
     #[tokio::test]
     async fn test_error_handling() {
         // Start test server
         let server_handle = start_test_server().await;
         
         // Create test client
         let mut client = TestClient::new().await;
         
         // Test invalid request
         let result = client.execute_invalid_trade().await;
         assert_eq!(result.status().code(), tonic::Code::InvalidArgument);
         
         // Test authentication failure
         let result = client.execute_unauthenticated_trade().await;
         assert_eq!(result.status().code(), tonic::Code::Unauthenticated);
         
         // Test circuit breaker open
         let result = client.execute_trade_with_circuit_breaker_open().await;
         assert_eq!(result.status().code(), tonic::Code::Unavailable);
         
         // Shutdown test server
         server_handle.abort();
     }
     ```

5. Load testing:
   - Create tests that verify service behavior under load:
     ```rust
     #[tokio::test]
     #[ignore] // Run manually for load testing
     async fn test_service_under_load() {
         // Start test server
         let server_handle = start_test_server().await;
         
         // Create multiple concurrent clients
         let mut handles = vec![];
         for i in 0..50 {
             let handle = tokio::spawn(async move {
                 let mut client = TestClient::new().await;
                 for j in 0..20 {
                     let result = client.execute_test_trade().await;
                     assert_eq!(result.status.status_code, "SUCCESS");
                 }
             });
             handles.push(handle);
         }
         
         // Wait for all clients to complete
         for handle in handles {
             handle.await.unwrap();
         }
         
         // Verify metrics
         let metrics = get_service_metrics().await;
         assert_eq!(metrics.total_requests, 1000); // 50 clients * 20 requests
         
         // Shutdown test server
         server_handle.abort();
     }
     ```

6. Graceful shutdown testing:
   - Test that in-flight requests complete during shutdown:
     ```rust
     #[tokio::test]
     async fn test_graceful_shutdown() {
         // Start test server
         let (server_handle, shutdown_sender) = start_test_server_with_shutdown().await;
         
         // Create long-running requests
         let mut handles = vec![];
         for i in 0..10 {
             let handle = tokio::spawn(async move {
                 let mut client = TestClient::new().await;
                 client.execute_long_running_trade().await
             });
             handles.push(handle);
         }
         
         // Wait for requests to start
         tokio::time::sleep(Duration::from_millis(100)).await;
         
         // Initiate shutdown
         shutdown_sender.send(()).await.unwrap();
         
         // Verify all requests complete
         for handle in handles {
             let result = handle.await.unwrap();
             assert_eq!(result.status.status_code, "SUCCESS");
         }
         
         // Verify server has shut down
         server_handle.await.unwrap();
     }
     ```

7. End-to-end testing:
   - Create tests that verify the complete flow from request to execution:
     ```rust
     #[tokio::test]
     async fn test_end_to_end_paper_trading() {
         // Start test environment with all components
         let env = TestEnvironment::new().await;
         
         // Create test client
         let mut client = env.create_client().await;
         
         // Execute paper trade
         let request = TradeRequest {
             request_id: "e2e-test-123".to_string(),
             token_in: "So11111111111111111111111111111111111111112".to_string(),
             token_out: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v".to_string(),
             amount: "1000000000".to_string(),
             is_exact_in: true,
             slippage_tolerance: 0.5,
             enable_mev_protection: true,
             mode: TradingMode::Paper as i32,
             auth_token: env.get_auth_token(),
         };
         
         let result = client.execute_trade(request).await.unwrap();
         
         // Verify trade execution
         assert_eq!(result.status.status_code, "SUCCESS");
         
         // Verify virtual portfolio was updated
         let portfolio = env.get_virtual_portfolio().await;
         assert!(portfolio.contains_transaction(&result.transaction_id));
         
         // Verify trade was logged in QuestDB
         let trade_log = env.get_trade_log(result.request_id).await;
         assert!(trade_log.is_some());
     }
     ```
