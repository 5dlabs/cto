# Task ID: 5
# Title: Implement Redis Price Caching and Event Streaming
# Status: pending
# Dependencies: 2
# Priority: high
# Description: Create a high-performance Redis integration for price caching with <1ms reads and event streaming for UI updates
# Details:
1. Implement price caching system:
   - Create a price updater service that fetches and caches prices
   - Set TTL of 1-2 seconds as specified in the PRD
   - Optimize for <1ms read times
   - Support all MVP tokens (SOL, USDC, BONK, JitoSOL, RAY)

2. Implement Redis Streams for event propagation:
   - Create streams for trade events, position updates, and system status
   - Configure automatic trimming at 10,000 entries
   - Support 10Hz refresh rate for TUI updates

3. Create a subscription system for real-time updates:
   - Allow components to subscribe to specific event types
   - Implement efficient batching for multiple events

Example implementation:
```rust
pub struct PriceCache {
    redis: Pool<RedisConnectionManager>,
    update_interval: Duration,
}

impl PriceCache {
    pub async fn start_price_updater(&self, tokens: Vec<String>) -> JoinHandle<()> {
        let redis = self.redis.clone();
        let interval = self.update_interval;
        
        tokio::spawn(async move {
            let mut interval_timer = tokio::time::interval(interval);
            loop {
                interval_timer.tick().await;
                for token in &tokens {
                    if let Ok(price) = fetch_token_price(token).await {
                        let mut conn = redis.get().await.unwrap();
                        let _: () = conn.set_ex(
                            format!("price:{}", token),
                            price.to_string(),
                            2, // 2 second TTL
                        ).await.unwrap_or_else(|e| eprintln!("Redis error: {}", e));
                    }
                }
            }
        })
    }
    
    pub async fn get_price(&self, token: &str) -> Result<Decimal> {
        let mut conn = self.redis.get().await?;
        let price: String = conn.get(format!("price:{}", token)).await?;
        price.parse::<Decimal>().map_err(Into::into)
    }
}

pub struct EventStream {
    redis: Pool<RedisConnectionManager>,
    stream_name: String,
    max_len: usize,
}

impl EventStream {
    pub async fn publish<T: Serialize>(&self, event: T) -> Result<()> {
        let mut conn = self.redis.get().await?;
        let payload = serde_json::to_string(&event)?;
        let _: () = conn.xadd_maxlen(
            &self.stream_name,
            "~",
            self.max_len,
            "*",
            &[("data", payload)],
        ).await?;
        Ok(())
    }
    
    pub async fn subscribe<T: DeserializeOwned>(&self) -> impl Stream<Item = Result<T>> {
        // Implementation of Redis Streams subscription
    }
}
```

# Test Strategy:
Benchmark Redis price cache to verify <1ms read times. Test cache update frequency and TTL behavior. Verify Redis Streams can handle 10Hz update frequency with proper trimming at 10,000 entries. Create integration tests that simulate high message volumes. Test subscription system with multiple consumers. Verify correct serialization/deserialization of all event types.

# Subtasks:
## 1. Implement Redis Price Caching System [pending]
### Dependencies: None
### Description: Design and implement a high-performance Redis-based price caching system with TTL management
### Details:
Create a price caching system using Redis that: 1) Stores price data with appropriate key structure (e.g., 'price:{symbol}'), 2) Implements configurable TTL for cache entries to ensure data freshness, 3) Optimizes for sub-millisecond read performance through connection pooling and pipelining, 4) Includes cache invalidation strategy for manual updates, 5) Implements error handling and fallback mechanisms.

## 2. Develop Redis Streams for Event Propagation [pending]
### Dependencies: 5.1
### Description: Implement Redis Streams for efficient event propagation with automatic trimming
### Details:
Build an event streaming system using Redis Streams that: 1) Creates appropriate stream keys for different event types, 2) Implements efficient event publishing with proper serialization, 3) Configures automatic stream trimming to prevent unbounded growth (XADD with MAXLEN), 4) Handles backpressure scenarios, 5) Includes monitoring for stream size and throughput.

## 3. Create Real-time Subscription System [pending]
### Dependencies: 5.2
### Description: Develop a subscription system for real-time updates with efficient batching
### Details:
Implement a subscription system that: 1) Allows clients to subscribe to specific price or event streams, 2) Efficiently batches updates to minimize network overhead, 3) Supports the required 10Hz refresh rate, 4) Implements reconnection logic for dropped connections, 5) Provides mechanisms for subscription management (add/remove subscriptions dynamically), 6) Includes performance metrics collection for monitoring system health.

