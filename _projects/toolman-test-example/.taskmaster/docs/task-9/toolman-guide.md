# Task 9: Performance Optimization and Scaling - Toolman Usage Guide

## Overview

This guide provides step-by-step instructions for using Toolman to implement performance optimizations and scaling for the Task Master platform. The goal is to achieve sub-100ms latency and support 1000+ concurrent users through systematic optimization.

## Prerequisites

Before starting, ensure you have:
- Toolman CLI installed and configured
- Access to the Task Master repository
- Redis and PostgreSQL instances available
- Node.js development environment set up
- Load testing tools (K6, Artillery) installed

## Phase 1: Performance Analysis

### Step 1: Baseline Performance Measurement

First, establish current performance metrics as a baseline:

```bash
# Initialize performance analysis
toolman analyze performance --baseline

# This will:
# 1. Run automated performance tests
# 2. Profile database queries
# 3. Analyze bundle sizes
# 4. Measure API response times
# 5. Generate baseline report
```

Expected output:
```
Performance Analysis Complete:
- Current concurrent users: 150 max
- Average API response: 350ms
- WebSocket latency: 180ms
- Bundle size: 1.2MB
- Database queries: 15 slow queries detected
Report saved to: metrics/baseline.json
```

### Step 2: Identify Bottlenecks

Use Toolman to identify performance bottlenecks:

```bash
# Run bottleneck analysis
toolman analyze bottlenecks --deep

# Analyzes:
# - N+1 query patterns
# - Unindexed database queries  
# - Large bundle imports
# - Synchronous operations
# - Memory leaks
```

Review the generated report:
```bash
cat bottleneck_analysis.md
```

## Phase 2: Caching Implementation

### Step 3: Set Up Redis Infrastructure

Deploy Redis using Toolman's infrastructure commands:

```bash
# Generate Redis configuration
toolman generate redis-config --cluster --persistence

# Deploy Redis containers
toolman deploy redis --config redis.conf

# Verify Redis cluster
toolman test redis-connection
```

### Step 4: Implement Cache Middleware

Generate and apply caching middleware:

```bash
# Generate cache middleware
toolman generate middleware cache \
  --strategy multi-layer \
  --invalidation smart \
  --monitoring enabled

# This creates:
# - middleware/cache.ts
# - utils/cacheInvalidation.ts
# - config/redis.ts
```

Apply caching to API routes:

```bash
# Analyze routes for caching opportunities
toolman analyze routes --suggest-caching

# Apply caching decorators
toolman apply caching --routes "GET:/api/*" --ttl 300
```

### Step 5: Configure Browser Caching

Set up static asset caching:

```bash
# Generate webpack optimization config
toolman optimize webpack \
  --split-chunks \
  --tree-shake \
  --cache-busting

# Configure nginx for static assets
toolman generate nginx-config \
  --gzip \
  --cache-headers \
  --http2
```

## Phase 3: Socket.io Optimization

### Step 6: Optimize Real-time Communication

Configure Socket.io for scale:

```bash
# Generate optimized Socket.io config
toolman optimize socketio \
  --transport websocket-only \
  --compression true \
  --binary-support true

# Implement room-based broadcasting
toolman refactor socketio \
  --pattern room-based \
  --presence-tracking optimized
```

### Step 7: Enable Socket.io Clustering

Set up Redis adapter for horizontal scaling:

```bash
# Configure Socket.io Redis adapter
toolman configure socketio-redis \
  --adapter cluster \
  --sticky-sessions true

# Test cluster communication
toolman test socketio-cluster --instances 4
```

## Phase 4: Database Optimization

### Step 8: Create Performance Indexes

Analyze and create database indexes:

```bash
# Analyze query patterns
toolman analyze database --slow-queries --explain

# Generate index recommendations
toolman suggest indexes --threshold 10ms

# Apply indexes
toolman apply indexes --review
```

Example index creation:
```sql
-- Generated by Toolman
CREATE INDEX CONCURRENTLY idx_tasks_project_status 
ON tasks(project_id, status, priority);

CREATE INDEX CONCURRENTLY idx_messages_room_created 
ON messages(room_id, created_at DESC);
```

### Step 9: Optimize Database Queries

Refactor slow queries:

```bash
# Find and optimize N+1 queries
toolman optimize queries --fix-n-plus-one

# Add query result caching
toolman apply query-cache --repository "*Repository"

# Implement connection pooling
toolman configure db-pool --min 5 --max 20
```

## Phase 5: Frontend Optimization

### Step 10: Implement Code Splitting

Set up route-based code splitting:

```bash
# Analyze bundle for splitting opportunities
toolman analyze bundle --visualize

# Apply code splitting
toolman optimize react \
  --lazy-routes \
  --dynamic-imports \
  --prefetch
```

### Step 11: Add Component Optimization

Optimize React components:

```bash
# Add memoization to expensive components
toolman optimize components \
  --memo \
  --use-callback \
  --use-memo

# Implement virtual scrolling
toolman add virtual-scroll \
  --lists "TaskList,MessageList" \
  --threshold 100
```

## Phase 6: Horizontal Scaling

### Step 12: Configure Load Balancing

Set up nginx load balancer:

```bash
# Generate load balancer config
toolman generate load-balancer \
  --upstream 4 \
  --health-checks \
  --least-conn

# Deploy configuration
toolman deploy nginx --config nginx.conf
```

### Step 13: Enable Application Clustering

Configure PM2 for process management:

```bash
# Generate PM2 ecosystem file
toolman generate pm2-config \
  --instances max \
  --watch false \
  --cluster true

# Start clustered application
toolman start cluster --monitor
```

## Phase 7: Load Testing

### Step 14: Execute Performance Tests

Run comprehensive load tests:

```bash
# Run progressive load test
toolman test load \
  --users "100,500,1000,1500" \
  --duration 30m \
  --ramp-up 5m

# Run spike test
toolman test spike \
  --baseline 200 \
  --spike 1500 \
  --duration 5m

# Run stress test
toolman test stress \
  --find-breaking-point \
  --max-users 2000
```

### Step 15: Validate Performance Targets

Verify all performance criteria:

```bash
# Run acceptance tests
toolman test acceptance \
  --criteria task-9/acceptance-criteria.md

# Generate performance report
toolman report performance \
  --compare baseline \
  --format html
```

## Phase 8: Monitoring Setup

### Step 16: Deploy Monitoring Stack

Set up performance monitoring:

```bash
# Deploy monitoring infrastructure
toolman deploy monitoring \
  --prometheus \
  --grafana \
  --statsd

# Import dashboards
toolman import dashboards \
  --source templates/grafana/*.json
```

### Step 17: Configure Alerts

Set up performance alerts:

```bash
# Configure alert rules
toolman configure alerts \
  --latency ">100ms" \
  --error-rate ">2%" \
  --memory ">80%"

# Test alert notifications
toolman test alerts --simulate
```

## Troubleshooting Guide

### Common Issues and Solutions

#### High Memory Usage
```bash
# Analyze memory usage
toolman profile memory --heap-snapshot

# Find memory leaks
toolman analyze memory-leaks --duration 1h

# Apply fixes
toolman fix memory-leaks --auto
```

#### Slow API Responses
```bash
# Profile API endpoints
toolman profile api --endpoints "/api/*"

# View flame graph
toolman visualize performance --flame-graph

# Apply optimizations
toolman optimize api --aggressive
```

#### WebSocket Connection Issues
```bash
# Debug WebSocket connections
toolman debug websocket --verbose

# Test reconnection logic
toolman test websocket-reconnect --chaos

# Optimize heartbeat settings
toolman tune websocket --auto
```

## Validation Workflow

### Final Performance Validation

1. **Run Full Test Suite**:
```bash
toolman test all --performance
```

2. **Generate Performance Report**:
```bash
toolman report full \
  --include-metrics \
  --include-graphs \
  --format pdf
```

3. **Deploy with Monitoring**:
```bash
toolman deploy production \
  --health-checks \
  --gradual \
  --monitor
```

## Best Practices

### 1. Incremental Optimization
- Apply one optimization at a time
- Measure impact after each change
- Maintain performance regression tests

### 2. Monitoring First
- Set up monitoring before optimizing
- Establish baseline metrics
- Track improvements systematically

### 3. Cache Wisely
- Start with short TTLs
- Monitor cache hit rates
- Implement proper invalidation

### 4. Test Under Load
- Test each optimization under load
- Simulate real-world usage patterns
- Include edge cases in tests

## Advanced Commands

### Custom Performance Profiles
```bash
# Create custom performance profile
toolman profile create "e-commerce" \
  --pattern "read-heavy" \
  --users 2000 \
  --think-time 5s
```

### Automated Optimization
```bash
# Run AI-powered optimization
toolman optimize auto \
  --target "latency<50ms" \
  --constraints "memory<512MB" \
  --iterations 10
```

### Continuous Performance Testing
```bash
# Set up CI/CD performance gates
toolman ci setup \
  --performance-budget \
  --regression-detection \
  --auto-rollback
```

## Conclusion

This guide provides a comprehensive approach to performance optimization using Toolman. Follow the phases sequentially, validate each optimization, and maintain monitoring throughout the process. The key to success is systematic measurement, incremental improvement, and continuous validation.