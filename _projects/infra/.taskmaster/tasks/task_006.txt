# Task ID: 6
# Title: Deploy Jupiter API with High Availability
# Status: pending
# Dependencies: 5
# Priority: medium
# Description: Deploy Jupiter swap API with high availability configuration using Helm charts, direct connection to local Solana validator, automatic failover to public API if needed, and integrated monitoring with Prometheus/Grafana stack.
# Details:
1. Create Helm chart for Jupiter API deployment:
```yaml
# Chart.yaml
apiVersion: v2
name: jupiter-api
version: 1.0.0
description: High-availability Jupiter swap API
dependencies:
  - name: kube-prometheus-stack
    version: "~45.0.0"
    repository: https://prometheus-community.github.io/helm-charts
    condition: monitoring.enabled
```

2. Create values.yaml for Jupiter API:
```yaml
replicaCount: 2
image:
  repository: jupiter-api
  tag: latest
  pullPolicy: IfNotPresent

env:
  RPC_ENDPOINT: "http://solana-validator:8899"
  FALLBACK_RPC_ENDPOINT: "https://api.mainnet-beta.solana.com"
  YELLOWSTONE_ENDPOINT: "http://solana-validator-grpc:8081"
  MARKET_CACHE_UPDATE_INTERVAL: "1800000"

resources:
  requests:
    cpu: "4"
    memory: 8Gi
  limits:
    cpu: "8"
    memory: 16Gi

affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
    - labelSelector:
        matchExpressions:
        - key: app
          operator: In
          values:
          - jupiter-api
      topologyKey: "kubernetes.io/hostname"

monitoring:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: 30s
  prometheusRule:
    enabled: true
    rules:
      - alert: JupiterAPIHighLatency
        expr: jupiter_api_quote_latency_ms > 200
        for: 5m
      - alert: JupiterAPIDown
        expr: up{job="jupiter-api"} == 0
        for: 1m
```

3. Create custom Grafana dashboard ConfigMap:
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: jupiter-api-dashboard
  labels:
    grafana_dashboard: "1"
data:
  jupiter-api.json: |
    {
      "dashboard": {
        "title": "Jupiter API Metrics",
        "panels": [
          {
            "title": "Quote Latency",
            "targets": [{
              "expr": "jupiter_api_quote_latency_ms"
            }]
          },
          {
            "title": "Request Rate",
            "targets": [{
              "expr": "rate(jupiter_api_requests_total[5m])"
            }]
          }
        ]
      }
    }
```

4. Implement Prometheus metrics exporter in Jupiter API
5. Configure ServiceMonitor for automatic metric discovery
6. Set up PrometheusRule for Jupiter-specific alerts
7. Create Helm values for different environments (dev, staging, prod)

# Test Strategy:
1. Verify Jupiter API Helm chart deploys successfully
2. Validate Prometheus is scraping Jupiter API metrics
3. Test custom Grafana dashboards display correct data
4. Verify alert rules trigger correctly (simulate high latency)
5. Test direct connection to local Solana validator
6. Validate Yellowstone gRPC integration
7. Benchmark quote response times (target <200ms)
8. Test failover by simulating local validator failure
9. Verify session affinity for consistent routing
10. Monitor market cache updates via metrics
11. Load test with simulated swap requests while monitoring dashboards

# Subtasks:
## 1. Build and Containerize Jupiter API [pending]
### Dependencies: None
### Description: Create and validate a Dockerfile for the Jupiter API, ensuring all dependencies are installed and the application builds and runs successfully in a containerized environment.
### Details:
Use the provided Dockerfile to clone the Jupiter API repository, install dependencies, build the application, and set up the container entrypoint. Verify the image builds and runs locally.

## 2. Create Jupiter API Helm Chart [pending]
### Dependencies: 6.1
### Description: Develop a custom Helm chart for Jupiter API deployment with high availability configuration, including templates for Deployment, Service, ServiceMonitor, and PrometheusRule resources.
### Details:
Create Helm chart structure with Chart.yaml, values.yaml, and templates. Include dependency on kube-prometheus-stack for monitoring integration. Define configurable values for replicas, resources, and monitoring settings.

## 3. Implement Prometheus Metrics in Jupiter API [pending]
### Dependencies: 6.1
### Description: Add Prometheus client library to Jupiter API and expose custom metrics for quote latency, request rate, cache hit ratio, and RPC endpoint health.
### Details:
Integrate prometheus client library into the API codebase. Expose metrics endpoint at /metrics. Track key performance indicators including jupiter_api_quote_latency_ms, jupiter_api_requests_total, jupiter_api_cache_hits_total.

## 4. Deploy Jupiter API with Helm and Configure Monitoring [pending]
### Dependencies: 6.2, 6.3
### Description: Deploy the Jupiter API Helm chart with monitoring enabled, configure ServiceMonitor for metric scraping, and apply PrometheusRule for alerts.
### Details:
Deploy using 'helm install' with monitoring.enabled=true. Verify ServiceMonitor is created and Prometheus discovers the target. Apply custom alert rules for latency and availability.

## 5. Create Custom Grafana Dashboards for Jupiter API [pending]
### Dependencies: 6.4
### Description: Design and deploy Grafana dashboards as ConfigMaps showing Jupiter API performance metrics, RPC endpoint status, and market cache statistics.
### Details:
Create dashboard JSON with panels for quote latency percentiles, request rate, error rate, cache hit ratio, and RPC endpoint health. Apply ConfigMap with grafana_dashboard label for automatic import.

## 6. Configure Automatic Failover and Health Monitoring [pending]
### Dependencies: 6.4
### Description: Implement health check endpoint with RPC connectivity validation and configure automatic failover logic with metrics tracking for failover events.
### Details:
Enhance /health endpoint to check local RPC connectivity. Implement failover logic that switches to FALLBACK_RPC_ENDPOINT on failure. Expose jupiter_api_rpc_failover_total metric to track failover events.

