# Task ID: 11
# Title: Create Comprehensive Helm Chart for Jupiter DEX Integration Service
# Status: pending
# Dependencies: 6, 7
# Priority: high
# Description: Develop a production-ready Helm chart for deploying Jupiter DEX integration services including API gateway, price oracle, route optimization, rate limiting, and monitoring capabilities with full support for different Solana environments.
# Details:
1. Create Helm chart structure for Jupiter DEX integration:
```bash
jupiter-dex-integration/
├── Chart.yaml
├── values.yaml
├── values-mainnet.yaml
├── values-testnet.yaml
├── values-devnet.yaml
├── templates/
│   ├── _helpers.tpl
│   ├── configmap.yaml
│   ├── secret.yaml
│   ├── api-gateway/
│   │   ├── deployment.yaml
│   │   ├── service.yaml
│   │   ├── hpa.yaml
│   │   └── pdb.yaml
│   ├── price-oracle/
│   │   ├── deployment.yaml
│   │   ├── service.yaml
│   │   └── cronjob.yaml
│   ├── route-optimizer/
│   │   ├── deployment.yaml
│   │   ├── service.yaml
│   │   └── configmap.yaml
│   ├── monitoring/
│   │   ├── servicemonitor.yaml
│   │   ├── prometheusrule.yaml
│   │   └── grafana-dashboard.yaml
│   └── networkpolicy.yaml
```

2. Define Chart.yaml:
```yaml
apiVersion: v2
name: jupiter-dex-integration
description: Production-ready Helm chart for Jupiter DEX integration services
type: application
version: 1.0.0
appVersion: "1.0.0"
dependencies:
  - name: redis
    version: "17.x.x"
    repository: https://charts.bitnami.com/bitnami
    condition: redis.enabled
```

3. Create comprehensive values.yaml:
```yaml
global:
  environment: mainnet-beta
  solanaRpcUrl: "http://solana-validator:8899"
  jupiterApiUrl: "https://quote-api.jup.ag/v6"
  
apiGateway:
  enabled: true
  replicaCount: 3
  image:
    repository: jupiter-api-gateway
    tag: latest
    pullPolicy: IfNotPresent
  
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 2000m
      memory: 4Gi
  
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
  
  circuitBreaker:
    enabled: true
    failureThreshold: 5
    timeout: 30s
    resetTimeout: 60s
  
  rateLimiting:
    enabled: true
    requestsPerMinute: 1000
    burstSize: 100
    
priceOracle:
  enabled: true
  replicaCount: 2
  updateInterval: "*/5 * * * *"  # Every 5 minutes
  
  resources:
    requests:
      cpu: 250m
      memory: 512Mi
    limits:
      cpu: 1000m
      memory: 2Gi
      
routeOptimizer:
  enabled: true
  replicaCount: 2
  
  optimization:
    maxRoutes: 5
    slippageTolerance: 0.5
    priorityFeeMultiplier: 1.5
    
  cache:
    enabled: true
    ttl: 300  # 5 minutes
    
monitoring:
  enabled: true
  prometheus:
    enabled: true
    interval: 30s
    scrapeTimeout: 10s
  
  alerts:
    enabled: true
    rules:
      - name: JupiterAPIHighErrorRate
        expr: rate(jupiter_api_errors_total[5m]) > 0.1
        severity: warning
      - name: JupiterAPIHighLatency
        expr: histogram_quantile(0.95, jupiter_api_latency_seconds) > 2
        severity: critical
        
secrets:
  jupiterApiKey: ""  # Set via --set or external secret
  solanaRpcAuth: ""
```

4. Implement API Gateway deployment template:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "jupiter-dex.fullname" . }}-api-gateway
  labels:
    {{- include "jupiter-dex.labels" . | nindent 4 }}
    component: api-gateway
spec:
  replicas: {{ .Values.apiGateway.replicaCount }}
  selector:
    matchLabels:
      {{- include "jupiter-dex.selectorLabels" . | nindent 6 }}
      component: api-gateway
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
      labels:
        {{- include "jupiter-dex.selectorLabels" . | nindent 8 }}
        component: api-gateway
    spec:
      serviceAccountName: {{ include "jupiter-dex.serviceAccountName" . }}
      containers:
      - name: api-gateway
        image: "{{ .Values.apiGateway.image.repository }}:{{ .Values.apiGateway.image.tag }}"
        imagePullPolicy: {{ .Values.apiGateway.image.pullPolicy }}
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        env:
        - name: SOLANA_RPC_URL
          value: {{ .Values.global.solanaRpcUrl }}
        - name: JUPITER_API_URL
          value: {{ .Values.global.jupiterApiUrl }}
        - name: JUPITER_API_KEY
          valueFrom:
            secretKeyRef:
              name: {{ include "jupiter-dex.fullname" . }}-secrets
              key: jupiter-api-key
        - name: CIRCUIT_BREAKER_ENABLED
          value: "{{ .Values.apiGateway.circuitBreaker.enabled }}"
        - name: RATE_LIMIT_RPM
          value: "{{ .Values.apiGateway.rateLimiting.requestsPerMinute }}"
        livenessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          {{- toYaml .Values.apiGateway.resources | nindent 10 }}
```

5. Create ServiceMonitor for Prometheus integration:
```yaml
{{- if .Values.monitoring.prometheus.enabled }}
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: {{ include "jupiter-dex.fullname" . }}
  labels:
    {{- include "jupiter-dex.labels" . | nindent 4 }}
spec:
  selector:
    matchLabels:
      {{- include "jupiter-dex.selectorLabels" . | nindent 6 }}
  endpoints:
  - port: metrics
    interval: {{ .Values.monitoring.prometheus.interval }}
    scrapeTimeout: {{ .Values.monitoring.prometheus.scrapeTimeout }}
    path: /metrics
{{- end }}
```

6. Implement environment-specific configurations:
```yaml
# values-mainnet.yaml
global:
  environment: mainnet-beta
  solanaRpcUrl: "http://solana-validator:8899"
  jupiterApiUrl: "https://quote-api.jup.ag/v6"

apiGateway:
  replicaCount: 5
  autoscaling:
    minReplicas: 5
    maxReplicas: 20

# values-devnet.yaml  
global:
  environment: devnet
  solanaRpcUrl: "https://api.devnet.solana.com"
  jupiterApiUrl: "https://quote-api.jup.ag/v6"

apiGateway:
  replicaCount: 1
  autoscaling:
    enabled: false
```

7. Create backup and recovery procedures:
```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ include "jupiter-dex.fullname" . }}-backup
spec:
  schedule: "0 */6 * * *"  # Every 6 hours
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: backup
            image: bitnami/kubectl:latest
            command:
            - /bin/bash
            - -c
            - |
              # Backup configuration and state
              kubectl get configmap,secret -l app.kubernetes.io/instance={{ .Release.Name }} -o yaml > /backup/config-$(date +%Y%m%d-%H%M%S).yaml
              # Upload to S3 or other storage
          restartPolicy: OnFailure
```

# Test Strategy:
1. Validate Helm chart syntax and structure:
   - Run `helm lint jupiter-dex-integration/`
   - Execute `helm template` with different values files
   - Verify all templates render correctly

2. Test deployment in different environments:
   - Deploy to devnet with minimal resources
   - Verify all pods start successfully
   - Check service connectivity between components

3. Validate API Gateway functionality:
   - Test swap quote endpoints
   - Verify circuit breaker triggers on failures
   - Confirm rate limiting works as configured
   - Measure response times (target <500ms)

4. Test Price Oracle service:
   - Verify price updates occur on schedule
   - Validate price accuracy against Jupiter API
   - Check Redis cache integration
   - Monitor memory usage during operation

5. Verify Route Optimizer:
   - Test route calculation for various token pairs
   - Validate optimization improves swap rates
   - Check caching mechanism effectiveness
   - Measure computation time for complex routes

6. Test monitoring and alerting:
   - Verify Prometheus scrapes metrics successfully
   - Trigger test alerts by simulating failures
   - Validate Grafana dashboards display correctly
   - Check custom Jupiter-specific metrics

7. Validate auto-scaling and resilience:
   - Generate load to trigger HPA scaling
   - Kill pods to test recovery
   - Simulate network partitions
   - Verify PodDisruptionBudget enforcement

8. Test secret management:
   - Rotate API keys and verify updates
   - Check secret encryption at rest
   - Validate RBAC permissions

9. Verify backup and recovery:
   - Execute backup job manually
   - Test restoration procedure
   - Validate data integrity after restore

# Subtasks:
## 1. Design Helm Chart Structure and Directory Layout [pending]
### Dependencies: None
### Description: Establish the foundational directory structure for the Jupiter DEX integration Helm chart, including Chart.yaml, values files for different environments, and a well-organized templates directory for all service components.
### Details:
Create the main chart directory with Chart.yaml, values.yaml, environment-specific values files (mainnet, testnet, devnet), and a templates directory containing subdirectories for api-gateway, price-oracle, route-optimizer, monitoring, and network policies. Ensure the structure supports modularity and maintainability.

## 2. Define and Parameterize Core Service Templates [pending]
### Dependencies: 11.1
### Description: Develop Helm templates for all core Jupiter DEX integration services, including deployments, services, HPA, PDB, and CronJobs, ensuring parameterization via values.yaml for flexibility across environments.
### Details:
Implement deployment, service, and configuration templates for api-gateway, price-oracle, and route-optimizer. Use Helm templating to inject values from values.yaml and environment-specific files. Ensure templates support resource requests/limits, autoscaling, and environment variables.

## 3. Integrate Monitoring, Rate Limiting, and Security Features [pending]
### Dependencies: 11.2
### Description: Add templates and configuration for monitoring (Prometheus ServiceMonitor, PrometheusRule, Grafana dashboards), rate limiting, circuit breaker, and secure handling of secrets and sensitive data.
### Details:
Create monitoring templates under templates/monitoring, implement rate limiting and circuit breaker configuration in api-gateway, and ensure secrets are managed via Kubernetes Secret objects. Follow best practices for labeling and resource metadata.

## 4. Implement Environment-Specific Configuration and Dependency Management [pending]
### Dependencies: 11.3
### Description: Configure values-mainnet.yaml, values-testnet.yaml, and values-devnet.yaml for environment-specific overrides, and manage chart dependencies (e.g., Redis) using Helm's dependency mechanism.
### Details:
Populate environment-specific values files with appropriate resource counts, endpoints, and autoscaling settings. Define dependencies in Chart.yaml and ensure subcharts are referenced correctly. Validate that environment overrides work as intended.

## 5. Document, Test, and Validate the Helm Chart for Production Readiness [pending]
### Dependencies: 11.4
### Description: Write comprehensive documentation for chart usage, configuration, and customization. Implement chart tests and backup/recovery CronJobs. Validate the chart with linting, rendering, and test deployments.
### Details:
Provide README and inline documentation, add tests under templates/tests, and implement backup CronJob for configuration/state. Use helm lint, helm template, and test deployments to ensure production readiness.

