//! # PR Comments
//!
//! Create and manage comments on GitHub pull requests using the `gh` CLI.
//!
//! ## Example
//!
//! ```no_run
//! use utils::PrComment;
//!
//! # async fn example() -> anyhow::Result<()> {
//! let comment = PrComment::new("5dlabs", "cto");
//!
//! // Post a simple comment
//! comment.post(1864, "Hello from utils!").await?;
//! # Ok(())
//! # }
//! ```

use anyhow::{Context, Result};
use std::process::Stdio;
use tokio::process::Command;
use tracing::{debug, info};

use crate::alerts::{Annotation, AnnotationLevel};

/// Client for posting comments to GitHub PRs
#[derive(Debug, Clone)]
pub struct PrComment {
    owner: String,
    repo: String,
}

impl PrComment {
    /// Create a new PR comment client
    pub fn new(owner: impl Into<String>, repo: impl Into<String>) -> Self {
        Self {
            owner: owner.into(),
            repo: repo.into(),
        }
    }

    /// Post a comment to a PR
    pub async fn post(&self, pr_number: u32, body: &str) -> Result<()> {
        debug!(pr = pr_number, body_len = body.len(), "Posting PR comment");

        let output = Command::new("gh")
            .args([
                "pr",
                "comment",
                &pr_number.to_string(),
                "--repo",
                &format!("{}/{}", self.owner, self.repo),
                "--body",
                body,
            ])
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .context("Failed to execute gh CLI")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            anyhow::bail!("gh pr comment failed: {stderr}");
        }

        info!(pr = pr_number, "Posted comment to PR");
        Ok(())
    }

    /// Post a formatted alerts summary to a PR
    pub async fn post_alerts(&self, pr_number: u32, annotations: &[Annotation]) -> Result<()> {
        let body = format_alerts_comment(annotations);
        self.post(pr_number, &body).await
    }
}

/// Format annotations as a markdown comment
pub fn format_alerts_comment(annotations: &[Annotation]) -> String {
    if annotations.is_empty() {
        return "## ‚úÖ No CI Failures\n\nAll checks passed without errors.".to_string();
    }

    let mut md = String::new();

    // Header with count
    let failure_count = annotations
        .iter()
        .filter(|a| a.level == AnnotationLevel::Failure)
        .count();
    let warning_count = annotations
        .iter()
        .filter(|a| a.level == AnnotationLevel::Warning)
        .count();

    md.push_str("## üö® CI Alerts Summary\n\n");

    // Stats line
    let mut stats = Vec::new();
    if failure_count > 0 {
        stats.push(format!("**{failure_count}** failure(s)"));
    }
    if warning_count > 0 {
        stats.push(format!("**{warning_count}** warning(s)"));
    }
    let other_count = annotations.len() - failure_count - warning_count;
    if other_count > 0 {
        stats.push(format!("**{other_count}** notice(s)"));
    }
    md.push_str(&stats.join(" ¬∑ "));
    md.push_str("\n\n");

    // Group by file
    let mut by_file: std::collections::BTreeMap<&str, Vec<&Annotation>> =
        std::collections::BTreeMap::new();
    for ann in annotations {
        by_file.entry(&ann.path).or_default().push(ann);
    }

    // Failures first
    let failures: Vec<_> = annotations
        .iter()
        .filter(|a| a.level == AnnotationLevel::Failure)
        .collect();

    if !failures.is_empty() {
        md.push_str("### ‚ùå Failures\n\n");
        for ann in failures {
            md.push_str(&format_annotation(ann));
        }
    }

    // Then warnings
    let warnings: Vec<_> = annotations
        .iter()
        .filter(|a| a.level == AnnotationLevel::Warning)
        .collect();

    if !warnings.is_empty() {
        md.push_str("### ‚ö†Ô∏è Warnings\n\n");
        for ann in warnings {
            md.push_str(&format_annotation(ann));
        }
    }

    // Then notices
    let notices: Vec<_> = annotations
        .iter()
        .filter(|a| a.level == AnnotationLevel::Notice)
        .collect();

    if !notices.is_empty() {
        md.push_str("### ‚ÑπÔ∏è Notices\n\n");
        for ann in notices {
            md.push_str(&format_annotation(ann));
        }
    }

    // Footer
    md.push_str("\n---\n*Generated by `utils post-alerts`*\n");

    md
}

/// Format a single annotation as markdown
fn format_annotation(ann: &Annotation) -> String {
    use std::fmt::Write;

    let mut s = String::new();

    // File and line as a clickable reference
    let line_range = if ann.start_line == ann.end_line {
        format!("L{}", ann.start_line)
    } else {
        format!("L{}-L{}", ann.start_line, ann.end_line)
    };

    let _ = writeln!(s, "**`{}`** ([{line_range}])", ann.path);

    // Message in a quote block
    let _ = writeln!(s, "> {}", ann.message);

    // Title if present
    if !ann.title.is_empty() {
        let _ = writeln!(s, "> *{}*", ann.title);
    }

    s.push('\n');
    s
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_empty_annotations() {
        let result = format_alerts_comment(&[]);
        assert!(result.contains("No CI Failures"));
    }

    #[test]
    fn test_format_single_failure() {
        let annotations = vec![Annotation {
            path: "src/main.rs".to_string(),
            start_line: 10,
            end_line: 10,
            level: AnnotationLevel::Failure,
            message: "unused variable".to_string(),
            title: String::new(),
            raw_details: String::new(),
        }];

        let result = format_alerts_comment(&annotations);
        assert!(result.contains("CI Alerts Summary"));
        assert!(result.contains("1** failure"));
        assert!(result.contains("src/main.rs"));
        assert!(result.contains("unused variable"));
    }

    #[test]
    fn test_format_mixed_levels() {
        let annotations = vec![
            Annotation {
                path: "src/lib.rs".to_string(),
                start_line: 5,
                end_line: 5,
                level: AnnotationLevel::Failure,
                message: "error message".to_string(),
                title: String::new(),
                raw_details: String::new(),
            },
            Annotation {
                path: "src/lib.rs".to_string(),
                start_line: 10,
                end_line: 10,
                level: AnnotationLevel::Warning,
                message: "warning message".to_string(),
                title: String::new(),
                raw_details: String::new(),
            },
        ];

        let result = format_alerts_comment(&annotations);
        assert!(result.contains("Failures"));
        assert!(result.contains("Warnings"));
        assert!(result.contains("error message"));
        assert!(result.contains("warning message"));
    }

    #[test]
    fn test_pr_comment_new() {
        let comment = PrComment::new("owner", "repo");
        assert_eq!(comment.owner, "owner");
        assert_eq!(comment.repo, "repo");
    }
}
