# Toolman Integration - Product Requirements Document

## Executive Summary
Enable users to specify which MCP tools Claude should use when working on tasks. Users should be able to say "Hey Claude, start task 6 with local tool filesystem and remote tools Brave, Kubernetes, and Helm" and have Claude configured with exactly those tools.

## Core User Experience

The primary goal is to enable this workflow:
1. User tells Claude which tools to use for a task
2. Platform configures Claude with only those specified tools
3. Claude executes the task with the requested tool configuration

Example interactions:
- "Start task 6 with filesystem and GitHub tools"
- "Work on the docs task with only read-only filesystem and web search"
- "Deploy the service using Kubernetes, Helm, and git tools"

## Current State vs Target State

### Current State
- All agents get the same tool configuration based on `tool_config` level (minimal/default/advanced)
- No way to specify tools per task
- Limited to filesystem server in advanced mode
- No access to remote tools like web search, Kubernetes, etc.

### Target State
- Users can specify exact tools needed per task
- Claude gets configured with only the requested tools
- Support for both local tools (filesystem, git) and remote tools (via toolman)
- Simple, functional implementation that "just works"

## Technical Approach

### Understanding: How Toolman Works
- **HTTP Mode**: Toolman runs as a simple aggregator that exposes all configured MCP servers
- **No Server-Side Filtering**: Toolman exposes everything; filtering happens on the client side
- **Simple Proxy**: Just forwards requests to the appropriate MCP server

### Key Innovation: ConfigMap as Single Source of Truth

The brilliance of this approach is that **toolman's ConfigMap becomes the authoritative source** for what MCP tools are available in the platform:

```
User adds new MCP server → Updates toolman ConfigMap → Everything knows about it
```

This means:
- **Docs Agent** reads the ConfigMap during documentation phase to know available tools
- **Code Agent** just uses the configuration generated by Docs Agent
- **Platform Admin** just maintains one configuration
- **Automatic Discovery** - no code changes needed when adding new tools

### The Critical Flow: Discovery vs Consumption

**Phase 1: Documentation (Discovery)**
```
Docs Agent:
- Analyzes project
- Reads toolman ConfigMap to see available tools
- Matches project needs with available tools
- Generates optimal configuration
- Saves configuration for code agents
```

**Phase 2: Implementation (Consumption)**
```
Code Agent:
- Loads configuration from docs phase
- Uses exactly those tools
- No discovery, no ConfigMap reading
- Just works!
```

This separation is key - discovery happens once during docs generation, then all code agents just consume that configuration.

### CRITICAL: Zero Hardcoding Policy

**There are NO hardcoded tool lists anywhere in the platform code**. This is fundamental to the design:

- ❌ **NO** hardcoded tool names in orchestrator code
- ❌ **NO** static lists of available tools in templates
- ❌ **NO** tool enumerations in CRD schemas
- ❌ **NO** predefined tool mappings in handlers

Instead:
- ✅ **ALL** tool discovery happens by reading toolman's ConfigMap (in docs agent)
- ✅ **ALL** tool validation happens against the ConfigMap (when user overrides)
- ✅ **ALL** tool recommendations are based on ConfigMap contents
- ✅ **ALL** new tools are instantly available without code changes

Example of what we're NOT doing:
```rust
// ❌ NEVER THIS - No hardcoded tool lists!
const AVAILABLE_TOOLS: &[&str] = &["github", "kubernetes", "postgres"];

// ✅ ALWAYS THIS - Dynamic discovery (in docs agent)
let available_tools = read_toolman_configmap().await?;

// ✅ ALWAYS THIS - Code agent just uses config
let config = load_project_config().await?;
```

### Platform Changes (What We're Building)

#### 1. Deploy Toolman Service
**What**: Run existing toolman as a Kubernetes service
**Why**: Provides access to 25+ remote MCP tools
**Changes**:
- Create Helm chart for toolman deployment
- Configure with available MCP servers via ConfigMap
- Expose HTTP endpoint within cluster

**The ConfigMap Structure**:
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: toolman-servers-config
  namespace: orchestrator
data:
  servers-config.json: |
    {
      "servers": {
        "github": { /* config */ },
        "kubernetes": { /* config */ },
        "postgres": { /* config */ },
        # User adds new server here - instantly available everywhere
      }
    }
```

#### 2. Docs Agent Tool Discovery
**What**: During docs generation, read toolman's ConfigMap
**Why**: AI can make intelligent tool recommendations based on what's actually available
**How It Works**:

```
1. Docs agent analyzes project (finds PostgreSQL, Kubernetes files, etc.)
2. Reads toolman ConfigMap to see available tools
3. Matches project needs with available tools
4. Generates optimal client-config.json for the project
5. Saves this configuration for all code agents to use
```

**Benefits**:
- Only configures tools the project actually needs
- Automatically aware of new tools when admin adds them
- Smarter, context-aware defaults
- Zero maintenance when tools change
- Code agents don't need to rediscover anything

#### 3. Update CRD to Accept Tool Specifications
**What**: Modify CodeRun/DocsRun to accept tool lists
**Why**: Capture user's tool requirements when they override defaults
**Changes**:
```yaml
apiVersion: platform.5dlabs.com/v1
kind: CodeRun
spec:
  # Existing fields...
  tools:
    local:
      - filesystem  # Maps to filesystem MCP server
      - git        # Maps to git MCP server
    remote:
      - brave-search_brave_web_search
      - kubernetes_listResources
      - helm_installChart
```

#### 4. Template Updates for Hybrid Configuration
**What**: Update Handlebars templates to generate correct configuration
**Why**: Configure Claude with the exact tools requested
**Changes**:

`client-config.json.hbs`:
```handlebars
{
  {{#if tools}}
  {{!-- User specified exact tools (override) --}}
  "remoteTools": [
    {{#each tools.remote}}
    "{{this}}"{{#unless @last}},{{/unless}}
    {{/each}}
  ],
  "localServers": {
    {{#if (includes tools.local "filesystem")}}
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"],
      "tools": ["*"],
      "workingDirectory": "project_root"
    }{{#if (includes tools.local "git")}},{{/if}}
    {{/if}}
    {{#if (includes tools.local "git")}}
    "git": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-git"],
      "tools": ["*"],
      "workingDirectory": "project_root"
    }
    {{/if}}
  }
  {{else}}
  {{!-- Use configuration generated by docs agent --}}
  {{!-- Code agent just consumes, no discovery --}}
  {{#if project_config}}
  "remoteTools": [...],
  "localServers": {...}
  {{/if}}
  {{/if}}
}
```

`mcp.json.hbs`:
```handlebars
{
  "mcpServers": {
    {{#if (or tools.remote project_config.remote_tools)}}
    "toolman": {
      "transport": "http",
      "url": "http://toolman-service.orchestrator.svc.cluster.local:3000/mcp"
    }
    {{/if}}
  }
}
```

#### 5. Orchestrator Logic Updates
**What**: Parse user tool specifications and pass to templates
**Why**: Bridge between user request and configuration
**Changes**:
- Parse tool specifications from CRD (if user overrides)
- Pass tool lists to template context
- Validate tool names against toolman ConfigMap (only for overrides)
- Load docs-generated config for normal flow
- NO hardcoded tool names anywhere

### Optional Toolman Changes (Only if Needed)

#### Basic Monitoring
**What**: Add request logging with headers
**Why**: Know which agent used which tool (if not available from Claude metrics)
**Changes**:
- Log requests with any identifying headers
- Expose basic metrics endpoint

## Implementation Plan

### Week 1: Deploy Toolman
- Deploy unmodified toolman to cluster
- Create ConfigMap with standard MCP servers
- Verify HTTP endpoint works
- Test ConfigMap updates

### Week 2: Platform Updates
- Update CRDs to accept tool specifications
- Modify docs handler to discover and generate configs
- Modify code handler to consume generated configs
- Update templates to use either source
- Ensure ZERO hardcoded tool names

### Week 3: Testing & Polish
- Test docs agent discovery and config generation
- Test code agent consumption of generated configs
- Test user overrides with specific tools
- Test adding new MCP server to ConfigMap
- Verify instant availability without restarts
- Document tool names for users

## Success Criteria

1. **Functional**: Users can specify tools and Claude uses only those tools
2. **Simple**: No unnecessary complexity - it just works
3. **Clear**: Users know which tool names to use
4. **Reliable**: Tool configuration works every time
5. **Discoverable**: Adding tools to toolman makes them available everywhere
6. **Zero Maintenance**: Adding new tools requires ONLY ConfigMap update
7. **Efficient**: Discovery happens once (docs phase), not repeatedly

## Out of Scope

- Security enhancements (internal use only)
- Performance optimization (just needs to work)
- Complex tool filtering logic
- Tool usage analytics (available from Claude)
- Custom authentication schemes
- Toolman architecture changes

## Tool Administration

### Adding New MCP Servers - The ONLY Process
```bash
# Admin adds new tool
kubectl edit configmap toolman-servers-config
# Add new server configuration

# Restart toolman to pick up changes
kubectl rollout restart deployment toolman

# That's it! Now:
# - Docs agent will see it and can recommend it
# - Users can request it in their tool specifications
# - No code changes needed anywhere
# - No updates to docs agent needed
# - No updates to orchestrator needed
# - It just works!
```

### Tool Name Reference

Users will need to know tool names. We'll provide a simple reference:

**Local Tools**:
- `filesystem` - Read/write files
- `git` - Git operations

**Remote Tools** (via toolman):
- Dynamic list - check `kubectl get configmap toolman-servers-config -o yaml`
- Or call toolman's tool discovery endpoint
- Never hardcoded anywhere!

## Example User Flows

### Example 1: Standard Development Flow
User: "Generate docs for my project"

Docs Agent:
1. Analyzes project files
2. Reads toolman ConfigMap
3. Finds postgres files, k8s configs
4. Generates config with postgres and kubernetes tools
5. Saves config for code agents

User: "Implement task 15"

Code Agent:
1. Loads the config from docs phase
2. Has postgres and kubernetes tools available
3. No discovery needed!

### Example 2: User Override
User: "Start task 15 (write docs) with read-only filesystem and web search"

Platform:
1. Creates CodeRun with tools: `local: [filesystem], remote: [brave-search_brave_web_search]`
2. Validates these tools exist in toolman ConfigMap
3. Configures Claude with only those tools
4. Claude can read files and search web, but not write files

### Example 3: New Tool Added Yesterday
Admin added `new-ai-analyzer` to toolman ConfigMap yesterday.

Next docs run:
1. Docs agent sees `new-ai-analyzer` in ConfigMap
2. Project uses AI, so it includes the tool
3. All code agents now have access to it!

User can also request it directly:
1. "Use the new AI analyzer tool for task 20"
2. Platform validates it exists in ConfigMap
3. Works immediately - no code changes were needed!

## Conclusion

This integration focuses on one thing: letting users tell Claude which tools to use. By keeping the implementation simple and leveraging toolman as-is, we can deliver this functionality quickly and reliably.

The ConfigMap-based discovery approach creates a single source of truth that makes the entire system maintainable with ZERO hardcoding of tool names anywhere in the platform code.

The separation between discovery (docs agent) and consumption (code agent) ensures efficiency - we discover once and use many times.