# Task 7: Update Code Agent to Load Saved Configuration

## Overview
Modify the code agent to load tool configurations generated during the docs phase, eliminating the need for code agents to perform tool discovery. This completes the separation of concerns where docs agents discover and configure, while code agents simply consume.

## Context
Code agents currently use hardcoded defaults or require users to specify tools. With this update, they will load the intelligent configurations generated by docs agents, providing a seamless experience while still allowing user overrides when needed.

## Objectives
1. Implement configuration loading from Kubernetes ConfigMap
2. Establish clear precedence: user override > saved config > defaults
3. Handle missing or corrupted configurations gracefully
4. Integrate seamlessly with existing code agent flow
5. Maintain backward compatibility

## Architecture

### Configuration Loading Flow
```
┌─────────────────────────────────────────────────┐
│              Code Agent Configuration Loading           │
├─────────────────────────────────────────────────┤
│                                                         │
│  1. Check User Override (from CRD)                      │
│     │                                                   │
│     ├─── Yes ──▶ Use User Specified Tools              │
│     │                                                   │
│     └─── No                                            │
│         │                                               │
│         ▼                                               │
│  2. Load Saved Configuration                            │
│     │                                                   │
│     ├─── Found ──▶ Use Docs-Generated Config          │
│     │                                                   │
│     └─── Not Found                                     │
│         │                                               │
│         ▼                                               │
│  3. Use Minimal Defaults                                │
│     │                                                   │
│     └──▶ filesystem (read/write)                       │
│                                                         │
└─────────────────────────────────────────────────┘
```

### Precedence Rules
1. **User Override** (Highest Priority)
   - Explicitly specified in CodeRun CRD
   - Complete control over tool selection
   - Validated against toolman ConfigMap

2. **Saved Configuration** (Default Behavior)
   - Generated by docs agent
   - Intelligent, project-aware selection
   - Includes tool-specific configurations

3. **Minimal Defaults** (Fallback)
   - Basic filesystem access only
   - Ensures agent can always function
   - Logs warning about missing config

## Implementation Details

### 1. Configuration Loading Implementation
```rust
use k8s_openapi::api::core::v1::ConfigMap;
use kube::{Api, Client};
use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone)]
pub struct CodeHandler {
    k8s_client: Client,
    namespace: String,
}

impl CodeHandler {
    /// Load project configuration from ConfigMap
    pub async fn load_project_config(
        &self,
        project_id: &str,
    ) -> Result<Option<ProjectConfig>> {
        let config_name = format!("{}-project-config", project_id);
        
        info!("Loading project configuration from ConfigMap: {}", config_name);
        
        let configmaps: Api<ConfigMap> = Api::namespaced(
            self.k8s_client.clone(),
            &self.namespace
        );
        
        match configmaps.get(&config_name).await {
            Ok(cm) => {
                // Extract configuration JSON
                let config_json = cm.data
                    .as_ref()
                    .and_then(|d| d.get("config.json"))
                    .ok_or_else(|| anyhow!("Missing config.json in ConfigMap"))?;
                
                // Parse configuration
                match serde_json::from_str::<ProjectConfig>(config_json) {
                    Ok(config) => {
                        info!(
                            "Loaded project configuration generated at {} with {} tools",
                            config.generated_at.format("%Y-%m-%d %H:%M:%S"),
                            config.metadata.total_tools_recommended
                        );
                        
                        // Log confidence score if available
                        info!(
                            "Configuration confidence score: {:.0}%",
                            config.metadata.confidence_score * 100.0
                        );
                        
                        Ok(Some(config))
                    }
                    Err(e) => {
                        error!("Failed to parse project configuration: {}", e);
                        // Return None to fall back to defaults
                        Ok(None)
                    }
                }
            }
            Err(kube::Error::Api(err)) if err.code == 404 => {
                info!("No saved configuration found for project: {}", project_id);
                Ok(None)
            }
            Err(e) => {
                warn!("Failed to load project configuration: {}", e);
                // Don't fail the entire operation
                Ok(None)
            }
        }
    }
    
    /// Extract just the tool configuration from ProjectConfig
    fn extract_tool_config(config: &ProjectConfig) -> ProjectToolConfig {
        config.tools.clone()
    }
}
```

### 2. Agent Initialization with Configuration Loading
```rust
#[derive(Debug, Clone)]
pub struct AgentConfig {
    pub tools: ProjectToolConfig,
    pub project_id: String,
    pub run_id: String,
    pub config_source: ConfigSource,
}

#[derive(Debug, Clone, Serialize)]
pub enum ConfigSource {
    UserOverride,
    SavedConfiguration { 
        generated_at: String,
        confidence: f32,
    },
    DefaultFallback,
}

impl CodeHandler {
    /// Initialize agent with appropriate tool configuration
    pub async fn initialize_agent(
        &self,
        ctx: &CodeContext,
    ) -> Result<AgentConfig> {
        let mut agent_config = AgentConfig {
            tools: ProjectToolConfig::default(),
            project_id: ctx.project_id.clone(),
            run_id: ctx.run_id.clone(),
            config_source: ConfigSource::DefaultFallback,
        };
        
        // Priority 1: Check for user-specified tools (override)
        if let Some(tools) = &ctx.run_spec.tools {
            info!("Using user-specified tool configuration");
            
            // Validate user tools against toolman ConfigMap
            self.validate_user_specified_tools(tools).await?;
            
            agent_config.tools = tools.clone();
            agent_config.config_source = ConfigSource::UserOverride;
            
            self.log_tool_selection(&agent_config.tools, "user-specified");
        } 
        // Priority 2: Load configuration from docs phase
        else if let Some(project_config) = self.load_project_config(&ctx.project_id).await? {
            info!("Using saved configuration from docs phase");
            
            agent_config.tools = project_config.tools.clone();
            agent_config.config_source = ConfigSource::SavedConfiguration {
                generated_at: project_config.generated_at.to_rfc3339(),
                confidence: project_config.metadata.confidence_score,
            };
            
            self.log_tool_selection(&agent_config.tools, "docs-generated");
            
            // Apply any tool-specific configurations
            self.apply_tool_configs(&mut agent_config.tools, &project_config.tools.tool_configs);
        } 
        // Priority 3: Fallback to minimal defaults
        else {
            warn!(
                "No configuration found for project {}, using minimal defaults",
                ctx.project_id
            );
            
            agent_config.tools = self.get_minimal_defaults();
            agent_config.config_source = ConfigSource::DefaultFallback;
            
            self.log_tool_selection(&agent_config.tools, "minimal-defaults");
        }
        
        // Log final configuration source
        info!("Agent configuration source: {:?}", agent_config.config_source);
        
        Ok(agent_config)
    }
    
    /// Get minimal default tools
    fn get_minimal_defaults(&self) -> ProjectToolConfig {
        ProjectToolConfig {
            local: vec!["filesystem".to_string()],
            remote: vec![],
            tool_configs: HashMap::new(),
        }
    }
    
    /// Apply tool-specific configurations
    fn apply_tool_configs(
        &self,
        tools: &mut ProjectToolConfig,
        configs: &HashMap<String, serde_json::Value>,
    ) {
        // Copy over any tool-specific configurations
        tools.tool_configs = configs.clone();
        
        // Log any special configurations
        for (tool, config) in configs {
            if let Some(readonly) = config.get("readonly").and_then(|v| v.as_bool()) {
                if readonly {
                    info!("Tool '{}' configured as read-only", tool);
                }
            }
        }
    }
    
    /// Log selected tools for visibility
    fn log_tool_selection(&self, tools: &ProjectToolConfig, source: &str) {
        info!(
            "Tool selection from {}: {} local tools, {} remote tools",
            source,
            tools.local.len(),
            tools.remote.len()
        );
        
        if !tools.local.is_empty() {
            info!("Local tools: {}", tools.local.join(", "));
        }
        
        if !tools.remote.is_empty() {
            info!("Remote tools: {}", tools.remote.join(", "));
        }
    }
}
```

### 3. Integration with Code Agent Workflow
```rust
impl CodeHandler {
    /// Main entry point for code agent execution
    pub async fn execute_code_task(
        &self,
        ctx: CodeContext,
    ) -> Result<()> {
        info!(
            "Starting code task execution for project: {} (run: {})",
            ctx.project_id,
            ctx.run_id
        );
        
        // Initialize agent with appropriate configuration
        let agent_config = self.initialize_agent(&ctx).await?;
        
        // Log configuration summary
        self.log_configuration_summary(&agent_config);
        
        // Pass configuration to template context
        let mut template_context = self.build_template_context(&ctx)?;
        template_context.insert("tools", &agent_config.tools);
        template_context.insert("config_source", &agent_config.config_source);
        
        // Render agent configurations
        let rendered_configs = self.render_agent_configs(&template_context).await?;
        
        // Continue with normal code execution
        self.execute_with_config(&ctx, &agent_config, &rendered_configs).await?;
        
        info!("Code task execution completed successfully");
        Ok(())
    }
    
    /// Log configuration summary for debugging
    fn log_configuration_summary(&self, config: &AgentConfig) {
        let summary = match &config.config_source {
            ConfigSource::UserOverride => {
                "Using user-specified tool configuration (override)".to_string()
            }
            ConfigSource::SavedConfiguration { generated_at, confidence } => {
                format!(
                    "Using saved configuration from {} (confidence: {:.0}%)",
                    generated_at,
                    confidence * 100.0
                )
            }
            ConfigSource::DefaultFallback => {
                "Using minimal default configuration (fallback)".to_string()
            }
        };
        
        info!("Configuration summary: {}", summary);
    }
}
```

### 4. Error Handling and Recovery
```rust
impl CodeHandler {
    /// Robust configuration loading with fallback
    pub async fn load_configuration_with_fallback(
        &self,
        project_id: &str,
    ) -> ProjectToolConfig {
        match self.load_project_config(project_id).await {
            Ok(Some(config)) => {
                // Validate loaded configuration
                if self.validate_loaded_config(&config).is_ok() {
                    config.tools
                } else {
                    warn!("Loaded configuration failed validation, using defaults");
                    self.get_minimal_defaults()
                }
            }
            Ok(None) => {
                info!("No saved configuration, using defaults");
                self.get_minimal_defaults()
            }
            Err(e) => {
                error!("Error loading configuration: {}, using defaults", e);
                self.get_minimal_defaults()
            }
        }
    }
    
    /// Validate loaded configuration
    fn validate_loaded_config(&self, config: &ProjectConfig) -> Result<()> {
        // Check version compatibility
        if config.version != "1.0.0" {
            return Err(anyhow!(
                "Unsupported configuration version: {}",
                config.version
            ));
        }
        
        // Ensure tools are not empty (at least one tool)
        if config.tools.local.is_empty() && config.tools.remote.is_empty() {
            return Err(anyhow!("Configuration has no tools"));
        }
        
        // Check for duplicate tools
        let mut seen = HashSet::new();
        for tool in &config.tools.local {
            if !seen.insert(tool) {
                return Err(anyhow!("Duplicate local tool: {}", tool));
            }
        }
        
        for tool in &config.tools.remote {
            if !seen.insert(tool) {
                return Err(anyhow!("Duplicate remote tool: {}", tool));
            }
        }
        
        Ok(())
    }
}
```

### 5. Backward Compatibility
```rust
impl CodeHandler {
    /// Handle legacy code runs without tool specifications
    pub async fn handle_legacy_mode(
        &self,
        ctx: &CodeContext,
    ) -> Result<ProjectToolConfig> {
        // Check if this is a legacy run (no tools field in CRD)
        if ctx.run_spec.api_version == "v1alpha1" {
            warn!("Legacy CodeRun detected, using compatibility mode");
            
            // Try to load saved config, otherwise use enhanced defaults
            if let Some(config) = self.load_project_config(&ctx.project_id).await? {
                info!("Found saved configuration for legacy run");
                Ok(config.tools)
            } else {
                // Enhanced defaults for legacy mode
                Ok(ProjectToolConfig {
                    local: vec!["filesystem".to_string(), "git".to_string()],
                    remote: vec![],
                    tool_configs: HashMap::new(),
                })
            }
        } else {
            // Normal flow
            let agent_config = self.initialize_agent(ctx).await?;
            Ok(agent_config.tools)
        }
    }
}
```

## Testing Strategy

### 1. Configuration Loading Tests
```rust
#[tokio::test]
async fn test_load_saved_configuration() {
    let handler = create_test_handler();
    
    // Create and save test configuration
    let config = create_test_project_config();
    save_test_configmap(&config).await;
    
    // Load configuration
    let loaded = handler.load_project_config("test-project").await.unwrap();
    
    assert!(loaded.is_some());
    let loaded_config = loaded.unwrap();
    assert_eq!(loaded_config.tools.local, vec!["filesystem", "git"]);
    assert_eq!(loaded_config.tools.remote, vec!["github", "kubernetes"]);
}
```

### 2. Precedence Tests
```rust
#[tokio::test]
async fn test_configuration_precedence() {
    let handler = create_test_handler();
    
    // Save configuration
    let saved_config = create_test_project_config();
    save_test_configmap(&saved_config).await;
    
    // Test 1: User override takes precedence
    let ctx_with_override = CodeContext {
        run_spec: CodeRunSpec {
            tools: Some(ProjectToolConfig {
                local: vec!["filesystem".to_string()],
                remote: vec!["custom-tool".to_string()],
                ..Default::default()
            }),
            ..Default::default()
        },
        ..create_test_context()
    };
    
    let config = handler.initialize_agent(&ctx_with_override).await.unwrap();
    assert_eq!(config.tools.remote, vec!["custom-tool"]);
    assert!(matches!(config.config_source, ConfigSource::UserOverride));
    
    // Test 2: Saved config used when no override
    let ctx_no_override = CodeContext {
        run_spec: CodeRunSpec {
            tools: None,
            ..Default::default()
        },
        ..create_test_context()
    };
    
    let config = handler.initialize_agent(&ctx_no_override).await.unwrap();
    assert_eq!(config.tools, saved_config.tools);
    assert!(matches!(config.config_source, ConfigSource::SavedConfiguration { .. }));
}
```

### 3. Fallback Tests
```rust
#[tokio::test]
async fn test_fallback_to_defaults() {
    let handler = create_test_handler();
    
    // No saved config, no user override
    let ctx = CodeContext {
        project_id: "no-config-project".to_string(),
        run_spec: CodeRunSpec {
            tools: None,
            ..Default::default()
        },
        ..create_test_context()
    };
    
    let config = handler.initialize_agent(&ctx).await.unwrap();
    
    // Should use minimal defaults
    assert_eq!(config.tools.local, vec!["filesystem"]);
    assert!(config.tools.remote.is_empty());
    assert!(matches!(config.config_source, ConfigSource::DefaultFallback));
}
```

### 4. Error Handling Tests
```rust
#[tokio::test]
async fn test_corrupted_config_handling() {
    let handler = create_test_handler();
    
    // Save corrupted configuration
    save_corrupted_configmap("test-project").await;
    
    let ctx = create_test_context();
    let config = handler.initialize_agent(&ctx).await.unwrap();
    
    // Should fall back to defaults
    assert!(matches!(config.config_source, ConfigSource::DefaultFallback));
    assert_eq!(config.tools.local, vec!["filesystem"]);
}
```

## Success Criteria
1. ✅ Loads saved configurations successfully
2. ✅ Respects configuration precedence rules
3. ✅ Falls back gracefully when config missing
4. ✅ Handles errors without failing tasks
5. ✅ Maintains backward compatibility
6. ✅ Logs configuration source clearly

## Performance Considerations

1. **Caching**: Consider caching loaded configs for multiple agents
2. **Async Loading**: All ConfigMap operations are async
3. **Minimal Overhead**: Configuration loading < 500ms
4. **No Blocking**: Failures don't block execution

## Related Tasks
- Task 6: Creates the configurations we're loading
- Task 11: Validates tools when user overrides
- Task 12: Uses loaded configuration in templates
- Task 4: Defines tools field in CodeRun CRD