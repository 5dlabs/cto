# Acceptance Criteria: Task 7 - Update Code Agent to Load Saved Configuration

## Overview
This document defines the acceptance criteria for updating the code agent to load tool configurations generated by the docs agent, implementing proper precedence rules and error handling.

## Core Requirements

### 1. Configuration Loading
- [ ] **ConfigMap Reading**: Successfully loads from K8s ConfigMap
- [ ] **JSON Parsing**: Correctly parses saved configurations
- [ ] **Error Handling**: Gracefully handles missing/invalid configs
- [ ] **Performance**: Loads configuration in < 500ms
- [ ] **Logging**: Clear logging of loading process

### 2. Precedence Rules
- [ ] **User Override**: Takes highest priority when specified
- [ ] **Saved Config**: Used when no override provided
- [ ] **Default Fallback**: Minimal tools when nothing available
- [ ] **Clear Logic**: Precedence rules clearly implemented
- [ ] **Source Tracking**: Records which source was used

### 3. Integration
- [ ] **Agent Flow**: Seamlessly integrated into agent init
- [ ] **Template Context**: Config passed to templates
- [ ] **Tool Configs**: Tool-specific settings applied
- [ ] **Backward Compatible**: Works with legacy runs
- [ ] **No Disruption**: Failures don't block execution

## Technical Specifications

### 1. Configuration Precedence
```
Priority Order:
1. User Override (from CodeRun.spec.tools)
2. Saved Configuration (from ConfigMap)
3. Default Fallback (minimal filesystem)
```

### 2. Expected Data Flow
```rust
// Step 1: Check user override
if let Some(tools) = ctx.run_spec.tools {
    return (tools, ConfigSource::UserOverride);
}

// Step 2: Try loading saved config
if let Some(config) = load_project_config(project_id).await? {
    return (config.tools, ConfigSource::SavedConfiguration);
}

// Step 3: Use defaults
return (minimal_defaults(), ConfigSource::DefaultFallback);
```

### 3. Configuration Structure
```rust
struct AgentConfig {
    tools: ProjectToolConfig,
    project_id: String,
    run_id: String,
    config_source: ConfigSource,
    metadata: AgentMetadata,
}

enum ConfigSource {
    UserOverride { specified_at: DateTime<Utc> },
    SavedConfiguration { 
        generated_at: DateTime<Utc>,
        confidence: f32,
    },
    DefaultFallback { reason: String },
}
```

## Test Cases

### Test Case 1: Load Saved Configuration
```rust
#[tokio::test]
async fn test_load_saved_config() {
    // Setup: Create and save config
    let saved_config = create_test_project_config();
    save_configmap(&saved_config).await;
    
    let handler = CodeHandler::new(test_client());
    let loaded = handler.load_project_config("test-project").await.unwrap();
    
    assert!(loaded.is_some());
    let config = loaded.unwrap();
    assert_eq!(config.tools.local, vec!["filesystem", "git"]);
    assert_eq!(config.tools.remote, vec!["github", "kubernetes"]);
    assert_eq!(config.metadata.confidence_score, 0.85);
}
```

### Test Case 2: User Override Precedence
```rust
#[tokio::test]
async fn test_user_override_precedence() {
    // Setup: Save a config
    let saved_config = create_test_config_with_tools(vec!["github"]);
    save_configmap(&saved_config).await;
    
    // Create context with user override
    let ctx = CodeContext {
        run_spec: CodeRunSpec {
            tools: Some(ProjectToolConfig {
                local: vec!["filesystem".to_string()],
                remote: vec!["custom-tool".to_string()],
                ..Default::default()
            }),
            ..Default::default()
        },
        project_id: "test-project".to_string(),
        ..Default::default()
    };
    
    let handler = CodeHandler::new(test_client());
    let agent_config = handler.initialize_agent(&ctx).await.unwrap();
    
    // Should use user override, not saved config
    assert_eq!(agent_config.tools.remote, vec!["custom-tool"]);
    assert!(matches!(agent_config.config_source, ConfigSource::UserOverride { .. }));
}
```

### Test Case 3: Fallback to Defaults
```rust
#[tokio::test]
async fn test_fallback_defaults() {
    let ctx = CodeContext {
        project_id: "nonexistent-project".to_string(),
        run_spec: CodeRunSpec {
            tools: None,
            ..Default::default()
        },
        ..Default::default()
    };
    
    let handler = CodeHandler::new(test_client());
    let agent_config = handler.initialize_agent(&ctx).await.unwrap();
    
    // Should use minimal defaults
    assert_eq!(agent_config.tools.local, vec!["filesystem"]);
    assert!(agent_config.tools.remote.is_empty());
    assert!(matches!(
        agent_config.config_source,
        ConfigSource::DefaultFallback { .. }
    ));
}
```

### Test Case 4: Handle Corrupted Configuration
```rust
#[tokio::test]
async fn test_corrupted_config_handling() {
    // Save invalid JSON
    save_corrupted_configmap("test-project").await;
    
    let handler = CodeHandler::new(test_client());
    let loaded = handler.load_project_config("test-project").await.unwrap();
    
    // Should return None, not error
    assert!(loaded.is_none());
    
    // Should fall back to defaults in full flow
    let ctx = create_context("test-project");
    let agent_config = handler.initialize_agent(&ctx).await.unwrap();
    assert!(matches!(
        agent_config.config_source,
        ConfigSource::DefaultFallback { .. }
    ));
}
```

### Test Case 5: Configuration Validation
```rust
#[tokio::test]
async fn test_config_validation() {
    let handler = CodeHandler::new(test_client());
    
    // Test invalid version
    let mut config = create_test_config();
    config.version = "2.0.0".to_string();
    assert!(handler.validate_config(&config).is_err());
    
    // Test no tools
    config.version = "1.0.0".to_string();
    config.tools.local.clear();
    config.tools.remote.clear();
    assert!(handler.validate_config(&config).is_err());
    
    // Test duplicate tools
    config.tools.local = vec!["filesystem".to_string(), "filesystem".to_string()];
    assert!(handler.validate_config(&config).is_err());
    
    // Test future timestamp
    config.tools.local = vec!["filesystem".to_string()];
    config.generated_at = Utc::now() + Duration::days(1);
    assert!(handler.validate_config(&config).is_err());
}
```

### Test Case 6: Performance Test
```rust
#[tokio::test]
async fn test_config_load_performance() {
    // Setup large config
    let config = create_large_config();
    save_configmap(&config).await;
    
    let handler = CodeHandler::new(test_client());
    let start = Instant::now();
    
    let loaded = handler.load_project_config("test-project").await.unwrap();
    let duration = start.elapsed();
    
    assert!(loaded.is_some());
    assert!(duration.as_millis() < 500, "Load took {}ms", duration.as_millis());
}
```

### Test Case 7: Tool-Specific Configuration
```rust
#[tokio::test]
async fn test_tool_specific_configs() {
    let mut config = create_test_config();
    config.tools.tool_configs.insert(
        "filesystem".to_string(),
        json!({
            "readonly": true,
            "allowed_paths": ["/workspace"]
        })
    );
    save_configmap(&config).await;
    
    let handler = CodeHandler::new(test_client());
    let ctx = create_context("test-project");
    let agent_config = handler.initialize_agent(&ctx).await.unwrap();
    
    // Tool configs should be preserved
    assert!(agent_config.tools.tool_configs.contains_key("filesystem"));
    let fs_config = &agent_config.tools.tool_configs["filesystem"];
    assert_eq!(fs_config["readonly"], json!(true));
}
```

### Test Case 8: Integration Flow
```rust
#[tokio::test]
async fn test_complete_integration() {
    // Save config from "docs phase"
    let docs_config = create_docs_generated_config();
    save_configmap(&docs_config).await;
    
    // Execute code task
    let handler = CodeHandler::new(test_client());
    let ctx = CodeContext {
        project_id: "test-project".to_string(),
        run_id: "code-run-123".to_string(),
        task_id: Some("implement-feature".to_string()),
        ..Default::default()
    };
    
    // Should complete successfully with loaded config
    handler.execute_code_task(ctx).await.unwrap();
    
    // Verify correct config was used
    let logs = get_test_logs();
    assert!(logs.contains("Using saved configuration from docs phase"));
    assert!(logs.contains("confidence: 85%"));
}
```

## Validation Checklist

### Loading Validation
- [ ] **ConfigMap Found**: Correctly loads when present
- [ ] **Not Found Handling**: Returns None for 404
- [ ] **Parse Errors**: Handles invalid JSON gracefully
- [ ] **Network Errors**: Retries transient failures
- [ ] **Timeout Handling**: Doesn't hang on slow loads

### Precedence Validation
- [ ] **Override First**: User tools always win
- [ ] **Saved Second**: Uses docs config when available
- [ ] **Default Last**: Falls back appropriately
- [ ] **Source Recorded**: Tracks decision made
- [ ] **Logging Clear**: Decision process visible

### Integration Validation
- [ ] **Template Context**: Tools passed correctly
- [ ] **No Blocking**: Errors don't stop execution
- [ ] **Metrics Recorded**: Config source tracked
- [ ] **Warnings Captured**: Issues logged appropriately
- [ ] **Performance Good**: Minimal overhead added

## Performance Criteria

### 1. Load Performance
- [ ] **ConfigMap Load**: < 200ms average
- [ ] **JSON Parse**: < 50ms for typical configs
- [ ] **Total Init**: < 500ms including validation
- [ ] **Memory Usage**: < 10MB overhead

### 2. Error Recovery
- [ ] **Retry Logic**: Exponential backoff implemented
- [ ] **Max Attempts**: 3 retries for transient errors
- [ ] **Fail Fast**: 404s don't retry
- [ ] **Timeout**: 5 second max per attempt

## Security Requirements

### 1. Access Control
- [ ] **RBAC**: Respects ConfigMap read permissions
- [ ] **Namespace**: Only reads from correct namespace
- [ ] **No Escalation**: Can't access other projects

### 2. Validation
- [ ] **Input Sanitization**: Tool names validated
- [ ] **JSON Safety**: Handles malformed data
- [ ] **Size Limits**: Rejects oversized configs

## Documentation Requirements

### 1. Code Documentation
- [ ] **Public Methods**: All documented with examples
- [ ] **Error Cases**: Failure modes documented
- [ ] **Precedence**: Rules clearly explained

### 2. Integration Guide
- [ ] **Setup**: How to enable config loading
- [ ] **Troubleshooting**: Common issues covered
- [ ] **Monitoring**: How to track config sources

## Definition of Done

✅ **Loading Implementation**
- Loads from ConfigMap successfully
- Handles all error cases
- Validates configurations
- Performance acceptable

✅ **Precedence Implementation**
- All three levels work correctly
- Source tracking implemented
- Clear logging throughout
- No surprising behavior

✅ **Integration Complete**
- Works in agent flow
- Templates receive config
- Backward compatible
- Well tested

✅ **Testing Verified**
- All test cases pass
- Edge cases covered
- Performance validated
- Integration tested

✅ **Documentation Delivered**
- Code documented
- Integration guide ready
- Troubleshooting included
- Examples provided

## Sign-off Requirements

- [ ] **Code Review**: Implementation reviewed and approved
- [ ] **Security Review**: No security concerns
- [ ] **Performance Test**: Meets performance criteria
- [ ] **Integration Test**: Works in full agent flow
- [ ] **Documentation Review**: Guides complete and clear

## Notes
- This completes the configuration flow from docs to code agents
- Ensures intelligent tool selection is actually used
- Critical for the zero-discovery principle in code agents
- Must maintain reliability - failures should not break agents