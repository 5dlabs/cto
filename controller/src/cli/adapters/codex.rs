//! Codex Adapter Implementation (Stub)
//!
//! Stub implementation for OpenAI's Codex CLI.
//! This will be fully implemented in Task 4.

use crate::cli::base_adapter::{BaseAdapter, AdapterConfig};
use crate::cli::trait_adapter::*;
use crate::cli::types::CLIType;
use async_trait::async_trait;
use std::time::Duration;
use tracing::{debug, warn};

/// Codex CLI adapter (stub implementation)
#[derive(Debug)]
pub struct CodexAdapter {
    /// Base adapter functionality
    base: BaseAdapter,
}

impl CodexAdapter {
    /// Create a new Codex adapter
    pub async fn new() -> Result<Self, AdapterError> {
        let base = BaseAdapter::new(CLIType::Codex);

        warn!("CodexAdapter is a stub implementation - will be completed in Task 4");

        Ok(Self { base })
    }

    /// Create Codex adapter with custom configuration
    pub async fn with_config(config: AdapterConfig) -> Result<Self, AdapterError> {
        let base = BaseAdapter::with_config(CLIType::Codex, config);

        Ok(Self { base })
    }
}

#[async_trait]
impl CliAdapter for CodexAdapter {
    async fn validate_model(&self, model: &str) -> Result<bool, AdapterError> {
        debug!("CodexAdapter::validate_model called with model: {}", model);

        // Stub: Accept common OpenAI models
        let is_valid = model.starts_with("gpt-")
            || model.starts_with("o")  // o1, o3, etc.
            || model == "codex";

        Ok(is_valid)
    }

    async fn generate_config(&self, _agent_config: &AgentConfig) -> Result<String, AdapterError> {
        debug!("CodexAdapter::generate_config called (stub implementation)");

        // Stub: Return basic TOML config
        Ok(r#"# Codex Configuration (Generated by stub)
model = "gpt-4"
model_provider = "openai"
sandbox_mode = "workspace-write"
approval_policy = "on-failure"

[mcp_servers]
# MCP servers will be configured here
"#.to_string())
    }

    fn format_prompt(&self, prompt: &str) -> String {
        // Stub: Basic prompt formatting
        prompt.to_string()
    }

    async fn parse_response(&self, response: &str) -> Result<ParsedResponse, AdapterError> {
        debug!("CodexAdapter::parse_response called (stub implementation)");

        // Stub: Basic response parsing
        Ok(ParsedResponse {
            content: response.to_string(),
            tool_calls: vec![],
            metadata: ResponseMetadata {
                id: Some(uuid::Uuid::new_v4().to_string()),
                usage: None,
                model: Some("gpt-4".to_string()),
                timing: None,
            },
            finish_reason: FinishReason::Stop,
            streaming_delta: None,
        })
    }

    fn get_memory_filename(&self) -> &str {
        "AGENTS.md"
    }

    fn get_executable_name(&self) -> &str {
        "codex"
    }

    fn get_capabilities(&self) -> CliCapabilities {
        CliCapabilities {
            supports_streaming: false,  // STDIO-based
            supports_multimodal: false,
            supports_function_calling: true,
            supports_system_prompts: true,
            max_context_tokens: 128_000,
            memory_strategy: MemoryStrategy::MarkdownFile("AGENTS.md".to_string()),
            config_format: ConfigFormat::Toml,
            authentication_methods: vec![AuthMethod::ApiKey],
        }
    }

    async fn initialize(&self, _container: &dyn Container) -> Result<(), AdapterError> {
        debug!("CodexAdapter::initialize called (stub implementation)");
        Ok(())
    }

    async fn cleanup(&self, _container: &dyn Container) -> Result<(), AdapterError> {
        debug!("CodexAdapter::cleanup called (stub implementation)");
        Ok(())
    }

    async fn health_check(&self) -> Result<HealthStatus, AdapterError> {
        debug!("CodexAdapter::health_check called (stub implementation)");

        // Stub: Always return degraded status to indicate incomplete implementation
        Ok(HealthStatus::Degraded("Stub implementation - full implementation pending".to_string()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_codex_adapter_creation() {
        let adapter = CodexAdapter::new().await.unwrap();
        assert_eq!(adapter.get_executable_name(), "codex");
        assert_eq!(adapter.get_memory_filename(), "AGENTS.md");
    }

    #[tokio::test]
    async fn test_model_validation() {
        let adapter = CodexAdapter::new().await.unwrap();

        assert!(adapter.validate_model("gpt-4").await.unwrap());
        assert!(adapter.validate_model("gpt-4o").await.unwrap());
        assert!(adapter.validate_model("o3").await.unwrap());
        assert!(adapter.validate_model("codex").await.unwrap());

        assert!(!adapter.validate_model("claude-3-opus").await.unwrap());
        assert!(!adapter.validate_model("invalid").await.unwrap());
    }

    #[tokio::test]
    async fn test_capabilities() {
        let adapter = CodexAdapter::new().await.unwrap();
        let caps = adapter.get_capabilities();

        assert!(!caps.supports_streaming);  // STDIO-based
        assert!(!caps.supports_multimodal);
        assert!(caps.supports_function_calling);
        assert_eq!(caps.max_context_tokens, 128_000);
        assert!(matches!(caps.config_format, ConfigFormat::Toml));
    }

    #[tokio::test]
    async fn test_health_check() {
        let adapter = CodexAdapter::new().await.unwrap();
        let health = adapter.health_check().await.unwrap();

        // Should be degraded since it's a stub
        assert!(matches!(health, HealthStatus::Degraded(_)));
    }
}