#!/usr/bin/env bash
# =============================================================================
# pre-push hook with Claude Code auto-remediation
# =============================================================================
# This hook runs all CI checks before pushing. If checks fail, it invokes
# Claude Code to automatically fix the issues and amend the commit.
#
# Features:
# - Detects what changed and runs appropriate checks
# - Auto-fixes issues using Claude Code (up to MAX_ATTEMPTS)
# - Amends the commit with fixes automatically
# - Bypass with: git push --no-verify
#
# Installation:
#   ./scripts/install-hooks.sh
# =============================================================================

set -euo pipefail

# Configuration
MAX_ATTEMPTS="${CLAUDE_MAX_ATTEMPTS:-3}"
SKIP_TESTS="${CLAUDE_SKIP_TESTS:-false}"
AUTO_FIX="${CLAUDE_AUTO_FIX:-true}"
QUIET="${CLAUDE_QUIET:-false}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Get repo root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ "$SCRIPT_DIR" == *".git/hooks"* ]]; then
    REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
else
    REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
fi

LOCAL_CI="$REPO_ROOT/scripts/local-ci.sh"
OUTPUT_FILE=$(mktemp)
trap 'rm -f "$OUTPUT_FILE"' EXIT

log() { echo -e "$1"; }
log_info() { log "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
log_success() { log "${GREEN}‚úÖ $1${NC}"; }
log_warning() { log "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
log_error() { log "${RED}‚ùå $1${NC}"; }
log_header() { 
    echo ""
    echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë${NC}  $1"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
}

# Find Claude Code command
# Prioritize full path since aliases don't work in subshells/hooks
find_claude_cmd() {
    # Check the standard install location first (most reliable)
    if [ -x "$HOME/.claude/local/claude" ]; then
        echo "$HOME/.claude/local/claude"
    # Fallback to PATH (might work if it's a real binary)
    elif command -v claude &>/dev/null; then
        command -v claude
    else
        echo ""
    fi
}

# Check if Claude Code is available
check_claude() {
    local cmd
    cmd=$(find_claude_cmd)
    if [ -z "$cmd" ]; then
        log_warning "Claude Code not found in PATH or ~/.claude/local/"
        log_info "Install from: https://claude.ai/download"
        return 1
    fi
    return 0
}

# Run local CI checks
run_checks() {
    local args=()
    
    if [ "$SKIP_TESTS" = "true" ]; then
        args+=("--skip-tests")
    fi
    
    if [ "$QUIET" = "true" ]; then
        "$LOCAL_CI" "${args[@]}" > "$OUTPUT_FILE" 2>&1
    else
        "$LOCAL_CI" "${args[@]}" 2>&1 | tee "$OUTPUT_FILE"
    fi
    
    return "${PIPESTATUS[0]}"
}

# Extract just the critical errors from CI output
extract_errors() {
    local output="$1"
    
    # Extract only the error lines, not warnings or info
    echo "$output" | grep -E '(^error|^‚ùå|Error:|failed|FAILED|: error)' | head -50
}

# Invoke Claude to fix issues
invoke_claude_fix() {
    local output="$1"
    
    log_header "ü§ñ Invoking Claude Code to fix issues..."
    
    # Find Claude command
    local claude_cmd
    claude_cmd=$(find_claude_cmd)
    
    if [ -z "$claude_cmd" ]; then
        log_error "Claude Code not found"
        return 1
    fi
    
    # Extract just the important errors (not the full verbose output)
    local errors
    errors=$(extract_errors "$output")
    
    if [ -z "$errors" ]; then
        errors="$output"
    fi
    
    # Build a focused prompt
    local prompt="Fix these CI failures. Edit the files directly:

$errors

Instructions:
- Run 'cargo fmt' to fix formatting
- Fix clippy errors (check the actual error messages)
- Fix YAML lint errors (check line numbers mentioned)
- Make minimal changes"

    log_info "Running Claude with auto-edit permissions..."
    log_info "Errors to fix:"
    echo "$errors" | head -20
    echo ""
    
    # Run Claude with permissions to edit files automatically
    # --dangerously-skip-permissions allows Claude to edit without prompts
    # --print outputs the result but still allows tool use
    # Prompt is passed via stdin (required for --print mode)
    # Timeout after 5 minutes
    if echo "$prompt" | timeout 300 "$claude_cmd" \
        --print \
        --dangerously-skip-permissions \
        --allowedTools "Edit,Write,Bash,Read" \
        2>&1; then
        log_success "Claude completed fixes"
        return 0
    else
        local exit_code=$?
        if [ $exit_code -eq 124 ]; then
            log_error "Claude timed out after 5 minutes"
        else
            log_error "Claude encountered an error (exit code: $exit_code)"
        fi
        return 1
    fi
}

# Stage and amend commit with fixes
amend_commit() {
    if [ -z "$(git status --porcelain)" ]; then
        log_info "No files changed by Claude"
        return 0
    fi
    
    log_info "Staging fixed files..."
    git add -A
    
    log_info "Amending commit with fixes..."
    git commit --amend --no-edit
    
    log_success "Commit amended with fixes"
    return 0
}

# Main pre-push logic
main() {
    local remote="${1:-origin}"
    local url="${2:-}"
    
    log_header "üîç Pre-push CI checks"
    
    # Check if local-ci.sh exists
    if [ ! -f "$LOCAL_CI" ]; then
        log_error "local-ci.sh not found at $LOCAL_CI"
        log_info "Run: ./scripts/install-hooks.sh"
        exit 1
    fi
    
    log_info "Pushing to: $remote ${url:+($url)}"
    log_info "Max attempts: $MAX_ATTEMPTS | Skip tests: $SKIP_TESTS | Auto-fix: $AUTO_FIX"
    
    local attempt=0
    local checks_passed=false
    
    while [ $attempt -lt "$MAX_ATTEMPTS" ]; do
        attempt=$((attempt + 1))
        
        if [ $attempt -gt 1 ]; then
            log_header "üîÑ Retry attempt $attempt/$MAX_ATTEMPTS"
        fi
        
        # Run checks
        if run_checks; then
            checks_passed=true
            break
        fi
        
        # If auto-fix is disabled or Claude not available, fail immediately
        if [ "$AUTO_FIX" != "true" ]; then
            log_error "Checks failed. Auto-fix is disabled."
            log_info "Fix manually or run: ./scripts/local-ci.sh"
            exit 1
        fi
        
        if ! check_claude; then
            log_error "Checks failed and Claude is not available for auto-fix"
            log_info "Fix manually or run: ./scripts/local-ci.sh"
            exit 1
        fi
        
        # If this is the last attempt, don't try to fix
        if [ $attempt -ge "$MAX_ATTEMPTS" ]; then
            log_error "Max attempts ($MAX_ATTEMPTS) reached"
            break
        fi
        
        # Try to fix with Claude
        local output
        output=$(cat "$OUTPUT_FILE")
        
        if invoke_claude_fix "$output"; then
            if amend_commit; then
                log_info "Fixes applied, re-running checks..."
            fi
        else
            log_warning "Claude could not fix the issues"
            break
        fi
    done
    
    if [ "$checks_passed" = "true" ]; then
        log_success "All checks passed! Proceeding with push..."
        exit 0
    else
        log_error "Checks failed after $attempt attempt(s)"
        echo ""
        echo "Options:"
        echo "  1. Fix manually and commit --amend"
        echo "  2. Run checks: ./scripts/local-ci.sh"
        echo "  3. Bypass hook: git push --no-verify"
        echo ""
        exit 1
    fi
}

# Read push info from stdin (required for pre-push hooks)
while read -r local_ref local_sha remote_ref remote_sha; do
    # Skip if deleting a branch
    if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
        exit 0
    fi
done

main "${1:-origin}" "${2:-}"




