{{> header }}

{{> config }}

{{> github-auth }}

{{> git-setup }}

{{> task-files }}

{{> tools-config }}

# =========================================================================
# Infrastructure Provisioning Pre-checks
# =========================================================================

echo ""
echo "ðŸ”§ Infrastructure Provisioning Mode"
echo "===================================="

# Verify kubectl access
if ! kubectl auth can-i get pods -n databases &>/dev/null; then
    echo "âš ï¸ Limited kubectl access - some verification steps may fail"
fi

# Check operator availability
echo "ðŸ“¦ Checking available operators..."
OPERATORS_AVAILABLE=""

if kubectl get crd clusters.postgresql.cnpg.io &>/dev/null; then
    echo "  âœ“ CloudNative-PG (PostgreSQL)"
    OPERATORS_AVAILABLE="${OPERATORS_AVAILABLE}postgresql,"
fi

if kubectl get crd redis.redis.opstreelabs.in &>/dev/null; then
    echo "  âœ“ Redis Operator (Valkey/Redis)"
    OPERATORS_AVAILABLE="${OPERATORS_AVAILABLE}redis,"
fi

if kubectl get crd kafkas.kafka.strimzi.io &>/dev/null; then
    echo "  âœ“ Strimzi (Kafka)"
    OPERATORS_AVAILABLE="${OPERATORS_AVAILABLE}kafka,"
fi

if kubectl get crd perconaservermongodbs.psmdb.percona.com &>/dev/null; then
    echo "  âœ“ Percona (MongoDB)"
    OPERATORS_AVAILABLE="${OPERATORS_AVAILABLE}mongodb,"
fi

if kubectl get crd rabbitmqclusters.rabbitmq.com &>/dev/null; then
    echo "  âœ“ RabbitMQ Operator"
    OPERATORS_AVAILABLE="${OPERATORS_AVAILABLE}rabbitmq,"
fi

# Check SeaweedFS availability (not a CRD, it's a Helm deployment)
if kubectl get pods -n seaweedfs -l app.kubernetes.io/name=seaweedfs 2>/dev/null | grep -q Running; then
    echo "  âœ“ SeaweedFS (S3 Storage)"
    OPERATORS_AVAILABLE="${OPERATORS_AVAILABLE}seaweedfs,"
fi

# Check NATS availability
if kubectl get pods -n nats -l app.kubernetes.io/name=nats 2>/dev/null | grep -q Running; then
    echo "  âœ“ NATS (Messaging)"
    OPERATORS_AVAILABLE="${OPERATORS_AVAILABLE}nats,"
fi

export OPERATORS_AVAILABLE
echo ""
echo "Available operators: ${OPERATORS_AVAILABLE:-none detected}"
echo ""

# =========================================================================
# Infrastructure Verification Functions
# =========================================================================

verify_postgresql() {
    local name="$1"
    local namespace="${2:-databases}"
    local timeout="${3:-300}"
    
    echo "â³ Waiting for PostgreSQL cluster '$name' to be ready..."
    if kubectl wait --for=condition=Ready "cluster/${name}" -n "$namespace" --timeout="${timeout}s" 2>/dev/null; then
        echo "âœ… PostgreSQL cluster '$name' is ready"
        
        # Output connection info
        local rw_service="${name}-rw"
        echo "   Connection: postgresql://<user>:<password>@${rw_service}.${namespace}.svc:5432/<database>"
        echo "   Secret: ${name}-app"
        return 0
    else
        echo "âŒ PostgreSQL cluster '$name' not ready within ${timeout}s"
        kubectl describe "cluster/${name}" -n "$namespace" 2>/dev/null | tail -20
        return 1
    fi
}

verify_valkey() {
    local name="$1"
    local namespace="${2:-databases}"
    local timeout="${3:-180}"
    
    echo "â³ Waiting for Valkey instance '$name' to be ready..."
    
    # The Redis operator doesn't have a standard Ready condition, check pod status
    local end_time=$(($(date +%s) + timeout))
    while [ $(date +%s) -lt $end_time ]; do
        local pod_status=$(kubectl get pods -n "$namespace" -l redis_setup_type=standalone,app="${name}" -o jsonpath='{.items[0].status.phase}' 2>/dev/null)
        if [ "$pod_status" = "Running" ]; then
            echo "âœ… Valkey instance '$name' is ready"
            echo "   Connection: redis://${name}.${namespace}.svc:6379"
            return 0
        fi
        sleep 5
    done
    
    echo "âŒ Valkey instance '$name' not ready within ${timeout}s"
    kubectl describe "redis/${name}" -n "$namespace" 2>/dev/null | tail -20
    return 1
}

verify_s3_bucket() {
    local bucket="$1"
    local endpoint="${2:-http://seaweedfs-filer.seaweedfs.svc:8333}"
    
    echo "â³ Verifying S3 bucket '$bucket'..."
    
    # Try to list the bucket (will fail if doesn't exist)
    if aws s3 ls "s3://${bucket}" --endpoint-url "$endpoint" &>/dev/null; then
        echo "âœ… S3 bucket '$bucket' exists and is accessible"
        echo "   Endpoint: $endpoint"
        return 0
    else
        echo "âš ï¸ S3 bucket '$bucket' may not exist yet (will be created by workflow)"
        return 0  # Non-fatal - bucket might be created during task
    fi
}

export -f verify_postgresql verify_valkey verify_s3_bucket

{{> acceptance-probe }}

# =========================================================================
# CLI Execution
# The Rust adapter injects the CLI-specific invocation here
# =========================================================================

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘ Executing {{cli_type}} CLI - Infrastructure Mode"
echo "â•‘ Attempt ${CURRENT_ATTEMPT:-1} of ${EXECUTION_MAX_RETRIES:-{{default_retries}}}"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

{{> cli_execute}}
CLI_EXIT_CODE=$?

# =========================================================================
# Post-Execution Infrastructure Verification
# =========================================================================

if [ $CLI_EXIT_CODE -eq 0 ]; then
    echo ""
    echo "âœ“ CLI execution completed successfully"
    echo ""
    echo "ðŸ” Verifying provisioned infrastructure..."
    
    # Check for infra directory and apply if exists
    if [ -d "infra" ]; then
        echo "  Found infra/ directory with manifests"
        
        # List what was created
        find infra -name "*.yaml" -o -name "*.yml" 2>/dev/null | while read -r manifest; do
            echo "    - $manifest"
        done
    fi
    
    # Run acceptance criteria probe
    if type probe_acceptance_criteria >/dev/null 2>&1; then
        probe_acceptance_criteria
        PROBE_RESULT=$?
        
        if [ $PROBE_RESULT -ne 0 ]; then
            echo ""
            echo "âš ï¸ Acceptance criteria not fully met"
            echo "   Controller will evaluate retry based on policy"
        fi
    fi
else
    echo ""
    echo "âŒ CLI execution failed with exit code: $CLI_EXIT_CODE"
fi

{{> completion }}

