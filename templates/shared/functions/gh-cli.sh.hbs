# =========================================================================
# GitHub CLI Functions - Shared Functions
# 
# Common GitHub CLI (gh) helper functions used across all CLI containers.
# Provides authentication, PR management, and API helpers.
# =========================================================================

# Ensure GitHub CLI is authenticated
ensure_gh_authenticated() {
  if ! command -v gh >/dev/null 2>&1; then
    echo "‚ö†Ô∏è GitHub CLI (gh) not found; skipping authentication"
    return 1
  fi

  if gh auth status --hostname "$GH_HOST" >/dev/null 2>&1; then
    echo "‚úÖ GitHub CLI already authenticated for $GH_HOST"
    return 0
  fi

  echo "üîê Logging in to GitHub CLI for host $GH_HOST"
  
  # Try to authenticate using the token
  if echo "$GH_TOKEN" | gh auth login --hostname "$GH_HOST" --with-token 2>/dev/null; then
    echo "‚úÖ GitHub CLI authenticated for $GH_HOST"
    return 0
  fi

  echo "‚ö†Ô∏è Unable to confirm GitHub CLI auth; GH_TOKEN will still be used for git operations"
  return 1
}

# Derive bot identity from GitHub App
derive_bot_identity() {
  local app_slug="${GITHUB_APP:-cto-bot}"
  
  # Convert app name to bot format (e.g., "5DLabs-Rex" -> "5dlabs-rex[bot]")
  local bot_name
  bot_name=$(echo "$app_slug" | tr '[:upper:]' '[:lower:]')
  
  GIT_AUTHOR_NAME="${bot_name}[bot]"
  GIT_COMMITTER_NAME="${bot_name}[bot]"
  
  # Try to get the bot's noreply email from GitHub API
  if command -v gh >/dev/null 2>&1 && [ -n "${GH_TOKEN:-}" ]; then
    local app_info
    app_info=$(gh api /app 2>/dev/null || true)
    if [ -n "$app_info" ]; then
      local app_id
      app_id=$(echo "$app_info" | jq -r '.id // empty')
      if [ -n "$app_id" ]; then
        GIT_AUTHOR_EMAIL="${app_id}+${bot_name}[bot]@users.noreply.github.com"
        GIT_COMMITTER_EMAIL="${app_id}+${bot_name}[bot]@users.noreply.github.com"
        export GIT_AUTHOR_NAME GIT_COMMITTER_NAME GIT_AUTHOR_EMAIL GIT_COMMITTER_EMAIL
        return 0
      fi
    fi
  fi
  
  # Fallback to generic noreply email
  GIT_AUTHOR_EMAIL="${bot_name}[bot]@users.noreply.github.com"
  GIT_COMMITTER_EMAIL="${bot_name}[bot]@users.noreply.github.com"
  export GIT_AUTHOR_NAME GIT_COMMITTER_NAME GIT_AUTHOR_EMAIL GIT_COMMITTER_EMAIL
}

# Check if config file/value is valid (non-empty and not "null")
is_valid_cfg() {
  local val="$1"
  [ -n "$val" ] && [ "$val" != "null" ]
}

# Resolve PR URL from branch
resolve_pr_url() {
  local branch="${1:-$(git rev-parse --abbrev-ref HEAD 2>/dev/null)}"
  
  if [ -z "$branch" ]; then
    return 1
  fi
  
  local pr_url
  pr_url=$(gh pr view "$branch" --json url --jq '.url' 2>/dev/null || true)
  
  if [ -n "$pr_url" ] && [ "$pr_url" != "null" ]; then
    echo "$pr_url"
    return 0
  fi
  
  return 1
}

# Ensure PR is created for the current branch
ensure_pr_created() {
  local branch="${1:-$(git rev-parse --abbrev-ref HEAD 2>/dev/null)}"
  local title="${2:-Task {{task_id}} implementation}"
  local body="${3:-Automated PR for task {{task_id}}}"
  
  # Check if PR already exists
  if resolve_pr_url "$branch" >/dev/null 2>&1; then
    echo "‚úÖ PR already exists for branch $branch"
    return 0
  fi
  
  echo "üìù Creating PR for branch $branch..."
  
  # Push branch if not already pushed
  if ! git ls-remote --heads origin "$branch" | grep -q "$branch"; then
    git push -u origin "$branch" || return 1
  fi
  
  # Create PR
  local pr_url
  pr_url=$(gh pr create \
    --title "$title" \
    --body "$body" \
    --head "$branch" \
    --base "${DEFAULT_BRANCH:-main}" \
    2>&1) || {
    echo "‚ö†Ô∏è Failed to create PR: $pr_url"
    return 1
  }
  
  echo "‚úÖ PR created: $pr_url"
  return 0
}

# Sanitize status message for API calls (escape special characters)
sanitize_status_message() {
  local msg="$1"
  # Escape backslashes, double quotes, and newlines for JSON
  echo "$msg" | sed 's/\\/\\\\/g; s/"/\\"/g' | tr '\n' ' '
}


