# =========================================================================
# Git Operations - Shared Functions
# 
# Common git helper functions used across all CLI containers.
# Provides safe wrappers, credential management, and state cleanup.
# =========================================================================

# Write git credentials file for HTTPS authentication
write_git_credentials() {
  if [ -z "${GITHUB_TOKEN:-}" ]; then
    return
  fi
  printf 'https://x-access-token:%s@github.com\n' "$GITHUB_TOKEN" >"$CREDENTIALS_FILE"
  chmod 600 "$CREDENTIALS_FILE" 2>/dev/null || true
}

# Write GitHub CLI hosts configuration
write_gh_hosts_config() {
  if [ -z "${GITHUB_TOKEN:-}" ]; then
    return
  fi

  local hosts_dir="${GH_CONFIG_DIR:-$HOME/.config/gh}"
  mkdir -p "$hosts_dir"

  cat >"$hosts_dir/hosts.yml" <<EOF
github.com:
    user: x-access-token
    oauth_token: ${GITHUB_TOKEN}
    git_protocol: https
EOF

  chmod 600 "$hosts_dir/hosts.yml" 2>/dev/null || true
}

# Find the gh CLI hosts file
gh_hosts_file() {
  if [ -n "${GH_CONFIG_DIR:-}" ] && [ -f "${GH_CONFIG_DIR}/hosts.yml" ]; then
    printf '%s\n' "${GH_CONFIG_DIR}/hosts.yml"
    return
  fi
  if [ -f "$HOME/.config/gh/hosts.yml" ]; then
    printf '%s\n' "$HOME/.config/gh/hosts.yml"
    return
  fi
  printf ''
}

# Sync gh hosts config to a target directory
sync_gh_hosts_to_path() {
  local target="$1"
  if [ -z "$target" ]; then
    return
  fi
  local source
  source=$(gh_hosts_file)
  if [ -z "$source" ] || [ ! -f "$source" ]; then
    return
  fi
  local dest_dir="$target/.config/gh"
  mkdir -p "$dest_dir"
  if cp "$source" "$dest_dir/hosts.yml" >/dev/null 2>&1; then
    chmod 600 "$dest_dir/hosts.yml" 2>/dev/null || true
  fi
}

# Cleanup stale git state (merge conflicts, rebase, etc.)
cleanup_git_state() {
  if [ ! -d ".git" ]; then
    return
  fi

  # Check for unresolved merge conflicts
  if git status --porcelain 2>/dev/null | grep -q "^UU\|^AA\|^DD\|^..U\|^U..\|^AU\|^UA\|^DU\|^UD"; then
    echo "‚ö†Ô∏è Detecting unresolved merge conflicts, aborting merge..."
    git merge --abort 2>/dev/null || true
    echo "‚úì Merge conflicts aborted"
  fi

  # Check for incomplete git operations
  if [ -f ".git/REBASE_HEAD" ] || [ -f ".git/CHERRY_PICK_HEAD" ] || [ -f ".git/MERGE_HEAD" ]; then
    echo "‚ö†Ô∏è Detecting incomplete git operation, resetting..."
    git rebase --abort 2>/dev/null || true
    git cherry-pick --abort 2>/dev/null || true
    git merge --abort 2>/dev/null || true
    if ! git diff-index --quiet HEAD 2>/dev/null; then
      git reset --hard HEAD 2>/dev/null || true
    fi
    echo "‚úì Git operations reset"
  fi
}

# Cleanup locked refs from git fetch error log
cleanup_locked_refs_from_log() {
  local log_file="$1"
  local cleaned=0

  while IFS= read -r line; do
    if echo "$line" | grep -qE "cannot lock ref.*exists"; then
      ref_name=$(echo "$line" | sed -n "s/.*cannot lock ref '\([^']*\)'.*/\1/p")
      if [ -n "$ref_name" ]; then
        echo "üßπ Cleaning stale ref: $ref_name"
        git update-ref -d "$ref_name" 2>/dev/null || true
        cleaned=1
      fi
    fi
  done < "$log_file"

  if [ $cleaned -eq 1 ]; then
    git remote prune origin >/dev/null 2>&1 || true
    return 0
  fi

  return 1
}

# Safe git fetch with automatic locked ref cleanup
safe_git_fetch() {
  local log_file
  log_file=$(mktemp)

  if git fetch "$@" >"$log_file" 2>&1; then
    rm -f "$log_file"
    return 0
  fi

  if cleanup_locked_refs_from_log "$log_file"; then
    echo "üîß Cleaned stale remote refs; retrying git fetch $*"
    if git fetch "$@" >>"$log_file" 2>&1; then
      rm -f "$log_file"
      return 0
    fi
  fi

  cat "$log_file"
  rm -f "$log_file"
  return 1
}

# Safe git config with retry logic and lock file cleanup
safe_git_config() {
  local max_attempts=5
  local attempt=1
  local sleep_time=1
  
  while [ $attempt -le $max_attempts ]; do
    # Clean up stale lock files before attempting
    if [ -f "${GIT_CONFIG_GLOBAL}.lock" ]; then
      # Check if lock file is stale (older than 10 seconds)
      if find "${GIT_CONFIG_GLOBAL}.lock" -mmin +0.17 2>/dev/null | grep -q .; then
        echo "‚ö†Ô∏è  Removing stale git config lock file"
        rm -f "${GIT_CONFIG_GLOBAL}.lock" 2>/dev/null || true
      fi
    fi

    # Attempt the git config operation
    if git config "$@" 2>/dev/null; then
      return 0
    fi

    # Operation failed, retry with exponential backoff
    local exit_code=$?
    if [ $exit_code -ne 0 ] && [ $attempt -lt $max_attempts ]; then
      echo "‚ö†Ô∏è  Git config attempt $attempt/$max_attempts failed (exit $exit_code), retrying in ${sleep_time}s..."
      rm -f "${GIT_CONFIG_GLOBAL}.lock" 2>/dev/null || true
      sleep "$sleep_time"
      attempt=$((attempt + 1))
      sleep_time=$((sleep_time * 2))  # Exponential backoff
    else
      break
    fi
  done
  
  if [ $attempt -gt $max_attempts ]; then
    echo "‚ùå Git config failed after $max_attempts attempts: git config $*"
    return 1
  fi
  
  return 0
}


