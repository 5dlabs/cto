#!/bin/sh
# Factory Heal Remediation - Blaze
# Executes remediation tasks identified by the heal monitoring system
# Spawned via CodeRun CRD when heal detects frontend issues requiring intervention

set -e

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘           BLAZE HEAL REMEDIATION (FACTORY) STARTING          â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'

# ============================================================================
# DOCKER SIDECAR MANAGEMENT
# ============================================================================
{{#if enable_docker}}
wait_for_docker() {
  echo "ðŸ³ Waiting for Docker daemon..."
  export DOCKER_HOST="${DOCKER_HOST:-unix:///var/run/docker/docker.sock}"
  for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
    if docker info >/dev/null 2>&1; then
      echo "âœ… Docker daemon ready (socket: ${DOCKER_HOST})"
      return 0
    fi
    echo "   Waiting... ($i/15)"
    sleep 2
  done
  echo "âš ï¸ Docker daemon not available after 30s (continuing anyway)"
  return 1
}

stop_docker_sidecar() {
  echo "ðŸ›‘ Stopping Docker sidecar"
  TASK_ID="{{task_id}}"
  if [ -n "$TASK_ID" ] && [ "$TASK_ID" != "0" ]; then
    SIGNAL_DIR="/workspace/task-${TASK_ID}"
    mkdir -p "$SIGNAL_DIR" 2>/dev/null || true
    touch "${SIGNAL_DIR}/.agent_done" 2>/dev/null || true
  fi
  DOCKER_SOCK="${DOCKER_HOST:-unix:///var/run/docker/docker.sock}"
  SOCK_PATH="${DOCKER_SOCK#unix://}"
  if [ ! -S "$SOCK_PATH" ] && [ ! -S /var/run/docker.sock ]; then
    return
  fi
  for i in 1 2 3 4 5 6; do
    if ! pidof dockerd >/dev/null 2>&1 && ! pidof docker-init >/dev/null 2>&1; then
      echo "âœ… Docker sidecar stopped gracefully"
      return
    fi
    sleep 2
  done
  if command -v pkill >/dev/null 2>&1; then
    pkill -TERM dockerd >/dev/null 2>&1 || true
    sleep 2
    pkill -KILL dockerd >/dev/null 2>&1 || true
  fi
}

trap 'stop_docker_sidecar || true' EXIT
wait_for_docker || true
echo "ðŸ³ Docker enabled"
{{else}}
echo "ðŸ³ Docker disabled"
{{/if}}
echo "ðŸŽ¯ Agent: {{github_app}}"
echo "ðŸ“‹ Task ID: {{task_id}}"
echo "ðŸ”§ Alert Type: ${ALERT_TYPE:-unknown}"
echo "ðŸ“‚ Repository: {{repository_url}}"
echo "ðŸŒ³ CodeRun: ${CODERUN_NAME:-unknown}"
if [ -n "${HEAL_ISSUE_NUMBER}" ]; then
    echo "ðŸ”— GitHub Issue: #${HEAL_ISSUE_NUMBER}"
fi

# ============================================================================
# CONFIGURATION
# ============================================================================
COMPLETION_TIMEOUT=${HEAL_COMPLETION_TIMEOUT:-60}
REPO_NAME=$(basename "{{repository_url}}" .git | tr '/' '-')
REPO_PATH="/workspace/${REPO_NAME}"
export REPO_PATH
export WORKTREE_PATH="/workspace/worktrees/${CODERUN_NAME}"
echo "ðŸ“ Worktree: ${WORKTREE_PATH}"
mkdir -p /workspace/worktrees

# ============================================================================
# WORKSPACE CLEANUP
# ============================================================================
echo ""
echo "â•â•â• WORKSPACE CLEANUP â•â•â•"
git config --global --add safe.directory '*' 2>/dev/null || true
echo "âœ“ Git safe.directory configured"

if [ -d "/workspace/worktrees" ]; then
    echo "ðŸ§¹ Cleaning stale worktrees..."
    find /workspace/worktrees -maxdepth 1 -type d -mmin +1440 -not -name "$(basename ${WORKTREE_PATH})" 2>/dev/null | while read -r old_wt; do
        if [ -d "$old_wt" ] && [ "$old_wt" != "/workspace/worktrees" ]; then
            rm -rf "$old_wt" 2>/dev/null || true
        fi
    done
    echo "âœ“ Worktree cleanup complete"
fi

find /workspace -name "*.lock" -type f -mmin +30 2>/dev/null | while read -r lockfile; do
    rm -f "$lockfile" 2>/dev/null || true
done

if [ -d "/workspace/archived" ]; then
    find /workspace/archived -maxdepth 1 -type d -mtime +7 2>/dev/null | while read -r old_archive; do
        if [ -d "$old_archive" ] && [ "$old_archive" != "/workspace/archived" ]; then
            rm -rf "$old_archive" 2>/dev/null || true
        fi
    done
fi

# ============================================================================
# GITHUB APP AUTHENTICATION
# ============================================================================
generate_github_token() {
    echo "ðŸ” Generating GitHub App token..."
    if [ -z "${GITHUB_APP_ID:-}" ] || [ -z "${GITHUB_APP_PRIVATE_KEY:-}" ]; then
        echo "âš ï¸ GitHub App credentials not available"
        return 1
    fi

    TEMP_KEY_FILE="/tmp/github-app-key-$$"
    printf '%s' "$GITHUB_APP_PRIVATE_KEY" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"

    HEADER='{"alg":"RS256","typ":"JWT"}'
    NOW=$(date +%s)
    IAT=$((NOW - 60))
    EXP=$((NOW + 600))
    PAYLOAD="{\"iat\":${IAT},\"exp\":${EXP},\"iss\":\"${GITHUB_APP_ID}\"}"

    B64_HEADER=$(printf '%s' "$HEADER" | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
    B64_PAYLOAD=$(printf '%s' "$PAYLOAD" | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
    SIGNATURE=$(printf '%s.%s' "$B64_HEADER" "$B64_PAYLOAD" | \
        openssl dgst -sha256 -binary -sign "$TEMP_KEY_FILE" | \
        base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')

    JWT_TOKEN="${B64_HEADER}.${B64_PAYLOAD}.${SIGNATURE}"

    INSTALLATIONS_RESPONSE=$(curl -sS -L --retry 3 --retry-delay 2 \
        --connect-timeout 10 --max-time 30 \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations")

    INSTALLATION_ID=$(echo "$INSTALLATIONS_RESPONSE" | jq -r '.[0].id')

    if [ "$INSTALLATION_ID" = "null" ] || [ -z "$INSTALLATION_ID" ]; then
        rm -f "$TEMP_KEY_FILE"
        return 1
    fi

    TOKEN_RESPONSE=$(curl -sS -L --retry 3 --retry-delay 2 \
        --connect-timeout 10 --max-time 30 \
        -X POST \
        -H "Authorization: Bearer $JWT_TOKEN" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

    GITHUB_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')

    if [ "$GITHUB_TOKEN" = "null" ] || [ -z "$GITHUB_TOKEN" ]; then
        rm -f "$TEMP_KEY_FILE"
        return 1
    fi

    rm -f "$TEMP_KEY_FILE"

    export GITHUB_TOKEN
    export GH_TOKEN="$GITHUB_TOKEN"
    export TOKEN_GENERATED_AT=$(date +%s)

    git config --global --replace-all credential.helper store
    echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
    chmod 600 ~/.git-credentials

    echo "$GITHUB_TOKEN" | gh auth login --with-token 2>/dev/null || true

    echo "âœ… GitHub App authenticated successfully"
}

echo ""
echo "â•â•â• GITHUB APP AUTHENTICATION â•â•â•"
if [ -n "${GITHUB_APP_PRIVATE_KEY:-}" ] && [ -n "${GITHUB_APP_ID:-}" ]; then
    if ! generate_github_token; then
        echo "âŒ Failed to authenticate with GitHub App"
        exit 1
    fi
else
    echo "âš ï¸ GitHub App credentials not found"
fi

# ============================================================================
# GIT RETRY LOGIC
# ============================================================================
git_with_retry() {
    _gwr_max_attempts=5
    _gwr_attempt=1
    _gwr_delay=2

    while [ $_gwr_attempt -le $_gwr_max_attempts ]; do
        echo "   git_with_retry: attempt $_gwr_attempt/$_gwr_max_attempts: git $*"
        _gwr_output=$(git "$@" 2>&1) && {
            echo "$_gwr_output"
            return 0
        }

        if echo "$_gwr_output" | grep -qiE "(500|502|503|504|internal server error|connection refused|connection reset|network|timed out)"; then
            if [ $_gwr_attempt -lt $_gwr_max_attempts ]; then
                sleep $_gwr_delay
                _gwr_delay=$((_gwr_delay * 2))
                if [ $_gwr_delay -gt 60 ]; then _gwr_delay=60; fi
            fi
        else
            echo "   Error: $_gwr_output"
            return 1
        fi
        _gwr_attempt=$((_gwr_attempt + 1))
    done
    return 1
}

# ============================================================================
# REPOSITORY PRE-STAGING
# ============================================================================
echo ""
echo "â•â•â• REPOSITORY PRE-STAGING â•â•â•"
echo "ðŸ“¦ Repository: {{repository_url}}"
echo "ðŸ“‚ Local path: ${REPO_PATH}"

if [ -d "${REPO_PATH}/.git" ]; then
    echo "âœ“ Repository exists, syncing with origin/main..."
    cd "${REPO_PATH}"
    git config --global --add safe.directory "${REPO_PATH}" 2>/dev/null || true
    git worktree prune 2>/dev/null || true
    if ! git_with_retry fetch --depth 1 origin main; then
        exit 1
    fi
    git reset --hard origin/main
    git clean -fd
    echo "âœ“ Repository synced to $(git rev-parse --short HEAD)"
else
    echo "ðŸ“¥ Repository not found, cloning (shallow)..."
    CLONE_URL="{{repository_url}}"
    if ! echo "${CLONE_URL}" | grep -q "\.git$"; then
        CLONE_URL="${CLONE_URL}.git"
    fi
    if ! git_with_retry clone --depth 1 "${CLONE_URL}" "${REPO_PATH}"; then
        exit 1
    fi
    cd "${REPO_PATH}"
    git config --global --add safe.directory "${REPO_PATH}" 2>/dev/null || true
    echo "âœ“ Repository cloned to $(git rev-parse --short HEAD)"
fi

git config core.bare false 2>/dev/null || true
echo "âœ“ Repository ready at ${REPO_PATH}"

# ============================================================================
# VERIFY HEAL CONTEXT FILES
# ============================================================================
PROMPT_FILE="${HEAL_PROMPT_FILE:-/workspace/issues/issue-${HEAL_ISSUE_NUMBER:-unknown}/prompt.md}"
LOG_FILE="${HEAL_LOG_FILE:-/workspace/logs/${ALERT_TYPE:-A7}-*.log}"

if [ -n "${HEAL_ACCEPTANCE_FILE}" ]; then
    ACCEPTANCE_FILE="${HEAL_ACCEPTANCE_FILE}"
    LEGACY_MODE="false"
elif [ -n "${HEAL_ISSUE_DIR}" ]; then
    ACCEPTANCE_FILE="${HEAL_ISSUE_DIR}/acceptance-criteria.md"
    LEGACY_MODE="false"
elif [ -n "${HEAL_ISSUE_NUMBER}" ]; then
    ACCEPTANCE_FILE="/workspace/issues/issue-${HEAL_ISSUE_NUMBER}/acceptance-criteria.md"
    LEGACY_MODE="false"
else
    ACCEPTANCE_FILE=""
    LEGACY_MODE="true"
fi

echo ""
echo "â•â•â• HEAL CONTEXT FILES â•â•â•"
echo "ðŸ“„ Prompt file: ${PROMPT_FILE}"
if [ "${LEGACY_MODE}" = "true" ]; then
    echo "âš ï¸  Legacy mode: No acceptance criteria"
else
    echo "âœ… Acceptance: ${ACCEPTANCE_FILE}"
fi

if [ -f /workspace/scripts/lib/common.sh ]; then
    . /workspace/scripts/lib/common.sh
fi

AGENT_PROMPT="/task-files/CLAUDE.md"
if [ ! -f "${AGENT_PROMPT}" ]; then
    echo "âŒ Agent prompt not found at ${AGENT_PROMPT}"
    exit 1
fi
echo "âœ… Agent prompt file exists: ${AGENT_PROMPT}"

# ============================================================================
# MCP TOOLS VALIDATION
# ============================================================================
echo ""
echo "â•â•â• MCP TOOLS VALIDATION â•â•â•"
if command -v droid >/dev/null 2>&1; then
    TOOL_LIST=$(droid exec --list-tools 2>&1 || echo "FAILED")
    if [ "$TOOL_LIST" != "FAILED" ] && echo "$TOOL_LIST" | grep -q "mcp_tools\|github\|kubernetes"; then
        echo "âœ… MCP tools available"
    else
        echo "âš ï¸  No MCP tools found (proceeding anyway)"
    fi
else
    echo "âš ï¸  Droid CLI not found - MCP validation skipped"
fi

# ============================================================================
# COMPLETION PROBE LOOP
# ============================================================================
ATTEMPT=1
SUCCESS=0

PERSISTENT_LOG_DIR="/workspace/completion/${CODERUN_NAME:-unknown}"
mkdir -p "${PERSISTENT_LOG_DIR}"
COMPLETION_LAST_MESSAGE="${PERSISTENT_LOG_DIR}/last-message.txt"
COMPLETION_LOG="${PERSISTENT_LOG_DIR}/completion.log"
AGENT_OUTPUT_LOG="${PERSISTENT_LOG_DIR}/agent-output.log"

echo "ðŸ“ Persistent logs: ${PERSISTENT_LOG_DIR}"

flush_logs_and_exit() {
    EXIT_CODE="${1:-130}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "â•‘ âš ï¸ SIGTERM RECEIVED - Flushing state before exit            â•‘"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    {
        echo "=== TERMINATION RECORD ==="
        echo "Time: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        echo "Exit Code: ${EXIT_CODE}"
        echo "Iteration: ${ATTEMPT:-1}"
        echo "CodeRun: ${CODERUN_NAME:-unknown}"
    } >> "${PERSISTENT_LOG_DIR}/termination.log" 2>/dev/null || true
    sync 2>/dev/null || true
    {{#if enable_docker}}
    stop_docker_sidecar || true
    {{/if}}
    exit "${EXIT_CODE}"
}

trap 'flush_logs_and_exit 130' TERM INT

echo ""
echo "â•â•â• STARTING REMEDIATION (iterating until acceptance criteria met) â•â•â•"

while [ $SUCCESS -eq 0 ]; do
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "â•‘ ITERATION ${ATTEMPT}                                                â•‘"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    PROMPT_CONTENT=$(cat "${AGENT_PROMPT}")

    if [ $ATTEMPT -gt 1 ] && [ -f "${COMPLETION_LAST_MESSAGE}" ]; then
        LAST_REASON=$(cat "${COMPLETION_LAST_MESSAGE}" 2>/dev/null || echo "")
        if [ -n "${LAST_REASON}" ]; then
            PROMPT_CONTENT="${PROMPT_CONTENT}

ðŸ” **ITERATION ${ATTEMPT} - Previous attempt incomplete**

${LAST_REASON}

Focus on addressing the above items."
        fi
    fi

    echo "ðŸš€ Running Factory remediation agent (Blaze - Frontend)..."
    set +e
    droid exec \
        --auto high \
        --model "{{model}}" \
        --output-format stream-json \
        "${PROMPT_CONTENT}"
    AGENT_EXIT=$?
    set -e

    echo ""
    echo "ðŸ§­ Agent exited with code: ${AGENT_EXIT}"

    # Check PR status
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "â•‘ CHECKING PR STATUS & MERGE CONFLICTS                         â•‘"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    cd "${WORKTREE_PATH}" 2>/dev/null || cd "${REPO_PATH}" || true
    PR_NUMBER=$(gh pr view --json number -q '.number' 2>/dev/null || echo "")
    
    if [ -n "${PR_NUMBER}" ]; then
        echo "ðŸ“‹ Found PR #${PR_NUMBER}"
        
        MERGEABLE=$(gh pr view ${PR_NUMBER} --json mergeable -q '.mergeable' 2>/dev/null || echo "")
        if [ "${MERGEABLE}" = "CONFLICTING" ]; then
            echo "âš ï¸ Merge conflict detected - rebasing..."
            git_with_retry fetch origin main
            if git rebase origin/main; then
                git push origin HEAD --force-with-lease
            else
                git rebase --abort 2>/dev/null || true
                echo "Merge conflict" > "${COMPLETION_LAST_MESSAGE}"
            fi
            sleep 10
        fi
        
        echo "ðŸ” Checking CI status..."
        CI_ATTEMPTS=0
        while [ $CI_ATTEMPTS -lt 20 ]; do
            CI_STATUS=$(gh pr checks ${PR_NUMBER} --json state -q '.[].state' 2>/dev/null | sort -u || echo "")
            
            if echo "${CI_STATUS}" | grep -q "FAILURE"; then
                echo "âŒ CI failed"
                break
            elif echo "${CI_STATUS}" | grep -q "PENDING"; then
                echo "â³ CI still running..."
                sleep 30
                CI_ATTEMPTS=$((CI_ATTEMPTS + 1))
            else
                echo "âœ… CI checks passed"
                break
            fi
        done
        
        MERGED=$(gh pr view ${PR_NUMBER} --json merged -q '.merged' 2>/dev/null || echo "false")
        if [ "${MERGED}" = "true" ]; then
            echo "âœ… PR already merged!"
        fi
    else
        echo "ðŸ“ No PR found yet"
    fi

    # Completion probe
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "â•‘ COMPLETION PROBE - Checking Acceptance Criteria              â•‘"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    if [ -n "${ACCEPTANCE_FILE}" ] && [ -f "${ACCEPTANCE_FILE}" ]; then
        ACCEPTANCE_CONTENT=$(cat "${ACCEPTANCE_FILE}")
    else
        ACCEPTANCE_CONTENT="Use basic health checks:
- [ ] Fix has been deployed (PR merged)
- [ ] ArgoCD sync successful
- [ ] Target pod running without errors"
    fi

    COMPLETION_PROMPT="You are a completion probe for a heal remediation task.

## Acceptance Criteria
${ACCEPTANCE_CONTENT}

## Instructions
Review the current state and determine if ALL acceptance criteria are met.

Respond with ONLY:
- **yes** - if ALL criteria are satisfied
- **no** - if ANY criteria are NOT satisfied

If no, add:
REASON: [list the specific criteria that are not met]"

    echo "ðŸ“‹ Running completion probe..."
    set +e
    COMPLETION_OUTPUT=$(droid exec --auto high --model "{{model}}" --output-format text "${COMPLETION_PROMPT}" 2>&1 | tee "${COMPLETION_LOG}")
    set -e

    echo "ðŸ§­ Completion probe response:"
    printf '%s\n' "${COMPLETION_OUTPUT}"

    COMPLETION_RESPONSE=$(printf '%s\n' "${COMPLETION_OUTPUT}" | tr -d '\r' | grep -Eio '\*\*(yes|no)\*\*|(^|[[:space:]])(yes|no)([[:space:]]|$)' | sed 's/\*//g; s/^[[:space:]]*//; s/[[:space:]]*$//' | head -n1 | tr '[:upper:]' '[:lower:]')

    if [ "${COMPLETION_RESPONSE}" = "yes" ]; then
        echo "âœ… Completion probe confirmed: ALL acceptance criteria met!"
        SUCCESS=1
        break
    elif [ "${COMPLETION_RESPONSE}" = "no" ]; then
        CURRENT_REASON=$(printf '%s\n' "${COMPLETION_OUTPUT}" | awk 'BEGIN{IGNORECASE=1}/^reason:/{sub(/^reason:[[:space:]]*/,"");flag=1} flag{print}')
        if [ -n "${CURRENT_REASON}" ]; then
            echo "âš ï¸ Completion probe found incomplete criteria:"
            echo "${CURRENT_REASON}"
            printf '%s\n' "${CURRENT_REASON}" > "${COMPLETION_LAST_MESSAGE}"
        else
            echo "Task incomplete" > "${COMPLETION_LAST_MESSAGE}"
        fi
    else
        echo "Unable to verify completion" > "${COMPLETION_LAST_MESSAGE}"
    fi

    ATTEMPT=$((ATTEMPT + 1))
done

# Final status
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
if [ $SUCCESS -eq 1 ]; then
    echo "â•‘ âœ… REMEDIATION COMPLETE                                       â•‘"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "Completed in ${ATTEMPT} attempt(s)"

    if [ -n "${HEAL_ISSUE_NUMBER}" ]; then
        gh issue comment "${HEAL_ISSUE_NUMBER}" --repo 5dlabs/cto --body "âœ… **Remediation Complete**
Completed by: ${CODERUN_NAME}
Attempts: ${ATTEMPT}" 2>/dev/null || true
        gh issue close "${HEAL_ISSUE_NUMBER}" --repo 5dlabs/cto --reason completed 2>/dev/null || true
    fi

    if [ -n "${HEAL_ISSUE_DIR}" ] && [ -d "${HEAL_ISSUE_DIR}" ]; then
        ARCHIVE_DIR="/workspace/archived/${HEAL_ISSUE_NUMBER:-unknown}"
        mkdir -p "$(dirname ${ARCHIVE_DIR})"
        mv "${HEAL_ISSUE_DIR}" "${ARCHIVE_DIR}" 2>/dev/null || true
    fi

    if [ -n "${WORKTREE_PATH}" ] && [ -d "${WORKTREE_PATH}" ]; then
        cd "${REPO_PATH:-/workspace}" 2>/dev/null || true
        git worktree remove "${WORKTREE_PATH}" --force 2>/dev/null || rm -rf "${WORKTREE_PATH}" 2>/dev/null || true
    fi

    {{#if enable_docker}}
    stop_docker_sidecar || true
    {{/if}}
    
    exit 0
else
    echo "â•‘ âš ï¸ REMEDIATION LOOP EXITED UNEXPECTEDLY                        â•‘"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    if [ -n "${HEAL_ISSUE_NUMBER}" ]; then
        LAST_REASON=$(cat "${COMPLETION_LAST_MESSAGE}" 2>/dev/null || echo "Unknown")
        gh issue comment "${HEAL_ISSUE_NUMBER}" --repo 5dlabs/cto --body "âš ï¸ **Remediation Loop Exited**
${LAST_REASON}
Agent: ${CODERUN_NAME}" 2>/dev/null || true
    fi

    {{#if enable_docker}}
    stop_docker_sidecar || true
    {{/if}}
    
    exit 1
fi

