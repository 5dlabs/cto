//! Response schemas for AI-generated content.
//!
//! These structures define the expected format of AI responses
//! for various task operations.

use serde::{Deserialize, Serialize};

use crate::entities::{TaskPriority, TaskStatus};

/// Response from parse-prd command.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParsePrdResponse {
    /// Generated tasks
    pub tasks: Vec<GeneratedTask>,
    /// Optional metadata
    #[serde(default)]
    pub metadata: Option<serde_json::Value>,
}

/// A task generated by AI.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedTask {
    /// Task ID
    pub id: i32,
    /// Task title
    pub title: String,
    /// Task description
    pub description: String,
    /// Implementation details
    #[serde(default)]
    pub details: Option<String>,
    /// Test strategy
    #[serde(default, rename = "testStrategy")]
    pub test_strategy: Option<String>,
    /// Task priority
    #[serde(default)]
    pub priority: Option<TaskPriority>,
    /// Dependencies (task IDs)
    #[serde(default)]
    pub dependencies: Vec<i32>,
    /// Task status
    #[serde(default)]
    pub status: Option<TaskStatus>,
}

/// Response from expand-task command.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExpandTaskResponse {
    /// Generated subtasks
    pub subtasks: Vec<GeneratedSubtask>,
    /// Optional metadata
    #[serde(default)]
    pub metadata: Option<serde_json::Value>,
}

/// A subtask generated by AI.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedSubtask {
    /// Subtask ID
    pub id: i32,
    /// Subtask title
    pub title: String,
    /// Subtask description
    pub description: String,
    /// Implementation details
    #[serde(default)]
    pub details: Option<String>,
    /// Test strategy
    #[serde(default, rename = "testStrategy")]
    pub test_strategy: Option<String>,
    /// Dependencies (subtask IDs within this task)
    #[serde(default)]
    pub dependencies: Vec<i32>,
    /// Subtask status
    #[serde(default)]
    pub status: Option<TaskStatus>,
}

/// Response from analyze-complexity command.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalyzeComplexityResponse {
    /// Complexity analysis for each task
    #[serde(rename = "complexityAnalysis")]
    pub complexity_analysis: Vec<TaskComplexityAnalysis>,
    /// Optional metadata
    #[serde(default)]
    pub metadata: Option<serde_json::Value>,
}

/// Complexity analysis for a single task.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskComplexityAnalysis {
    /// Task ID
    #[serde(rename = "taskId")]
    pub task_id: i32,
    /// Task title
    #[serde(rename = "taskTitle")]
    pub task_title: String,
    /// Complexity score (1-10)
    #[serde(rename = "complexityScore")]
    pub complexity_score: i32,
    /// Recommended number of subtasks
    #[serde(rename = "recommendedSubtasks")]
    pub recommended_subtasks: i32,
    /// Prompt to guide subtask generation
    #[serde(rename = "expansionPrompt")]
    pub expansion_prompt: String,
    /// Reasoning for the complexity score
    pub reasoning: String,
}

/// Response from add-task command.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddTaskResponse {
    /// Task title
    pub title: String,
    /// Task description
    pub description: String,
    /// Implementation details
    pub details: String,
    /// Test strategy
    #[serde(rename = "testStrategy")]
    pub test_strategy: String,
    /// Dependencies (task IDs)
    #[serde(default)]
    pub dependencies: Vec<i32>,
}

/// Response from update-task command.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateTaskResponse {
    /// Updated task
    pub task: GeneratedTask,
}

/// Response from update-tasks command.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateTasksResponse {
    /// Updated tasks
    pub tasks: Vec<GeneratedTask>,
}

/// Complexity report file structure.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplexityReport {
    /// Report metadata
    pub meta: ComplexityReportMeta,
    /// Complexity analysis for each task
    #[serde(rename = "complexityAnalysis")]
    pub complexity_analysis: Vec<TaskComplexityAnalysis>,
}

/// Complexity report metadata.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplexityReportMeta {
    /// Timestamp of report generation
    #[serde(rename = "generatedAt")]
    pub generated_at: String,
    /// Task file analyzed
    #[serde(rename = "tasksFile")]
    pub tasks_file: String,
    /// Model used for analysis
    pub model: String,
    /// Complexity threshold used
    pub threshold: i32,
}

impl ComplexityReport {
    /// Create a new complexity report.
    pub fn new(
        tasks_file: impl Into<String>,
        model: impl Into<String>,
        threshold: i32,
        analysis: Vec<TaskComplexityAnalysis>,
    ) -> Self {
        Self {
            meta: ComplexityReportMeta {
                generated_at: chrono::Utc::now().to_rfc3339(),
                tasks_file: tasks_file.into(),
                model: model.into(),
                threshold,
            },
            complexity_analysis: analysis,
        }
    }

    /// Get tasks that need expansion (score >= threshold).
    pub fn tasks_needing_expansion(&self) -> Vec<&TaskComplexityAnalysis> {
        self.complexity_analysis
            .iter()
            .filter(|a| a.complexity_score >= self.meta.threshold)
            .collect()
    }

    /// Get the analysis for a specific task.
    pub fn get_task_analysis(&self, task_id: i32) -> Option<&TaskComplexityAnalysis> {
        self.complexity_analysis.iter().find(|a| a.task_id == task_id)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_prd_response() {
        let json = r#"{
            "tasks": [
                {
                    "id": 1,
                    "title": "Setup project",
                    "description": "Initialize the project structure",
                    "details": "Create directories and files",
                    "testStrategy": "Verify structure exists",
                    "priority": "high",
                    "dependencies": [],
                    "status": "pending"
                }
            ]
        }"#;

        let response: ParsePrdResponse = serde_json::from_str(json).unwrap();
        assert_eq!(response.tasks.len(), 1);
        assert_eq!(response.tasks[0].title, "Setup project");
    }

    #[test]
    fn test_complexity_analysis_response() {
        let json = r#"{
            "complexityAnalysis": [
                {
                    "taskId": 1,
                    "taskTitle": "Setup project",
                    "complexityScore": 3,
                    "recommendedSubtasks": 0,
                    "expansionPrompt": "No expansion needed",
                    "reasoning": "Simple setup task"
                }
            ]
        }"#;

        let response: AnalyzeComplexityResponse = serde_json::from_str(json).unwrap();
        assert_eq!(response.complexity_analysis.len(), 1);
        assert_eq!(response.complexity_analysis[0].complexity_score, 3);
    }

    #[test]
    fn test_complexity_report() {
        let analysis = vec![
            TaskComplexityAnalysis {
                task_id: 1,
                task_title: "Simple task".to_string(),
                complexity_score: 2,
                recommended_subtasks: 0,
                expansion_prompt: "N/A".to_string(),
                reasoning: "Simple".to_string(),
            },
            TaskComplexityAnalysis {
                task_id: 2,
                task_title: "Complex task".to_string(),
                complexity_score: 8,
                recommended_subtasks: 5,
                expansion_prompt: "Break down into...".to_string(),
                reasoning: "Complex".to_string(),
            },
        ];

        let report = ComplexityReport::new("tasks.json", "claude-3", 5, analysis);
        
        let needing_expansion = report.tasks_needing_expansion();
        assert_eq!(needing_expansion.len(), 1);
        assert_eq!(needing_expansion[0].task_id, 2);
    }
}

